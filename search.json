[{"title":"latex常用命令","path":"/2023/10/11/latex常用命令/","content":"51561 基于我用Overleaf写的第一篇论文总结出来的，方便下次查找~ u1s1，第一次学不太熟练，然而如果熟练掌握的话，写文章看排版就是一种享受了：） 首先的首先当然是在模板库里边套好模板啦！！！试过一次真的好爽 超链接1\\href[连接地址][文字说明] 文献应用准备一个bib文件，比如我这里test.bib 在正文的合适位置引入： 1\\bibliography&#123;test&#125; 在test.bib中，直接复制谷歌学术引用的BibTex，复制进去： 123456789101112%test.bib@article&#123;wang2022design, %文献的key，必须唯一 author = &#123;Wang Dongqing and Dong Yuyang&#125;, title = &#123;Design of portable EEG acquisition system based on ADS1299(in Chinese)&#125;, journal = &#123;Communications Technology&#125;, volume = &#123;55&#125;, number = &#123;08&#125;, year = &#123;2022&#125;, pages=&#123;1090-1098&#125;, doi =&#123;&#125;, &#125;...%其他文献依次放入 然后在正文要应用的地方，放入文献的key即可 1These signals provide valuable information about brain function, cognition, emotions, and health status. EEG amplifiers hold significant value and importance in scientific research, clinical diagnosis, rehabilitation therapy, and brain information decoding\\citep&#123;wang2022design&#125;EEG amplifiers, as a critical component in the field of neuroscience, are currently undergoing significant expansion. bty，如果是word要求引用文献是什么比如Chicago风格的，你会发现谷歌学术引用里边没有，这个时候只需将在设置中把语言换成英文，就会出现很多其他的风格。 多级标题1234\\section&#123;一级标题&#125;\\subsection&#123;二级标题&#125;\\subsubsection&#123;三级标题&#125;\\paragraph&#123;四级标题&#125; 插入图片这里建议将图片转为pdf格式而不是esp，esp占用空间太大，放进去后会导致overleaf编译超时，要加钱噜。 将图片的pdf格式放到根目录命好名后，我按期刊要求在手稿的最后罗列了图片： 1234567\\begin&#123;figure&#125;[h!]\\begin&#123;center&#125;\\includegraphics[width=9.7cm,height=8.2cm]&#123;MindBridge-NaNo&#125;\\end&#123;center&#125;\\caption&#123; MindBridge-NaNo EEG Amplifier&#125;\\label&#123;fig:Nano&#125; %这个label就是来引用的\\end&#123;figure&#125; 在正文引用的地方插入图片label进行引用： 1...as shown in Figure \\ref&#123;fig:Nano&#125; 插入表格在正文开头处引入宏 1\\usepackage&#123;booktabs&#125; 推荐一个很好用的工具，excel直接转latex，然后复制代码进来就好啦，链接：[搞定LaTeX论文中的表格 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/108505177#:~:text=搞定LaTeX论文中的表格 1 1. 好看的三线表 画表格最常用的包自然是 booktabs了，好看的三线表的基本命令如下图。 比较麻烦的是左右两端缩小一点点的横线，这个 叫做,3 3. 表格大小可以整体调整 如果一张表过大，超过了行宽，如果超过得不多的话，下面这个命令非常好用： \\resizebox{width} {height} {tabular} ) 序列有序 1234\\begin&#123;enumerate&#125;\\item 放分点一\\item 放分点二\\end&#123;enumerate&#125; 无序 1234\\begin&#123;itemize&#125;\\item 放分点一\\item 放分点二\\end&#123;itemize&#125; 各种符号换行符 12// %换行符/par %分段符","tags":["笔记"]},{"title":"软件体系结构笔记","path":"/2023/09/20/软件体系结构笔记/","content":"1 构件管理1.构建描述：构建模型是对构建本质的抽象描述 2.构建分类与组织 已有的三大类构建分类方法： 关键字分类法 刻面分类法 超文本组织方法 构成一个系统的构件可分为以下5类： 独立而成熟的构建 有限制的构件 适应性构件 装配的构件 可修改的构件 3.人员及权限管理 构件重用构件开发的目的是重用，为了让构件在新的软件项目发挥作用，必须完成： 检索与提取构件 理解与评价构件 修改构件 构件组装 基于功能的组装技术 基于数据的组装技术 面向对象的组装技术 软件体系结构的兴起和发展软件体系结构的定义随着研究发展，定义不断完善 软件体系结构为软件系统提供了一个结构、行为和属性的高级抽象，由构成系统的元素的描述、这些元素的相互作用、指导元素集成的模式以及这些模式的约束组成。 发展阶段 无体系结构设计阶段。以汇编语言进行小规模应用程序开发为特征。 萌芽阶段。出现了程序结构设计主题，以控制流图和数据流图构成软件结构为特征。 初期阶段。出现了从不同侧面描述系统的结构模型，如UML。 高级阶段。以描述系统的高层抽象结构为中心，不关心具体的建模细节，划分了体系结构模型与传统软件结构的界限。 软件体系结构建模种类结构模型 最直观、最普遍 以体系结构的构件、连接件和其他概念来刻画结构 力图用结构反映系统重要语义内容 研究结构模型的核心——体系结构描述语言 框架模型 与结构模型类似 但更侧重整体结构 主要以特殊问题为目标，建立只针对和适应问题的结构 动态模型 是对结构或框架模型的补充，研究系统“大颗粒”行为性质 例如描述系统的重新配置或演化 动态可以指系统总体结构的配置、建立或拆除通信通道或计算的过程 过程模型 研究内容：构造系统的步骤和过程 结构是遵循某些过程脚本的结果 功能模型 功能模型认为体系结构是由一组功能构件按层次组成，下层为上层提供服务 可以看作一种特殊的框架模型 4+1模型Kruchten 1995年提出 从5个不同的视角，来描述软件体系结构 逻辑视图 进程视图 物理视图 开发视图 场景视图 每个视图只关系系统的一个侧面，结合才一起能反映系统软件体系结构的全部内容 image-20230927090653322 image-20230927094351154 逻辑视图 逻辑架构主要支持功能性需求——即在为用户提供服务方面系统所应该提供的功能 在面向对象技术中，通过抽象、封装和继承，可以用对象模型来代表逻辑视图，用类图来描述逻辑视图 表示方法：Booch标记法 image-20230927095041358 类图用来显示一个类的集合和它们的逻辑关系：关联、使用、组合、继承等等 例子： image-20230927095238536 image-20230927095304341 开发视图 也称模块视图，关注软件开发环境下实际模块的组织。主要侧重于软件模块的组织和管理 大部分情况考虑的内部需求与以下几项有关： 开发难度 软件管理 重用性 通用性 工具集、编程语言所带来的限制 关注程序包，可以直接使用第三方SDK、框架或中间件 表示方法：Booch方法的变形 image-20230927095943041 过程视图 侧重系统的运行特性，关注一些非功能性需求 强调并发性、分步性、系统集成性和容错能力 关注对象、进程、线程等运行时的概念，以及相关的并发、同步、通信等问题 可以描述为多层抽象，每个级别关注不同的方面。在最高层抽象中，进程结构可以看作是构成一个执行单元的一组任务。 物理视图主要考虑如何把软件映射到硬件上，最终如何安装或部署到物理机器 它通常要考虑到系统性能、规模、可靠性等。解决系统拓扑结构、系统安装、通讯等问题 物理视图和进程视图的关系 进程视图特别关注目标程序的动态执行情况 物理视图重视目标程序的动态位置问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。 场景 是重要系统活动的抽象，它使四个视图有机联系起来，从某种意义上是说场景是最重要的需求抽象。 在开发体系结构时，它可以帮助设计者找到体系结构的构件和它们之间的作用关系。同时，也可以用场景来分析一个特定的视图，或描述不同视图构件间是如何相互作用的 场景可以用文本表示，也可以用图形表示。 融合所有的视图 小结 逻辑视图和开发视图描述系统的静态结构 进程视图和物理视图描述系统的动态结构 不同软件系统，侧重的角度有所不同。 对于信息管理系统来说，比较侧重于从逻辑视图和开发视图来描述系统 对于实时控制系统，比较注重于从进程视图和物理视图来描述系统 并不是所有的软件架构都需要4+1视图，无用的视图可以省略 只有一个处理器可以省略物理视图 仅有一个进程&#x2F;程序，可以省略过程视图 非常小型的系统，甚至可能逻辑视图与开发视图非常相似，而不需要分开描述 ### 实例 #### 逻辑视图：设计满足功能需求的架构 应用层负责什么，通讯层负责什么... * 应用层负责设备状态的显示，并提供模拟控制台供用户发送调试命令。 * 应用层使用通讯层和嵌入层进行交互，但应用层不知道通讯的细节。 * 通讯层负责在RS232协议之上实现一套专用的\"应用协议\"。 * 当应用层发送来包含调试指令的协议包，由通讯层负责按RS232协议将之传递给嵌入层 #### 开发视图：设计满足开发期质量属性的架构 采用哪些现成框架、哪些第三方SDK、哪些中间件平台 #### 进程视图：设计满足运行期质量属性的架构 关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题 设备调试系统采用多线程的设计 #### 物理视图：和部署相关的架构决策 关 * 目标程序及其依赖的运行库和系统软件 * 最终如何安装或部署到物理机器 * 如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求 ## 体系结构的核心模型 核心模型的5种元素： * **构件** * 具有某种功能的可重用软件模板单元 * 分类：复合构件、原子构件 * **连接件** * 构件之间的交互 * 连接件接口由一组角色组成，每一个角色定义了该连接件表示的交互的参与者 * **配置** * 表示构件和连接件的拓扑逻辑和约束 * 端口 * 表示构件和外部环节的交互点 * 角色 ## 体系结构的生命周期模型 需求分析--建立体系结构--设计--实现--测试 # 软件体系结构风格 **软件体系结构的组成：** * 构件，各种基本的软件构造模块（函数、对象、模式等 image-20231011090546301； 连接件，将它们组合起来形成完整的软件系统 物理分布 约束 性能 体系结构&#x3D;构件+连接件+约束 软件体系结构风格的定义 惯用模式 词汇表和约束，即构件连接件+约束 共同的结构和语义特征 熟悉的软件体系结构 Client&#x2F;Server结构 Browse&#x2F;Server结构 Three-tier三层cs结构 Distributed分布式结构 软件体系结构风格分类 经典SA风格 其他常用SA风格 异构（复合）SA风格 什么是数据流风格 数据从一个处理单元流入到另一个处理单元，每经过一个单元就做一次转换 注意：数据流风格不是某个过程的数据流图，它描述的是系统体系结构级别的设计 管道过滤器风格编译器"},{"title":"计算机组成原理","path":"/2023/09/19/计算机组成原理/","content":"123 异或门就是进制 同余 假定有两个数a和b，若用某一个整数m去除，所得的余数相同，就称a,b两个数对m同余,记作： a≡b (mod m) 模为m 假设X,Y,Z三个数，满足下列关系：Z&#x3D;nX+Y (n为整数),则称Z和Y对模X是同余的，记作： Z≡Y (mod X) Y≡Z (mod X) 例子：以12为模 9 ≡ 12+9 ≡ 24+9 ≡ 36+9 9 ≡ 21 ≡ 33 ≡ 45 ≡ -3 ≡ 12-3 ≡ 9 7+(-3) ​ &#x3D;7+(12-3) ​ &#x3D;7+9 ​ &#x3D;16 再对12取余 ​ &#x3D;4 表示负数的时候如利用模的性质转换成正数，即可将原码运算中的减法变成加法运算 2.2 数值数据表示方法数的机器码原反补补码十因为正负数有符号位(0正1负)，加减不能直接算，而补码可以直接运算 正数都一致 负数： 机算：原码–符号位不变，数值位取反-&gt;反码–末尾加1–&gt;补码 快速算：补码–从右往左找到第一个1，这个1左边的所有“数值位”(不包括符号)按位取反-&gt;原码 补码的加法从最低为开始，按位相加(符号位参与运算)，并往更高位进位，丢弃超出的部分，比如8bit寄存器超出8位去掉。 负数的补码各位不能解读为位权信息！！！转为原码才能解读 补码的减法减一个数等于加这个数的相反数 那么已知“减数”的补码，如何求其负值的补码表示？ 机算方法：B补&lt;—全部位按位取反，末位+1—&gt;-B补 手算方法：从右往左找到第一个1，左边**所有位(包括符号)**全部取反 注意和补码-原码的区别！一个数值位，一个所有位 总结image-20230919094524121 移码image-20230919170130942 定点表示 (小数点位置固定的数) 定点整数 定点小数 仅能表示纯小数及纯整数 浮点表示（解决小数点问题） 机器数 （解决符号问题） image-20230919170553322 image-20230919170603587 image-20230919170831705 数据校验奇偶校验image-20230926084436366 右边是改进的，三个bit可以表示8种状态，只取4个，其他是非法状态。 奇偶校验码：在首位加一个校验位 image-20230926084723091 当有偶数个位发生错误就发现不了，因为1和0数目没有变 计算机求奇偶校验码就是把位数进行异或 image-20230926085304860 运算优先级：与&gt;或 与、或、非 与非、或非、异或、同或（异或取反） 算数逻辑单元image-20231010084939783 并行进位加法器串行进位，依赖于前一个的信息 如何更快的产生进位？其实就是把所有的加数和被加数再结合最开始输入的C0就可以直接得出最终的结果 并行进位的并行加法器：各级进位信息同时形成，又称为先行进位、同时进位。 然而无休止的套娃会让电路越来越复杂，因此一般只用4位加法器，由4个FA和一些新的线路、运算逻辑组成 补码加减运算器加减运算和溢出判断原码的加减法被加数和加数，组合有4中 原码的加法运算： 正+正–绝对值做加法，结果为正 负+负–绝对值加法，结果为负 正+负–绝对值大的减绝对值小的，符号同绝对值大的数 负+正–绝对值大的减绝对值小的，符号同绝对值大的数 原码的减法运算：“减数”符号取反，转变为加法 正-正–&gt;正+正 负-正–&gt;负+负 正-正–&gt;正+负 负+正–&gt;负-负 补码的加减法原码的逻辑在电路实现中太难了 补码取负值：所有位按位取反再末位+1 对于补码，最终都转变为加法，符号位也参与运算 8位补码最高位是符号位，表示范围为-128-127,超出会溢出 溢出判断下溢-负数区-0-正数区-上溢 只有正数+正数才会上溢—结果是负 只有负数+负数才会下溢—结果是正 方法 一位符号位 image-20231010094609942 “+”或运算 溢出情况：As,Bs&#x3D;0,Ss&#x3D;1或As,Bs&#x3D;1,Ss&#x3D;0 采用一位符号位，证据数据位进位情况判断溢出 image-20231010095631809 双符号位 扩展符号位，正数符号位为00，负数符号位为11 实际存储1个，运算时会复制一个符号位 符号扩展为了解决溢出问题 小数为了不影响位权，在末尾拓展 image-20231010100324855 image-20231010100537593 标志位的生成定点数的移位运算原码的乘法乘法运算的实现思想原码的一位乘法X存被乘数，MQ存乘数原码的绝对值 ACC存乘积高位 ACC MQ用完后逻辑右移，MQ可以存放乘积地位，MQ右移出去的位舍弃(乘数低位乘完之后本来就舍弃了没用了) 数值：绝对值相乘，用n轮加法，移位实现，看图步骤 符号为：异或运算 image-20231010113633834 补码的一位乘法和原码一位乘法类似，采用Booth算法 image-20231017092733316 image-20231017090457843 原码 补码 进行n轮加法、移位 进行n轮加法、移位，最后再多来一次加法 每次的加法 可能是+0，+[|x|]原 可能是+0，+[x]补，+[-x]补 每次的移位 逻辑右移，符号位也移动，高位补0 补码的算数右移，符号位固定补位，正数补0，负数补1 符号位 符号位不参与运算 符号位参与运算 加法怎么加 根据当前MQ中的最低位来确定加什么：MQ中最低为&#x3D;1时，(ACC)+[|x|]原MQ中最低为&#x3D;0时，(ACC)+0 根据当前MQ中的最低位辅助位来确定加什么(初始为0)辅助位-MQ中最低位&#x3D;1时，(ACC)+[x]补辅助位-MQ中最低位&#x3D;0时,(ACC)+0辅助位-MQ中最低位&#x3D;-1时(ACC)+[-x]补 MQ中拓展多一位为辅助位，而所说的最低为是辅助位前一位，为了和原码方法对应 由于所有寄存器长度统一，因此ACC和X都会多加一位，可以表示双符号位 乘数单符号位补码(有一位被辅助位占了)，被乘数双符号位补码 原码的除法image-20231017094703807 恢复余数法，逻辑左移 image-20231017102516997 加减交替法， image-20231017103734867 如果第一位商是1，说明被除数比除数大，定点小数没法表示1，检测出来停止运算，因为定点小数没法表示这种情况 补码的除法image-20231017105414064 除法类型 符号位参与运算 加减次数 移位方向 移位次数 上商、加减原则 说明 原码加减交替法 否 N+1或N+2 左 N 余数的正负 若最终余数为负，需恢复余数 补码加减交替法 是 N+1 左 N 余数和除数是否同号 商末位恒置1 C语言的类型转换无符号数与有符号数：不改变数据内容，改变解释方式 长整数变短整数：高位截断，保留地位 指令系统一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。 注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令Eg: X86架构(Inter的)、ARM架构(手机) 指令格式：一个指令 image-20231024104055949 零地址指令操作符就是一个零地址指令 image-20231024104316071 一地址指令image-20231024104552021 二、三地址指令image-20231024104730193 四地址指令image-20231024104844533 image-20231024105004386 指令-按指令长度分类 指令字长：一条指令的总长度（可能会变） 机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关） 存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同） 指令-按操作码长度分类 定长操作码：指令系统中所有指令的操作码长度都相同n位→2n条指令控制器的译码电路设计简单，但灵活性较低 可变长操作码：指令系统中各指令的操作码长度可变控制器的译码电路设计复杂，但灵活性较高 定长指令字结构+可变长操作码-&gt;扩展操作码指令格式 指令-按操作类型分类 数据传送类：CPU、主存之间的数据传输 运算类：算数逻辑操作、移位操作 程序控制类：改变程序执行流 输入输出类：CPU、IO设备之间的数据传送 扩展操作码为什么要扩展？因为除了表示四地址指令(16为)，可能还需要表示一、二、三地址指令，但是又因为固定是16位，所以短的地址指令相比大的要退一格，把上一格用全1来填充，因此上一个码只有15种(去掉全1)。 cpu一次读入16位，根据是否全1判断是三地址指令还是二地址指令 ·在设计扩展操作码指令格式时，必须注意以下两点： 1)不允许短码是长码的前缀，即短操作码不能与长操作码的前 面部分的代码相同。 2 image-20231024161232495各指令的操作码一定不能重复。 通常情况下，对使用频率较高的指令，分配较短的操作码对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。 image-20231024164856526 指令寻址下一条 欲执行 指令 的 地址 顺序寻址定长指令字结构 跳跃寻址image-20231024170857837 执行指令：JMP，CALL会直接修改PC的值，JMP类似goto，CALL调用函数 数据寻址确定本条指令的地址码指明的真实地址"},{"title":"数字图像处理笔记","path":"/2023/09/18/数字图像处理笔记/","content":"13 基于直方图的图像增强方式当一幅图像的像素占据了所有可能的灰度级并且呈均匀分布–&gt;具有较高对比度&amp;多变的灰度色调 由上，图像增强的一种方法——把不均匀的图像变均匀 知道灰度概率密度函数 求积分，乘一个系数 得到的结果 离散变换函数 直方图均衡化 频率域图像处理频率域图像处理的基本实现思路综上所述，频率域图像处理的步骤为：(1)用（一1）红+”乘以输入图像，进行中心变换。 (2)对步骤(1)的计算结果图像（一1）(x+y)f(x,y)进行二维傅里叶变换，即求F(u,v)。 (3)用**设计的转移函数H(u,v)**乘以F(u,),即按式(5.27)求G(u,v)。 (4)求步骤(3)的计算结果的傅里叶反变换，即计算F-[G(u,)]。 (5)取步骤(4)的计算结果的实部。 (6)用（一1）(x+y)乘以步骤(5)的计算结果，就可得到通过频率域增强后的图像g(x,y)。 以上过程可简要地描述为 image-20231016145528056 转移函数的设计 频率域图像处理的关键是转移函数H(u,v)的设计 关于转移函数的设计： 比较笼统的说法是：频率域在很大程度上凭直观指定滤波器。 比较具体的说法是：一般利用频率成分和图像外表之间的对应关系选择频率滤波器。 更为一般的方法是利用基于数学和统计准则的近似设计二维数字滤波器、 可以先通过滤波实验构造合适的频率滤波器，然后将其变换到空间域，在空间域进行实际的滤波运算。 频率域低通滤波在频率域中，图像中的噪声和边缘对应于傅里叶频谱的高频部分，选择能让低频通过、高频衰减的转移函数达到滤除噪声的效果。 理想低通滤波器最简单的思路就是设计一个分段函数，低频部分值为1，高频为0 理想低通滤波器的含义为： 在半径为D0的圆内的所有频率没有衰减地通过该滤波器； 而在此半径的圆之外的所有频率完全被衰减掉。 所以D0称为截止频率。 截止频率如何设置？可以通过实验分析。 image-20231016150944266 巴特沃斯低通滤波器前面提到的0，1转移函数太简单粗暴了。 图。巴特沃斯低通滤波器的转移函数H的透视图如图5.10(b)所示，该透视图的含义是： 只有那些位于该草帽形体内的频率范围的信号才能通过，而位于草帽形体外的频率成分都将被滤除掉。 由图可见，巴特沃斯低通滤波器在高低频率间的过渡比较平滑。 image-20231016151552763 高斯低通滤波器由于高斯函数的傅里叶变换和反变换均为高斯函数，并常常用来帮助寻找空间域与频率域之间的联系，所以基于高斯函数的滤波具有特殊的重要意义。 image-20231016151743835 与巴特沃斯低通滤波器相比， 高斯低通滤波器没有振铃现象。 另外在需要严格控制低频和高频之间截止频率的过渡的情况下，选择高斯低通滤波器更合适一些。 在频率域中，滤波器越窄，滤除掉的高频成分就越多，滤波后的图像就越模糊。 这一特性正好对应于在空间域中，滤波器越宽（模板尺寸越大），平滑后的图像就越模糊的情况。 频率域高通滤波高通滤波达到突出图像的高频边缘成分，实现图像增强效果 理想高通滤波 巴特沃斯高通滤波，在高低频率间的过渡比较平滑 高斯高通滤波，随着截止频率D0值增大，增强效果更加明显，即时对于微小的物体和细线条，用高斯滤波器后也比较清晰 类比低通这里不再过多赘述原理 带阻滤波和带通滤波图像恢复图像的退化模型图像退化模型的表示image-20231023142807969 $$g(x,y)&#x3D;H[f(x,y)]+n(x,y)$$图像退化的过程可以理解为作用于原图像f(x,y)的运算H，同时数字图像也常会因受一些随机误差也即噪声n(x,y)而退化。 离散退化模型1.一位离散退化模型 当利用卷积计算 g(x) 时，由 A 个样本表示的函数 f(x) 与由 C 个样本表示的另一个函数 h(x) 进行卷积将得到 A+C一1 个样本序列。 2.二维离散退化模型 用矩阵表示为：g&#x3D;Hf+n 卷积和泰勒级数、傅里叶奇数的内在逻辑是一脉相承的 空间域图像的恢复无约束最小二乘方恢复n&#x3D;g-Hf 有约束最小二乘方恢复 最小均方误差滤波(维纳滤波)恢复 最大熵约束恢复 恢复后的图像不具有唯一性，称为图像恢复的病态性 由 n&#x3D;g-Hf，不考虑噪声情况下要恢复图像需要对矩阵 H 求逆，即： f&#x3D;H-1g 在实际中，可能有逆矩阵 H-1 不存在的情况，但却存在有与 f 十分近似的解，称为图像恢复问题的奇异性。 匀速直线运动模糊的恢复本节讨论其中最简单的相机和目标的相对运动可以看成是匀速直线运动而造成的模糊图像的恢复问题。 如果用卷积的方法模拟出水平方向匀速运动产生的模糊图像，其过程可表示为： image-20231030142917980 h(x,y)为模糊算子或点扩散函数,*表示卷积，f(x,y)表示原始的清晰图像，g(x,y)表示观察到的退化图像 图像噪声 高斯噪声，也称正态噪声，左右对称，中间突出。高斯噪声是一种源于电子电路噪声和由低照明度或高温带来的传感器噪声。高斯噪声是白噪声的一个特例 瑞利噪声 均匀分布噪声 脉冲噪声(椒盐噪声) 其他 为了在有噪声的情况下恢复图像，就需要了解噪声的统计性质 被噪声污染图像的恢复 谐波均值滤波 逆谐波均值滤波 中点滤波 自适应中值滤波 几何失真的校正小波图像处理小波是指小区域、长度有限、均值为0的振荡波形 image-20231030150826846"},{"title":"JJ的算法之旅","path":"/2023/09/17/JJ的算法之旅/","content":"12 kk&#x3D;kk&amp;(kk-1)，可以消除kk二进制的最后一个1 动态规划 动规基础 背包问题 打家劫舍 股票问题 子序列问题 重要点： dp数组以及下界的含义，dp[i][j]、dp[i] 递推公式 dp数组如何初始化,0?1?… 遍历顺序 打印dp数组，看看输出结果是否正确 最长回文子串应该从下网上，从左往右遍历推导 因为d[i][j]是由d[i+1][j-1]得到，d[i][j]布尔型，表示i,j是否为回文子串 最长公共子序列区间DP线性DP一般是在前缀&#x2F;后缀上转移 区间DP从小区间转移到大区间 石子合并 image-20231011152428565 回溯算法递归和回溯相辅相成 递归函数下面就是回溯内容 回溯搜索：纯暴力搜索算法 组合问题 切割问题 子集问题 排列问题 棋盘问题，n王后，解数独 抽象为n叉数问题，横向节点用for循环表示，纵向深度用递归 123456789101112void backtracking(参数)&#123; if(终止条件)&#123; 在叶子节点搜集结果; return; &#125; for(集合元素)&#123; 处理结点; 递归; 回溯;//撤销处理节点结果 &#125; return;&#125; 回溯三部曲 递归函数参数返回值 确定终止条件 单层递归逻辑 注意点 oj运行出错：数组开小了 oj和答案不对的一个重要原因：没有说明是eof的就得换一种方式读取！！，如果保持eof的方式就会错 1234567#include &lt;stdio.h&gt;int main() &#123; int n; while (scanf(&quot;%d&quot;, &amp;n) != EOF) &#123; printf(&quot;%d &quot;, (1 + n) * n / 2); &#125;&#125; 读取方式有可能会造成运行超时： 123456789101112131415161718//超时版int len;int v[100001]=&#123;0&#125;;while (scanf(&quot;%c&quot;, &amp;n) != &#x27; &#x27;) &#123; if (n != &#x27; &#x27;) &#123; v[len] = n - &#x27;0&#x27;; len++; &#125; if (n == &#x27; &#x27;) break;&#125;//不超时版vector&lt;int&gt; v;int i;while (cin &gt;&gt; i) &#123; v.push_back(i); if (cin.get() == &#x27; &#x27;) break;&#125; SCNUOJP01 最大二叉树 读取，构造二叉树 构造最大二叉树 特殊情况–只有一个元素 找最大值 判左右是否空，左右递归 返回根节点 前序遍历函数 终止情况：为空结点，返回 排除叶子结点情况 其他：输出结点，递归左右 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 最大二叉树#define _CRT_SECURE_NO_WARNINGS# include&lt;iostream&gt;# include&lt;vector&gt;using namespace std;//定义二叉树struct TreeNode&#123; int val; TreeNode* left; TreeNode* right; //无参 TreeNode() :val(0), left(nullptr), right(nullptr) &#123;&#125; //有参 TreeNode(int x) :val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode* left, TreeNode* right) :val(x), left(left), right(right) &#123;&#125;&#125;;//前序遍历void PreOrder(TreeNode* tr) &#123; if (tr == NULL) &#123; cout &lt;&lt; &quot;null&quot; &lt;&lt; &quot; &quot;; return; &#125; //叶子节点的两个子空节点要去掉不输出！否则会多输出一对null else if (tr-&gt;left == NULL &amp;&amp; tr-&gt;right == NULL) &#123; cout &lt;&lt; tr-&gt;val&lt;&lt;&quot; &quot;; return; &#125; else &#123; cout &lt;&lt; tr-&gt;val &lt;&lt; &quot; &quot;; PreOrder(tr-&gt;left); //递归左子树 PreOrder(tr-&gt;right); //递归右子树 &#125;&#125;class Solution &#123;public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123; TreeNode* node = new TreeNode(0); if (nums.size() == 1) &#123; //只有一个元素，直接返回 node-&gt;val = nums[0]; return node; &#125; //中间找最大 int maxValue = 0; int maxValueIndex = 0;//找最大值 for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; maxValue) &#123; maxValue = nums[i]; maxValueIndex = i; &#125; &#125; node-&gt;val = maxValue; //左边还有元素 if (maxValueIndex &gt; 0) &#123; //newVec左闭右开 vector&lt;int&gt; newVec(nums.begin(), nums.begin() + maxValueIndex); //左子树的构造就是对左边递归 node-&gt;left = constructMaximumBinaryTree(newVec); &#125; if (maxValueIndex &lt; (nums.size() - 1)) &#123; //右边递归 vector&lt;int&gt; newVec(nums.begin() + maxValueIndex + 1, nums.end()); node-&gt;right = constructMaximumBinaryTree(newVec); &#125; return node; &#125;&#125;;int main() &#123; int a ; vector&lt;int&gt; nums; //读取 while (scanf(&quot;%d&quot;, &amp;a) != EOF) &#123; nums.push_back(a); &#125; Solution s1; TreeNode *re; re=s1.constructMaximumBinaryTree(nums); PreOrder(re); return 0;&#125; ！P02. [算法课分治] 寻找多数12345678910111213141516171819202122232425262728293031323334353637383940//寻找多数#include&lt;iostream&gt;using namespace std;//返回特定元素在特定数组中出现的次数int traverse(int nums[], int pivot, int left, int right) &#123;\tint num = 0;\tfor (int i = left; i &lt;= right; i++) &#123; if (nums[i] == pivot) num++;\t&#125;\treturn num;&#125;int findM(int nums[], int left, int right) &#123;\t//规模为1直接求解\tif (left == right) return nums[left];\t//分解\tint mid = (left + right) / 2;\tint leftNum = findM(nums, left, mid);\tint rightNum = findM(nums, mid+1, right);\t//当前数组的解为两个数组解在当前数组出现次数较大的解\tif (leftNum == rightNum) return leftNum;\telse &#123; int lcount = traverse(nums, leftNum, left, right); int rcount = traverse(nums, rightNum, left, right); return lcount &gt; rcount ? leftNum : rightNum;\t&#125;&#125;int main() &#123;\t//读取\tint n;\tint nums[10001] = &#123; 0 &#125;;\tcin &gt;&gt; n;\tint a;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; nums[i] = a;\t&#125;\tcout &lt;&lt; findM(nums, 0, n - 1);\treturn 0;&#125; P03. [算法课分治] 找到最大子序和1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;vector&gt;#include &lt;climits&gt;using namespace std;int getMaxNum(int a, int b, int c) &#123; if (a &gt; b &amp;&amp; a &gt; c) &#123; return a; &#125; if (b &gt; a &amp;&amp; b &gt; c) &#123; return b; &#125; return c;&#125;int maxSumRec(int data[], int left, int right) &#123; if (right - left == 1) &#123; //如果当前序列只有一个元素 return data[left]; &#125; int center = (left + right) / 2;//计算当前序列的分裂点 int maxLeftSum = maxSumRec(data, left, center); int maxRightSum = maxSumRec(data, center, right); //计算左边界最大子序列和 int leftBonderSum = 0; int maxLeftBonderSum = data[center - 1]; for (int i = center - 1; i &gt;= left; i--) &#123; leftBonderSum += data[i]; if (maxLeftBonderSum &lt; leftBonderSum) &#123; maxLeftBonderSum = leftBonderSum; &#125; &#125; //计算右边界最大子序列和 int rightBonderSum = 0; int maxRightBonderSum = data[center]; for (int i = center; i &lt; right; i++) &#123; rightBonderSum += data[i]; if (maxRightBonderSum &lt; rightBonderSum) &#123; maxRightBonderSum = rightBonderSum; &#125; &#125; //返回当前序列最大子序列和 return getMaxNum(maxLeftBonderSum + maxRightBonderSum, maxLeftSum, maxRightSum);&#125;int main() &#123;\tint n;\tint v1[1000000];\tcin &gt;&gt; n;\tint t;\tfor(int i=0;i&lt;n;i++)\t&#123; cin &gt;&gt; t; v1[i]=t;//读入\t&#125; cout&lt;&lt;maxSumRec(v1, 0, n);&#125; P04. [算法课分治] 找到 k 个最小数就是一个快速排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int part(int* a, int low, int height) &#123;\tint i = low, j = height, pviot = a[low]; //这里是low就要从j开始，要从i开始就得是height\twhile (i &lt; j) &#123; while (a[j]&gt;pviot&amp;&amp;i&lt;j) &#123; j--; &#125; if (i &lt; j) &#123; swap(a[i++], a[j]);//交换后i后移 &#125; while (a[i] &lt; pviot &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; swap(a[i], a[j--]);//交换后，j前移 &#125;\t&#125;\treturn i;//返回最终划分完成后基准元素所在的位置&#125;void Quicksort(int* a, int low, int height) &#123;\tint mid;\tif (low &lt; height) &#123; mid = part(a, low, height); //分治 Quicksort(a, low, mid - 1); Quicksort(a, mid + 1, height);\t&#125;&#125;int main() &#123;\tint n,a,k;\tint nums[10001] = &#123; 0 &#125;;\tcin &gt;&gt; n &gt;&gt; k;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a; nums[i] = a;\t&#125;\tQuicksort(nums, 0, n - 1);\tfor (int i = 0; i &lt; k; i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;;\t&#125;\treturn 0;&#125; P05. [算法课分治] 寻找第 k 个最大元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;int part(int* a, int low, int height) &#123;\tint i = low, j = height, pviot = a[low];\twhile (i &lt; j) &#123; while (a[j] &gt; pviot &amp;&amp; j &gt; i) &#123; j--; &#125; if (i &lt; j) &#123; swap(a[i++], a[j]);//交换后，i后移 &#125; while (a[i] &lt; pviot &amp;&amp; i &lt; j) &#123; i++; &#125; if (i &lt; j) &#123; swap(a[i], a[j--]); &#125; &#125;\treturn i;//返回最终划分完成后基准元素所在的位置&#125;void Quicksort(int *a, int low,int height) &#123;\tint mid;\tif (low &lt; height) &#123; mid = part(a, low, height); Quicksort(a, low, mid - 1); Quicksort(a, mid + 1, height);\t&#125;&#125;int main() &#123;\t//数据读取\tint len, k;\tint a[1000];\tint t;\tcin &gt;&gt; len &gt;&gt; k;\tfor (int i = 0; i &lt; len; i++) &#123; cin &gt;&gt; t; a[i] = t;\t&#125;\t//快速排序\tQuicksort(a, 0,len-1);\tcout &lt;&lt; a[len-k];&#125; P06. [算法课动态规划]走网格123456789101112131415161718192021222324//棋盘#include&lt;iostream&gt;using namespace std;int main() &#123;\tint m, n;\tcin &gt;&gt; m &gt;&gt; n;\tint dp[11][11] = &#123; 0 &#125;;\tdp[1][1] = 1;\t//初始化\tfor (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i == 1 || j == 1) &#123; dp[i][j] = 1; &#125; else &#123; dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; &#125; &#125;\t&#125;\tcout &lt;&lt; dp[m][n];\treturn 0;&#125; P07. [算法课动态规划]爬楼梯12345678910111213141516#include&lt;iostream&gt;using namespace std;int main() &#123;\tint n;\tint dp[21];\tdp[0] = 1;\tdp[1] = 1;//零一阶都是只有一种方法达到\tcin &gt;&gt; n;\tfor (int i = 2; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2];\t&#125;\tcout &lt;&lt; dp[n];\treturn 0;&#125; P08. [算法课动态规划]背包问题 不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。) 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 12345678910111213141516171819202122232425262728//背包问题#include&lt;iostream&gt;using namespace std;int main() &#123;\tint weight[] = &#123; 7,3,4,5 &#125;;\tint value[] = &#123; 42,12,40,25 &#125;;\tint wetLen,cap;\tcin &gt;&gt; wetLen &gt;&gt; cap;\tint dp[11][11] = &#123; 0 &#125;;\tfor (int i = weight[0]; i &lt;= cap; i++) &#123; //能放物品1的进行初始化 dp[0][i] = value[0];\t&#125;\t//遍历物品\tfor (int i = 1; i &lt;= wetLen; i++) &#123; //遍历背包容量 for (int j = 1; j &lt;= cap; j++) &#123; if (j &lt; weight[i-1]) dp[i][j] = dp[i - 1][j];//放不进，就是不妨上一个物品 else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i-1]] + value[i-1]);//放的进就是比较上一个和放进这个的大小 &#125;\t&#125;\tcout &lt;&lt; dp[wetLen][cap];\treturn 0;&#125; P09 最长回文子串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/Problem P09. [算法课动态规划]最长回文子串#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int dp[1001][1001] = &#123; 0 &#125;;int main() &#123;\tstring s1;\tcin &gt;&gt; s1; //对角线为1\tfor (int i = 0; i &lt; s1.size(); i++) &#123; for (int j = 0; j &lt; s1.size(); j++) &#123; if (i == j) &#123; dp[i][j] = 1; &#125; &#125;\t&#125;\tfor (int i = s1.size()-1; i &lt; s1.size(); i--) &#123; for (int j = i ; j &lt; s1.size(); j++) &#123; //少了一个判断是两个字符的情况 if (s1[i] == s1[j]) &#123; //两个字符 if (j - i &lt;= 1) &#123; dp[i][j] = 1; &#125; else if (dp[i + 1][j - 1] == 1) &#123; dp[i][j] = 1; &#125; &#125; &#125;\t&#125;\t//找最长的，记录下来\tint maxI = 0, maxJ = 0, maxdis = 0;\tfor (int i = 0; i &lt; s1.size(); i++) &#123; for (int j = i; j &lt; s1.size(); j++) &#123; if (j - i &gt; maxdis&amp;&amp;dp[i][j]==1) &#123; maxI = i; maxJ = j; maxdis = j - i; &#125; &#125;\t&#125;\tfor (int z = maxI; z &lt;= maxJ; z++) &#123; cout &lt;&lt; s1[z];\t&#125;\treturn 0;&#125; P10 连续数组最大123456789101112131415161718192021222324252627282930313233//Problem P10.[算法课动态规划]连续数组最大和#include&lt;iostream&gt;using namespace std;int main() &#123;\tint n;\tint a[51] = &#123; 0 &#125;;\tint dp[51][51] = &#123; 0 &#125;;\tcin &gt;&gt; n;\tint p;\tfor (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; p; a[i] = p;\t&#125;\tfor (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i; j &lt; n; j++) &#123; if (i == j) dp[i][j] = a[i]; else dp[i][j] = dp[i + 1][j - 1] + a[i] + a[j];//加端点 &#125;\t&#125;\tint max=0;\tfor (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dp[i][j] &gt; max) &#123; max = dp[i][j]; &#125; &#125;\t&#125;\tcout &lt;&lt; max;\treturn 0;&#125; ⭐P11 最长公共子序列12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int dp[1001][1001] = &#123; 0 &#125;;int main() &#123;\tstring s1, s2;\tcin &gt;&gt; s1&gt;&gt;s2;\t//空出一个外围，非则会越界\tfor (int i = 1; i &lt;= s1.size(); i++) &#123; for (int j = 1; j &lt;= s2.size(); j++) &#123; //注意i，i都要退一个 //如果当前字母想都，就是左上角加上1 if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1; //如果不同，找左边或者上边的最大值 else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); &#125; &#125;\t&#125;\tcout &lt;&lt; dp[s1.size()][s2.size()];\treturn 0;&#125;"},{"title":"大型数据库笔记","path":"/2023/09/14/大型数据库笔记/","content":"环境配置登录oracle(Oracle已经安装)：sqlplus sys/orcl as sysdba sqlplus scott&#x2F;tiger (以超级管理员登录必须加as sysdba) 1sz [文件名] 切换用户：su - oracle （-和oracle中间有空格） 运行设置Oracle环境shell脚本：. oraenv （. 后面有空格） 注释：. = source(执行 shell 文件) 输入实例名：orcl 按回车 su -xxx，-xxx是运行脚本 image-20230915001830676 sys用户 dba登录 01体系结构OracleDB体系结构image-20230914150100943 内存结构Oracle DB 内存结构 Oracle DB 创建并使用内存结构来满足多种需要。例如，使用内存来存储正在运行的程序代码、在各用户之间共享的数据以及所连接的每个用户的专用数据区域。 一个实例有两个关联的基本内存结构： •系统全局区 (SGA)：一组共享的内存结构（称为 SGA 组件），其中包含一个 Oracle DB 实例的数据和控制信息。SGA 由所有服务器进程和后台进程共享。SGA 中存储的数据有高速缓存的数据块和共享 SQL 区域等。 •程序全局区 (PGA)：包含某个服务器进程或后台进程的数据及控制信息的内存区域。PGA 是 Oracle DB 在服务器进程或后台进程启动时创建的非共享内存。服务器进程对 PGA 的访问是独占式的。每个服务器进程和后台进程都具有自己的 PGA。 image-20230914150838773 SGA共享池 数据缓冲区 重做日志缓冲区 后台进程进程监视器进程 (PMON)进程监视器进程 (PMON) 在用户进程失败时执行进程恢复。PMON 负责清除数据库缓冲区高速缓存和释放该用户进程占用的资源。例如，PMON 会重置活动事务处理表的状态，释放锁，并从活动进程列表中删除该进程 ID。 PMON 定期检查分派程序和服务器进程的状态，并重新启动任何已停止运行（除了 Oracle DB 故意终止）的分派程序和服务器进程。PMON 还会在网络监听程序中注册有关实例和分派程序进程的信息。 与 SMON 一样，PMON 定期检查以查看是否需要运行；如果其它进程检测到需要该进程，也可以调用它。 image-20230914161215340 **恢复器进程 (**RECO)恢复器进程 (RECO) 是一个用于分布式数据库配置的后台进程，它可以自动解决涉及分布式事务处理的故障。实例的 RECO 进程会自动连接到有问题的分布式事务处理中涉及的其它数据库。当 RECO 进程在涉及到的数据库服务器之间重新建立连接后，它会自动解决所有有问题的事务处理，并从每个数据库的暂挂事务处理表中删除所有对应于已解决的有问题事务处理的行。 如果 RECO 进程无法与远程服务器连接，RECO 会在某个计时间隔之后自动尝试重新连接。但是，RECO 在再次尝试另一个连接之前，会等待一段时间，该时间会随尝试次数不断 增加（呈幂指数增长）。 image-20230914161228190 归档进程 (ARCn)发生日志切换之后，归档进程 (ARCn) 会将重做日志文件复制到指定的存储设备。仅当 数据库处于 ARCHIVELOG 模式且已启用自动归档时，才会存在 ARCn 进程。 如果您预计归档的工作负荷很重（例如在成批加载数据期间），可以增加最大归档进程数。此外，也可以有多个归档日志目标位置。建议每个目标位置至少有一个归档进程。默认 设置是四个归档进程。 image-20230914161301300 归档模式默认为非归档模式。 查看数据库是否处于归档模式：archive log list。 1SQL&gt; archive log list 改变数据库的归档模式步骤： (1)停止Oracle Server并装载数据库： 123sql&gt;shutdown immediate //停sql&gt;startup mount //启动到：装载数据库阶段 (2)修改数据库为归档模式： 1alter database archivelog; (3) 打开数据库：alter database open; 测试是否生成归档日志： （1）update emp表（生成重做日志信息）: • update scott.emp set sal&#x3D;sal + 500; • commit; （2）日志切换（生成归档日志）： alter system switch logfile; （3）检查是否生成归档日志: 在文件夹&#x2F;opt&#x2F;oracle&#x2F;flash_recovery_area下查看是否有归档文件生成。 改为非归档模式： Mount状态： alter database noarchivelog; 打开数据库：alter database open; 逻辑和物理数据库结构数据库具有逻辑结构和物理结构。 数据库、表空间和数据文件 本幻灯片对数据库、表空间和数据文件之间的关系进行了说明。每个数据库都在逻辑上分为两个或多个表空间。在每个表空间均显式创建一个或多个数据文件，以在物理上存储表空间中所有逻辑结构的数据。对于 TEMPORARY 表空间，不创建数据文件，而是创建临时文件。表空间的数据文件可以采用任何受支持的存储技术进行物理存储。 表空间 数据库分为多个逻辑存储单元，这些单元称为“表空间”，用于对相关逻辑结构或数据 文件进行分组。例如，表空间一般会将一个应用程序的所有段分成一组，以简化一些管理操作。 数据块 Oracle DB 的数据存储在“数据块”中，数据块是粒度最低的一级。一个数据块对应于磁盘中特定字节数的物理空间。每个表空间的数据块大小是在表空间创建时指定的。数据库以 Oracle 数据块为单位使用和分配空闲数据库空间。 自动存储管理不需要做，实验室磁盘太少 04实例spfile：&#x2F;opt&#x2F;orcale&#x2F;product 图形界面 管理 服务器 控制台地址可以在此文件中查看：$ORACLE_HOME\\install\\readme.txt 控制台的操作： 查看状态： emctl status dbconsole 启动：emctl start dbconsole 停止（不要执行停止这条命令）：emctl stop dbconsole 改显示日期 1alter session set nls_date_format=&#x27;yyyy-mm-dd&#x27;; V$PARAMETER 显示当前会话中的当前参数值 1234567SQL&gt; SELECT name , value FROM V$PARAMETER;NAME VALUE------------ ----------lock_name_space 2processes 150sessions 247… MOUNT阶段 执行以下任务必须装载数据库 重命名数据文件 启用和禁用联机重做日志文件归档选项 执行完整的数据库恢复 OPEN阶段 image-20231007142725996 image-20231007144423909 数据字典视图image-20231007145236364 用法举例： 12345678910111213SELECT table_name, tablespace_name FROM user_tables;SELECT sequence_name, min_value, max_value, increment_by FROM all_sequences WHERE sequence_owner IN (&#x27;MDSYS&#x27;,&#x27;XDB&#x27;);SELECT USERNAME, ACCOUNT_STATUS FROM dba_users WHERE ACCOUNT_STATUS = &#x27;OPEN&#x27;;DESCRIBE dba_indexes 查找scott用户有哪些索引，以及这些索引所在的表空间名称: 1234select table_name from dict where table_name like &#x27;%INDEX%’;Desc user_indexes select INDEX_NAME, TABLESPACE_NAME from user_indexes; 06配置Oracle Networkvim保存失败，修改文件权限可以用winscp 07Storage08User权限 系统权限：允许用户在数据库中执行特定的操作 对象权限：允许用户访问和操纵特定的对象 dba分配权限 1sqlplus / as sysdba 查权限 1select * from user_role_privs; 系统权限所有系统权限： 1select * from system_privilege_map; 授予系统权限： 123GRANT &lt;system_privilege&gt; TO &lt;grantee clause&gt; [WITH ADMIN OPTION] # Grant create table, unlimited tablespace to scott with admin option; WITH ADMIN OPTION: 被授权用户可以转授权给其它用户，收回权限没有级联，慎用 查询用户具有的系统权限： 1select * from user_sys_privs; 撤销系统权限的 SQL语句： 12REVOKE &lt;system_privilege&gt; FROM &lt;grantee clause&gt;# REVOKE CREATE TABLE FROM joe; 对象权限授予对象权限 1GRANT &lt;object_privilege&gt; ON &lt;object&gt; TO &lt;grantee clause&gt; [WITH GRANT OPTION] 查看用户对象权限： 1select * from user_tab_privs; 撤销对象权限时会级联撤销。 •用户只能撤销授予他们的那些权限。例如，Bob 无法撤销 Joe 授予 Emily 的对象权限。 •只有被授予者或者具有 GRANT ANY OBJECT PRIVILEGE 系统权限的用户可以撤销对象权限。"},{"title":"操作系统笔记","path":"/2023/09/14/操作系统笔记/","content":"第一章 操作系统引论操作系统的概念、功能操作系统 是指控制和管理整个计算机系统的硬件和软件资源——操作系统是系统资源的管理者 ⭐提供的功能：处理机管理、存储器管理、文件管理、设备管理 目标：安全高效 以提供给用户和其他软件方便的接口环境——向上层提供方便易用的服务 硬件只接受二进制指令，在硬件之上安装操作系统，友好交互接口 把复杂的硬件功能封装成简单易用的服务 是计算机系统中最基本的系统软件——是最接近硬件的一层软件 直接给用户使用：GUI 图形化用户接口、命令接口（联机命令接口、脱机命令接口，前者说一句计算机做一句，后者说一堆做一堆如txt配置文件) 给软件&#x2F;程序员使用：程序接口 没有任何软件支持的计算机称为裸机，操作系统实现了对硬件机器的拓展。 通常把覆盖了软件的机器称为扩充机器，又称之为虚拟机 用户——应用程序——操作系统——裸机(纯硬件) ​ 进程-虚存-文件 操作系统的特征并发并发：指两个或多个时间在统一时间间隔发送，宏观上是同时发生，微观上是交替的。 注意区分，并行指两个或多个同时发生，宏观微观都是同时 操纵系统并发性：同时运行多个程序，微观上交替运行 操作系统伴随着“多道程序技术”出现，操作系统和程序并发是一起诞生的 考点： 单核CPU同一时刻执行一个程序，各个程序并发执行 多核执行多个，并行执行 计算机系统中同时存在多个运行的程序，需要OS管理和调度 共享资源共享，系统的资源可供内存中多个并发执行的程序共同使用 两种方式 互斥共享方式，一个时间段只允许一个进程访问该资源 同时共享方式，一个时间段允许多个进程“同时”对它们进行访问 读取文件，微观上其实也是交替访问硬盘的；扬声器确实可以微观上同时使用 并发与共享的关系并发性指计算机系统中同时存在着多个运行着的程序。共享性是指系统中的资源可供内存中多个并发执行的进程共同使用。 互为存在条件，失去并发性，系统只有一个程序，共享性没意义；失去共享性，无法实现同时访问资源，无法并发。 虚拟指把物理上的实体变为逻辑上的对应物，物理实体存在，而逻辑上对应物是用户感受的。 虚拟存储器，好像运行内存大于实际的内存 虚拟技术： 空分复用技术，如虚拟存储技术 时分复用技术，如虚拟处理器 失去了并发性，一个时间段只运行一道程序，失去了实现虚拟性的意义。因此没有并发现就失去了虚拟性 异步允许多个程序并发执行，但进程的执行不是一贯到底，而是走走停停 并发的程序会争用资源 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。 image-20230928110145877 操作系统的发展手工操作阶段批处理阶段单道批处理系统(引入脱机输入输出技术)优：缓解人机速度矛盾 缺：资源利用率依然很低 多道批处理系统(操作系统开始出现)优：多道程序并发执行，资源利用率高 缺：不提供人机交互功能 分时操作系统以时间片轮流为各个用户服务，用户请求可以被即时响应，解决了人机交互问题 缺点：不能有限解决紧急任务 实时操作系统优点：能优先响应一些紧急任务 要在严格时限内处理完事件，及时性和可靠性 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 操作系统的运行机制两种程序 内核程序：负责实现操作系统，由很多内核程序组成操作系统内核，内核(Kernel)是操作系统最核心的部分，也是最接近硬件的部分 应用程序，跑在操作系统之上 两种指令指令：是指处理器(cpu)能识别、执行的最基本命令，二进制机器指令 两种处理器状态cpu判断指令类型，如何区分此时正在运行的是内核程序还是应用程序？ 内核态(目态)，此时正在运行内核程序，可以执行特权指令 用户态(管态)，运行应用程序，只能执行非特权指令 CPU有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示内核态，0表示用户态。 ⭐状态切换内核态-&gt;用户态：执行一条特权指令–修改PSW的标志位为”用户态”，操作系统主动让出CPU使用权 用户态-&gt;内核态：由中断(非法使用特权指令等)引发，硬件自动完成变态过程，触发中断信号意味着操作系统强行夺回CPU使用权 image-20231007090904321 中断和异常中断的作用CPU运行两种程序，内核程序和应用程序，内核程序是系统管理者 一个应用程序上cpu运行后就会一直运行下去 “中断”是让操作系统内核夺回CPU使用权的唯一途径，用户态-&gt;内核态 中断的类型内中断(也称异常)与当前执行的指令有关，中断信号来源于CPU内部 例子： 试图在用户态执行特权指令，终止 执行除法指令发现除数为0，终止 若当前执行的指令是非法的，则会引发一个中断信号 应用程序请求内核服务，执行一条特殊的指令——陷入指令，会引发内部中断信号，陷阱、陷入(trap) 陷入指令主动将控制权还给操作系统内核，“系统调用”就是通过陷入指令完成。陷入指令不是特权指令！ 外中断(也称中断，狭义的中断)与当前执行的指令无关，中断信号来源于CPU外部 例子： 时钟中断——由时钟部件发来的中断信号 如时钟部件每隔一个时间片发送时钟中断信号，用户态-&gt;内核态 执行内核程序，操作系统内核决定接下来让另一个程序上CPU运行，内核态-&gt;用户态 I&#x2F;O中断——由输入&#x2F;输出设备发来的中断信号 当输入输出任务完成后，向CPU发送中断信号 每一条指令执行结束后，CPU都会例行检查是否有外中断信号 image-20231007100331373 中断机制的基本原理不同的中断信号，需要不同的中断处理程序来处理 CPU检测到中断信号后，根据中断信号的类型去查询”中断向量表“，找到相应的中断处理程序在内存中的存放位置 系统调用系统调用是操作系统提供给应用程序(程序员&#x2F;编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获取操作系统内核的服务 操作系统向上的的接口 给用户用的 GUI 命令接口 联机命令接口 脱机命令接口 给应用程序用的 程序接口(系统调用) 计算机本质四个字寻址执行 系统调用和库函数的区别image-20231012085435583 为什么系统调用是必须的生活场景：去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开始工作。你的论文打印到一半时，另一位同学按下了Wod的“打印”按钮，开始打印他自己的论文。思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？两个进程并发运行，打印机设备交替地收到WPS和Word两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…解决方法：由操作系统内核对共享资源进行统一的管理，并向上提供“系统调用”，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。 系统调用按功能分类 设备管理，完成设备的 请求&#x2F;释放&#x2F;启动 等功能 文件管理，完成文件的 读&#x2F;写&#x2F;创建&#x2F;删除 等功能 进程控制，完成进程的 创建&#x2F;撤销&#x2F;阻塞&#x2F;唤醒 等功能 进程通信，完成进程之间的 消息传递&#x2F;信息传递 等功能 内存管理，完成内存的 分配&#x2F;回收 等功能 由于 ①应用程序通过系统调用请求操作系统服务 ②而系统中的各种共享资源由操作系统内核统一掌管 因此，凡是与共享资源有关的操作(如存储分配、I&#x2F;O操作、文件管理等)，都必须通过系统调用的方式向操作系统内核作出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。 系统调用的过程用户态应用程序要执行一列执行然后加一条陷入指令，引发一个内中断，使得能够转变为内核态运行系统调用入口程序，检查寄存器中的应用程序设置好的参数，判断是那种服务，调用处理程序上CPU运行，然后转回用户态 image-20231012092740165 image-20231012092809273 操作系统的体系结构本节简要了解 内核是操作系统最基本、最核心的部分 实现操作系统内核功能的那些程序都是内核程序 大内核和微内核√大内核√又名宏内核&#x2F;单内核和微内核√ image-20231012093655556 image-20231012093754573 分层结构 模块化 外核 image-20231012103814193 操作系统引导 BIOS：Basic Input&#x2F;Output System image-20231012105645065 虚拟机传统计算机，一台物理机器只能运行一个操作系统，容易造成性能浪费 虚拟机：使用虚拟化技术，将一台物理机器虚拟化成为多台虚拟机器，每个虚拟机器都可以独立运行一个操作系统 第一类VMM，直接运行在硬件上 此种上层操作系统运行在虚拟内核空间不是真实的，因此一些特权指令需要通过虚拟机管理程序进行转化并反馈 第二类VMM，运行在宿主操作系统上 常用的虚拟机软件，VirtualBox、Vmware。 虚拟机管理程序请求宿主操作系统再进行资源分配 image-20231012184011898 两类虚拟机管理程序(VMM)的对比 第一类VMM 第二类VMM 对物理资源的控制权 直接运行在硬件之上，能直接控制和分配物理资源 运行在Host OS之上，依赖于Host OS为其分配物理资源 资源分配方式 在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于“外核“的分配方式，分配未经抽象的物理硬件 GuestOS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。GuestOS分配到的内存是虚拟内存 性能 性能更好 性能更差，需要HostOS作为”中介” 可支持的虚拟机数量 更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机 更少，Host OS本身需要使用物理资源，HostOS上运行的其他进程也需要物理资源 虚拟机的可迁移性 更差 更好，只需导出虚拟机镜像文件即可迁移到另一台Ho5tO5上，商业化应用更广泛 运行模式 第一类VMM运行在最高特权级(Ring 0),可以执行最高特权的指令。 第二类VMM****。GuestOS发出的系统调用会被VMM截获，并转化为VMM对Ho5tOS的系统调用 进程和线程进程的概念、组成和特征进程的概念程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。 进程：是动态的，是程序的一次执行过程。(同一个程序多次执行会对应多个进程) 进程的组成——PCB操作系统给每一个进程分配一个PID，相当于进程的身份证号 还记录进程所属用户ID(UID) 还记录进程的运行情况(CPU使用时间，磁盘使用情况..) 这些信息都保存到PCB(Process Control Block)这个数据结构中，即进程控制块 操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息都被放在PCB中。 image-20231012194155841 image-20231012194722570 PCB 进程描述信息 进程控制和管理信息 资源分配清单 处理机相关信息 程序段 程序的代码(指令序列 数据段 运行过程中产生的各种数据(程序中定义的变量) image-20231012195222855 进程的特征程序是静态的，进程是动态的，相比于程序，进程有以下特征 动态性，是进程最基本的特征 进程是程序的一次执行过程，是动态地产生、变化和消亡 并发性 内存中有多个进程实体，各进程可并发执行 独立性 进程是独立运行、独立获得资源、独立接受调度的基本单位 异步性，异步性会导致并发程序执行结果的不确定性。 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题 结构性 每个进程都会配置PCB，结构上看，进程是由程序段、数据段、PCB组成 进程的状态与转换进程的状态运行态一个进程此时在CPU上运行，处于运行态。 就绪态阻塞态等待态。在进程运行的过程中，可能会请求等待某个时间的发生(如等待某种系统资源的分配，或者等待其他进程的响应) 创建态正在被创建，尚未转到就绪态 结束态进程正在从系统中消失，正常结束或其他原因退出运行。进程需要结束则先置为结束态——&gt;再进一步处理资源释放和回收等工作 #### 进程的控制 ##### 进程的创建 1 image-20231026093952808为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB是有限的)。若PCB申请失败，则创建失败。 2)为进程分配其运行所需的资源，如内存、文件、I&#x2F;O设备和CPU时间等（在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。 3)初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。 4)若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。 进程的终止操作系统终止进程的过程如下（终止原语）： 1)根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。 2)若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。 3)若该进程还有子孙进程，则应将其所有子孙进程终止。 4)将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。 5)将该PCB从所在队列（链表）中删除。 进程的阻塞和唤醒阻塞： 1)找到将要被阻塞进程的标识号对应的PCB。 2)若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。 3)把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。 唤醒： 1)在该事件的等待队列中找到相应进程的PCB。 2)将其从等待队列中移出，并置其状态为就绪态。 3)把该PCB插入就绪队列，等待调度程序调度。 进程的通信共享存储对共享空间进行读&#x2F;写操作时，需要使用同步互斥工具(如P操作、V操作)，对共享空间的写&#x2F;读进行控制。 共享存储分两种： 低级方式的共享是基于数据结构的共享 高级方式则是基于存储区的共享 消息传递若通信进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方式实现进程通信。 直接通信方式，发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息，如图23所示。 间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。 graph LR 共享存储: 进程1-->共享空间 共享空间-->进程1 共享空间-->进程2 进程2-->共享空间 graph LR 消息传递: 进程3-->进程4 进程4-->进程3 管道通信向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道：而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。 graph LR 进程1--字符流-->缓冲区 缓冲区--读取-->进程2 进程2-->- - -->进程1 为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 管道可以理解为共享存储的优化和发展 如果共享有进程在操作，会阻塞 儿存储空间变回缓冲区，不用担心阻塞，可以一边写入一边读出 线程和多线程引入进程——多道程序能并发执行——提高资源利用率和系统吞吐量 引入进程——减小程序在并发执行时所付出的时空开销——提高操作系统的并发性能 线程-轻量级进程 一个进程内部有多个线程，线程切换发生在一个进程内部 本章结束"},{"title":"数据库&php大作业","path":"/2023/07/10/数据库-php大作业/","content":"数据库&php说明文档2023/6/19","tags":["项目"],"categories":["本科课程"]},{"title":"磨蹭天气app--安卓大作业","path":"/2023/07/10/磨蹭天气app-安卓大作业/","content":"磨蹭天气app说明文档2023/6/12","tags":["项目"],"categories":["本科课程"]},{"title":"数据库笔记","path":"/2023/07/10/数据库笔记/","content":"习题 如何构造出一个合适的数据逻辑结构是_____C_______主要解决的问题。 A．关系数据库优化 B．数据字典 C．关系数据库规范化理论 D．关系数据库查询 ​ 关系数据库规范化理论，一个关系数据库模式由一组关系模式组成，一个关系模式由一组属性名组成。关系数据库设计，就是如何把已给定的相互关联的一组属性名分组，并把每一组属性名组成关系的问题。然而，属性的分组不是唯一的，不同的分组对应着不同的数据库应用系统，它们的效率往往相差很远。为了使数据库设计合理可靠，简单实用，长期以来，形成了关系数据库设计的理论——规范化理论。​ 关系数据库的优化是一个和实际数据库结构密切相关的问题，在实际应用中应该结合具体的数据库服务器，深入的理解服务器的运作模式、资源配置，优化服务器的运行环境，选择合适的操作系统，最大限度的发挥服务器的性能。​ 数据字典是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑、外部实体等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明。 其关注点是在数据项、数据元素上。​ 关系数据库查询，是通过查询语言（SQL），从关系数据库中查找符合查询条件信息的过程。 1概论三级模式结构，外模式、模式和内模式 模式也称为逻辑模式，对应于逻辑层数据抽象，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式也称子模式或用户模式，对应于视图层数据抽象，是数据库用户(包括应用程序员和最终用户)能够看见和使用的局部数据的逻辑和特征的描述。 内模式称为存储模式，对应于物理层数据抽象，是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。 4数据库建模矩形表示实体集、椭圆表示属性、双椭圆表示多值属性、菱形框表示联系集、双矩形表示弱实体集、双菱形表示表示实体集、虚下划线表示弱实体集部分码，ISA为“is a”表示父类-子类联系，内部包含菱形框的带填充背景的矩形表示联系实体集， →表示指向参与联系集中的“一”方实体集，—表示参与联系集中的“多”方实体集 约束映射约束 一对一 一对多 多对多 码约束多值属性1可以转化为多个单值属性 2将多值属性单独建模为一个弱实体集 主码选取原则： 属性长度最短的候选码 包含单个属性的码，而不是复合候选码 在数据库系统生命周期内属性值最少变化的候选码 在数据库系统生命周期内更可能包含唯一值的候选码 联系集的主码和属性安置二元联系集主码依赖于联系集的映射基数 一对一联系集：主码使用任何一方实体集的主码 一对多(多对一)联系集：主码由“多”的一方实体集的主码组成 多对多联系集：主码由参与实体集中所有实体集的主码组成 二元联系集 主码 属性安置 一对一联系集 任何一方 任一边的实体集上 一对多(多对一)联系集 “多”方 联系集或“多”方上 多对多联系集 所有实体集的主码 只能在联系集上 例如 将聘用日期直接定义为多方实体集教师的属性。 依赖约束两种： 依赖实体集：实体集依赖于联系集 弱实体集：实体集依赖于另一个实体集 参与约束如果实体集A中只有部分实体参与到联系集R的联系中，则称实体集部分参与到联系集R的联系中。每个实体都参与则为全部参与。 全部参与双实线表示 弱实体集弱实体集：其属性不足以形成主码，必须依赖于其他实体集的存在而存在 强实体集：可以形成主码的实体集称为强实体集 标识实体集：弱实体集所依赖的实体集称为标识实体集 联系实体集：聚合功能将一个联系集及其相关联的实体集抽象为联系实体集(高层实体集)对待，然后建立该联系实体集与其他实体集之间的联系集 ER建模问题ER建模的基本原则 忠实性 实体集、联系集、属性都应当反映现实世界，根据事实建模 简单性 非必须不增加更多成分 只需对数据库使用者感兴趣的属性建模，例如教师联系集中没必要将身高作为属性 避免冗余 原则：一个对象指存放在一个地方 选择实体集还是属性 作为属性：①属性不可分②属性不能和其他实体相联系 对于复合属性，可将该复合属性的每一个子部分直接建模为一个属性，而不必建模为实体集。例如“家庭住址”可分成“省份”、“城市”、“街道”三个部分 选择实体集还是联系集 实体对应现实世界中实际存在的事物，是名词 联系对应一般为一种动作，即描述实体间的一种行为 多元联系转化为二元联系 大部分情况下是建立一个依赖实体集或弱实体集，再与原实体集之间建立二元联系。 5关系数据理论与模式属性集闭包，由A函数确定的所有属性的集合 问题数据冗余导致的问题拿表举例：字段 studentNo studentName courseNo courseNo score 冗余存储 浪费大量存储空间 学生姓名和课程名被重复存储多次 更新异常 重复的副本被修改后，所有副本都必须进行同样的修改 修改的时候只修改了部分副本的学生姓名或课程名 插入异常 只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中 如果学生没有选修课程，那不能将他的信息插入，因为会违背实体完整性原则 删除异常 删除某些信息时可能丢失其他信息 当一个学生的所有选修课程信息都被删除时，该课程的信息也会被丢失 模式分解导致的问题分解后的模式是否具有无损连接，保持依赖等特性 无损连接：能够通过连接分解后所得到的较小关系完全还原被分解关系的所有实例，称为无损连接。 有损连接：无法完全还原回的 保持依赖：分解之后，主码和其他的属性要在同个关系模式中，可以理解为原本属性都依赖主码，分解后，属性依旧依赖于主码。所有依赖关系都应该在分解得到的关系模式中保留。 关系就是一个二维表 关系模式：用来定义关系 Student(Sno,Sname) 就是对关系表的描述，这是R(U)形式 五元组，R(U,D,DOM,F)，R关系名，U组成该关系的属性名集合，D属性组U中属性所来自的域，DOM属性向域的映像集合，F属性间数据的依赖关系集合。一般用R(U)，R(U,F)表示 关系数据库：基于关系模型的数据库，用关系描述现实世界 关系数据库的模式：定义这组关系的全体 数据依赖 完整性约束，实体完整性，参照完整性，用户自定义完整性 表现形式： 限定属性取值范围 定义属性值间的相互关联(值相等与否)，这就是数据依赖，是数据库模式设计的关键 主要类型 函数依赖FD 多值依赖 连接依赖 关系模式的简化表示 关系模式简化为三元组R(U,F) R关系模式，二维表是关系 当且仅当U上的一个关系r满足F(数据依赖)时，r称为关系模式R(U,F)的一个关系 规范化理论 用来改造关系模式 判断数据依赖是否存在是否存在不合适的地方，通过分解消除其中不合适的数据依赖 解决插入异常、删除异常、更新异常和数据冗余问题 函数依赖在关系模式R的任意一个可能的r，每一个X对应一个Y则X决定Y，称X确定Y，或Y函数依赖于X，X→Y 如学号决定性别，学号决定年龄，姓名决定性别，姓名决定年龄(不同名)；不存在学号相等的情况下性别不等，反过来不一定成立 平凡函数依赖与非平凡函数依赖X→Y，当Y不包含于X，则称为非平凡依赖，若Y包含于X则为平凡依赖 例如关系模式SC(Sno,Cno,Grade) 非平凡依赖：(Sno,Cno)→Grade，一个学号和的一门课程对应一个唯一的成绩，Grade不包含于(Sno,Cno)中 平凡依赖：(Sno,Cno)→Sno和(Sno,Cno)→Cno，学号可课程号可以确定唯一学号&#x2F;课程号，后者包含于前者 完全函数依赖与部分函数依赖 例如关系模式SC(Sno,Cno,Grade) 完全函数依赖：(Sno,Cno)→Grade，只有学号加课程号才能决定成绩，单独的学号或课程号无法决定成绩Grade 部分函数依赖，：(Sno,Cno)→Sno和(Sno,Cno)→Cno，其中一个真子集可以决定 传递函数依赖 借助中间的Y 码 候选码：K为关系模式R(U,F)中的属性或属性组合，U完全依赖与K(K完全决定U)，则K称为R的一个候选码。(K可以决定所有的其他属性，且它本身不含多余值) 若关系模式R有多个候选码，则选定其中一个作为主码 候选码能够唯一地标识一个关系的元组 主码又和外码一起提供了一个表示关系间联系的手段 组成候选码的属性叫做主属性，其他的就是非主属性 范式关系数据库的关系满足一定要求称为一种范式 第一范式1NF是最基本的要求，R的所有属性都是不可分的基本数据项 部分函数依赖使得不是一个好的模式——要分解 （Sno,Cno image-20230429215614925能决定其他全部属性，但是是一个部分函数依赖，分解成下图： 但是这样还是不够好，SC是好的，SL中每一个学生都对应一个宿舍楼Sloc，2000个学生就有2000个宿舍，冗余了，因此要求要再严格些 第二范式2NF SL仍有异常，因为存在传递依赖，分解掉 第三范式3NF上面的例子中，SL属于第二范式2NF，但是有传递函数依赖，去掉之后得到SD、DL，消除了函数依赖 注意定理中，第三范式还是建立1NF基础上而不是2NF，其实3NF是一种特殊的2NF，是3NF则一定是2NF 若R∈3NF，则R的每一个**非主属性既不部分函数依赖于**候选码也不传递函数依赖于候选码。解决的是非主属性，但仍存在问题 BC范式(BCNF) 候选码一定包含在左端！修正的第三范式 如果一个关系模式R(属于第一范式)写出来的所有函数依赖X→Y，左边X都含有候选码，R是BC范式。 BCNF的关系模式所具有的性质 所有非主属性都完全函数依赖于每个候选码 所有主属性都完全函数依赖于每个不包含它的候选码 没有任何属性完全依赖于非码的任何一组属性 BC范式与第三范式的关系 BC一定是第三，第三不一定是BC(因为第三只规定了非主属性) 如果R是第三范式，且R只有一个候选码，则R必属于BCNF。（一般情况下关系模式有一个候选码，第三范式就满足了BC范式） BC是最高等级了，消除了异常 BCNF范式排除了： 任何属性(包括主属性和非主属性)对候选码的部分依赖和传递依赖； 主属性之间的传递依赖。 例子： 这题中关系模式只有三个属性，(S,C)→T，(S,T)→C，则这两个都是候选码，S、T、C都是主属性，所以也满足第三范式即STC∈3NF 但是不是BCNF，因为(S,T)→C同时T→C，主属性部分依赖于码(S,T)因此还需要分解才能变成BC范式。 对比3NF和BCNF BCNF比3NF严格。 BCNF要求所有的非平凡函数依赖中的是超码，而3NF则放松了该约束，允许不是超码。 若关系模式属于BCNF范式就一定属于3NF范式。反之则不一定成立。 3NF存在数据冗余和异常问题，而BCNF是基于函数依赖理论能够达到的最好关系模式。 BCNF范式分解是无损分解，但不一定是保持依赖分解; 而3NF分解既是无损分解，又是保持依赖分解。 规范化 范式 特征 1NF 所有的数据项不能再分 2NF 消除非主属性对码的部分函数依赖 3NF 消除非主属性对码的传递函数依赖 BCNF 函数依赖左端属性集一定包含候选码 函数依赖理论函数依赖集闭包（重要概念） 定义5.11 若给定函数依赖集F，可以证明其他函数依赖也成立，则称这些函数依赖被F逻辑蕴涵。 定义5.12 令F为一函数依赖集，F逻辑蕴涵的所有函数依赖组成的集合称为F的闭包，记为F+。 函数依赖集F的闭包计算方法 Armstrong公理的推理规则 属性集闭包（重要概念） 无损连接分解表格判断法 image-20230623110907566 保持依赖分解候选码的计算把左边写出来，右边写出来，重复的删去，只在左边出现一定是候选码，右边出现的一定不是候选码 如果能推出来全体，则为唯一候选码 当去重的左边不能推出全部的时候，从不确定的中任取一个加入到左边的 8数据库存储结构与查询启发式优化策略 尽早执行选择操作 尽早执行投影运算","tags":["笔记"],"categories":["本科课程"]},{"title":"软件需求笔记","path":"/2023/07/10/软件需求笔记/","content":"第一周软件需求层次 业务需求 内容：表示组织或客户对系统、产品高层次的目标 描述方式：前景（视图）和范围文档 示例：为了让南海校区的同学和老师提供订餐便 利，节约排队打饭时间，同时减少食堂的浪费， 需要开发“南海校区网上订餐系统” 。 用户需求 内容：描述了用户要求系统、产品必须能完成的任务 描述方式：用例模型 示例：“订餐” 、 “变更订单” 、 “查看菜单” 、 “支付订单” 。 系统、功能需求系统需求 描述子系统包含的需求，实现的功能。 示例： 系统需求：自动订餐系统要能实现选菜、选时间送餐功能等。 通过功能需求来进行细化描述。 功能需求 开发人员必须在产品中实现的软件功能， 用户利用这些功能来完成任务，满足业务需求。 有时称为行为需求。简而言之，描述的是开发人员需要实现什么。 描述方式：软件需求规格说明书（SRS） 示例：“订餐” Order.Place、 “创建浏览修改和 删除订餐” 、 “订餐支付” Order.Place.Pay 、 “请求送餐” Order.Deliver.Select等等 质量属性声明各种系统操作特定的性能需求。影响功能需求 外部接口a.用户接口； b.硬件接口； c.软件接口； d.通信接口的需求。 业务规则 是对业务的某个方面进行定义或约束的语句。业务规则用于声明业务机构、或者控制、影响业务的行为。 需求的开发与管理需求工程分为需求开发与需求管理 需求开发需求获取 编写前景和范围文档 用户代表沟通确定用例 召开专门的需求获取讨论会 需求分析 绘制关联图 确定需求优先级 为需求建模 创建数据字典 规格说明 采用SRS模板 为需求分配唯一标号 需求验证 审查需求文档 测试需求 需求管理 在需求开发阶段，通过市场、客户、管理三方将需求通过分析、编写文档、评审、商议得到基准需求说明 在需求管理阶段，定义需求变更控制过程，通过基准需求说明获取当前基线。跟踪每项需求的状态，市场、客户、管理会进行需求变更，项目环境会产生项目变更，这个需求变更过程就需要对基准需求说明进行基线修正，建立基线和控制需求文档的版本。 第二周关于签字：要建立需求协议的基线。将需求 变更控制在基线范围内。 需求分析 创建关联图 确定需求优先级 为需求建模 创建数据字典 需求验证 审查需求文档 需求管理 定义需求变更控制过程 建立基线和控制需求文档的版本 跟踪每项需求的状态 项目管理 选择合适的软件开发生命周期 管理与需求相关的风险及编写风险文档 需求分析员工作 获取需求 分析需求 编写需求规格说明 第三周前景与范围文档 关联图 生态系统图 特性树 第四周聆听客户的需求需求获取的核心：发现用户需求 强调用户任务，而不是用户界面 强调根本需求，而不是用户表达 第五周用例图 子系统有时多个用例包含一组相同的步骤。为了避免每个用例都重复相同的步骤，可以定 一个单独的用例来包括这些相同的功能， 然后由其他用例来包含这个子用例。 包含关系image-20230620110010476 （2）一个用例的功能太多时，可以用包含关系创建多个子用例。 拓展关系image-20230620110203026 第六周业务规则 是对业务的某个方面进行定义或约束的语句。业务规则用于声明业务机构、或者控制、影响业务的行为。  基本的业务规则是公司的重要资产，如果没有适当的记录和管理，就只会存在于个 人的大脑中，而不同的人对规则的理解可 能是相互矛盾的。如果知道每个应用程序在什么位置，如何实现引用与其相关的业务规则，那么当业务规则发生变化时，修改程序会容易很多。 业务规则影响了业务需求、用户需求、功能需求、质量属性 用特定数学公式货算法进行的计算: 例： 订单数量为6-10件，则单价降低10%； 数量为11-20件，单价降低20%； 数量超过20件，单价降低35%。 用表格形式表示更清晰。 image-20230620092845057 一些业务规则目录的例子： image-20230620092913807 每条业务规则都有一个唯一的标识符，这样你就能从功能性需求追溯到对应的规则 规则类型：这里指出是事实、约束、动作触发规则、推论还是计算。 静态或动态：这一列说明该规则随时间变化的可能性有多大。 来源：公司政策、管理政策、主题专家、其他人士、政府法规、软件代码、数据库定义。 如何发现业务规则？ 通过不同角度来提问 image-20230620093053561 大作业： 第七八周需求规格说明 优秀需求的特点 完整性 一致性 可修改性 可追溯性 避免使用有歧义的术语！！ 实例 只叙述一个实体 时间起点和预防错误 标准宽泛，信息不清 歧义、信息不清 操作结果不清晰 例子 数据字典！！是一个共享存储库，用于定义应用程序中使用的所有数据元素或属性的含义、数据类型、长度、格式、需要的精度以及数据允许的取值范围或数据值的列表。 离散值 [a|b|c] 重复项 3{a}8 基本数据元素 x&#x3D;”a” 第九周数据流图image-20230620091720572 泳道图image-20230620091454213.png 状态转换图image-20230620091809896 1.DF2 外部实体与实体之间不存在数据流 2.DF6 外部实体与数据存储之间不存在数据流 3.DF7 数据存储与数据存储之间不存在数据流 4.P4 加工的输入和输出不能同名 5.P1 P3 每个加工既有输入又有输出 电话号码&#x3D;[校内电话号码|校外电话号码] 校内电话号码&#x3D;非零数字+ 3 位数字 &#x2F;&#x2F;后面继续 校外电话号码&#x3D;[本市号码|外地号码] 本市号码&#x3D;数字零+8位数字 外地号码&#x3D;数字零+3位数字+8位数字 3位数字＝3{数字}3 &#x2F;&#x2F;3至3个数字 8位数字&#x3D;非零数字+7位数字 7位数字&#x3D;7{数字}7 非零数字&#x3D;[1|2|3|4|5|6|7|8|9] 数字零＝0 数字＝[0|1|2|3|4|5|6|7|8|9] 第十周实体关系图 ER图 类图关联-&gt; 聚合 组合 依赖 泛化 实现 区别关联VS聚合VS组合 三者都体现类之间的“拥有”关系，聚合和组合，都是整体和部分的关系，只是两种关系中类的生命周期不同。聚合是“弱拥有”，组合是“强拥有”。 关联VS依赖 这两种关系的区别很明显，关联体现的是“拥有”，依赖体现的是“使用”。 泛化VS实现 泛化体现两个类之间的关系，实现是类与接口之间的关系。泛化强调的是类之间的继承，实现强调的是类对接口的实现。 通过对比总结出类图之间4种关系的强弱：依赖&lt;关联&lt;聚合&lt;组合&lt;泛化&#x3D;实现 十二周 V&#x3D;E-N+2，11-10+2&#x3D;3，环路复杂度为3 十三周 第一个空正推得到最长的、第二个空倒推，用最长的往前推，而且往前推要往耗时长的推，例如L是22，往BD推经过走LK，因为耗时长，找那个最需要满足的 如果是BF，最长22，到F是十六，就是十六天要到F，而BF路径最快只需要6天，因此可以拖10天。","tags":["笔记"],"categories":["本科课程"]},{"title":"人机交互笔记","path":"/2023/07/09/人机交互笔记/","content":"概述什么是人机交互人机交互是指关于设计、实现和评估供人们使用的交互式计算机系统，并围绕相关的主要现象进行研究的学科。 ⭐人机交互技术的研究内容 7点 人机交互界面表示模型与设计方法 Web设计 移动界面设计 移动界面的设计方法、可用性与评估原则、移动界面导航技术以及移动界面的实现技术和开发工具。 认知与智能用户界面 上下文感知、三维输入、语音识别、手写识别、自然语言理解。 多通道交互技术 视觉、听觉、触觉和力觉语音、手势、眼神、表情表示模型、评估方法以及多通道信息的融合等。 群件 群件系统的体系结构、计算机支持的交流与共享信息的方式、交流中的决策支持工具、应用程序共享以及同步实现方法等。 可用性分析与评估 人机交互技术所导致的社会问题与解决方案 缺点 焦虑 疏远 信息匮乏的少数群体 个人的无力 令人困惑的复杂性和速度 组织脆弱性 侵犯隐私 失业和裁员 缺乏专业的责任制 恶化的人类形象 解决方案 以人为本的参与式设计 组织的支持 工作设计 教育 反馈、认可和奖励 提高公共意识 立法 ⭐设计上的不同观点📑 软件工程师(技术视角) 软件需求分析 软件设计 接口软件编码 交互支撑软件编码 应用程序编码 软件验证和确认 人机交互设计师(用户视角) 用户任务分析 可用性规格说明 交互体系结构&#x2F;设计 界面设计&#x2F;规格说明 软件支撑确认 可用性评估 ⭐发展历程基本交互：命令行图形界面：GUI语音交互：语音助手体感交互：5D电影 ⭐人机交互的三个革命性产品鼠标多点触控体感设备 第一章可用性工程🟡交互系统可用性的概念📑可用性是指当用户在特定的环境中使用产品完成具体任务时交互过程的有效性、交互效率和用户满意度。 增强可用性的好处 提高生产力 增加销售和利润 降低培训和产品支持的成本 减少开发时间和开发成本 减少维护成本 增加用户的满意度 可用性的目标和度量📑 书p9最后🟡目标可用性目标：有效性、交互效率和用户满意度，有效性通常是软件测试需要解决的基本问题，因此度量可用性两种只关注后两个目标。 🟡度量1.学习时间 典型的用户群体需要花多长时间来学习如何使用与一组任务相关的任务? 效率 2.运行速度 执行基准任务需要花多长时间? 效率 3.用户出错率 在基准测试任务中会犯多少错误? 4.记忆保持时间 使用频率和易于学习有助于提高用户记忆 5.主观满意度 允许用户通过访谈、自由形式的评论和满意度量表进行反馈 用户满意度 五个核心人为因素–易学习 支持用户对产品的入门使用户在以后使用过程中的持续学习。 –有效性 怎样准确、完整地完成工作或达到目标。 –效率 怎样快速地完成工作。 –吸引力 用户界面如何吸引用户进行交互并在使用中得到满意和满足。 –容错 产品避免错误的方式并帮助用户修正错误的能力。 可靠性标准化集成一致性和可移植性 可用性分析 支持可用性的设计原则（如何保证三个原则–多选题） p47三个原则 可学习性 可预见性 用户利用对前面交互过程的了解就足以确定后面交互的结果。 同步性 是指用户依据界面当前状态评估过去操作造成影响的能力，也就是说用户能不能同步地知道交互操作的结果。 熟悉性 如果新系统跟过去使用过的类似系统有一 定相关性，那使用起来就比较方便。 通用性 就是在交互中尽可能地提供一些通用的或能够从现有功能类推出来的功能 一致性 是指在相似的环境下或执行相似的任务时一般会执行相似的行为。 灵活性 可定制性 指用户或系统修改界面的能力 对话主动性 多线程 同时支持多个交互任务 可互换性 可互换性意味着任务的执行可以在系统控制和用户控制间进行转移。 可替换性 可替换性要求等量的数字可以彼此交换 鲁棒性 可观察性 可恢复性 响应性 任务规范性 什么是交互系统的可用性可用性的度量 可用性动机 专业环境：精确 工商业：易学、准确、性能的折中 娱乐：主观满意度 社会：隐私、安全 你是否体验过可用性差的软件系统？可否分析其原因？📑第二章 通用性🟡通用性的目标 书p26满足所有用户的需求 作为专业人士，用户会因为我们满足了他们的需求而记住我们移动设备的巨大国际消费市场，陡然提高了对普遍可用性设计的压力 ⭐人的感知和知觉的特性 p10人机交互过程主要是通过视觉、听觉和触觉感知进行的。 视觉 一方面，眼睛特性决定人类无法看到某些事物 另一方面，视觉系统对不完全信息发挥一定想象力 所以人机交互设计时需要了解人真正能够看到的信息 听觉 声音三个属性：音调、响度和音色 触觉和力觉 触觉和上面两个最大不同在于非局部性 温度感受器——冷热 伤害感受器——疼痛 机械刺激感受器——压力 力觉指肌肉和关节等感受到的力量感和方向感 内部感觉 体位感觉 快速适应感受器 慢速适应感受器 位置感受器 深度感觉 内脏感觉 ⭐🟡知觉的特性📑 ppt参考答案： ① 知觉的选择性：分化对象和背景的选择性是知觉最基本的特性，背景往往衬托着、弥漫着、扩展着，对象往往轮廓分明、结构完整。 ② 知觉的整体性(补全残缺)：当一个残缺不全的部分呈现到眼前时，人脑中的神经联系马上被激活，从而把知觉对象补充完整。格式塔心理学家认为，主要有五种完形法则：图形背景法则，接近法则，相似法则，闭合法则和连续法则。 图形背景法则：在界面设计中的实例 接近律：空间距离接近者容易被感知为一个整体 相似律：相似（颜色、形状、纹理）的图形会被认为一个整体 闭合律：知觉具有把不完全图形补充为一个完全图形的倾向 连续律：把经历最小变化或最少阻断的直线或者圆滑曲线感知为一个整体 ③ 知觉的理解性：旧经验与新刺激建立多维度、多层次的联系，以保证理解的全面和深刻。 ④ 知觉的恒常性：当客观条件在一定范围内改变时,人的知觉映象在相当程度上却保持着它的稳定性，即知觉恒常性。(例如红旗不管在什么光照下，人都会把它知觉为红色。) 常见认知📑 感知与识别：人们可以使用感官从环境中获取信息，并把它转变为对物品、事件、声音和味觉的体验。 注意：注意通常是指选择性注意，即注意是有选择的加工某些刺激而忽视其他刺激的倾向。 记忆：记忆就是回忆各种知识以便采取适当的行动。 问题解决：问题解决是由一定的情景引起的，按照一定的目标，应用各种认知活动、技能等，经过一系列的思维操作，使问题得以解决的过程。 语言处理：阅读、说话和聆听这三种形式的语言处理具有一些相同和不同的属性。相似性之一是，不论用哪一种形式表示，句子或短语的意思是相同的。但是，人们对阅读、说话和聆听的难易有不同的体会。 ⭐影响认知的因素📑情感，个体差异，动机，兴趣 影响感知和运动性能的因素📑‒警醒度和警惕性 ‒疲劳和睡眠不足 ‒感知(精神)负担 ‒结果和反馈知识 ‒单调和乏味 ‒感官剥夺 ‒营养与饮食 ‒恐惧、焦虑、情绪和情感 ‒吸毒、抽烟和酗酒 ‒生理周期 ⭐个体差异和不同的使用场所人是被细分的，但没有针对用户个性的简单分类，不过有迈尔斯-布里格斯类型指标 (MBTI），分为 外向还是内向 感觉和直觉 感知与判断 感受与思考 没有“平均”用户，要么必须做出妥协，要么必须创建多个版本的系统 音频大小调节 触摸屏灵敏度调节 屏幕亮度、对比度调节 不同的认知和感知能力 长期记忆和语义记忆 短期记忆和工作记忆 问题求解和推理 决策和风险评估 语言交流与理解 搜索、表象和感官记忆 学习、技能开发、知识获取和概念获得 🟡残疾用户、老年用户、儿童 书p31-36理解针对三种用户如何来设计软件 描述三个有特殊需求的用户群体。对于这些人群中的每一个人，建议有三种方法可以改善当前的界面，以更好地服务于他们。📑参考答案：① 残疾用户： i. 视觉障碍者(文本转成语言)，听觉障碍者（语音转文本），身体障碍(语言输入设备、人眼凝视技术等)；ii. 用脑机接口等高科技手段，帮助高度残疾或者其他特殊人群（比如渐冻症患者）使用计算机。 ② 老年用户： i. 界面使用更大的字体，更明显的图标，提高音量，方便老年用户进行操作。ii. 减少动画的干扰，增加界面的色彩饱和度。iii. 包含语音交互的模式，降低操作精度，减少老年用户的点触。 ③ 儿童用户： i. 降低操作精度，减少精确的操作，比如区域化选择对象、时效性拖动对象等操作，从而提升儿童用户的体验乐趣。ii. 更多的使用形象化的、生活化的图形界面设计，减少同一化的、相似的、抽象的概念图形，让界面对儿童用户更加有吸引力。iii. 简化应用流程，降低应用程序逻辑的复杂度。 ⭐通用性设计原则 7条 公平地使用一Equitable Use：对具有不同能力的人，产品的设计应该是可以让所有人都公平使用的。 可以灵活地使用一一Flexibility in Use：设计要迎合广泛的个人喜好和能力。 简单而直观一Simple and Intuitive Use：设计出来的使用方法是容易明白的，而不会受使用者的经验，知识，语言能力及当前的集中程度所影响。 能感觉到的信息一一Perceptible Information：无论四周的情况或使用者是否有感官上的缺陷，都应该把必要的信息传递给到对使用者。 容错能力一Tolerance for Error：设计应该可以让误操作或意外动作所造成的反面结果或危险的影响减到最少。 尽可能地减少体力上的付出一Low Physical Effort：设计应该尽可能地让使用者有效地和舒适地使用，而丝毫不费他们的气力 提供足够的空间和尺寸，使用者能够接近使用一一Size and Space for Approach and Use 人的感知和知觉特性 声音属性听觉现象知觉的特性（4个） 晚上的红旗–恒常性个体差异和不同的使用场所个性差异、文化多样性、国际多样性残疾用户、老年用户、儿童什么是认知 常见的认知影响认知的因素作业2 第三章 指南成功的用户界面开发 用户界面需求 指南文档和过程 用户界面软件工具 专家评审 可用性测试 ⭐🟡指南、原则与理论（模型） 书p42什么是指南？基于最佳实践的具体而通用的做法 指南(Guidelines) 底层，具体而实用 规定好的做法并警告危险 原则(Principles)中级，策略和规则，用于分析和比较设计备选方案。 理论和模型(Theories and model)高层，用一致的术语描述对象和动作；可用于交流、教学、预测 常用指南三个常用的指南 IOS 微信 WCAG ⭐四个具体导航 p12 界面导航 4个要求+NCI指南 指南 4个要求 替代文本。为每个非文本内容提供替代文本。 基于时间的媒体。为基于时间的媒体（如电影或动画）提供备选项。 可辨识。使用户更易看到和听到的内容，包括前景和背景的分离。 可预测。为每一帧加上标题，以方便识别和导航 NCI指南 将任务序列标准化 确保嵌入的链接是描述性的 使用一致的描述性标题 对互斥选择使用单选按钮 开发出适合于打印的页面 使用缩略图预览较大的图像 组织显示 5个目标 五个高水平的目标 数据显示的一致性：各类术语、字体颜色、格式、大小统一标准 详细的动作序列加快学习进度 用户信息的有效吸收：数据排列整齐、对齐、适当换算、添加标签 降低了错误率 用户记忆负担最小化：执行步骤少，不应该被要求记住冗长的代码列表 数据显示与数据输入的兼容性 数据输入信息的格式应与显示信息的格式紧密相 连，例如电话号码中的破折号 用户控制数据显示的灵活性 引起用户注意 8个技术点 p34 亮度 标记 尺寸 字体选择 反视频 闪烁的 颜色 音频 数据输入 5个目标 p39 数据输入业务的一致性：加快用户学习速度 最少的用户输入动作：减少步骤 用户记忆负担最小化：减少长代码列表 数据输入与数据显示的兼容性：统一输入和显示的信息格式 用户控制数据输入的灵活性：按用户喜好灵活调准输入顺序 🟡图形用户界面的主要思想（要能够解释这三个名词） pptp50❗ 桌面隐喻 指在用户界面中用人们熟悉的桌面上的图例清楚地表示计算机可以处理的能力直接隐喻、过程隐喻、工具隐喻 所见即所得 界面中，用户交互行为与应用程序最终产生的结果一致。 直接操纵：直接操纵是指可以把操作的对象、属性、关系显式地表示出来，用光标、鼠标、触摸屏或数据手套等指点设备直接从屏幕上获取形象化命令与数据的过程界面设计的8条黄金法则： 🟡图形用户界面设计的一般原则 （区分八条黄金法则）p54 书p51 ❗非常重要 背！！ 坚持一致性 概念：在相似的环境中应要求一致的动作序列。在设计类似的情况和操作顺序时，通过利用相似的图标、颜色、菜单层次结构等争取一致性，减轻用户认知负担。 例子：顶部栏结构交互文案高度统一 违反的例子：①蓝桥杯官方（https://dasai.lanqiao.cn/）：账号不一致。登录官网报名和使用官网练习系统需要登陆两次，不一致，很麻烦 寻求通用性 概念：随着使用次数的增加，用户需要有更快的完成任务的方法。 常用操作要有快捷方式。认识到不同用户和可塑性的要求，可使内容的转换更便捷。 例子：搜索显示搜索热点历史，关联搜索，提前显示词条 违反：华师图书馆公众号的服务门户：没有将用户常用的功能放在较为显眼的位置，也没有将功能分类，而是单纯的堆叠 提供信息反馈 概念：用户应该始终知道他们当前位于哪里以及发生了什么。 对于每一个行动，在合理的时间内应该有适当的、人类可读的反馈。 例子：无网络告知状态和操作，给予相关可操作按钮，提供解决方案 违反：微信好友拉黑无消息反馈、群成员退群群主&#x2F;管理员无消息反馈 设计对话框产生结束信息 概念：不要让你的用户猜测。 告诉他们他们的行为把他们导向了哪里。 例子：支付成功提示、发布成功提示 违反：Pixiv lite APP ： 违背了第4 条法则， 在图片下载完成后没有弹窗提示下载完成 预防错误 概念：系统的设计应该尽可能地防止错误，例如不适应的菜单项变为灰色。但是当发生不可避免的错误时，应确保向用户提供简单、直观的分步说明，以尽快、尽可能没有痛苦得解决问题。 例子：没有输入不能点击、删除的二次确认，错误后撤回 违反：华师选课系统：退选操作没有确认提示 提供回退操作 概念：设计师应该为用户提供明显的方式来扭转他们的行为。因为用户知道错误能够撤销后，就能够减轻焦虑，进而尝试不熟悉的选项。 例子：撤销、保存、返回 违反：微信不提供灵活的撤销消息，如果超过一定时间未撤回无法再撤回 用户掌握控制 概念：让用户作为行动的发起者，让用户感觉到他们完全控制了数字空间中发生的事件。 例子：保存、不保存、取消 违反：微信的语音播放：不允许自己拉动播放进度，这对于60 秒这样的长语音很麻烦 减少短期记忆负担 概念：界面设计应当尽可能简洁，保持适当的信息层次结构，让用户去再认信息而不是去回忆。再认信息总是比回忆更容易，因为再认通过感知线索让相关信息重现。 例子：观看历史 微信：表情包不能分组，要发表情包的时候全部在一个组里，挑选困难，记忆负担大 🟡五大人机交互理论 参考案例，会用模型，含义 层次设计理论 pptp60 书p59， GOMS，以填充猫咪的头为例 G-Goals（目标）就是执行任务最终想要得到的结果。 目标是填充猫咪的头 O-Operations（操作）是任务分析到最底层的行为，是用户为了完成任务必须执行的基本动作。 需要通过涂鸦来填充区域 M-Methods（方法）是描述如何完成目标的过程。 填充区域需要点击涂鸦工具，然后给区域上色 S-Selection rules（选择规则）是用户要遵守的判定规则， 以确定在特定环境下所使用的方法。 鼠标移动到涂鸦工具20ms-点击2ms-移动到猫咪头位置20ms-点击2ms-填充4ms 行动阶段理论 一致性理论 情境理论 动态理论 🟡多层级设计 书p47多层级设计：循序渐进地教授新手不同的功能，提供个性化的帮助和相应（更多&#x2F;少提示信息）&amp;界面设计（更简单&#x2F;复杂的展示页面） 指南、原则和理论 明确概念引起用户注意的指南 13.选择交互风格 🟡作业 界面设计的八条黄金法则第四章 设计🟡设计进程 （4个阶段）p16 📑 书p76页图❗背 1需求分析 对象 背景 用户需求分析 功能性 非功能性 用户体验 2概要和详细设计 p21 概要设计：明确交互系统的高层次设计或架构。 确定技术路线选择 根据需求划分功能模块 定义每个模块的职责 指定各功能模块间的接口 设计项目数据结构 编写严谨的数据字典 指定开发和测试计划 详细设计：制定每个交互的细节。 细化每个模块的输入和输出 指定每个模块内部数据结构 规划每个模块内部处理算法 确定每个模块内部状态转换过程 概要设计需映射出高层次的概念：用户、控件、界面、导航机制、工作流程等 3构造与实施 将所有精心的设计转化为实际的、可运行的代码。 4评估 测试并验证系统的实现情况，以尽可能地确保其符合需求和设计方案。 🟡为医院设计一个系统，使接待员能够更快地为病人登记。 利用四个阶段参考答案：没有标准答案，只要以这个项目的管理计划的形式写下答案就好。对于每个阶段，指出应该分配的周数。提示:注意设计过程的四个阶段: 需求分析 初步(概念)和详细设计 建立和实施 评价（同学1）1 需求分析(1) ⽤户对象：病⼈、接待员(2) 背景：医院(3) 功能性需求：病⼈可以通过系统完成个⼈信息的注册，若已存在注册， 则可通过该账户进⾏登录并进⾏挂号，同时将信息传送⾄接待员。接待员在得到病⼈的个⼈信息后，可通过该系统帮助⽤户进⾏信息登记，并查看该类科室是否有空位可及时提供给病⼈进⾏问诊，若⽆，则将其按顺序放置于较少⼈在排队的序列中。(4) ⾮功能性需求：⽤户可以修改⾃⼰的个⼈信息，如身体状态、电话号码、个⼈地址等；接待员在⽤户修改信息时，可以看到变更的信息，并将其记录于系统中。(5) ⽤户体验需求：该界⾯将设计帮助功能，以帮助⽤户解决在登陆或注册过程中存在的问题。例如，⽤户当不知道个⼈症状属于哪类科室时，可以点击上⽅的帮助功能中的科室症状分类，并于其中查看个⼈症状所属科室。(6) 阶段完成时间：三周 2 概要和详细设计 (1) 概要设计 ①技术路线：利⽤⾼保真原型技术进⾏设计，虽花费时间可能较⻓，但能得到⼀个较为完善的模型，他能有基本的计算能⼒，可使设计者可以直观的看到设计的效果。 ②功能模块：查询、挂号、登录、注册、预约、分配 ③⼯作流程：病⼈先进⾏注册后再登陆账号，按⾃⼰的症状查询是否存在空余的科室，可以按个⼈需求进⾏提前的预约，并进⾏挂号。接待员帮助病⼈挂号后，查询是否有空余的科室，将病⼈分配⾄指定的科室。 (2) 详细设计 注册：病⼈或接待员使⽤系统功能前需进⾏个⼈注册，若已有个⼈信息档案则可跳⾄⽤户 登录阶段； 登录：病⼈或接待员需进⾏登录才可以使⽤系统； 预约：病⼈可以以指定⽇期进⾏预约， 防⽌当天指定的医⽣就诊⼈数已满； 挂号：病⼈进⾏问诊前，需进⾏挂号才可以进⼊科室； 查询：病⼈可以查询需要就诊的科室是否还有空位，或当天指定医⽣是否出诊。 分配： 当病⼈挂号未指定医⽣时，接待员通过该系统帮助其查询是否存在科室有空闲， 并将病⼈安排⾄该类科室。 (3) 阶段完成时间：四周 3 构造和实施 ⼿机：可利⽤微信⼩程序搭建⼀个相对稳定开发的环境进⾏设计，且在微信上可⽅便⽤户的使⽤； ⽹络：利⽤web 前端技术如⽹⻚搭建技术可使⽤html 进⾏⽹⻚的设计，同时利⽤java技术进⾏功能的设计，以及axure 进⾏ui 设计。后期还可以利⽤jjsdk 进⾏⽀付等功能的添加 ​ 阶段完成时间：四周 4 评估⾸先需要对注册与登录功能的联动进⾏测试，在进⾏注册后，⽹络是否保存了⽤户的注册信息并且⽤户是否可以顺利登录该⽹站，或者未注册的账号是否错误的存在可以登陆的情况。同时验证预约和挂号的功能，⽤户预约后，在指定的⽇期中⽤户是否可以挂号，并且在挂号后，接待员是否看得⻅病⼈挂号的信息，以及能否顺利的将病⼈分配⾄指定的科室。在⽤户查询到指定的科室后，还需验证是否可以顺利的完成预约或挂号。若以上功能的联动都能准确⽆误的完成，则判定该设计已经顺利地完成，若存在部分功能的缺漏， 则需返回上个阶段进⾏功能的补充。 阶段完成时间：两周 ⭐用户分析方法 研究方法 情景调查 用户访谈 问卷调查 A&#x2F;B测试 可用性测试 用户行为分析 最有效的方法之一 分析方法 漏斗模型 描述各个 阶段中关键环节的用户转化和流失率情况 常用用户指标 访问用户数 新用户数 活跃用户数 流失用户数 回访用户数 ⭐⭐任务分析❗（7种任务分析的方法 前两种是重点 看课件）pptp37 🟡用例图、顺序图任务分析关心的是如何从用户那里理解和获取用户的思维模式 使用行为分析 p38 要理解系统中每个参与者及其所需完成的任务 一般使用‘用例图’描述 p40 顺序分析 p42 使用顺序图进行描述。 用例常常被细化为一个或更多的顺序图 返回是虚线！！ 协作关系分析 某个用户行为中各个系统元素之间的关系 工序约束陈述 工序–步骤，某些工序之间的顺序有一些逻辑关系 工序约束例子：eg.系统管理员必须先增加借阅者信息，读者才能登陆。 用户任务一览表 任务金字塔 任务金字塔描述了不同层次的任务之间的关系 任务-子任务的结构 故事讲述和情节分析 描述情景，使这些故事能够典型的反映交互任务，具有充分的代表性。 对故事所反映的交互任务的理性分析，分离出故事中所描述的角色、目标、环境、步骤、策略、感情等诸方面的因素。 📑考虑设计一个还不存在的系统（全新的系统）。例如，一家完全自动化的快餐店，顾客通过触摸屏交互下单，刷借记卡或信用卡付款，然后取餐——类似于一些超市的自助结账系统，但更为极端。请采用一种任务分析方法进行任务分析。 顺序分析： 🟡设计框架（名词解释3个框架）了解 🟡以用户为中心的设计(UCD) 书p79 在设计过程的每个设计阶段都考虑到最终用户的需求、想法和局限性。 难点：难以选择代表性用户 Gould、Boies和Lewis于1991年提出了以用户为中心设计的四个重要原则：①及早以用户为中心：设计人员应当在设计过程的早期就致力于了解用户的需要②综合设计：设计的各方面应当齐头并进地发展，而不是顺次发展，使产品的内部设计与用户界面的需要始终保持一致③及早并持续性地进行测试：当前对软件测试的唯一可行的方法是根据经验总结出的方法，即若实际用户认为设计是可行的，它就是可行的④反复式设计：大问题往往会掩盖小问题的存在。设计人员和开发人员应当在整个测试过程中反复对设计进行修改 参与式设计(PD) 人们直接参与到他们所用产品和技术的协同设计中。 敏捷交互设计 表示一类适用于团队开发的方法，目的是确保灵活性、适应性，并快速对不断变化的需求做出快速反应，并以渐进式开发为基础。 🟡敏捷交互设计 不需要被概念，知道什么是，和一般的有什么区别敏捷设计强调“make a real change”而不是”make a report’,频繁的测试与修改是敏捷设计的首要原则表示一类适用于团队开发的方法，目的是确保灵活性、适应性，并快速对不断变化的需求出快速反应，并以渐进式开发为基础 优点 更快的交付：快速交付软件，使团队能够更快地向客户提供有用的功能。 更高的客户满意度：鼓励与客户密切合作，这意味着客户可以更频繁地提供反馈和建议，从而确保软件开发符合客户的需求和期望。 更强的团队合作：强调团队合作和沟通，这有助于确保所有成员都了解项目的目标和愿景 更灵活的风险管理：团队可以更快地发现和解决问题，从而降低项目风险。 缺点 缺乏明确的计划：难以预测项目完成的时间和成本，因为每个迭代都可能会引入新的需求和挑战。 需要高度的自我组织能力：要求团队成员具备高度的自我组织和自我驱动能力 可能导致质量问题：快速交付软件可能导致团队在快速开发的过程中忽略质量问题 需要客户积极参与：需要客户积极参与，提供反馈和建议，如果客户不积极参与，团队可能会遇到困难。 作业3 第五章专家评审和启发式方法专家评审 专家：有形象力的从业人员，或有评审专家资格的人员 🟡专家评估法(看一下，总结一下)：以专家为索取未来信息的对象，组织各领域的专家运用专业方面的知识和经验，通过直观的归钠，对预测对象过去和现在的状况、发展变化过程进行综合分析与研究，找出预测对象变化、发展规律、从而对预测对象未来的发展与实际状况做出判断。 流程：使用某种方法，遍历界面中的所有功能，在较短时间内给出评审结果，通常是一份正式报告书。 🟡优点 总结 高效地发现不同问题与进行可用性测试 严格测试，短时间内迅速给出评审结果 🟡局限 总结 专家可能对任务领域或用户社区没有足够了解 很难了解典型用户，尤其是初次用户的真实行为 ①主要依靠评标专家的知识和经验进行判断，评标的主观性有余，客观性不足； ②评标的定性方法与定量方法结合不够即使是经验丰富的专家审查员也很难了解典型用户，尤其是初次用户的真实行为。 常用评审方法 🟡启发式评估：评审专家对界面进行评审，确定这些界面是否符合启发式设计的简要列表。 书p99概念 启发式是以一种快速的看起来不费力的方式做复杂的决定或进行推论时应用的一些简单规则 指南评审：检查界面是否符合组织文档或其他的指南文档是否相符 一致性检查：检查所有同类界面的一致性，检查各种术语、标签等是否与培训材料和在线帮助中所描述的一致。 认知过程走查法：专家模拟用户使用界面来执行典型的任务. 正式的可用性检查：专家会举办一些与庭审类似的会议，由仲裁人或法官参加。在会议上展示界面，并讨论其优缺点。 启发性评估的两大原则 不能是设计师本人 具有可用性知识 优点 成本低、效率高、可以发现大多数可用性问题 缺点 不能代表真实用户、比较主观 有时发现问题过多；对评估者的要求较高。 可用性评估的方法（多选或选择）诊查式方法：没有用户参与 用户模型法：用数学模型来模拟人机交互的过程。 GOMS模型是描述任务和用户执行该任务所需知识的方法 Goals（目标） Operations（操作） Methods（方法） Selection rules（选择规则） 启发式评估：使用一套相对简单、通用、有启发性的可用性原则进行可用性评估。 系统状态可见性 系统与用户现实世界相互匹配 用户控制与自由 一致性与标准 错误预防 识别而不是回忆 使用的灵活性与效率 美观而精炼的设计 帮助用户认识、诊断和修正错误 帮助和文档 测试方法：A&#x2F;B测试(分割测试)，两个版本相互比较以确定哪个版本的性能更好的方法 认知性遍历：描述系统原型和用户任务，列出所有操作并确定用户身份。 进行认知性遍历活动，需要以下四个条件 1)对系统原型的详尽描述。这种描述不一定是完整的，但要相当详尽。诸如菜单的位置 描述或措辞选择等这样的细节也可能导致相当大的差异。 2)对用户在系统中要完成任务的描述，这些任务应当是大多数用户将要执行的有代表性 的任务。 3)一个完整的、书面的操作清单，列出使用给定原型完成任务所需执行的操作。 4)确定用户的身份，以及评估人员能够确定这些用户已具有哪一类别的知识和经验。 完成一个任务包括以下步骤 1在交互界面上寻找能帮助完成任务的行动方案 2选择并采用看起来最能帮助完成任务的行动 3评估系统作出的反馈，判断在任务上的进展情况 测试式方法：有用户参与 1用户测试：让用户使用软件系统，由试验人员观察、记录和测量。 2问卷调查：需求分析——问卷设计——问卷实施——结果分析 3放声思考法：用户一边执行任务一边大声地说出自己的想法 4访谈法：研究人员通过与研究对象进行口头交谈 🟡A&#x2F;B测试 书P108将两组用户随机分配到对照组(无变化)或实验组(有变化) 例如：将参与者随机分配到两个测试组(A或B)，他们看到的界面类似，但要对特定标准进行评估，且每个测试组得到的是不同版本的界面。通过对结果进行评估，查看是否存在差异。 🟡尼尔森十大原则 ppt 8条法则联系记忆启发式可用性十大原则 知道是什么 一 ①一致性与标准 通 ②系统与用户现实世界相互匹配 反 ③系统状态可见性 结 防 ④错误预防 ⑤帮助用户认识、诊断和修正错误 ​ 退 ​ 控​ ⑥用户控制与自由​ 记​ ⑦识别而不是回忆​ ⑧使用的灵活性和效率​ ⑨美观而精炼的设计​ ⑩帮助和文档 🟡❓作业 多看看1)至少描述三种不同类型的专家评审方法2)给出两个专家评论有用的理由。同时给出专家评论的两个局限性3)反对当前流行的文字处理程序界面设计的一个论点是，它将所有功能菜单项一起显示，导致界面过于复杂。这种复杂性会给新手用户带来困惑和祖丧的体验，另一种设计是提供不同层次的功能复杂性，用户可以选择适合自己的层次，当他们熟悉工具时，再进一步到更高的层次，从而感到更舒适，更有效地学习这种情况下应该使用哪种可用性测试？解释为什么。请列出并简要描述可用性测试的步骤 1.评估的决定因素（可能多选） 5.可用性评估遵循的原则 8.启发式评估（十条原则）【GOMS】12.放声思考法作业1 第六章 不存在重点考点⭐敏捷交互设计 p22 快速迭代。 简单快捷 让测试人员和开发者参与讨论需求。 轻松定义可测试的需求。 编写可测试的需求文档。用“用户故事”方法编写需求文档。 多沟通，少文档。 好的沟通是敏捷开发的先决条件。 做好产品原型。 用草图和模型阐明用户界面 尽早考虑测试。 需求完成时，可以接受的测试用例也基本一起完成了。 第七章 1⭐🟡直接操纵 p10 书p139 特别重要，❗背 直接操纵最早由施耐德曼提出的 直接操纵界面的基本思想是指用光笔、鼠标、触摸屏或数据手套等坐标指点设备，直接从屏幕上获取形象化命令与数据的过程。也就是说，直接操纵的对象是命令、数据或者对数据的某种操作，直接操作的工具是屏幕坐标指点设备 特点 4个 p13 该系统是真实世界的一种扩展：用户非常熟悉屏幕中的环境，倾向于关注数据本身 对象和操作一直可见：“虚拟现实”–纳尔逊，“所见即所得”–哈特菲尔德，“透明”–鲁特科夫斯基 迅速且伴有直观显示结果的增量操作：操作有反馈 增量操作可以方便地逆转：提供回退 真实世界的扩展，对象可见，增量操作，可逆 🟡原则 3个 用有意义的视觉隐喻连续表示感兴趣的对象和动作。 用物理动作或按压带标签的按钮来取代复杂的语法， 使用快速、斩进式的可逆动作，这些动作对兴趣对象的影响立竿见影。 属性 p17 新用户快速学会 专家用户能高效执行任务 知识渊博用户，可以记住各种操作概念 很少需要错误提示信息 用户可立即看到动作是否正促进目标的实现 减少用户焦虑 用户作为动作发起者，能感受到处于控制地位，自信并有掌控感 好处 控制&#x2F;显示兼容性 更少的语法减少了错误率 错误更容易预防 更快的学习和更高的记忆力 鼓励探索 问题 空间或视觉表现可能过于分散 高级流程图和数据库一模式可能会变得混乱 设计可能会迫使有价值的信息离开屏幕 用户必须学习图形表示 视觉表现可能会误导人 用键盘输入命令可能会更快 🟡优点 p31 6个 可以延伸（❗背 形象化地呈现任务概念 允许简单地学习 允许简单地记忆 允许避免错误 鼓励探索 提供较高的主观满意度 🟡缺点 2个 可以延伸（❗背p31 可能很难编写程序 需要特别注意可达性 在实践中，直接操纵对屏幕上所有对象和操作并非都是可行 的，原因如下 p11 此操作在图形化系统中可能很难概念化 系统图形能力局限性 窗口中放置操纵控件的空间存在限制 记住所有需要的操作会很困难 🟡间接操纵 大概明白当出现这些情况时，我们就会使用间接操纵。在间接操纵中，文本——如下拉式或弹出式菜单——取代了符号，并用键盘键入代替了定位指向。大多数的窗口系统都综合了直接和间接操纵。菜单可以通过指向菜单图标并进行选择（直接操纵）来访问。而菜单本身，是一些操作的名称列表（间接操纵）。当列表上的某个操作通过指向或者键盘选择之后，系统便开始执行相应的命令。 🟡直接操纵的平移距离 书p140 分为哪几类，什么是平移距离 大概知道哪种设备是什么平移距离想要了解直接操纵隐喻，并对其进行分类，其中一种办法是观察用户与隐喻的表现之间的平移距离，即隐喻的强度强度可以通过从“弱”到“沉浸式”的过渡 弱（基本的直接操纵）：使用映射函数，将设备的动作或身体动作转换为虚拟空回中的动作，交互是间接的，转换的差异较大如鼠标与光标之间的移动不是完全一致的、游戏手柄的核键与角色的运动也是不一致的 中等直接操纵：用户直接触摸、移动、捕获屏幕上的实体，而不需要使用设备（屏幕本身除外）与虚拟空同通信。操作支持点击、双击、多点触控等。但无法描述高级的动作，如力度、深度等信息，需要设计专门的手势。（取消了中间设备，单通道输入） 强直接操纵：可使用各种动作，如身体各部位的姿态，可用手、脚、头或全身完成，以上燥作都“真实“的投放在实体空间中，用户在三维空间中可以看到自己的手，实现抓取、投摇、放下等操作 ”沉浸式直接操纵 直接操纵与虚拟现实的结合，用户戴上眼镜或其他设备，置身干空间内用户可以看到自己，可以步行、侧身等动作在空间中行走、飞行，看到的影响也会随着用户的移动变化双向多通道 平移距离的例子： 平移距离 概念 特点 代表设备 弱 交互是间接的，转换的差异较大。 中间设备，距离远，不平衡的传递 早期的电子游戏控制器 中等 仅为屏幕，距离为0，二维，不平衡的传递。 触摸屏，多点触摸 强 操作都“真实”的投放在实体空间中 距离为0，三维，不平衡的传递。 数据手套，手势，操纵实物 沉浸式 距离为0，平衡的传递。 虚以现实，如头戴式显示器 ⭐🟡增强现实和虚拟现实 了解名词解释❗虚拟现实的远程呈现打破了空间限制，使得用户认为身处他处。 增强现实可以使用户看到叠加了附加信息的现实世界。 态势感知通过在计算机模型中跟踪你的动作来显示你周围的真实世界的信息。例子：远程医疗，全尺寸投影的体育赛事、远程会议等 2.直接操纵的概念和原则 6.直接操纵的优缺点11.增强现实和虚拟现实 名词解释 🟡作业 第八章导航的种类 菜单栏，弹出菜单，工具栏，面板和功能区 快捷方式和快速交互手势 长列表 序列菜单与同步菜单 米勒定律：人的短时记忆能力广度为7±2个信息块，超过范围人的记忆容易出错 🟡小型显示器❗小型设备的功能非常集中，可选择的区域很少。菜单的易发现性是一个问题 难点 同屏幕的选项少——&gt;操作深度增加 按钮不能缩小——&gt;点击不到 🟡设计考虑 了解 最好能复述 简化：“少即是多”–简单就是美 尽量降低或消除数据输入 考虑把不重要的功能转移到其他平台 学习能力是关键 上下文信息的使用 考虑使用的频率和重要性排序 为中断做好计划 清楚什么可选，什么不可选 为滚动和滑动手势留出空间，避免无意的行为 内容组织方法 策略有哪一些要对有意义的菜单项来分组和排序，精心编辑标题 和标签，适当的设计布局，可以缩短选择时间，提 高用户满意度。 🟡方法线性序列：按单一方向层次结构：按照层级划分多个级别网络结构：可以通过多个路径（例如网站）到达 注意事项顺序：字母顺序、使用频率顺序、主题关联顺序措辞：术语统一、选项区分、简洁、关键词前置布局 排版原则亲密性对齐重复对比 ⭐🟡音频菜单 了解优缺点 什么情况用，如何设计 可视菜单 持久性 比较性 音频菜单 依赖于记忆，难以比较 依赖于时间，消磨耐心。 通用的方法： 先说出描述，再给出选项（数字） 选项不能多，不能长，不能难理解(3-4个内)。 提供重复播放和退出机制。 菜单不能深，可提供跳过功能(如本机号码)。 使用场景：智能语音客服，相比传统的引导播报长、功能节点多，摆脱了这些问题，提供高效服务。 5小型显示器的设计考虑8音频菜单使用场景作业3 第九章语音识别 概念将人的语言转化为机器可识别的文本或命令的的过程 用处语音转文本翻译命令识别 语音输入：语音生成文本 （快速录入、字幕自动生成、专业词汇更正） 语音命令：有效识别某些命令 （语音助手） 对话翻译 ⭐完整的语音识别系统语音特征提取：提取声音信息 声学模型与模式匹配：匹配内容 语言模型与语义理解：理解意义做出反应 🟡✍口语交互 重点理解⭐优点 残疾用户、无法进行读写的用户（如儿童） 腾不出手的说话者 不断移动的人员 妨碍键盘使用的恶劣或狭小环境 词汇和任务有限的应用领域 比打字快：听写比打字快，对用户来说更方便。 易用性：并非所有人都能很好地使用技术设备。但任何用户都可以使用语音向VWUI设备或AI助手请求任务。 免提：在某些情况下，例如开车、做饭或当你远离设备时，说话比打字或敲击要实用得多。 免视：UI提供免视用户体验。在驾驶等情况下，你可以专注于道路而不是设备。它对于屏幕疲劳问题也很实用。 ⭐缺点 嘈杂环境和劣质麦克风的干扰 强烈的口音或不正常的词汇表会对识别产生影响 说话并非总是可被用户接受的（如在公共办公室中和会议期间) 命令需要学习和记忆 纠错很耗费时 与打字或指向相比，增加了认知负担 没有独特的定制功能，编程困难 ⭐发展障碍 与视觉显示相比，语音输出的速度较慢 语音具有短暂性 隐私问题：对VUI的潜在隐私侵犯涉及到一些用户。 误解和缺乏准确性：软件无法理解和解释语言的环境，从而导致错误和误解。VUI可能并不总是区分同音异义词。 公共空间：由于隐私和噪音问题，很难向公共空间中的设备和A!助手发出语音命令。 设计口语交互 6种1.发起交互：用户表明要开始语音交互。 • （欢迎提示音、语音命令（hey siri）、开始按钮） 2.知道该说什么：有针对性，学习和记忆有效命令。 3.反馈与对话：显示给用户的信息中应给出建议动作的细节，并要求 用户确认或取消。 4.错误识别：口吃、说错及背景噪音，地方口音或外国口音 5.纠错：费时耗力，取消，重新说一遍或换表达方式。 6.映射可能的动作：将程序限制到有限的应用领域，依靠上 下文信息，这是目前语音交互成功的关键。 ⭐语音生成方法 三种 峰段合成-通过一组基于文本语音表示的算法生成语音 串联合成-将事先录好的较短人类语音片段拼接为完整的句子。 语音录音-可将各个语音片段拼合在一起，形成更长的语音片段。 衡量语音质量：易懂性、自然性和可接受性。小冰 1语音技术应用场景 多选 警报类型2语音识别技术 概念 识别系统三部分口语交互的优缺点 障碍3语音识别的优点4.语音识别的障碍8语音生成三种方法作业1 第十章 设备指向设备 🟡菲茨定律 理解 利用来分析界面 作业！菲茨定律是用来预测从任意一点到目标中心位置所需时间的数学模型。这个模型考虑了用户定位点的初始位置与目标的相对距离以及目标的大小。用于估算用户移动光标点击链接或控件按钮所需的时间。 应用加大按钮 关联内容靠近 屏幕边放菜单栏 思考1.你手边有多少触屏设备，你能分析他们是哪种屏幕么？ 2.在设计导航系统时，是如何 使用菲茨定律的？ 3.你的电脑屏幕是哪种屏幕？其指标是什么？ 4.能否列出你身边的输入输出设备分别有什么（大于15个）？ 设备类型 手写板有哪几种类型等 2.输入设备 评测指标 手机是电容 指点输入设备包括哪些、优缺点-设备pdfP53 了解菲茨定律3.输出设备 光栅显示器性能指标作业3 第十一章🟡协作模型 七个指标维度 列举实例说明分析 在线市场如何应用(抖、红、淘宝等) p17 每个维度意思，用MOCA模型分析软件✍ 3.设计考虑作业1 第十二、十三章5网页设计 避免十大错误 重点 基于Web显示信息的十大错误(Tullis,2005) 信息在网站中藏得太深。 页面加载了过多的内容。 提供的导航笨拙或令人困惑。 信息放到了页面之外。 链接不明显、不清楚。 显示信息的表格设计拙劣。 文本太小，导致很多用户无法阅读。 文本使用了用户无法阅读的颜色组合。 使用了很差的表单。 隐藏（或不提供）能帮助用户的功能。 7非拟人化设计 指南 避免分散用户注意力 重点❗拟人化界面的倡导者认为，拟人化设计最有用的可能是教师、销售人员、治疗师或娱乐人物。另一种设计是通过预先录制的音频或视频呈现包的人类作者 🟡非拟人化界面指南❗ 7–将计算机呈现为人时，无论是合成人物还是卡通人物，均需谨慎。 –在游戏或儿童软件中使用卡通人物，但在其他地方应避免使用它们。 –设计可理解、可预测和可控制的界面。 –提供以用户为中心的概要，用于概述性和总结性内容。 –利用适当的人来做音频或视频介绍或向导。 –计算机响应人的动作时，不使用第一人称代词“我”。 –使用“你”来指导用户或仅陈述事实。 8错误消息P284错误消息要有特异性、具体的建设性指南和积极的语气： 消息应该在可能的情况下指出用户应该做什么来纠正问题 使用暴力术语的不必要的敌意信息会干扰非技术用户：最终产品和开发过程的错误消息指南最终产品 尽可能具体、精确、确定必要的、相关的错误消息 有建设性、指出用户需要做什么 使用积极的语气，避免谴责，有礼貌 选择以用户为中心的措辞，陈述问题、原因、解决方案 2.显示设计.多窗口的协调 考虑因素 6颜色 考太多次 8错误消息的比较 列出错误消息设计更好的方案 9🟡系统响应时间SRT 知道概念定义 书p294两张图看懂 减轻用户等待时的负面情绪用户对SRT的期望值和态度 SRT(系统响应时间)：从用户发起动作（通常为触碰图标、按回车键或点击鼠标)到计算机开始呈现反馈结果所需要的秒数。 用户思考时间：从计算机响应到用户发起下一动作所花的秒数 🟡影响用户对SRT的因素用户🟡 三个因素 以往的经验：设计能够快速引导用户上手的操作 个性的差异：每个人对时延 的忍耐度不同 任务的不同：任务的复杂性与用户对任务的熟悉程度 19.SRT指南 🟡作业3 4 第十四章 文档和用户支持3🟡在线文档的优势❗ 物理优势 可在上网的电子设备上随时使用，不会丢失或放错地方，不需要物理空间，能闭速更新。 导航功能 可提供索引和其他搜索工具，可链接到其他外部资源 交互式服务 可添加书签、注释和标签；可包含图形、声音、颜色和动画 可为残疾用户提供屏幕阅读器或其他工具 🟡纸面阅读和显示器阅读的比较 优缺点 书p313❗纸张印刷的历史有500多年，人们对纸张、颜色、字体、字形等进行了大量的实验，得出很有吸引力的阅读格式。 阅读计算机显示的内容会造成视觉被劳，但疲劳的原因也与休息方式中断及任务的多样性紧密相关 即使用户没有察觉到视觉疲劳或压力，他们使用显示器的效率也会能低于使用纸质文档的工作效率 设计师应该认识到，槽糕的设计会导致阅读困难，而且会干扰整个阅读过程 支持阅读的一些准则： 不使用不常见或不熟悉的词汇 避免使用难以阅读的字形（如全大写） 使用清晰不凌乱的无衬线字体 响应快，刷新率高 采用文档分页而非滚动方式 作业 第十五章没有要求第十六章🟡数据可视化 名词解释 p347这种数据驱动图片的想法，称为可视化 🟡2.数据可视化任务三个类别明白三个大类，怎么区分 这三个类别合并了支持迭代视觉分析的关键任务：包括可视化创建、交互式查询、多视图协调、历史和协作 3.数据可视化数据类型 一维二维.. 🟡数据类型P353 不需要背大概知道 🟡数据可视化挑战 作业 导入和清理数据 集成数据挖掘 查看大数据 实现通用性 支持临时用户 传播和讲故事 适配任何设备 评估 后记🟡未来界面 书p366 开放想法1.未来的界面和巨大的挑战P366 这些设备无处不在，且又小又便宜 新设各是可穿戴的、移动的、个人的和便携的 新设各是嵌入式的、上下文感知的和环绕的，内置于我们的环境中（因此不可见 即可访问，并能响应用户需求。通过视觉、听觉、触觉、手势和其他刺激进行交互 2.信息时代十大顽疾","tags":["笔记"],"categories":["本科课程"]},{"title":"计算机网络笔记","path":"/2023/07/09/计算机网络笔记/","content":"错题 无效Mac帧 帧的长度不是整数字节 数据字段的长度不在46-1500字节之间 帧的长度不在64-1518字节之间 用收到的帧检验序列FCS查出有差错 网桥从某一端口收到正确的数据帧后，在其他址转发表中查找该帧要到达的目的站，若查找不到，则会 向除该端口以外的所有端口转发此帧 以太网交换机进行转发决策时使用的PDU地址是 目的物理地址 关于100BASE-T以太网，错误的是：A，表示双绞线组网 A.T表示粗同轴电缆组网 B.100指的是传输速率为100Mb&#x2F;s C.BASE指的是基带传输 D.100BASE-T是一种星形以太网 属于虚电路操作特点的是：D A 每个分组携带有终点的地址信息，它的传送是自身寻址的 B 在整个传送过程中，不需要建立虚电路 C 网络节点要为每个分组做出路由选择 D 使所有分组按顺序到达目的系统 下面哪个协议不属于网络层？ C A ARP B ICMP C TCP D IP TCP&#x2F;IP 体系中网络层的协议：IP 协议、ARP协 议、ICMP协议、IGMP协议 TCP属于传输层 点分十进制：**-A类-127-B类-191-C类-223-D类** 在因特网中，IP数据报从源结点到目的结点可能需要经过多个网络和路由器在整个传输过程中，IP数据报报头的：源地址和目的地址都不会变化，读取过程只是找到下一跳地址 IP数据报需要由源主机和中途路由器到达目的主机，通常：；源主机和中途路由器都不知道IP数据报到达目的主机需要经过的完整路径。源主机只知道默认网关是谁，中途路由器根据路由表转发给下一跳 在因特网中，路由器可连接多个物理网络，此时路由器 B A具有单一IP地址 B具有多个IP地址，每个IP地址与各相连的物理网中具有相同网络号，并占用一个主机号 C具有多个IP地址，每个IP地址与各相连的物理网中具有相同网络号，并占用多个主机号 以下为源和目标主机的不同IP地址组合，其中()组合可以不经过路由直接寻址 B A.125.2.5.3&#x2F;24和136.2.2.3&#x2F;24 B125.2.5.3&#x2F;16和125.2.3&#x2F;16 C126.2.5.3&#x2F;16和126.2.2.3&#x2F;21 A，24位为网络号，不同；B，16位，相同；C，126.2.2.3借前21，换成2进制发现网络号一样，但是子网掩码(网络段)是不一样的，不能选 关于无分类编址CIDR，下列说法错误的是(C)ACIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号。 BCIDR将网络前缀都相同的连续的IP地址组成“CIDR”地址块。 C.网络前缀越短，其地址块所包含的地址数就越少 D使用CIDR，查找路由表时可能会得到多个匹配结果应当从匹配结果中选择具有最长网络前缀的路由。因为网络前缀越长，路由就越具体。 最长前缀匹配原则 对网际控制报文协议 (ICMP) 描述错误的是()。A.ICMP封装在IP数据报的数据部分B.ICMP是属于应用层的协议 C.ICMP是IP协议的必需的一个部分 D.Ping命令使用了ICMP回送请求与回送应答报文 下列前缀中的哪一个和地址152.7.77.159及15231.47.252都匹配?(D) A.152.40&#x2F;13 B.153.40&#x2F;9 C.152.64&#x2F;12D.152.0&#x2F;11 聚合，152.7-&gt;152.00000111 ​ 152.31-&gt;152.00011111 前三个都是0 因此网络号为152.00000000.0.0 后面全0，一共11为网络号，是152.0&#x2F;11 不属于路由选择协议 B A RIP B ICMP C BGP D OSPF RIP适用小型，OSPF适用大型 某自治系统采用RIP协议，R1收到邻居R2距离向量，包含信息**&lt;net1,16&gt;**，则可以得到结论 B A R2 通过 R1 到net1，跳数为17 B R2 不能到 net1 C R1 通过 R2 到net1，跳数为17 D R2 能到 net1，条数为16 忘记了16跳表示不可达了 下一跳路由器分别为N2、2、X，新收到从X发来的路由信息中目的网络、跳数、下跳路由器分别为N2、5、Y，则路由表D中更新后关于N2的路由信息为(C)。 A N2、2、X 错选 B N2、5、X C N2、6、X 注意自加1 D N2、5、Y 若下一跳字段给出的路由器地址相同，则把收到的项目替换源路由表项目。 如果收到项目中的距离小于路由表中的距离，则进行更新 下列关于IPv6的表述中，(D) 是错误的。、 AIPv6的头部长度是不可变的 BIPv6不允许路由设备来讲行分片 CIPv6采用了16B的地址号，理论上不可能用完 DIPv6使用了头部校验和来保证传输的正确性 基本首部40字节，不可变；开始的mpu值就设定好了，不需要分片；IPV4有首部检验，而IPV6反而没有，取消 下面哪个地址属于专用IP地址？(C) A127.0.0.1 环回地址 B192.32.116.22 –192.168开头 C172.16.1.31 –172.16-172.31 D255.0.0.0 属于传输层协议的是C AIP 网络层 BARP 网络层 CTCP DRARP TCP流量控制 A 对发送方 对接收方 对发、接双方 链路上任两结点间数据 一个TCP连接的数据传输阶段，如果发送端的发送窗口值由2000变为3000，意味着可以 C 在收到一个确认之前可发3000个TCP报文段 可发1000B 可发3000B 可发2000个TCP报文段 A和B之间建立了TCP连接，A向B发送了一个报文段，其中序号字段seq&#x3D;300，确认号字段ack&#x3D;101，数据部分包含7个字节，那么B在对该报文的确认报文段中seq,ack分别为(D) A307,101 B301,108 C101,306 D101,307 序号就是收到的确认号，确认号为上一个序号加数据300+7&#x3D;307 在一个TCP连接中，MSS为1KB，当拥塞窗口为34KB时收到了3个元余ACK报文。如果在接下来的4个RTT内报文段传输都是成功的，那么当这些报文段均得到确认后，拥塞窗口的大小是(D)A 8KB B16KB C27KB D21KB 3个ACK，超时减半，然后根据4个RTT(往返时间)线性增加，34&#x2F;2+4&#x3D;21 DNS说法错误的是 A A.DNS系统运行在TCP协议之上 对于数据小，用的少的用UDP B.DNS采用客户服务器工作模式 C.域名的命名原则是采用层次结构的命名树 D.域名不能反映计算机所在的物理地址 逻辑地址 一台主机希望解析域名www.bit.edu.cn，如果这台主机配置的本地域名服务器为202.120.6688，internet根域名服务器为10.1.2.3而存储www.bit.edu.cn与其IP地址对应关系的权限域名服务器为202.110.6.8，那么这台主机解析该域名时首先查询 ()。 A.地址为202.120.66.88的域名服务器 B.地址为10.1.2.3的域名服务器 C.地址为202.110.6.8的域名服务器 D.不能确定 主机想进行域名解析先查询本地域名服务器，如果其不知，查询根域名，再查顶级，再查权限 image-20230609085517082.png 一计网的作用 三网融合：电信网络、有线电视网络、计算机网络 互联网两个重要特点：连通性、共享 概述起源 ARPANET 组成 边缘部分，端系统之间的通信方式：C&#x2F;S、P2P 核心部分，三种交换方式：电路交换、分组交换(路由器)、电报交换 电路交换1950S，电报采用基于存储转发的报文交换 电路交换——整个报文的比特流连续地从源点直达终点。好像在一个管道传输。 报文交换报文交换——整个报文先传送到相邻节点、全部存储下来后查找转发表，转发到下一个节点。 分组交换分组又称为“包”，分组交换——单个分组传送到相邻节点，存储下来后查找转发表，转发到下一个节点。 路由器注意分组的存储转发过程，在路由器分组放入缓存，查路由表，转发 路由器输入和输出端口没有直接连线的，而交换机有 路由器利用软件时间数据交换，交换机是依靠硬件，前者比后者慢 注意路由器和交换机的区别 带来的问题： 要排队，会造成一定时延。（如果分组太多，造成时延太大，会直接丢掉分组） 必须携带首部，造成了一定的开销 ⭐三种交换比较image.png 稳定性：电报交换传输更加稳定，报文和分组交换存在丢包可能。 传输速率：当要连续传输大量的数据，电路交换的传输速率较快。 传输效率和信道利用率：传输突发式的计算机数据时，电报交换速率由于线路被占用，且需要预先分配带宽，使得传输效率和信道利用率很低；报文交换和不需要预先分配传输带宽，且不必先占用一条端到端的通信资源，省去了开销，数据的传输效率和信道利用率更高。 例子：有线电话和IP电话 IP电话成本低，计算机网络连接分组交换逐端占用，通话质量没那么高 有线电话稳定，通话质量高，专用链路连接，成本高 计网在我国的发展94年被正式承认为接入互联网的国家 《中国互联网络发展状况统计报告》 计算机网络的类别定义地理位置不同的具有独立功能的多台计算机及其外部设备（硬件），通过通信线路连接，在网络操作系统、网络管理系统和协议等（软件）的管理和协调下，实现 资源共享和i信息传递的计算机系统 分类 从作用范围上分类 广域网WAN(Wide) 作用距离在几十到几千公里，是互联网核心部分。 域域网MAN(Metroplitan) 作用距离在5-50公里 作用范围可跨越几个街区&#x2F;整个城市。 局域网LAN(Local) 作用距离1公里以内，作用范围一般是一个学校、公司或工厂。 个人区域网PAN(Personal) 作用距离10米以内，是用无线技术将个人使用的电子设备连接起来形成的网络。 从网络的使用者上分类 公用网 简单理解就是大家都可以用的网络(只要交了钱)，由电信公司出资建设。 专用网 某个部分&#x2F;机关由于内部需要专用的网络，不对外提供服务。 计算机网路的性能性能指标比特 一个比特就是二进制数字中的0或1 带宽 本来是指信号具有的频带宽度 在计网中表示在单位时间内网络中的某通道所能通过的“最高数据率”。单位是bit&#x2F;s，即比特每秒 在时间轴上的信号的宽度随带宽的增大而变窄，频率增大 吞吐量 在单位时间内通过某网络（或信道、接口）的数据量 时延 数据从网络的一端传送到另一端所需的时间，有时也称位延迟或迟延。 由四部分组成，发送时延、传播时延、处理时延、排队时延 发送时延：$$发送时延&#x3D;\\frac{数据帧长度(bit)}{发送速率(bit&#x2F;s)}$$传播时延：$$传播时延&#x3D;\\frac{信道长度(m)}{电磁波在信道上的传播速率(m&#x2F;s)}$$处理时延 排队时延$$总时延&#x3D;发送时延+传播时延+处理时延+排队时延$$ 总时延 发10个分组的用时：每个分组的发送时延之和+最后一个分组的传播时延和处理时延 时延带宽积$$时延带宽积&#x3D;传播时延×带宽$$ image.png 往返时间RTT $$发送时间&#x3D;\\frac{数据长度}{发送速率}$$ $$有效数据率&#x3D;\\frac{数据长度}{发送时间+RTT}$$ 利用率 利用率越大，时延增加 非性能特征费用 质量 标准化 可靠性 可拓展性和升级性 易于管理和维护 计算机网络的体系结构体系结构的形成 为什么分层？分层次结构有很多好处，比如： 能够使各层之间独立，问题的复杂度变小了； 灵活性好，各层互不影响； 结构上可分割，各层都采用最合适的技术来实现； 易于实现和维护； 能促进标准化工作，每一次的功能都很明确。 比如我们学生组织分为几个部门，有些部门负责统筹组织，有些部门负责整合资料，有些部门负责宣传推广，分层次地把一个大的项目和任务实施解决。 缺点 麻烦 各层完成的主要功能 差错控制 流量控制 分段和重装 复用和分用 连接建立和释放 协议与划分层次 网络协议三个要素 语法，即数据与控制信息的结构或格式 语义，即需要发出何种控制信息，完成何种动作以及做出何种响应； 同步，即事件实现顺序的说明。 三种分层概念具有五层协议的体系结构 OSI的七层协议 TCP&#x2F;IP的四层体系结构 五层协议image.png 应用层 处理不同应用 应用层是体系结构的最高处。任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。 运输层 运输 运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用传输控制协议TCP和用户数据报协议UDP。流量控制 网络层 路由，找路线 网络层负责为分组交换网上的不同主机提供通信服务，将用户数据封装成IP数据报，主要功能是路由。 数据链路层 封装，拆分成帧 将数据报组装成帧，包括了数据和必要的控制信息，是链路上传输数据的协议。 物理层 接口有关 物理层上传输数据的单位是比特，需要考虑传输的编码方式和硬件条件。 协议与服务有何区别？有何关系？协议是水平的，服务是垂直的。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。只有那些能被高一层实体“看得见”的功能才能称之为“服务”。 一些名词 协议栈：协议栈是指由多个协议层组成的一种网络通信协议体系结构。每一层协议都负责特定的功能，例如物理层、数据链路层、网络层、传输层、应用层等。协议栈中的每一层都通过接口与上下层交换信息，并对其上层提供服务。 实体：实体是指一个网络节点上的一个网络通信实体，它可以是硬件设备、软件程序、网络服务器等。实体在网络中通过地址进行标识，通常使用IP地址或MAC地址。 对等层：对等层是指在协议栈中相互配对的同级协议层。在对等层之间，通信双方具有相同的角色和功能，并且它们通过接口进行通信。 协议数据单元：协议数据单元是在网络通信中，不同层之间传递信息的基本单元。在不同层之间，PDU的命名和格式可能不同。 服务访问点：服务访问点是指在同一层协议中，对上下层提供服务的接口。每个SAP都有一个唯一的标识符，用于标识服务提供者和服务请求者之间的通信关系。 客户（Client）：客户指的是通过网络请求服务的设备或应用程序。在客户-服务器模型中，客户向服务器发出请求，等待服务器响应并接收数据。 服务器（Server）：服务器指的是提供服务的设备或应用程序。在客户-服务器模型中，服务器接收客户端请求，处理请求并向客户端发送响应数据。 客户-服务器方式（Client-Server）：客户-服务器方式是一种网络通信模型，其中客户端设备或应用程序通过网络向服务器发出请求，等待服务器响应并接收数据。服务器接收客户端请求，处理请求并向客户端发送响应数据。这种模型在分布式计算和Web服务中广泛使用 二 物理层数据通信的基础知识：奈氏准则、香农定理 传输媒体：导引型，非导引型 信道复用：频分、时分、波分、码分 主要任务解决与接口有关的任务，包括： 机械特性 电气特性 功能特性 过程特性 数据在计算机内部是并行传输，在通信线路上是串行传输 数据通信模型通信系统分为： 源系统 传输系统 目的系统 信道 单工通信 半双工通信 全双工通信 来自信号源的信号称为基带信号（基本频带信号） 解决通信问题需要对基带信号进行调制。 基带调制 变换后还是基带信号 带通调制 使用载波 常见编码方式 不归零制 归零制 曼彻斯特编码 差分曼彻斯特编码 基本的带通调制方法 调幅 调频 调相 正交振幅调制 ⭐信道的极限容量奈氏准则 单位波特率，码元传输最高速率是带宽的两倍，2W（码元&#x2F;秒） 比特率&#x3D;波特率×log2N 信噪比$$信噪比(dB)&#x3D;10log(S&#x2F;N)$$香农定理$$C&#x3D;Wlog2(1+S&#x2F;N)$$ 传输媒体传输媒体分为 导引型 （有线） 非导引型 （无线） 导引型双绞线无屏蔽双绞线UTP 非屏蔽双绞线STP PVC套层与带绝缘层的铜线之间有一层铝箔屏蔽层 image.png 导线相互缠绕可降低电磁干扰 同向的导线，磁场抵消，消除导线之间的串扰 差值法避免了噪声干扰 八个脚位 1、2发送数据正&#x2F;负极，3、6接收数据正&#x2F;负极 交换机内部做了翻转，1、2收，3、6发 主机和路由也用交叉 RJ45：接头+水晶头 image.png 同轴电缆光缆光纤做成结实的光缆 image.png 光线入射角足够大就会出现全发射，即光线碰到包层时就会折射会纤芯 image.png 纤芯直径 光源 传输速率 应用 多模光纤 较大，同时传输多条光线 发光二极管 低、性能差 局域网 单模光纤 较小，一次传输一条光线 激光 高 楼间、广域网 多模光线传输速率低、性能差但是成本低，一般用于局域网 单模光纤通常用于楼间连接或广域网连接 光纤优点 通信容量非常大 传输损耗小，中继距离长 抗雷电和电磁干扰性能好 无串音干扰，保密性好 体积小，重量轻 缺点 成本 脆弱 非导引型波长越长、频率越小 短波通信主要靠电离层的反射，会产生多经效应 一次反射可传输4000km，一般用于军事通讯 image.png 微波通信频谱范围：300MHz-300GHz 特性：在空间主要是直线传播，难以传过建筑物 两种方式：地面微波中继通信、卫星通信 ⭐信道复用技术复用技术允许共享信道进行通信，降低成本，提高利用率 频分复用、时分复用和统计时分复用频分复用在同样时间占用不同的带宽(频率带宽)资源.例子：同时听到猫叫和狗叫，可以区分，因为频率不同 image.png 时分复用所有用户在不同的时间占用同样的频带宽度 是将时间划分为一段段等长的时分复用帧 （TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 image.png 波分复用波分复用就是光的频分复用。使用一根 光纤来同时传输多个光载波信号。 #### ⭐码分复用CDMA * 码分复用 CDMA * 特殊挑选不同码型，因此彼此不会相互干扰 * 有较强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现 * 应用：第三代数字移动通信系统（3G image.png 码片序列每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。 ◼ 每个站被指派一个唯一的 m bit 码片序列。 ​ ◼ 如发送比特 1，则发送自己的 m bit 码片序列。 ​ ◼ 如发送比特 0，则发送该码片序列的二进制反码。 ◼ 例如，S 站的 8 bit 码片序列是 00011011。 ​ ◼ 发送比特 1 时，就发送序列 00011011， ​ ◼ 发送比特 0 时，就发送序列 11100100。 ◼ S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) ，-1表示0 两个不同站的码片序列正交，因此有规格化内积为0：$$S\\cdot T&#x3D;\\frac{1}{m}\\sum_{i&#x3D;1}^m{S_iT_i&#x3D;0}$$和别人为0，和自己为1，和反码为-1 应用接收信号的时候接收到不止一个站发送的信号，比如此时我想要接收S站的信息，假设收到的是$$(S+T)$$此时用S的码片序列去做规格化内积：$$S·(S+T)&#x3D;S·S+S·T$$此时S·T得到的结果是0，所以最终规格化内积后可得结果为：$$S·S$$将它除以码片序列的长度，结果为1时说明发了1，结果为-1时说明发了0 共有四个站进行码分多址CDMA通信。四个站的码片序列为: A: (-1 -1 -1 +1 +1 -1 +1 +1) B: (-1 -1 +1 -1 +1 +1 +1 -1) C: (-1 +1 -1 +1 +1 +1 -1 -1) D: (-1 +1 -1 -1 -1 -1 +1 -1) 现收到这样的码片序列：(-1 +1 -3 +1 -1 -3 +1 +1)。问哪个站发送了数据？发送数据的站发送的是1还是0？$$A站：\\left( -1-1-1+1+1-1+1+1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) &#x2F;8&#x3D;1$$ $$B站：\\left( -1-1+1-1+1+1+1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) &#x2F;8&#x3D;-1$$ $$C站：\\left( -1+1-1+1+1+1-1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) &#x2F;8&#x3D;0$$ $$D站：\\left( -1+1-1-1-1-1+1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) &#x2F;8&#x3D;1$$ A、D站发送的是1，B结果为-1发送的是0，而C站没有发送数据 例题模拟信道的信号功率为0.62W，噪声功率为0.02W，传输频率为3.5-3.9MHz，问最大传输速率？ 有噪声，利用香农公式，其实频带W&#x3D;(3.9-3.5)M（带宽：信号具有的频带宽度） 数字传输系统脉码调制 PCM般包括三个过程：采样、量化和编码。 image.png image.png 同步光纤网SONET1988美国提出一个数字传输标准，叫做同步光纤网SONET 同步数字序列SDHSDH相当于SONET的同义词，标准近似 首次实现了数字传输体制上的世界性标准 宽带接入技术用户要连接到互联网，必须先连接到某个ISP 初期用户利用电话的用户线通过调制解调器连接到ISP，最高速率56kbit&#x2F;s 美国联邦通信委员会FCC认为只要双向速率和超过200kbit&#x2F;s就是宽带 ADSL技术ADSL非对称数字用户线，上行与下行速率不同。 特点 下行速率远大于上下 采用非对称传输的原因：在网络应用中，用户 的下载数据量要远大于上传的数据量 ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。 我国目前采用的方案是离散多音调(频率) DMT (Discrete Multi-Tone)调制技术。 打电话、上网、上传、下载、多用户，都不互相影响 image.png 光纤同轴混合网（HFC网）HFC 网对 CATV 网进行了改造。HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 FTTx技术代表多种宽带光纤接入方式 🖼图床至此为止三 数据链路层 数据链路的主要功能 数据链路层协议的三个基本问题 数据链路使用的信道类型 PPP协议的特点、帧格式、工作状态 局域网拓扑结构 CSMA&#x2F;CD 协议 以太网V2的MAC帧地址 如何实现在物理层、数据链路层扩展以太网 集线器、交换机的特点与区别 交换机的工作原理 生成树协议的作用、工作原理 VLAN的作用和特点 以太网的演进 数据链路和帧链路是一条无源的点到点的物理线路段，中间没有任何其他的交换结点 不同的链路层可能采用不同的数据链路层协议： ### 三个基本问题 * 封装成帧 * 透明传输 * 差错控制 #### 封装成帧 首部和尾部进行帧定界 #### 透明传输 透明：实际存在但是又摸不到看不着，这里是相对上层来说透明 任何一个二层协议都要解决透明传输问题 控制字符在数据出现会导致帧定界出错！ 解决方法：**字节填充** 如果数据中有控制字符，那么在控制字符前进行字节填充 #### 差错控制 传输过程中可能会产生比特差错：1 可能会变 成 0 而 0 也可能变成 1。 传输错误的比特占所传输比特 总数的比率称为**误码率 BER** 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 * 广泛使用循环冗余检验CRC的检测方法： 假设待传送的一组数据 M = 101001（现在 k = 6 image-20230324105441524.png。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送 二进制模2运算：进行2^n乘M的运算，相当于在M后面添加n个0 冗余码计算举例 现在 k &#x3D; 6, M &#x3D; 101001。  设 n &#x3D; 3, 除数 P &#x3D; 1101，  被除数是 2^nM &#x3D; 101001000。  模 2 运算的结果是：商 Q &#x3D; 110101， 余数 R &#x3D; 001。  把余数 R 作为冗余码添加在数据 M 的后面发送出去。 发送的数据是：2^nM+R，即101001001，共(k+n)位 image-20230331091534750.png 余数001作为FCS 任意一个比特出错都能查出来 image-20230331090019952.png P&#x3D;1X^3+1X^2+0*X+1，表示1101 检验 若得出余数R&#x3D;0，则判断这个帧没有差错，就接收 若余数R≠0，则有差错，丢弃 这种方法并不能确定究竟是哪一个或哪几个比特出现了差错，只要经过严格的挑选，并使用位数足够多的除数P，则检测不出差错的概率将很小 仅用循环冗余检验 CRC 差错检测技术只能做到无差错 接受 (accept)。也就是说：“凡是接收端数据链路层接受的帧都没有 传输差错”（有差错的帧就丢弃而不接受） 要做到“可靠传输”（即发送什么就收到什么）就必 须再加上确认和重传机制。 奇偶校验这能检测出奇数个位出错，偶数位出错查不出来 练习：要发送的数据是101110，采用CRC的生成多项 式是P(X)&#x3D;X^3+1。试求应添加在数据后面的余数。 image-20230331091534750.png 不借位，注意补零，算错两次了 3.2点对点协议PPP特点、组成、工作状态、帧格式、透明传输 Point-to-Point image-20230331095445730.png 3.2.2PPP 协议的帧格式 PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。 标志字段 F &#x3D; 0x7E （符号“0x”表示后面的字符是用 十六进制表示。十六进制的 7E 的二进制表示是 01111110）。 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 控制字段 C 通常置为 0x03。 PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节 透明传输问题字符填充 零比特填充 在PPP协议中，为了解决传输中出现的数据丢失或者错误，采用了同步传输技术，并在数据帧中使用了零比特填充（Zero-bit stuffing）的方法。具体地，当数据帧中出现连续的五个1时，在第六个1之后自动插入一个零，以避免在传输过程中与控制帧的标识字段发生混淆。 3.3使用广播信道的数据链路层 以太网的两个标准 DIX Ethernet V2 IEEE 802.3 逻辑链路控制 LLC子层 媒体接入控制 MAC子层 由于TCP&#x2F;IP经常试验DIX Ethernet V2，LLC作用不大，很少有了 image-20230331103324404.png 适配器作用 网络接口板又称为通信适配器 (adapter) 或网络 接口卡 NIC (Network Interface Card)，或“网 卡”。 重要功能 进行串行&#x2F;并行转换 对数据进行缓存 在计算机的操作系统安装设备驱动程序 实现以太网协议 以太网采取了两种重要的措施，为了通信方便 采用较为灵活的无连接的工作方式 以太网发送的数据都使用曼彻斯特 (Manchester) 编码 image-20230331103533420.png 媒体共享技术： 动态媒体接入控制（多点接入） 随机接入方式：争用，可能会起冲突 受控接入方式，每一个站点轮流拿令牌，把信息加载令牌后 动态分配的特点 信息是开放的 没有预分配 通过多点接入协议动态分配信道资源，提高信道利用率。 常用的还是随机接入 典型的随机接入协议 ALOHA协议：想发就发 CSMA协议：先听后发 CSMA&#x2F;CD协议：先听后发、边发边听 CSMA&#x2F;CD协议“多点接入”表示许多计算机以多点接入的方式连接 在一根总线上。 “碰撞检测”就是计算机边发送数据边检测信道上的信 号电压大小。 “载波监听”是指每一个站在发送数据之前先要检测 一下总线上是否有其他计算机在发送数据，如果有， 则暂时不要发送数据，以免发生碰撞 争用期image-20230331110122116.png 最迟检测时间就是A到B的往返时延$2τ$。过了$2τ$说明就可以了，没有冲突。因此$2τ$称为征用期。 对于10Mbit&#x2F;s以太网，在争用期内可发送10Mbit&#x2F;s&#x2F;*51.2*10^-6&#x3D;64B，因此以太网最短的帧为64B。 如果发生冲突，就一定是在发送的前 64 字节之 内。由于一检测到冲突就立即中止发送，这时已经 发送出去的数据一定小于 64 字节。以太网规定了最短有效帧长为 64 字节，凡长度 小于 64 字节的帧都是由于冲突而异常中止的无 效帧。 二进制指数类型退避算法 发生碰撞的站在停止发送数据后，要推迟（退避）一 个随机时间才能再发送数据。说话有冲突，双方都等一下再说，等多久呢 从整数集合[0,1,…,(2k-1)]中随机取一个数，记为r。重传所需的时延就是r倍基本退避时间 比如k&#x3D;1，集合就是[0,1]，随机到0，那么冲突之后不等待，直接重传 当k≤10时，参数k等于重传次数 当重传达16次仍不成功则丢弃帧，并向高层报告 要点 准备发送。 检测信道。忙则等待，若检测到信道空闲，并在96比特时间内信道保存空闲（保证了帧间最小间隔），就发送这个帧。 检测碰撞 发送成功：未检测到碰撞，发送完毕，回到准备发送 发送失败：检测到碰撞，立即停止，发送人为干扰信号，然后执行指数退避算法，等待r倍512比特时间后，回到检测信道步骤。若重传16次仍不成功，停止重传向上报错。 使用集线器的星形拓扑1990年 IEEE 制定出星形以太网 10BASE-T 的 标准 802.3i。 10BAST-T,110BASE-T 中的“10”表示信号在电缆上的传输速率为 10Mbit&#x2F;s ，“BASE” 表示电缆上的信号是基带信号，“T” 代表双绞线星形网，奠定了以太网在局域网的统治地位，既降低了成本，又提高了可靠性，具有很高的性价比 从此以太网的总线型变为星形网络。 参数α与利用率在以太网中定义了参数 α，它是以太网单程端到 端时延  与帧的发送时间 T0 之比：α&#x3D;$τ$&#x2F;T0$$Smax&#x3D;\\frac{T0}{T0+τ}&#x3D;\\frac{1}{1+α}$$ 集线器工作在物理层MAC，所有接收的数据都发出去。 使用集线器的以太网在逻辑上仍是一个总线网， 工作站使用CSMA&#x2F;CD 协议共享逻辑上的总线。 使用集线器的以太网利用率很低。 以太网的MAC层MAC层硬件地址硬件地址又称为物理地址，或 MAC 地址。6个字节，48位 表示的是某个端口的地址。 适配器检查MAC地址发往本站的帧，包括以下三种帧 单播帧（一对一） 广播帧（一对全体） 多播帧（一对多） 混杂方式工作只要“听到”有帧在以太网上传输都接收下来。 帧头：目的地址、源地址、类型（协议） 加上前后帧，就是64-1518 在帧前面插入的8字节，第一个字段共7个字节，是前同步码，用来迅速实现MAC帧的比特同步。第二个字段1个字节是帧开始定界符，表示后面的信息就是MAC帧 7相当于1，2，1，1，2，1的准备指令，最后的1就是齐步走的指令， IEEE 802.3规定的MAC帧第三个字段是“长度&#x2F;类型” 3.4 扩展以太网在物理层扩展以太网在数据链路层扩展以太网早期使用网桥，现在使用以太网交换机 以太网交换机特点： 实质上就是一个多接口的网桥 每个接口都是与主机或交换机直接相连，并且全双工方式工作 以太网交换机具有并行性 优点： 用户独享带宽，增加了总容量 对于普通共享式以太网，所有用户平分带宽 而以太网交换机每个接口带宽都是一样，接口越多，带宽总容量越大 共享转交换不用改动 具有多种速率接口，适合不同用户 交换机要分割广播域，需要用到虚拟局域网(vlan) 工作原理： 交换机起初有一张空的mac地址表，通信之后自动学习mac地址，然后转发信息 pc0第一次ping pc1，交换机会广播包，然后pc1和pc2都收到，但是是pc1需要的，pc1接到后返回包给交换机，这时候交换机已经知道两者的mac地址了，将包返回给pc0。此后发包交换机都会直接在二者进行，不用广播了。 若在有效时间内两主机都没通信，该条目会被删除 MAC地址表空间有限，一旦表满，就会泛洪到所有新MAC地址的帧，知道现存地址条目老化未知 监听 短时间大量发送错误的mac地址进行攻击，造成内存溢出 交换机就会从点对点的交换式退回共享式hub，****监听其他主机的数据了image-20230407110421469 交换方式： 把整个数据帧先缓存，检查是否出错，如无错才送往目的端口。 有差错控制；交换时延较长。 从总线以太网到星形以太网 早期，以太网采用无源的总线结构。 现在，采用以太网交换机的星形结构成为以太网的首选拓扑。 总线以太网使用 CSMA&#x2F;CD 协议，以半双工方式工作。 交换机不使用共享总线，没有碰撞问题，因此不使用CSMA&#x2F;CD协议，而是以全双工式工作，但仍然采用以太网的帧结构 使用了生成树协议，不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 虚拟局域网虚拟局域网（ VLAN ）：它是将局域网从逻辑上划分为一个个的网段，从而实现虚拟工作组的一种交换技术。 因此同一个网段下的主机都要设置同一个网络号。 补充：当子网掩码为255.255.255.0，则ip前三个段表示网络号；255.255.0.0，前两个为网络号。(255在8位二进制表示全1) ：那么不同网段设置不同网络号就好了为什么要设VLAN？ ：IP是逻辑地址，随时改，不安全不严谨 一个VLAN&#x3D;一个广播域&#x3D;逻辑网段(子网) 3.5 高速以太网吉特以太网，上层链路速度要比下层所有加起来要大(或等于) 四 网络层网络层提供的两种服务： 虚电路服务(面向连接，让网络负责可靠交付) 数据报服务(无连接，让主机负责可靠交付) 网络层两种服务 含义 优点 缺点 虚电路服务 借助电信网经验，通信之前先建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。 使所发送的分组无差错按序到达终点，不丢失、不重复。 占用一定的网络带宽，造成资源浪费 数据报服务 网络在发送分组时不需要先建立连接。每一个分组（即IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 传输网络不提供端到端的可靠传输服务，网络的造价大大降低，运行方式灵活，能够适应多种应用。 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），不保证分组传送的时限 4.2 网际协议IPARP协议：IP到MAC的映射 ICMP( Internet Control Message Protocol )：报告出错情况 4.2.1 虚拟互连网络意义： 所谓虚拟互连网络也就是逻辑互连网络 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。 如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet) 核心层–汇聚层–接入层 为什么要有IP而不单独用MAC，因为MAC就像一个人的名字，找是很难找的，IP就像学号，具备逻辑信息，找起来方便 4.2.2 分类的IP地址 A类地址的第一个十进制数范围从(1-126) B类地址的第一个十进制数范围从(128-191) C类地址的第一个十进制范围(192-223)，例如192.168.1.1 网络号字段即192.168.1.0 -A类-127-B类-191-C类- 点分十进制记法机器中存放IP地址是32位二进制代码，8位为一组，转换为十进制数，提高可读性。 ※转换： 为1的位代表的十进制数相加。 一般不使用的特殊的IP地址： 网络号 主机号 源地址实验 目的地址实验 代表的意思 0 0 可以 不可 在本网络上的本主机（6.6节DHCP协议） 0 host-id 可以 不可 在本网络上的某台主机host-id 全1 全1 不可 可以 只在本网络上进行广播（各路由器均不转发） net-id 全1 不可 可以 对net-id上的所有主机进行广播 调试网络： ping自己，ip没错 ping网关，网关没错 ping下一跳，没问题再ping下一跳 IP地址的重要特点 分等级的地址结构，两个好处 IP 地址管理机构在分配 IP 地址时只分配网络号，由该网络号的单位自行分配剩下的主机号，方便IP地址管理。 路由器仅根据目的主机所连接的网络号来转发分组；使路由器中的项目数大幅减少，从而减小路由表所占的存储空间 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。 因此，当一个主机连接到两个网络上时，就必须同时具有两个相应的IP地址，这两个网络号必须不同，称为多归属主机。 一个路由器至少应对连接到两个网络，这样才能将数据报从一个网络转发到另一个，即路由器至少要有两个不同的IP地址。 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。 小结 IP 地址是一种分等级的地址结构 路由器用于连接不同网络，一个路由器至少有两个网络号不同的IP 地址。 用转发器或网桥连接起来的局域网仍属于一个网络。 在同一个网络上的主机或路由器的IP地址中的网络号必须是一样的。 4.2.3 IP地址与硬件地址IP数据报头部是IP地址，MAC帧首部是硬件地址 在 IP 层抽象的互联网上只能看到 IP 数据报。 图中的 IP1→IP2 表示从源地址 IP到目的地址 IP2 。两个路由器的 IP 地址并不出现在 IP 数据报的首部中。路由器只根据目的站的 IP 地址的网络号进行路由选择。*那怎么知道到哪个路由器呢？ 这个时候就需要MAC地址了，IP 层抽象的互联网屏蔽了下层很复杂的细节。在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信 。* 4.2.4 地址解析协议ARP 通信时使用了两个地址 IP地址(网络层地址) MAC地址(数据链路层地址)—ARP来找 地址解析协议ARP作用就是从网络层使用的IP地址解析出在数据链路层使用的硬件地址。 ARP 作用：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。 ARP要点： 不管网络层是什么协议，当网络上传输数据帧时还是需要使用硬件地址的。 每一个主机都设有一个ARP 高速缓存 (ARP cache)，里面有所在的局域网上的各主机和路由器的IP 地址到硬件地址的映射表。 &lt;IP address; MAC address; TTL&gt;，TTL(Time To Live):地址映射有效时间 A向B发IP数据报先查ARP cache有无B的IP地址 Yes，就可以查到硬件地址并写入MAC帧，通过局域网将MAC帧发往硬件地址 No，ARP进程在本局域网广播发送一个ARP请求分组，收到响应后，将映射写入ARP cashe 注意： ARP是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。 如果目的主机不在同一个局域网，则现有ARP找到一个位于本局域网上的某个路由器的硬件地址，将分组发送给路由器进行转发，剩下的工作由下一个网络来做。 从IP 地址到硬件地址的解析是自动进行，主机用户不知道 只要与已知IP的设备进行通信，ARP协议就会自动地将该IP 地址解析为链路层所需要的硬件地址。 为什么我们不直接使用硬件地址进行通信？ 异构网络，转换复杂：由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。 IP编址解决这一问题，统一标准，进行编号：连接到互联网的主机只需各自拥有一个唯一的IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。 因此，在虚拟的IP 网络上用IP 地址进行通信给广大的计算机用户带来了很大的方便。 第一个是广播，发送全1地址；发送路由器的MAC地址，让路由器转发分组 image-20230522093726982 主机1可以访问WWW服务器，但不能访问Internet。 以太网 数据部分46-1500B 整个帧64-1518B 小结 ARP协议的作用：从IP地址解析出硬件地址。 每一个主机都设有一个ARP高速缓存，用于存放最近获得的IP 地址到MAC 地址的绑定。 当目的主机和源主机不在同一个局域网时，通过ARP找到默认网关的硬件地址，然后由默认网关把分组转发给下一个网络。 4.2.5IP数据报的格式 一个 IP 数据报由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的。 IP 数据报首部的固定部分中的各字段 首部前一部分是固定长度，共20字节，是所有IP数据报必须具有的 可选字段说明长度是可变 第一行从左到右： 版本——占4 位，指IP 协议的版本。目前的IP 协议版本号为4 (即IPv4)。 首部长度——占4 位，可表示的最大数值是15 个单位(一个单位为4 字节)，因此IP 的首部长度的最大值是60 字节。 区分服务，只有使用区分服务才起作用，一般不使用 总长度——占16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为65535 字节。总长度必须不超过最大传送单元MTU。 最大传输单元MTU：一个帧可传输的数据量的上界。 数据经MTU先分片，到目的站再重组 第二行从左到右： 标识(identification) ——占16 位，它是一个计数器，用来产生IP 数据报的标识。 标志(flag) ——占3 位，目前只有前两位有意义。MF&#x3D;1表示后面还有分片，MF&#x3D;0表示最后一个分片。DF&#x3D;0时才允许分片 片偏移—— 占13 位，指出：较长的分组在分片后，某片在原分组中的某片在原分组中的相对位置。片偏移以8 个字节为偏移单位。**(除以8)** 例子 第三行从左到右： 生存时间——占8 位，记为TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。 协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的IP 层将数据部分上交给那个处理过程 首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用CRC 检验码而采用简单的计算方法。 死亡之pingping -l [包尺寸] 目标IP -t IP包最大65535，而实际规定的最大尺寸并达不到。 一直发大包，分片之后没问题，接收到重组之后就发现超过了尺寸，使得额外数据被写入其他正常区域，造成缓存溢出(Buffer Overflow)攻击 解决办法：对超出规定长度的包直接丢掉不重组 生存时间 协议 首部检验和 并不检验数据，为了减少路由器处理时延，转发分组更快 缺点，出现差错不能及时发现 计算距离了解即可 目的地址、源地址 可变部分，从1字节到40字节不等，现在少用，一般都是固定的 练习一行由8位16进制标识，当有一个IP分组表，每个单元是一个8位16进制，那么源地址就是第四个单元，如c0 a8 00 08–&gt;1100 0000. . . –&gt;192.168.0.8 【解答】（1）H主机的IP地址是192.169.0.8，对应的十六进制是c0 a8 00 08，根据IP分组的源IP地址知道，分组1、3和4是H发送的。 （2）快速以太网数据帧的数据最小长度为46B，当IP分组总和小于46B时，需要填充。 根据IP分组的“总长度”字段，5个分组的长度分别为00 30H、00 30H、00 28H、00 38H、00 28H，即：  第1、2、4个分组大小分别为48B、48B、52B（均大于最小帧长46B），不需要填充；  第3、5个分组28H（分组大小为40B），因此需要填充。 小结 IP 数据报由首部和数据组成。 途径MTU较小网络，数据报会被分片，到达目的站后再进行重组。 IP 数据报采用16 位二进制反码求和算法检验数据报的首部。 4.2.6 IP 层转发分组的流程在路由表中，对每一条路由，最主要的是 （目的网络地址，下一跳地址） 查找路由表 根据目的网络地址就能确定下一跳路由器，这样做的结果是： IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。 只有到达最后一个路由器时，才试图向目的主机进行直接交付。 特定主机路由 分组转发基于目的主机所在网络，特例是为特定目的主机指明一个路由 方便控制和测试 默认路由 减少路由表占用空间和搜索路由表时间 注意 数据报首部没有指明下一跳路由器的IP 当路由器接到数据报，是将下一跳地址递交下一层网络接口软件而非填入IP数据报 网络接口软件使用 ARP 负责将下一跳路由器的IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。 路由器分组转发算法 从首部提取目的主机IP地址D，得出目的网络地址N 若直接相连，则直接交付目的主机，否则间接交付，执行3 若有特定主机路由，则传送给指明的下一跳路由器，否则执行4 若有到达网络N的路由，传送，否则5 若有默认路由，传送给指明的默认路由器，否则6 报告转发分组出错 ⚠4.3划分子网和构造超网4.3.1划分子网原因：早期IP地址设计不够合理，利用率低，两级的IP地址不够灵活 解决：在IP地址中增加一个“子网号字段”，从两级IP变成三级IP地址，叫做划分子网 基本思路： 划分子网纯属单位内部的事。借助主机位划分子网，对外仍然是一个网络 从主机号再借用若干位作为子网号，因此主机号就相应减少了若干位 从其他网络发来的数据报，仍然根据IP数据包的目的网络号找到本单位网络上的路由器 此路由器再按目的网络号和子网号找到目的子网 优点： 减少了IP 地址的浪费 使网络的组织更加灵活 更便于维护和管理 子网掩码原因：根据IP数据报首部无法判断目的网络是否进行子网划分 解决：通过子网掩码可以找到IP地址中的子网部分 规则： 子网掩码长度＝32位 某位＝1：IP地址中的对应位为网络号和子网号 某位＝0：IP地址中的对应位为主机号 看例题 因此无法仅通过首部判断源主机或目的主机所连接的网络是否进行了子网划分。 与运算$$(IP地址)AND(子网掩码)&#x3D;网络地址$$ 借的位数越多，子网越多但是每个子网能带的主机数越少,如何理解借用呢，看下面的例子 image-20230428123203956 通过ip地址可以看到是个C类，但是子网掩码不是默认的255.255.255.0而是.224，写出224的2进制，是11100000，前面3个1，借了3位，也就是划分了23个子网，三位二进制有8种组合，每一种组合加上后面全0就对应一个子网号 image-20230428105145702 网络地址：192.168.10.0 子网掩码：255.255.255.192(&#x2F;26) ：192(11000000)说明借了两位产生子网 **1.子网数？ **借了多少位产生多少子网 2.主机数？ 3.有效子网？ 4.广播地址？ 网络段不变(包括借位的部分)，后面全1 5.有效主机范围是？ IP地址类别 分段 网络号 主机号 默认子网掩码 A 0-127 8位 24位 255.0.0.0 B 128-191 16位 16位 255.255.0.0 C 192-223 24位 8位 255.255.255.0 4.3.2 使用子网时分组的转发 4.3.3 无分类编址 CIDR128.14.32.0&#x2F;20 网络前缀的位数(即网络号)为20，&#x2F;20地址块 例 192.199.170.82&#x2F;27 有多少ip地址？一个32位，网络占27，则ip地址有2^5&#x3D;32 最大最小地址：看82:(01010010)，最后5位全0则为最小网络号，全1为最大网络号 CIDR地址块.后5位全0，即最小地址 子网掩码，令27位全1，后5位全0 路由聚合 构成超网将多个子网聚合成一个较大的子网，构成超网或网络聚合 方法：将网络前缀缩短所有网络取交集 206.1.0.0&#x2F;17 206.1.128.0&#x2F;17 这两个网络只有前16位相同，因此取交集，网络前缀缩短为16，即206.1.0.0&#x2F;16 划分子网：从少到多；构成超网：从多变少 最长前缀匹配使用CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。 使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码按位相与)，应选择具有最长网络前缀的路由。前缀越长，地址块越小，路由越具体。 根据最长前缀匹配，如果匹配成功则选择网络前缀最长的，就是目标路由器 解题步骤： 先将目的地址和路由表所有项目的子网掩码进行与运算 看看结果是否等于路由表的项目IP 如果有多个相同的结果，取子网掩码长的 例： 这里就匹配到了两个结果，选择子网掩码最长的，即206.71.128&#x2F;25，因此下一跳为2 二叉线索法4.4网际控制报文协议ICMP目的：为了更加有效转发IP数据报和提高交付成功的机会 作用：ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。 注意：不是高层协议，它封装在IP数据报中，作为数据部分，是IP层的协议 4.4.1ICMP报文的种类两种： ICMP 差错报告报文 ICMP 询问报文。 报文格式： 前4 个字节统一格式，三个字段：类型、代码和检验和。接着4个字节与ICMP类型有关 ICMP 差错报告报文四种： 终点不可达 时间超过 参数问题 改变路由（重定向）(Redirect) 不应发送ICMP 差错报告报文的几种情况 对ICMP 差错报告报文不再发送ICMP 差错报告报文。 对第一个分片的数据报片的所有后续数据报片都不发送ICMP 差错报告报文。 对具有多播地址的数据报都不发送ICMP 差错报告报文。 对具有特殊地址（如127.0.0.0 或0.0.0.0）的数据报不发送ICMP 差错报告报文。 ICMP 询问报文 回送请求和回答报文 时间戳请求和回答报文 4.4.2ICMP的应用距离PING(Packet InterNet Groper) PING用来测试两个主机之间的连通性 PING使用了ICMP 回送请求与回送回答报文。 PING是应用层直接使用网络层ICMP 的例子，它没有通过运输层的TCP 或UDP。 Traceroute Windows中命令是tracert 用来跟踪一个分组从源点到终点的路径 它利用IP 数据报中的TTL 字段和ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。 小结 ICMP用于主机或路由器报告差错情况和提供有关异常情况的报告 ICMP报文包括ICMP差错报告报文和ICMP询问报文两种 ICMP应用：PING、Traceroute 4.5互联网的路由选择协议4.5.1有关路由选择协议的几个基本概念 路由算法 路由选择 优点 缺点 静态路由选择策略 非自适应路由选择 简单和开销较小 但不能及时适应网络状态的变化 动态路由选择策略 自适应路由选择 能较好地适应网络状态的变化 实现起来较为复杂，开销也比较大。 分层次的路由选择协议互联网采用分层次的路由选择协议，原因： 互联网的规模非常大，为了节省路由表空间，同时避免通信链路饱和 单位不想让外界了解自己的网络 自治系统AS： 在单一的技术管理下的一组路由器，使用AS内部的路由选择协议和共同的度量来确定其中的路由，还使用AS之间的路由选择协议来确定分组在AS之间的路由。 尽管一个AS 使用了多种内部路由选择协议和度量，一个AS 对其他AS 表现出的是一个单一的和一致的路由选择策略。 互联网有两大类路由选择协议 内部网关协议IGP (Interior Gateway Protocol) 在一个自治系统内部使用的路由选择协议。 这类使用的最多，如RIP和OSPF 外部网关协议EGP (External Gateway Protocol) 源站和目的站不在一个自治系统，数据报传到自治系统边界就要用一种协议将路由选择信息传递进另一个自治系统，这个系欸就是EGP。 使用最多的是BGP-4 自治系统之间路由选择叫域间路由选择，内部路由选择叫做域内路由选择。 路由器和网关可以当作同义词 小结 路由选择包括静态和动态两种路由选择策略。 一个自治系统表现出一致的路由选择策略。 根据是在自治系统内部使用，还是在自治系统之间使用，路由选择协议可以分为内部网关协议IGP和外部网关协议EGP。 4.5.2RIP内部网关协议 内部网关协议IGP中最先得到广泛使用协议 一种分布式的、基于距离向量的路由选择协议 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 距离(指最短距离)： 路由器到直连网络距离定义为1 到非直连的距离定义为所经过的路由器数加1 也成为跳数，经过一个路由器跳数加1 好的路由就是经过路由器数目少，即距离短 RIP允许一条路径最多只能包含15个路由器，加上自己就是16，16跳就表示不可达，因此只适用于小型网络 RIP不能使用多条路由，这导致它永远选最短的那条，哪怕另外还有一条低时延的路由 把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值加1 特点 仅和相邻路由器交换信息。 交换自己的路由表。 按固定的时间间隔交换路由信息 查看错题 若下一跳字段给出的路由器地址相同，则把收到的项目替换源路由表项目。 如果收到项目中的距离小于路由表中的距离，则进行更新 RIP2报文存在划分子网情况要用version2 RIP2 具有简单的鉴别功能 小结 使用跳数判断到其他网络的距离。 周期性地和相邻路由器交换自己的路由表。 RIP能使用的最大距离为15跳(16不可达)，适用于小型网络。 RIP好消息传播得快，坏消息传播得慢(信息一直不匹配，要不断更新，直到超过15)，导致更新过程收敛时间过长。 OSPF内部网关协议采用分布式的链路状态协议(link stateprotocol)。 邻居表 邻居路由器的信息 拓扑表 也叫链路状态数据库（LSDB），同区域中所有路由器的LSDB信息必须保持一致。 路由表 到达目标网络的最佳路径 链路状态数据库(拓扑表) “链路状态”即本路由器和哪些路由器相邻，以及该链路的度量 所有路由器最终建立一个链路状态数据库，全网的拓扑结构图，它在全网范围内是一致的(同步) 能较快地更新，收敛快是其重要优点 OSPF区域 (area) OSPF用于规模大地网络，将一个自治系统再划分为若干个更小的范围即区域 每个区域有32位的区域标识符(点分十进制表示) 区域最好不超过200个 划分区域 主干区域，全0 常规区域，非0 好处： 利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。 OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。 主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 OSPF 不用UDP 而是直接用IP 数据报传送，数据报短，不必分片，但只要丢失一个就得整个重传 支持可变长度的子网划分和无分类编址CIDR。 OSPF五种分组类型： 类型1，问候(Hello) 分组。 类型2，数据库描述(Database Description) 分组。 类型3，链路状态请求(Link State Request) 分组。 类型4，链路状态更新(Link State Update) 分组，用洪泛法对全网更新链路状态。 类型5，链路状态确认(Link State Acknowledgment)分组。 与RIP比较 每隔一段时间，如30 分钟，要刷新一次数据库中的链路状态。 当互联网规模很大时，OSPF协议要比距离向量协议RIP 好得多。 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。 小结 包括邻居表、拓扑表（链路状态数据库）、路由表。 链路状态数据库在全网范围内一致（同步） OSPF的更新过程收敛速度快。 将一个自治系统划分为若干个区域，区域内部的路由器只需要知道本区域的网络拓扑。 区域包括主干区域和常规区域两种。 通过洪泛发送更新分组。 *4.5.4BGP外部网关协议*4.5.5路由器的构成4.6 IPV64.6.1 IPv6的基本首部 主要变化： 更大的地址空间，从IPv4 的32 位增大到了128 位。 扩展的地址层次结构。 灵活的首部格式。IPv6 定义了许多可选的扩展首部。 改进的选项。 允许协议继续扩充。 支持即插即用（即自动配置）。因此IPv6 不需要使用DHCP。 支持资源的预分配 IPv6 首部改为8 字节对齐。首部长度必须是8 字节的整数倍。原来的IPv4 首部是4 字节对齐。 扩展首部 Pv6 把原来IPv4 首部中选项的功能都放在扩展首部中 数据报途中经过的路由器都不处理这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。 这样就大大提高了路由器的处理效率 4.6.2 IPv6的地址 目的地址可以是以下三种基本类型地址之一 单播，点对点 多播，一点对多点 任播，目的是一组计算机，数据包交付时只交付其中一个，通常为距离最近的一个 冒分十六进制 允许零压缩，即一连串连续的零可以为一对冒号所取代。例如FF05:0:0:0:0:0:0:B3 可压缩为：FF05::B3 注意：在任一地址中只能使用一次零压缩。 CIDR 的斜线表示法仍然可用。 4.6.3 从IPv4向IPv6过渡 两种策略 使用双协议栈，网络地址转换&#x2F;协议转换技术NAT-PT 使用隧道技术，把IPv6 数据报封装成为IPv4 数据报，整个的IPv6 数据报变成了IPv4 数据报的数据部分。离开IPv4 网络中的隧道时，再把数据部分（即原来的IPv6 数据报）交给主机的IPv6 协议栈。 *4.6.4 ICMPv64.8 虚拟专用网VPN和网络地址转换NAT4.8.1 虚拟专用网VPN原因：IP地址紧缺，对于机构内部可以自行分配IP地址。 然而很容易有本地地址和全球地址相同的情况，造成二义性，因此需要作出规定。 三个专用IP 地址块： (1) 10.0.0.0 到10.255.255.255，即10开头 A类，或记为10.0.0.0&#x2F;8，它又称为24位块 (2) 172.16.0.0 到172.31.255.255，即172.16-172.31 B类，或记为172.16.0.0&#x2F;12，它又称为20位块 (3) 192.168.0.0 到192.168.255.255，即192.168开头 C类，或记为192.168.0.0&#x2F;16，它又称为16位块 这类地址不需要申请，直接可以使用，仅在本机构内部使用，不能出公网 虚拟专用网一般专用网就是专线直接相连使用专用IP地址，然而直接用线路连成本过高，对大部分机构不实际 需要“虚拟”，利用公用的互联网作为本机构各专用网之间的通信载体。表示“好像是”，但实际上并不是，因为现在并没有真正使用通信专线，而VPN只是在效果上和真正的专用网一样。 远程接入VPN 远程接入VPN (remote access VPN)可以满足外部流动员工访问公司网络的需求。 小结 专用地址只能用作本地地址，互联网中的路由器不转发目的地址为专用地址的数据报。 采用专用IP 地址的互连网络称为专用网。 虚拟专用网VPN利用公用的互联网作为本机构各专用网之间的通信载体。 使用隧道技术实现VPN。 4.8.2 网络地址转换NAT问题：在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？ 申请全球IP地址 采用网络地址转换NAT 装有NAT 软件的路由器叫作NAT路由器，它至少有一个有效的外部全球IP地址。 所有使用本地地址的主机在和外界通信时，都要在NAT 路由器上将其本地地址转换成全球IP地址，才能和互联网连接。 优点 避免重新编址 节约全局地址使用 不直接使用全局地址，在互联网上不直接可见，增加了安全性 NAT三种类型 静态，每个主机被永久映射成外部网络中的某个合法的地址。-一对一 动态，定义了一系列合法地址，利用动态分配进行映射。-一对一 重载(PAT)，把内部地址映射到外部网络**一个IP地址的不同端口(port)**上。-多对一 *4.9 多协议标记交换MPLS本章总结 ⭐网络层提供的两种服务:面向连接(虚电路)、无连接(数据报) ⭐网络互联设备：集线器、交换机、路由器、多层交换机 ⭐两级的IP 地址结构：网络号、主机号 IP 地址的点分十进制记法 ⭐IP 地址的分类：A类、B类、C类、D类、E类 ⭐IP 地址与硬件地址的区别 ⭐ARP协议的作用、工作原理（如何知道硬件地址） IP 数据报的格式 大题 ⭐路由器分组转发算法 ⭐划分子网的基本思路、优点 计算题 子网掩码 ⭐使用子网时分组的转发 CIDR的特点 ⭐最长前缀匹配 使用二叉线索查找路由表 ⭐ICMP 作用、ICMP报文的格式、种类、ICMP应用 路由选择协议: 内部网关协议、外部网关协议 ⭐RIP、OSPF协议的特点 IPv6的基本首部、IPv6的地址、IPv4向IPv6的过渡 VPN、NAT的作用、特点 ⭐专用IP 地址块 每一点都有关联，理清关系，为什么要有这样的协议&#x2F;技术，解决何种问题 5传输层运输层在协议栈中的地位 Ø 从通信和信息处理角度，运输层为上面的应用层提供通信服务，是面向通信部分的最高层和用户功能的最底层。端到端通信时，只有主机协议栈才有运输车，而路由器在转发分组时都只用到下三层。 Ø 从网络层来说，IP协议虽然能把分组送到目的主机，但是分组还停留在主机的网络层，没有交付主机的应用程序。然而真正的通信实体是主机间的进程。所以还需要运输层完成交付。 Ø 从运输层来看，通信真正的端点并不是主机，而是主机的进程，即端到端的通信是应用进程之间的通信。同时，运输层还有复用、分用的功能，还要对收到的报文进行差错检测。 Ø 因此运输层在协议栈中非常重要，必不可少 运输层和网络层的重要区别： *运输层* *网络层* *位置* 七层网络结构的第四层 七层网络结构的第三层 *重要区别* 提供应用进程之间的逻辑通信 提供主机之间的逻辑通信 *服务协议* UDP、TCP IP协议 5.1 运输层协议概述5.1.1 进程之间的通信路由器工作在下三层。不单只是主机之间通信，还得提供应用进程的通信 复用和分用功能 两大类端口(1) 服务器端使用的端口号 熟知端口，数值一般为0~1023。 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA 登记，以防止重复。 (2) 客户端使用的端口号 又称为短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 常用的熟知端口–记忆 http协议明文传输，抓包就能看到具体信息，而https在http基础上加上Secure Sockets Layer安全套接层，加密 5.1.2 运输层的两个主要协议(1) 用户数据报协议 UDP (User Datagram Protocol) (2) 传输控制协议 TCP (Transmission Control) TCP与UDP 表格 UDP：一种无连接协议 提供无连接服务。 在传送数据之前不需要先建立连接。 传送的数据单位协议是UDP 报文或用户数据报。 对方的运输层在收到UDP 报文后，不需要给出任何确认。 虽然 UDP 不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式。 TCP：一种面向连接的协议 提供面向连接的服务。 传送的数据单位协议是TCP 报文段(segment)。 TCP 不提供广播或多播服务。 由于TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。 5.2 用户数据报协议UDP在IP数据报服务增加了： 复用和分用的功能 差错检测的功能 UDP主要特点 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一和多对多 首部开销小，只有8字节，而TCP有20字节 检验和\\1. 检验和字段置零，UDP用户数据报凑够偶数字节； \\2. 把所有位（UDP伪首部+UDP首部+UDP数据部分）按16位划分为不同的字； \\3. 计算上述所有16位字的和，如果有进位导致总位数超过16位，则把进位值加到末位； \\4. 将上述计算的和取反即为UDP用户数据报的检验和。 UDP的应用 对传输协议的可靠性要求不高，需要传送的数据不多，使用频率不高。如：DNS服务(域名映射IP)、DHCP服务、SNMP服务等。 实时应用，如：IP电话、视频会议、QQ等。 IP、ICMP、UDP、TCP报文首部检验和字段校验和算法一样，但作用范围不同。 IP校验和只校验IP数据报的首部； ICMP校验和覆盖整个ICMP报文(首部+数据)； UDP和TCP校验和不仅覆盖整个报文，而且还有12个字节的伪首部。 5.3 传输控制协议TCP 概述5.3.1 TCP 最主要的特点 面向连接 只有两个端点 点对点 可靠交付 全双工 面向字节流 5.3.2TCP的连接 TCP 连接的端点叫做套接字(socket) 或插口。 端口号+IP地址构成套接字 套接字socket &#x3D; (IP地址: 端口号) TCP 连接::&#x3D; {socket1, socket2}&#x3D;&#x3D; {(IP1: port1)，(IP2: port2)} 5.4可靠传输的工作原理5.4.1 停止等待协议理想的传输条件有以下两个特点： (1)传输信道不产生差错。 (2) 不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。 每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 全双工通信的双方既是发送方也是接收方。 1.无差错情况 发完暂停，等待确认，收到确认后，再发送 2.出现差错 传输过程丢失&#x2F;接收时出错 解决办法：超时重传 3.确认丢失和确认迟到 确认丢失 此A 在超时计时器到期后就要重传M1 B接收到后可以1丢弃M1 2向A发送确认 确认重传 B 对分组M1 的确认迟到 A 会收到重复的确认后丢弃 B 仍然会收到重复的M，丢弃重复的M1，并重传确认分组 注意 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发 分组和确认分组都必须进行编号。 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发 4信道利用率 停止等待协议的优点是简单，缺点是信道利用率太低。 5.4.2 连续ARQ 协议连续ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 累计确认不必对分组逐个发送确认，对到达的最后一个分组发送确认，表示之前的所有我都收到了 优：容易实现，即使确认丢失也不必重传。 ？缺：不能向发送方反映出接收方已经正确收到的所有分组的信息。 Go-back-N（回退N）Go-back-N（回退N），表示需要再退回来重传已发送过的N 个分组。 比如A发的前5个分组是12345，B收到1245，由于3开始不联系，B只确认2(即2以前都收到)，A不知道后三个分组下落超时后重传 TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。 小结 流水线传输允许发送方连续发送多个分组，而不需要等待对方的确认，从而提高信道利用率。 位于发送窗口内的分组可连续发送出去。 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置 接收方采用累积确认的方式对按序到达的最后一个分组发送确认。 5.5TCP 报文段的首部格式面向字节流，传送的数据单元却是报文段。 ❗源端口和目的端口字段——各占2 字节：端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 ❗序号字段——占4 字节：数据流每个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号 ❗确认号字段——占4 字节：期望收到对方的下一个报文段的数据的第一个字节的序号。 比如发的1234，确认号字段就是5 ⭐序号确认号 数据偏移（即首部长度）——占4 位，它指出TCP 报文段的数据起始处距离TCP 报文段的起始处有多远。“数据偏移”的单位是32 位（以4 字节为计算单位）。 保留字段——占6 位 目前为0 紧急URG —— 当URG &#x3D; 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 ❗确认ACK —— 只有当ACK &#x3D; 1 时确认号字段才有效。当ACK &#x3D; 0 时，确认号无效。 推送PSH (PuSH) —— 接收TCP 收到PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 复位RST (ReSeT) —— 当RST  1 时，表明TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 ❗同步SYN —— 同步SYN &#x3D; 1 表示这是一个连接请求或连接接受报文。 ❗终止FIN (FINish) —— 用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 ❗窗口字段—— 占2 字节，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限。 窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化的。 如：设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有1000个字节数据（字节序号是701-1700）的接收缓存空间。 检验和(和IP类似)—— 占2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP 报文段的前面加上12 字节的伪首部。 紧急指针字段—— 占16 位 指出紧急数据多少字节 紧急数据放在本报文段数据的最前面 选项字段—— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度MSS(Maximum Segment Size，TCP报文段长度减去首部长度) 填充字段:使整个首部长度是4字节的整数倍 小结 TCP的每条连接都有发送序号和确认号。 序号字段是本报文段所发送的数据的第一个字节的序号。 确认号字段是期望收到对方的下一个报文段的数据的第一个字节的序号。 TCP 连接的一端根据缓存空间大小确定自己的窗口大小，利用窗口字段控制对方发送的数据量。 5.6 TCP 可靠传输的实现TCP 的滑动窗口是以字节为单位的。 根据B 给出的窗口值，A 构造出自己的发送窗口。 发送窗口表示：在没有收到B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。 发送窗口里面的序号表示允许发送的序号 显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。 小结TCP连接的一端根据另一端给出的窗口值构造自己的发送窗口。 TCP连接的一端可以连续把发送窗口内的数据都发送出去，而不需要等待对方的确认。 收到新的确认号，发送窗口向前滑动。 5.6.2 超时重传时间的选择重传时间的选择是TCP 最复杂的问题之一。 TCP 采用了一种自适应算法它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。 慢慢更新平均往返更新 通过加权平均往返时间RTTs计算超时重传时间RTO 5.6.3 选择确认SACK缺少部分只发送缺少的不全部重传 TCP 的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块。 如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在TCP 报文段的首部中都增加了SACK 选项，以便报告收到的不连续的字节块的边界。 小结 TCP 采用自适应算法计算报文段的往返时间RTT。 超时重传时间RTO略大于往返时间RTT。 5.7TCP的流量控制5.7.1利用滑动窗口实现流量控制 流量控制(flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 方法：滑动窗口机制 可能发生的问题：互相等待的死锁 方法：持续计时器 持续计时器只要TCP 连接的一方收到对方的零窗口通知（举例的最后一条），就启动该持续计时器。 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。 若窗口不是零，则死锁的僵局就可以打破了。 5.8 TCP 的拥塞控制5.8.1 拥塞控制的一般原理某资源需求超过了提供的可用部分，网络性能变坏，发生拥塞 拥塞问题很复杂 开环控制和闭环控制 开环控制 闭环控制 5.8.2 TCP 的拥塞控制方法TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。 拥塞判断重传定时器超时：超时 收到三个相同（重复）的ACK：丢包 TCP拥塞控制算法 拥塞控制算法 含义 作用 慢开始 由小到大逐渐增大拥塞窗口数值 防止拥塞窗口增长过大引起网络拥塞 拥塞避免 每经过一个往返时间就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长 加法增大的特点，按线性规律缓慢增长比慢开始算法的增长速率缓慢很多 快重传 首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即时收到了失序的报文段也要立即发出对已收到的报文段的重复确认。 让发送方尽早知道发生了个别报文段的缺失。发送方只要一连收到三个重复确认，就知道接收方确实没有收到，应当立即重传，因此不会出现超时，发送方也不会误认为出现了网络拥塞 快恢复 发送方收到三次确认可以认为网络没有发送拥塞，不执行慢开始而执行快恢复，新的拥塞窗口等于当前拥塞窗口的一半，并执行拥塞避免算法进行缓慢线性增长 提高网络传输效率，提升吞吐量 慢开始(slow-start) 算法的思路：由小到大逐渐增大拥塞窗口数值。 发1，收1 发2，收2 发4，收4 发8，收8 指数级增长 拥塞避免(congestion avoidance) 避免办法：设定阈值，超过后下一轮只加1。当计时器超时(拥塞)，将阈值改为一半，重新进行慢开始 快重传(fast retransmit) 3-ACK确认，发送方改为执行快重传和快恢复算法。 发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。 不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。 快恢复(fast recovery) 由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI(Additive Increase)。 当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD(Multiplicative Decrease) 乘法减小和加法增大 用途 乘法减小 当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。当网络频繁出现拥塞时，门限值就下降得很快，以大大减少注入到网络中的分组数 加法增大 在拥塞避免阶段，拥塞窗口是按照线性规律增大的，例如在收到对所有报文段得确认后(即经过一个往返时间)，就把拥塞窗口增加一个MSS大小，使拥塞窗口缓慢增大，防止网络过早出现拥塞。 小结 对网络资源的需求超过了可用资源，网络就会出现拥塞。 TCP 采用基于窗口的方法进行拥塞控制。 拥塞窗口的大小取决于网络的拥塞程度。 发送窗口大小取决于接收方公告的窗口和拥塞窗口。 后面的跳过了 5.9 TCP 的运输连接管理5.9.1 TCP 的连接建立TCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个TCP 报文段。称之为三报文握手。 防止失效又突然传送到了，产生错误 1SYN→ 2←SYN+ACK 3ACK→ SYN&#x3D;1说明TCP进行确认，确认包ACK&#x3D;1，ack的值是收到的seq+1 练习 5.9.2 TCP 的连接释放 数据传输结束后，通信的双方都可释放连接。 TCP 连接释放过程是四报文握手。 总结 掌握运输层的端口的概念及作用； 掌握UDP、TCP的特点； 可靠传输：停止等待协议, 连续ARQ 协议； 了解UDP、TCP 的首部格式**(源端口、目的端口、序号、确认号、窗口)；** 掌握TCP 可靠传输、流量控制、拥塞控制的实现； 掌握TCP 的连接建立、连接释放的过程。 TCP 连接处于 FIN-WAIT-1 状态。以下的事件相继发生： （1）收到 ACK 报文段 （2）收到 FIN 报文段 （3）发生了超时 在每一个事件之后，连接的状态是什么？在每一个事件之后发生的动作是什么？ (1) FIN-WAIT2 等待接收方发送连接释放报文 (2) close-wait 进入关闭等待状态半连接 (3) FIN-WAIT1 重传连接释放报文 第6章应用层6.1 域名系统DNS6.1.1 域名系统概述IP地址不便记忆 管理域名的系统就是DNS (Domain Name System) 。 6.1.2 互联网的域名结构互联网采用了层次树状结构的命名方法。 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。 域名的结构由标号序列组成，各标号之间用点隔开： 各标号分别代表不同级别的域名。 域名只是个逻辑概念，并不代表计算机所在的物理地点。 6.1.3 域名服务器 一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。 四种类型根域名服务器 顶级域名服务器 权限域名服务器 本地域名服务器 6.2 FTP特点使用TCP 主要功能：减少不同操作系统处理文件不兼容性 使用客户服务器方式。服务器进程由一个主进程负责接受新的请求和若干从属进程负责处理单个请求。 两个连接21端口控制连接 20端口数据连接 *6.3远程终端协议TELNET本节了解即可 用户用TELNET 就可在其所在地通过TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或IP 地址）。 用户感觉到好像键盘和显示器是直接连在远地主机上。 6.4万维网www概述万维网是一个大规模的、联机式的信息储藏所。并非某种特殊的计算机网络。 工作方式以客户-服务器方式工作 浏览器就是在用户计算机上的万维网客户程序 万维网文档所驻留的计算机则运行服务器程序， 客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。在一个客户程序主窗口上显示出的万维网文档称为**页面(page)**。 解决的问题（1）怎样标志分布在整个互联网上的万维网文档？使用URL统一资源定位符，唯一标识 输入URL： 解析域名-建立tcp连接-http请求报文–http响应报文–释放TCP连接 代理服务器使用高速缓存可减少访问互联网服务器的时延 6.4.4万维网的文档 了解超文本标记语言HTML 6.4.5 万维网的信息检索系统 了解6.4.6 博客和微博 了解小结 万维网是一个大规模的、联机式的信息储藏所； 万维网用链接的方法从互联网上的一个站点访问另一个站点； 万维网以客户服务器方式工作； 万维网使用URL 来标志文档； 万维网使用HTTP协议在客户程序与服务器程序之间进行交互； 万维网使用HTML语言令页面显示出来； 可以使用搜索引擎在万维网上查找信息。 6.5电子邮件发件人调用PC 中的用户代理撰写和编辑要发送的邮件。 发件人的用户代理把邮件用SMTP 协议发给发送方邮件服务器， SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。 发送方邮件服务器的SMTP 客户与接收方邮件服务器的SMTP 服务器建立TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。 6.5.2 简单邮件传送协议SMTP使用客户服务器方式 SMTP通信的三个阶段 连接建立：连接是在发送主机的SMTP 客户和接收主机的SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。 邮件传送 连接释放：邮件发送完毕后，SMTP 应释放TCP 连接 6.5.4 邮件读取协议POP3 和IMAP非常简单、但功能有限的邮件读取协议，现在使用的是它的第三个版本POP3。 POP 也使用客户-服务器的工作方式。 缺陷：读取完就在服务器删掉了 IMAP 协议客户服务器，IMAP 是一个联机协议 需要的时候才传到用户计算机，附件可以先不下载，存在服务器，节省资源 6.5.5 基于万维网的电子邮件 电子邮件从A 发送到网易邮件服务器使用HTTP 协议。 两个邮件服务器之间的传送使用SMTP。 邮件从新浪邮件服务器传送到B 是使用HTTP 协议。 万维网电子邮件的好处：只要能够找到上网的计算机，打开任何一种浏览器就可以非常方便地收发电子邮件。 6.5.6 通用互联网邮件扩充MIME受限于ASCII，无法传输 错题 6.6 动态主机配置协议DHCP互联网广泛使用的动态主机配置协议DHCP提供了即插即用连网的机制 客户-服务器方式需要IP 地址的主机在启动时就向DHCP 服务器广播发送发现报文（DHCPDISCOVER），这时该主机就成为DHCP 客户。 DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。 DHCP 中继代理(relay agent)原因：使得DHCP 服务器的数量太多。代理它配置了DHCP 服务器的IP 地址信息。 方法：当DHCP 中继代理收到主机发送的发现报文后，就以单播方式向DHCP 服务器转发此报文，并等待其回答。收到DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。","tags":["笔记"],"categories":["本科课程"]},{"title":"Android Studio降雨热力图","path":"/2023/06/08/Android-Studio降雨热力图/","content":"image-20230608163650808 基础配置AndroidManifest.xml配置定位服务和百度地图key 123456789&lt;!-- 百度地图定位服务--&gt;&lt;service android:name=&quot;com.baidu.location.f&quot; android:enabled=&quot;true&quot; android:process=&quot;:remote&quot;&gt;&lt;/service&gt;&lt;!--百度地图配置key--&gt;&lt;meta-data android:name=&quot;com.baidu.lbsapi.API_KEY&quot; android:value=&quot;填写百度地图key&quot; /&gt; 加权限 123456789101112131415161718192021 &lt;!-- 访问网络，进行地图相关业务数据请求，包括地图数据，路线规划，POI检索等 --&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;!-- 获取网络状态，根据网络状态切换进行数据请求网络转换 --&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;!-- 读取外置存储。如果开发者使用了so动态加载功能并且把so文件放在了外置存储区域，则需要申请该权限，否则不需要 --&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt; &lt;!-- 写外置存储。如果开发者使用了离线地图，并且数据写在外置存储区域，则需要申请该权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; &lt;!-- 这个权限用于进行网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于访问系统接口提供的卫星定位信息--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;&gt;&lt;/uses-permission&gt; &lt;!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt; &lt;!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=&quot;android.permission.CHANGE_WIFI_STATE&quot;&gt;&lt;/uses-permission&gt;&lt;!--读取手机状态--&gt; &lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt; 下载sdk放到jinLibs下 image-20230608162854413 build.gradle添加 1234567891011121314151617181920212223android &#123;\t...\tdefaultConfig &#123; ndk &#123; // 设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so） abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;arm64-v8a&quot;, &quot;x86&quot;,&quot;x86_64&quot; &#125;\t&#125;\t...\t//百度地图api用 sourceSets &#123; main &#123; jniLibs.srcDir &#x27;libs&#x27; &#125; &#125;&#125;dependencies &#123;\t... implementation &#x27;com.squareup.okhttp3:okhttp:4.8.1&#x27; //http请求 implementation &#x27;com.google.code.gson:gson:2.8.8&#x27; //GSON解析JSON implementation files(&#x27;libs\\\\BaiduLBS_Android.jar&#x27;) //百度地图sdk&#125;//导入了sdk就不用导入其他的百度地图以来了了，sdk基本都包含了，否则会发生冲突 生成地图初始化调整缩放 123456789101112131415161718192021222324252627282930313233343536373839404142//地图初始化private fun initloc() &#123; //定位初始化 mLocationClient = LocationClient(requireActivity()) //通过LocationClientOption设置LocationClient相关参数 val option = LocationClientOption() option.isOpenGps = true // 打开gps option.setCoorType(&quot;bd09ll&quot;) // 设置坐标类型 option.setScanSpan(1000) option.setAddrType(&quot;all&quot;) option.setIsNeedAddress(true) // 可选，设置是否需要地址信息，默认不需要 option.setIsNeedLocationDescribe(true) // 可选，设置是否需要地址描述 //设置locationClientOption mLocationClient!!.locOption = option //注册LocationListener监听器 val myLocationListener = MyLocationListener() mLocationClient!!.registerLocationListener(myLocationListener) //设置缩放 //缩放级别 val builder = MapStatus.Builder() builder.zoom(8.0f) mBaiduMap?.setMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build())) //开启地图定位图层 mLocationClient!!.start() //设置当前视图位置 mBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间&#125;//定位监听器inner class MyLocationListener : BDAbstractLocationListener() &#123; override fun onReceiveLocation(location: BDLocation) &#123; //mapView 销毁后不在处理新接收的位置 if (location == null || mMapView == null) &#123; return &#125; val locData = MyLocationData.Builder() .accuracy(location.radius) // 此处设置开发者获取到的方向信息，顺时针0-360 .direction(location.direction).latitude(location.latitude) .longitude(location.longitude).build() mBaiduMap?.setMyLocationData(locData) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//地图初始化private fun initloc() &#123; //定位初始化 mLocationClient = LocationClient(requireActivity()) //通过LocationClientOption设置LocationClient相关参数 val option = LocationClientOption() option.isOpenGps = true // 打开gps option.setCoorType(&quot;bd09ll&quot;) // 设置坐标类型 option.setScanSpan(1000) option.setAddrType(&quot;all&quot;) option.setIsNeedAddress(true) // 可选，设置是否需要地址信息，默认不需要 option.setIsNeedLocationDescribe(true) // 可选，设置是否需要地址描述 //设置locationClientOption mLocationClient!!.locOption = option //注册LocationListener监听器 val myLocationListener = MyLocationListener() mLocationClient!!.registerLocationListener(myLocationListener) //设置缩放 //缩放级别 val builder = MapStatus.Builder() builder.zoom(8.0f) mBaiduMap?.setMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build())) //开启地图定位图层 mLocationClient!!.start() //设置当前视图位置 mBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间&#125;//定位监听器inner class MyLocationListener : BDAbstractLocationListener() &#123; override fun onReceiveLocation(location: BDLocation) &#123; //mapView 销毁后不在处理新接收的位置 if (location == null || mMapView == null) &#123; return &#125; val locData = MyLocationData.Builder() .accuracy(location.radius) // 此处设置开发者获取到的方向信息，顺时针0-360 .direction(location.direction).latitude(location.latitude) .longitude(location.longitude).build() mBaiduMap?.setMyLocationData(locData) &#125;&#125; 1 显示定位监听器，获取当前位置，根据定位数据设置状态 12345678910111213141516inner class MyLocationListener : BDAbstractLocationListener() &#123; override fun onReceiveLocation(location: BDLocation) &#123; ... //获取经纬度 并保留两位小数&#x27;&#x27; preLatitude = String.format(&quot;%.2f&quot;, location.latitude).toDouble() preLongitude = String.format(&quot;%.2f&quot;, location.longitude).toDouble() //获取当前地址 preAddress = location.addrStr //保证经纬度 val ll = LatLng(location.latitude, location.longitude) //设置位置状态 preStatus = MapStatusUpdateFactory.newLatLng(ll) &#125;&#125; 动画方式回到定位位置 123456//点击按钮回到当前位置val setStatusBtn = binding.setStatusBtnsetStatusBtn.setOnClickListener &#123;\t//设置当前视图位置\tmBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间&#125; 获取降雨数据组建城市列表预设几个城市，生成地图步骤获取当前位置的经纬度数据 123456789101112private fun getRainData() &#123; thread &#123; //城市列表 val cities = listOf( Pair(preLatitude, preLongitude),//当前位置 Pair(39.90, 116.41), // 北京 Pair(31.23, 121.47), // 上海 ... ) // 假设要查询的城市经纬度列表 &#125;&#125; 准备类和取数据方法查看和风天气实例数据结构和属性，构建类 观察逐小时天气预报返回数据，我们需要的是hourly里的pop数据，并希望把24小时的数据组成一个列表。 12345678910111213141516171819202122&#123; &quot;code&quot;: &quot;200&quot;, &quot;updateTime&quot;: &quot;2021-02-16T13:35+08:00&quot;, &quot;fxLink&quot;: &quot;http://hfx.link/2ax1&quot;, &quot;hourly&quot;: [ &#123; &quot;fxTime&quot;: &quot;2021-02-16T15:00+08:00&quot;, &quot;temp&quot;: &quot;2&quot;, &quot;icon&quot;: &quot;100&quot;, &quot;text&quot;: &quot;晴&quot;, &quot;wind360&quot;: &quot;335&quot;, &quot;windDir&quot;: &quot;西北风&quot;, &quot;windScale&quot;: &quot;3-4&quot;, &quot;windSpeed&quot;: &quot;20&quot;, &quot;humidity&quot;: &quot;11&quot;, &quot;pop&quot;: &quot;0&quot;, &quot;precip&quot;: &quot;0.0&quot;, &quot;pressure&quot;: &quot;1025&quot;, &quot;cloud&quot;: &quot;0&quot;, &quot;dew&quot;: &quot;-25&quot; &#125;,... 因此我们需要先准备好类来接收数据，并准备读取pop列表的方法。并设置方法，提取需要的数据属性。 12345678910111213141516171819202122232425//接收api逐小时数据hourly类data class HourlyData( val fxTime: String, val temp: String, val icon: String, val text: String, val wind360: String, val windDir: String, val windScale: String, val windSpeed: String, val humidity: String, val pop: String, val precip: String, val pressure: String, val cloud: String, val dew: String)//获取降雨概率方法class CityRainProbability(private val hourlyData: List&lt;HourlyData&gt;) &#123; //降雨概率 fun getHourlyPop(): List&lt;Double&gt; &#123; return hourlyData.map &#123; it.pop.toDouble() &#125; &#125;&#125; 调用API组成降雨数据遍历列表，解析读取JSON 在getRainData()中补充，遍历城市列表，请求解析完数据后，构造成city类，并存入城市降雨列表citiesRain中 12345678//获取每个城市降雨数据，先放入citiesRain中for (city in cities) &#123; val location = city.second.toString() + &quot;,&quot; + city.first.toString() println(location) val url = &quot;https://devapi.qweather.com/v7/weather/24h?location=$location&amp;key=$key&quot; println(url) readJSONData(url, city)&#125; city类，包含了经纬度信息和24小时降雨概率列表 12345//城市名称，降雨概率data class City( val latLng: LatLng, val hourlyProbabilities: List&lt;Double&gt;?) 实例化类，获取降雨数据 主要分为两步，首先请求数据 ，然后解析数据。 12345678910111213141516171819202122232425262728293031//请求数据private fun readJSONData(url: String, city: Pair&lt;Double, Double&gt;) &#123; thread &#123; try &#123; val client = OkHttpClient() val request = Request.Builder().url(url).build() val response = client.newCall(request).execute() val responseData = response.body?.string() if (responseData != null) &#123; dealRainData(responseData, city) Log.d(&quot;responseData&quot;, responseData) // println(responseData) &#125; &#125; catch (e: Exception) &#123; e.printStackTrace() &#125; &#125;&#125;//提取降雨数据private fun dealRainData(JsData: String, city: Pair&lt;Double, Double&gt;) &#123; val gson = Gson() val cityData = gson.fromJson(JsData, JsonObject::class.java) val hourlyData = gson.fromJson(cityData.getAsJsonArray(&quot;hourly&quot;), Array&lt;HourlyData&gt;::class.java).toList() val City = CityRainProbability(hourlyData) hourlyPop = City.getHourlyPop()// 获取到一个城市24小时天气数据 val hourlyRainProb = hourlyPop?.toList() val thiscity = City(LatLng(city.first, city.second), hourlyRainProb) //单个城市降雨数据 citiesRain.add(thiscity) //插入城市降雨数据列表&#125; 组成降雨数据citiesRain，是一个City类的列表 1private val citiesRain = mutableListOf&lt;City&gt;()//城市降雨数据 显示热力图和信息窗热力图帧数据构建24帧数据 提取城市列表每个城市经纬度和当前小时的降雨概率组成代表当前小时的帧数据，降雨概率作为权重 123456789101112131415161718private fun showheat() &#123; // 创建热力图数据 val builder = HeatMap.Builder() // 添加热力图数据点 //构造24帧数据 val frames = MutableList(24) &#123; mutableListOf&lt;WeightedLatLng&gt;() &#125; // 遍历每个城市 citiesRain.forEach &#123; city -&gt; val hourProbabilities = city.hourlyProbabilities // 遍历每个小时的降雨概率 hourProbabilities?.forEachIndexed &#123; index, probability -&gt; val weightedLatLng = WeightedLatLng(city.latLng, probability) frames[index].add(weightedLatLng) &#125; &#125; builder.weightedDatas(frames)&#125; 配置热力图设置帧变化动画属性，热力图半径，渐变颜色，透明度 热力图权值范围0-100 添加热力图覆盖物 12345678910111213141516171819202122private fun showheat()&#123; // 设置开始动画属性：开启初始动画，时长100毫秒，动画缓动函数类型为线性 val init = HeatMapAnimation(true, 100, HeatMapAnimation.AnimationType.Linear) // 设置帧动画属性：开启帧动画，时长10000毫秒，动画缓动函数类型为线性 val frame = HeatMapAnimation(true, 10000, HeatMapAnimation.AnimationType.Linear) builder.initAnimation(init) builder.frameAnimation(frame) // 设置热力图半径范围 builder.radius(35) // 设置热力图渐变颜色 val colors = intArrayOf( Color.rgb(255, 0, 0), Color.rgb(0, 225, 0), Color.rgb(0, 0, 200) ) builder.gradient(Gradient(colors, floatArrayOf(0.2f, 0.5f, 1.0f))) builder.maxIntensity(100.0f) builder.opacity(0.8) val heatMapData = builder.build() Log.d(&quot;showHeat&quot;, &quot;添加覆盖物&quot;) // 添加热力图覆盖物 mBaiduMap?.addHeatMap(heatMapData) mBaiduMap?.startHeatMapFrameAnimation()&#125; 进度条进度条 1234567&lt;ProgressBar\tandroid:id=&quot;@+id/determinateBar&quot;\tstyle=&quot;?android:attr/progressBarStyleHorizontal&quot;\tandroid:layout_width=&quot;match_parent&quot;\tandroid:layout_height=&quot;wrap_content&quot;\tandroid:max=&quot;24&quot;\tandroid:progress=&quot;1&quot;/&gt; 回调动态热力图帧索引，给进度条赋值，让进度条提示当前是第几帧(小时)的热力图 1234567val progressText = binding.progressText //进度条提示文字// 回调动态热力图帧索引mBaiduMap?.setOnHeatMapDrawFrameCallBack &#123; indexCallBack -&gt; // 更新进度条和帧数\tprogressBar.progress = indexCallBack\t// Log.d(&quot;帧数&quot;,indexCallBack.toString())\tprogressText.text = &quot;$indexCallBack 小时后&quot;&#125; 信息窗遍历降雨数据找最大值，记录索引和最值 12345678910111213141516171819//计算当前位置最大降雨概率private fun countRainpro() &#123; val preCity = citiesRain.firstOrNull() maxRainIndex = -1 maxRainValue = Double.MIN_VALUE preCity?.let &#123; city -&gt; val attributeList = city.hourlyProbabilities if (attributeList != null) &#123; for ((index, value) in attributeList.withIndex()) &#123; if (value &gt; maxRainValue) &#123; maxRainValue = value maxRainIndex = index &#125; &#125; &#125; &#125;&#125; 设置信息窗内容和位置 123456789101112if (maxRainValue == 0.0) &#123; //24小时内不会下雨 messageBtn.text = &quot;$preAddress 24小时内不会下雨&quot;//信息窗显示当前地址&#125; else &#123; var rat = maxRainValue.toInt() messageBtn.text = &quot;$preAddress $maxRainIndex 小时后有$rat %概率会下雨&quot;&#125;//构造InfoWindow//point 描述的位置点//-100 InfoWindow相对于point在y轴的偏移量mInfoWindow = InfoWindow(messageBtn, LatLng(preLatitude, preLongitude), -100) 监听器中使InfoWindow生效，这样子就能满足当移动地图时，信息窗能够保持在初始位置，不会乱飞。 123456789inner class MyLocationListener : BDAbstractLocationListener() &#123; override fun onReceiveLocation(location: BDLocation) &#123; ... //实时更新信息窗位置 if (mInfoWindow != null) &#123; mBaiduMap?.showInfoWindow(mInfoWindow) &#125; &#125;&#125; 遇到的问题无法在模拟器显示进行真机调试，数据线连接安卓手机，手机开启usb调试，修改编辑器运行设备为手机 异步问题协程方法&#x2F;用按钮"},{"title":"脑电笔记","path":"/2023/04/01/脑电笔记/","content":"s实验常用评估指标image-20231018192044991 背景静息态脑电一般在频域进行分析，以刻画信号的周期性特征 需要使用频谱分析来描述脑电信号功率沿频率的分布特征。 任务态脑电 通常采用时频分析——时间-频率域中分析 事件相关的频谱变化被称为事件相关同步化&#x2F;去同步化(ERS&#x2F;ERD)，通常在时间-频率域中随时间变化的频谱功率可以通过时频分析方法进行估计 频谱估计基本概念时间序列信号在某通道连续记录的脑电信号，在时间域表征为信号幅度相对于时间的变化；也可以在频率域表征为信号功率沿评论变化的分布 频率描述振荡波形在单位时间内周期获得的基本参数，单位为赫兹(Hz),即每秒一个周期 频谱时序信号的功率、幅度或相位等在频率域沿频率的分布曲线 频谱分析将时域信号变换到频域频谱的估计方法，目的是观察对应周期的频率峰值以检测信号周期性 频域和时域频域和时域是信号处理中两个重要的概念。 时域是指信号在时间轴上的变化，即信号在时间上的波形表现。时域分析可以用来研究信号的幅度、频率、相位等特征，例如我们可以通过时域分析来计算信号的均值、方差、峰值、波形形状等。 频域是指信号在频率轴上的变化，即信号在频率上的分量组成。频域分析可以用来研究信号的频率、谐波、相位等特征，例如我们可以通过频域分析来计算信号的功率谱密度、频率分布、滤波等。 在脑电信号分析中，时域和频域分析常常是同时使用的，可以用来研究不同的脑电波形态、频率特征以及它们之间的相互作用关系。例如，我们可以通过时域分析来计算脑电信号的平均值、方差、峰值等，而通过频域分析则可以计算脑电信号在不同频段的能量分布、频率成分等。 频谱图和波形图频谱图和波形图是两种不同的图像展示方式，分别用于展示信号在频域和时域的特征。 波形图是一种时域表示方法，它将信号的振幅与时间轴关联起来，用于显示信号在时间上的变化情况，通常为一条连续的曲线。波形图可以直观地反映信号的幅度、频率、相位等时域特征。 频谱图是一种频域表示方法，它将信号的振幅与频率轴关联起来，用于显示信号在不同频率下的分布情况，通常为一张二维图像。频谱图可以直观地反映信号的频率成分、频率分布情况等频域特征。 在脑电信号处理中，频谱图和波形图都有广泛的应用。例如，可以通过分析脑电信号的频谱图来研究脑电信号的频率成分和频率分布情况，进一步研究脑电信号的生理意义；而波形图则可以用于显示不同条件下脑电信号的时域变化情况，例如事件相关电位（ERP）的波形图可以直观地反映某个事件对脑电信号的影响。 ssvepSSVEP 本质是当人的眼受到外界的周期的视觉刺激时，大脑皮层枕区就会周期性的相应 交叉调制频率刺激会引起大脑皮层的周期性脑电活动，通过分析由刺激引起的脑电信号，可以识别刺激目标。根据人眼中不同椎体细胞对颜色反应不同，蓝光最强、绿光次之，红光最弱。 其中刺激信号的幅值和诱发的SSVEP信号成正比、刺激范式的频率5~12Hz所激发的 SSVEP 最强，同时随着刺激信号的频率的增加，所激发的 SSVEP 信号幅值逐渐下降。但是占空比对 SSVEP 信号的诱发规律，还不清楚。 信号处理P300p300+ssvep 潘老师P300 SD当系统开始字符输入时，每个字符以随机的次序依次闪烁60毫秒 即在某个字符闪烁结束的一段时间后，才开始闪烁下一个字符，而不是同一行（或列）的字符同时闪烁。一个round包含36次闪烁，对应36个字符。每次输出一个字符，受试者只需要注视该目标字符并默数其闪烁的次数。因此，在每个round中，目标字符的闪烁概率为1&#x2F;36，即0.028。在若干个round后，系统通过检测P300就能确定目标字符。 对于SD字符输入系统，每个字符的输入需要10个round的闪烁，每个round包含36次闪烁，因此需要21.6秒（10 × 36 × 60𝑚𝑠）。每输入一个字符后都休息4秒 其中，根据国际10-20系统的标准[66]，本章只采用视觉区“Fz”、“Cz”、“P3”、“Pz”、“P4”、 “O1”、 “Oz”与“O2”这8个通道的脑电信号。 所有电极的阻抗值皆为5𝐾Ω以下。脑电信号以250Hz的频率采样，首先在0.1至30Hz的范围内进行带通滤波，然后对滤波后的信号进行1&#x2F;5下采样。对应每个闪烁刺激，我们取每个通道中刺激开始的0-600毫秒的这一段数据，再将8个通道中处理后的数据连接成一个特征向量。 对于每位受试者，我们把所有特征向量都进行归一化化到0到1之间。这些归一化的特征向量将作为SVM分类器的输入[67]。 SSVEP我们选择4个闪烁的刺激频率5.45Hz，6.0Hz，6.67Hz和7.5Hz。这是因为（1）在5-20Hz范围内的刺激频率能更稳定地激发SSVEP[95]；（2）如果刺激频率在8-13Hz范围内，当受试者处在空闲状态时，SSVEP检测将容易受到alpha节律的影响[91]；（3）与屏幕分辨率（60Hz）成倍数关系的闪烁刺激频率（如6.0Hz或7.5Hz等）在硬件上能更准确地产生 根据实时采集的信号进行SSVEP检测，每隔500毫秒进行一次检测。首先，在3Hz至20Hz的范围内进行带通滤波。然后，我们选取6个所选通道中当前时间点的前3.2秒数据段进行SSVEP检测。因此，每两次连续的SSVEP检测中包含有2.7秒的数据是重叠的。(3.2-0.5) 使用傅立叶变换，我们计算新定义的𝑁个信号向量的功率密度谱（Power densityspectrum，PSD）。 控制状态下，受试者注视着以频率𝑓闪烁的目标键，并忽视其他闪烁频率的伪键。在这种情况下，绝大部分受试者会产生以下两种生理现象：第一，有一个明显的波峰出现在目标键闪烁频率的功率密度谱中。第二，在所有闪烁频率中，目标键的闪烁频率所产生的SSVEP能量最大。因此，我们在SSVEP检测中利用了下列的2个准则： 阈值准则: 能量比率𝛿要大于一个预设的阈值。该准则已经普遍应用于SSVEP的研究，例如[83, 90]。 比较准则：目标键频率的SSVEP能量 ^𝑃 (𝑓𝑡) 在所有的闪烁频率中是最大的。 当这2个准则同时满足，则表示系统检测到目标键产生的SSVEP。在这个时候，系统处于控制状态中，即发出“开&#x2F;关”的控制指令。 实验每一个实验Session包含两个Run 第一个Run用于设置GUI中目标键的刺激频率，因为不同的受试者在不同刺激频率下产生SSVEP电位的幅度是不一样的[97]，第一个Run包含32个trial，共需要6分钟的时间。在每个trial中，受试者需要注视GUI中的一个闪烁按钮10秒钟（由屏幕中的箭头来指示）。在32个trial中，4个闪烁按钮的次序由系统随机产生的，每个闪烁按钮将被标示8次。响应最大的设为目标键，其他是伪键 p300+ssvep本实验只采用“Fz”、“Cz”、“P7”、“P3”、“Pz”、“P4”、“P8”、“O1”、“Oz”与“O2”这10个通道的脑电信号。所有电极的阻抗值皆为5𝐾Ω以下。脑电信号以250Hz的频率采样，并在0.1至30Hz的范围内进行带通滤波。 四组按钮中的四个大按钮分别以随机的顺序闪烁（形状变为方形，颜色变为绿色），每两次闪烁之间包含100ms的增强和100ms的间隔。因此，一个round包含四个大按钮的闪烁，共需要持续800ms（一个round被定义为每个大按钮闪烁一次的完整周期） image-20230402145312464 也就是小圈跟大圈固定频率黑到红闪，每隔100ms有一个随机的增强，即大按钮变为绿色方形，持续100ms 检测P300检测是每800毫秒(1round)进行一次，对应一轮所有按钮组的闪烁 ssvep检测是每200毫秒进行一次,我们选取8个通道中当前时间点的前3.2秒数据单元（3.2X250Hz，800数据点）进行SSVEP检测。 实验8位来自本实验室的20～33岁的健康受试者参加了3个实验，包括1个离线实验和2个在线实验。在实验之前，每位受试者参加一个包括30个trial的Session，采用如图4-2所示的GUI进行P300模型的训练。特别地，在每一个trial中，所有4组按钮中的大按钮以随机次序闪烁，每个大按钮闪烁10次。同一时刻，受试者要求注视着给定的目标按钮。收集的数据用于构建一个P300分类模型，用于后面3个实验。 进行3个Session，每 一个Session由80个trial组成 image-20230402145429594 P300+ssvep 薛仲林P300 电位检测：首先将采集 P300 信号进行带通滤波，其中通带频率为 0.1− 10Hz，然后进行 200 降采样，即每 5 个数据点选 1 个。提取每个导联的在脑电范式刺激范式后800毫秒的P300脑电数据，将8个导联脑电数据归一限制到[-1,1]之内，将 8 个导联脑电数据归一化数据特征向量，组成一个脑电数据特征向量矩阵。 每个被试人员均进行 6 次实验，一次实验输入 5 个目标字符，共输入字符30 个。在每两次实验之后被试人员休息 2 分钟，其中每次实验定义为一个 session，每输入一个目标字符为一个 run，每一个字符闪烁为trial，其中包含受试人员目标字符定义为一个 target，不包含受试人员的目标字符为 nontargat。此外依次从左到右定义行列闪烁 trail 编号为 136，共 36trial。136 号 trail 有且仅有一个target，35 个nontargat。36 个 trail 随机闪烁一次为一个 sequence。15 个sequence为一个 run，完成一个字符输入如下图 2.9 所示。 image-20230402153653507 p300+ssvep为了将SSVEP频带与P300频带分离，以0.2Hz的步长选择12个高于12Hz的闪烁频率，从12.4到14.6Hz。根据 [35]，可以通过模拟方法对40个频率 (范围从8hz到15.8Hz，步长为0.2Hz) 的任何刺激相位的ssvep进行模拟，其中涵盖了该实验的所有刺激频率。因此，通过使用具有200ms的刺激持续时间的模拟方法在公共SSVEP数据集上搜索JFPM方法的相位间隔 (从0到0.05 π) 来优化初始相位，从而在两个相邻频率之间产生0.35 π 的相位间隔。 传统方法SSVEPTRCA提取任务相关成分虽然基于CCA的方法在识别SSVEP信号方面具有不错的表现,但这类方法的性能仍旧易受到自发脑电活动的干扰的影响。除此之外,研究人员们考虑到基于CCA的方法还有一个很大的问题,即没有利用到相位信息(参考信号中正余弦中没有包含相位项)。那么如果能够有效地利用相位信息,想必会给SSVEP的识别性能带来较大的提升。 由此研究人员便提出了TRCA方法,TRCA的方法即通过最大化每个task中神经影像数据的复现性(reproducibility),提取任务相关成分(task-related com-ponents)。对于SSVEP这种锁时(time-locked)信号,该方法非常合适,因为在SSVEP中可以最大化多个trial之间的可再现性,提高SNR(Signal-to-Noise),抑制自发脑电活动。 (279条消息) 提取任务相关成分的TRCA算法_Ethan Hunt丶的博客-CSDN博客 在离线实验中，受试者进行模拟在线实验以记录数据以进行离线分析。实验由12个块组成。在每个块中，要求受试者凝视视觉刺激之一0.5 s，并完成对应于所有40个刺激的40个试验。每次试验都以刺激程序产生的指示目标刺激的视觉提示 (红色方块) 开始。提示在屏幕上出现了0.5秒。指示每个受试者在提示持续时间内尽快将视线转移到目标上。此后，所有刺激在监视器上同时闪烁0.5 s。为了减少眼球运动伪影，要求受试者在刺激期间避免眨眼。为了避免视觉乏力，在两个连续的block之间休息了几分钟。首先根据事件触发提取包含九通道ssvep的数据时期。将所有数据阶段下采样到250Hz，然后用IIR滤波器从7 hz到90Hz进行带通滤波。使用MATLAB中的filtfilt() 函数实现了零相位正向和反向滤波。考虑到视觉路径中的潜伏期延迟，在 [0.14 s] 中提取数据时期，其中时间0表示刺激开始，并且在离线分析中使用了数据长度。 训练阶段包括12个区块，每个区块包括40个试验。在此阶段获取的数据在测试阶段用作单独的训练数据。提示引导选择任务的测试阶段包括5个块，每个块还包括40个试验。每个试验持续0.8 s，包括0.3 s用于视觉刺激和0.5 s用于视线转移。下一个目标的提示出现在刺激偏移之后。实时向受试者提供视觉和听觉反馈。在线分析程序正确识别目标后，发出一声短促的哔哔声。同时，在屏幕顶部的文本输入字段中键入目标字符。 一个多通道的EEG信号由任务相关性成分si和任务无关的信号ni组成，任务相关部分在trial之间保持着不变性，而任务无关部分在trial之间是变化的。si之间的协方差为一正常数,si与ni之间的协方差为0 我们希望能够提取到任务相关成分s(t)，以增大信噪比。 首先将多通道的EEG信号加权求和，表示为一个线性模型y(t)，为了使得y(t)&#x3D;&#x3D;s(t)，就必须使每个通道相关成分的加权求和结果为1，无关成分加权求和结果为0。如果我们得到了这样的一个解，那么多通道的EEG信号经过线性加权求和后，便能够得到在多个trial之间具有高度相关性的y(t)。 原本trial(颜色片段)之间变化较大的N通道EEG信号，经过处理后得到的y ( t ) y*(t)在trial之间相关性较高。空间滤波器表示为W&#x3D;[W1,W2,..]，上述这一过程表示为Y&#x3D;WTX，X表示原本trials各通道的信号xi(t) 空间滤波器 于是，问题的重点就来到了如何求解出空间滤波器W，这里给出了两种方法，分别是： 协方差最大化(CovMax) 相关性最大化(CorrMax) 相关性最大化CorrMax 通过皮尔逊相关系数，求解来自k-th trial和来自I-th trial的EEG信号xk(t)和xl(t)相关性，然后找到所有trial可能的组合中使相关系数之和最大的解，然而这种结果只是一个相关性成分，不是封闭解，也就是说不能求出问题的解，因此需要用最大化trial之间的协方差 协方差最大化CovMax 和CorrMax不同的仅是将trial之间相关系数的求解变为计算协方差矩阵 多个trial之间的协方差之和为目标函数$$\\sum_{k,l&#x3D;1,k≠l}^K{\\hat{c}{kl}&#x3D;}\\sum{k,l&#x3D;1,k≠l}^K{Cov\\left( y^{\\left( k \\right)}\\left( t \\right) ,y^{\\left( l \\right)}\\left( t \\right) \\right) &#x3D;}\\sum_{k,l&#x3D;1,k≠l}^K{\\sum_{i,j&#x3D;1}^N{w_iw_jCov\\left( x_{i}^{\\left( k \\right)}\\left( t \\right) ,x_{j}^{\\left( k \\right)}\\left( t \\right) \\right) &#x3D;w^TSw}}$$$$\\text{其中,对称矩阵}S_{ij}&#x3D;\\sum_{k,l&#x3D;1,k≠l}^K{Cov\\left( x_{i}^{\\left( k \\right)}\\left( t \\right) ,x_{j}^{\\left( l \\right)}\\left( t \\right) \\right)}$$ 为了获得有限解，我们使y(t)的方差进行约束，归一化到1$$Var\\left( y\\left( t \\right) \\right) &#x3D;\\sum_{i,j&#x3D;1}^{N_c}{w_iw_jCov\\left( x_i\\left( t \\right) ,x_j\\left( t \\right) \\right) &#x3D;w^TQw&#x3D;1,}$$$$\\text{其中，}Q&#x3D;Cov\\left( x_i\\left( t \\right) ,x_j\\left( t \\right) \\right)$$ 这里Q应该是对于每一个y(t)进行的操作, 然后，我们的约束优化问题转变为Rayleigh–Ritz特征值问题最佳的系数向量W通过求解Q-1S的特征向量得到。其特征向量为一Nc维的向量矩阵，每一维对应一特征值，并且按特征值大小降序排序，特征值的大小表示了按其对应的特征向量对信号进行空间滤波后，y(t)在trial之间的任务相关性(task consistency)。 总结 总结一下，这个分类方法的核心就是TRCA，提取任务相关性分析，如何提取相关性成分成为了关键点。 简化流程就是：对于多个通道的信号，通过空间滤波器，得到任务相关性成分 这里我们复习一下线代乘法基础知识 空间滤波器就是各个通道对于权值的一个数组(一维矩阵)，假设为空间滤波器:$$W&#x3D;\\left( \\begin{array}{c} w_1\\ \\vdots\\ w_{Nc}\\\\end{array} \\right)$$W&#x3D;(w1,w2,…)，而多个通道的信号表示为:$$X&#x3D;\\left( \\begin{matrix} 3.1&amp; …&amp; 7\\ \\vdots&amp; \\vdots&amp; \\vdots\\ 5.9&amp; \\cdots&amp; 8.3\\\\end{matrix} \\right),每一行表示这一通道的采样点数值$$用公式表示就是Y&#x3D;WTX。 而求解空间滤波器就利用到协方差矩阵。将每次trials之间(不包括自己)求解一次协方差矩阵 协方差 在统计学中，给定 $n$ 个观测样本的 $m$ 个随机变量 $X_1, X_2, \\dots, X_m$，我们可以使用 $n \\times m$ 的数据矩阵 $X$ 来表示这些样本。矩阵 $X$ 的每一行表示一个观测样本，每一列表示一个随机变量。假设 $X$ 的每一列的均值为 $0$，则其协方差矩阵 $C$ 的第 $i,j$ 个元素可以表示为：$$Ci,j=1n−1∑k=1n(Xk,i−Xiˉ)(Xk,j−Xjˉ)C_{i,j} &#x3D; \\frac{1}{n-1}\\sum_{k&#x3D;1}^n (X_{k,i} - \\bar{X_i})(X_{k,j} - \\bar{X_j})Ci,j​=n−11​∑k=1n​(Xk,i​−Xi​ˉ​)(Xk,j​−Xj​ˉ​)$$ 其中，$\\bar{X_i}$ 表示 $X$ 的第 $i$ 列的均值，即第 $i$ 个随机变量的均值。上式可以改写为矩阵形式：$$C=1n−1(X−Xˉ)T(X−Xˉ)C &#x3D; \\frac{1}{n-1} (X - \\bar{X})^T (X - \\bar{X})C=n−11​(X−Xˉ)T(X−Xˉ)$$ 其中，$\\bar{X}$ 是一个 $1 \\times m$ 的向量，表示每个随机变量的均值，$(X - \\bar{X})$ 表示去均值化后的数据矩阵，$(X - \\bar{X})^T$ 表示其转置矩阵。因此，协方差矩阵可以看作是去均值化的数据矩阵的转置矩阵与去均值化的数据矩阵之积的标准化。 当数据矩阵 $X$ 中的每一行表示一个观测样本时，$X$ 的每一列表示一个随机变量的均值可以通过对 $X$ 按列求平均得到。在这种情况下，上式可以改写为：$$C=1n−1(X−xˉ)T(X−xˉ)C &#x3D; \\frac{1}{n-1} (X - \\bar{x})^T (X - \\bar{x})C=n−11​(X−xˉ)T(X−xˉ)$$ 其中，$\\bar{x}$ 是一个 $1 \\times n$ 的向量，表示每个观测样本的均值。在这种情况下，协方差矩阵可以看作是去均值化的观测样本数据矩阵的转置矩阵与去均值化的观测样本数据矩阵之积的标准化。 因此，我们可以得出结论，将去均值化的数据矩阵的转置矩阵与去均值化的数据矩阵之积除以 $n-1$，就可以得到协方差矩阵。这也是为什么可以通过两个矩阵相乘来计算协方差矩阵的原因。 深度学习方法深度学习和机器学习image-20230401234449494 机器学习特征通常需要手动设计，分类器需要手动选择，随着数据增大而收敛，停滞不前 深度学习，端到端，给一个网络数据和任务，特征提取和建模步骤都是自动完成的，随着数据变大而扩展，越来越好 迁移学习加载预训练的网络，比如一个Alexnet能输出1000个分类，如果我们实际只需要4分类，那么可以替换掉最后几层来加快学习 比从空白开始训练省时省力 image-20230401234757051 image-20230401234810906 两种方法时频域1.将时域信号转换为时频域表示形式，并训练卷积神经网络，直接从这些时频表示中提取模式。 image-20230401233434429 时频表示，描述了信号中的频谱成分如何随时间的变化而变化，增强了可能不可见的模式 方法将信号从时频表示保存为图像的技术，有： 频谱图，spectrogram 梅尔频谱图 连续小波变换，scalogram或尺度图 常数Q变化，constant Q 直接输入直接将信号输入神经网络进行训练，如lstm 为了加快速度，一般需要进行降采样，在matlab中可以使用invariant scattering convolutional network不变散射卷积网络来自动提取特征，获得提供低波动表示的特征，而不会丢失关键信息 小波变换两个基本概念缩放是指及时拉伸或收缩信号的过程 利用尺度图处理信号步骤：将信号进行时频变换，输入神经网络进行训练；对于信号先进行时频表示然后用训练好的模型进行预测 降采样Python脑电数据处理EEG-深度学习建模_哔哩哔哩_bilibili lstm，提取12个特征，它数据有pos和neg两个阶段，已经标好label 要分析多少赫兹的信号就将采样到它的两倍 image-20230402005247706 滤了1-100.功率频谱图100之后骤降 image-20230402005339811 将功率谱密度图转为numpy array格式 image-20230402005509859 计算面积值 注意换算，比如取300ms的值，采样率对应出来的numpy array是多少到多少 预处理滑动时间窗分类方法原始数据特征算法原始数据特征的卷积神经网络分类算法由 robin 提出，该算法提取的特征是初始脑电信号中的时空特征。时空特征的提取主要是基于滑动时间窗方法，在每一个 7.5s 的试验中，选用 4s 的运动想象时间，滑动窗口的长度设为 2s，时窗步进为 0.1s，每一次试验产生 21个时间窗，总共产生 6048（288*21）个短时域信号图作为训练样本。该方法的分类器是VGGnet 的卷积神经网络（CNN） 这种原始数据特征算法具有两个优势，第一是数据预处理简单，对时序信号进行裁剪，并且相邻时间窗之间重叠率高，边缘信息对分类精度的影响较低。第二是易与 CNN 分类器结合，裁剪后生成的样本图可以作为二维图片输入 CNN 中进行训练分类。 缺点包含两点，第一点是时序特征的实质是信号波形，实验数据采集过程中被试者的脑区状态对于特征的影响较大，算法可靠性较低，不同被试的分类效果差异较大。第二点是网络参数较大，以 2s 的时间窗为例，采样频率为 250Hz，则时间窗的时间点长度为 500（250*2），远大于相同信号的频域长度（脑电信号一般在 50Hz 左右），因此需要多次迭代训练。 平行多层感知网络算法平行多层感知网络（MLP）网络提取的是能量特征，包括静态能量特征和动态能量特征。如下图所示，标准的 MLP 网络用于分类静态能量，结合 MLP 层和 CNN（卷积层+池化层+全连接层）的结构用于分类动态能量，在两个并行网络的输出端是最大池化层，起到筛选识别分类的作用，选取两个网络识别的较大概率，对脑电信号分类作出判别（类似于数学中的 argmax 函数）。 image-20230402095023714 MLP 算法应用的网络结构相对简单，并没有过多的层数堆积，因此实际的分类时间相对较短，同时并行网络的优点是在保留卷积神经网络权值共享特点的基础上，实现更有针对性的特征提取和分类。 并行的神经网络处理架构是新兴的脑电处理思想之一，徐高伟[25]提出的方法是在脑电分类中，设置并行的 RNN 网络，一路为训练完毕网络，一路为训练网络（网络结构相同），在训练过程中完成模型的迁移和修正。而平行多层感知网络虽然具备并行网络并行取优的特点，但是仅把初始信号划分为动态能量和静态能量，缺乏可靠的数据预处理环节，导致数据分类准确率不高。并行网络的结构更适合与迁移学习或监督学习的方法结合，搭配合理高效的数据预处理环节，构建学习能力更强的脑电信号分类框架。 黎曼几何与支持向量机算法黎曼几何与支持向量机算法是目前对于四分类脑电信号识别效果最好的方法之一（M. Hersche, T. Rellstab, P. D. Schiavone, L. Cavigelli, L.Benini, and A. Rahimi. Fastand accurate multiclass inference for mi-bcis using large multiscale temporal and spectralfeatures[C]. in 2018 26th European Signal Processing Conference (EUSIPCO), 2018, 1690-1694） 多尺度 CSP 算法多尺度 CSP 算法也是提取的多尺度特征，包括时间，频率和空间特征 CNN SSVEP Using variable natural environment brain-computer interface stimuli for real-time humanoid robot navigation. 在离线实验期间，受试者会固定在闪烁的刺激之一上。每个SSVEP类收集来自每个受试者的皮层大脑信号进行40个实验试验，以形成离线先验训练集或训练每个受试者的CNN模型 (离线校准)。 image-20230402010906679 我们使用离线先验实验数据集训练SSVEP卷积单元 (SCU) CNN架构 [17]，包括一维卷积层、批归一化和最大池化 (如图4所示)。我们首先对9至100Hz之间的输入信号进行带通滤波，以减少在这项工作中不感兴趣的不期望的高频或低频。通过使用大型初始卷积滤波器来捕获由九个输入通道组成的滤波信号，以捕获我们对干EEG数据进行分类感兴趣的频率。SCU CNN模型使用具有随机梯度下降的反向传播进行训练 [24]。对于此训练，最初通过网格搜索在验证集上选择的关键超参数是L2权重衰减缩放0.004，dropout级别0.5，卷积内核大小1 × 10，内核步长4，maxpool内核大小2，分类交叉熵作为优化函数，ADAM梯度下降算法 [25] 和remu作为所有隐藏层上的激活函数。 MFCNN用于稳态视觉诱发电位目标识别的多尺度特征融合卷积神经网络方法 - 中国知网 (cnki.net) 将SSVEP信号数据转化为二维时频图像作为输入，基于MFCNN模型框架有效提取目标信号多尺度级联特征，实现SSVEP信号目标自适应特征提取及端到端识别。 时频化处理由于SSVEP信号的非平稳、非线性、时变特性[18],传统的时域或者频域分析方法具有信号处理的不确定性，谱分析无法反映各个频段能量随时间的变化情况，也不能完整地表达信号的特征参数。小波变换在传统傅里叶变换基础上，引入尺度和时间变量来分析信号的不同频率成分，同时提供时域和频域的信息特征[19],适合处理短时间内的突变信号。因此，本文利用小波变换对SSVEP信号进行时频化图像处理，将时频域特征生成时频图，以不同颜色分布表征不同类别的信号差异，如下式 神经网络构建小波变换将SSVEP信号转化成频率-时间-小波系数图(时频图),不同颜色分布的图像作为输入，利用CNN进一步提取图像特征进行学习并分类。 目标识别首先，采集受试者在不同闪烁目标刺激下的多通道SSVEP信号，经过预处理整合后输入至网络模型中，利用小波变换构造SSVEP信号为二维时频图像样本集 随机选取数据集的70%为训练集对MFCNN模型进行训练，30%为测试集 image-20230402011721328 实验实验开始时，受试者有２ｓ的 （ａ）实验时序图 （ｂ）实验场景图 图４ 实验时序图与场景图 image-20230402213147265 2s静息准 备 时 间，当 ＰＣ 机 提 示 音 响 起，正 式 开 始 闪烁，重复２０次为一轮，单次刺激目标的呈现时间为４ｓ，随后提示音响起闪烁停止，受试者间隔休息２ｓ后再次进行下一次闪烁，每个刺激目标呈现３轮，轮与轮之间也给予受试者充足的休息时间。 卷积预处理(滑动时间窗，原数据少，避免过拟合)–功率谱特征提取PSD 我们选用功率谱密度（PSD）作为网络的输入特征。选用原因包含以下两点；第一，前文提到了为了降低信号分类中的个体差异影响，在数据预处理阶段首先利用 DWT 分析不同被试关于运动想象任务的频率分布情况，PSD 生成特征图横轴即为频率轴，可以和数据预处理做有效整合。第二，数据预处理部分的滑动时间窗方法，程序实现过程中是基于python 的 epoch 实现的，PSD 特征图可以伴随 epoch 生成，与数据准备环节做有效的衔接，没有窗口信号的多余操作，直接进行变换域处理，保证了特征图的有效性和稳定性。 本实验选用的是 Welch 方法[53]生成 PSD 特征图，该方法也是采用了信号的滑窗处理方法，并利用快速傅里叶变换（FFT）计算信号能量分布。 CNN+LSTMimage-20230402113108116 EEG系统以2048年Hz的采样率收集。放置八个Ag&#x2F;AgCl电极PO7，PO3，POZ，PO4，PO8，O1，Oz和O2覆盖枕区。对于每个受试者，他们参加了15个模块的实验。每个块包含12个试验，对应于以随机顺序生成的所有12个刺激。每次试验持续5 s，分别包括1 s的提示期和4 s的目标刺激。总共收集了180个试验。 前景image-20230423203429043"},{"title":"AR开发-空间定位点与SLAM","path":"/2023/03/13/AR开发-空间定位点/","content":"在基于单目的摄像头的AR技术中，特征点（Feature）是最通用的一项技术手段，通过匹配不同帧图像之间特征点的对应关系，我们才能够准确计算相机的运动，从而恢复环境三维结构。特征点相关算法很多，在移动端，为了提高计算效率，倾向使用ORB和Freak，比如SLAM中我们就使用了ORB特征，Marker Tracking中我们使用了Freak特征；而类似SIFT这种，匹配精度高，但是运算效率低，一般用于SFM这类技术中。使用特征点的好处在于，特征具有良好的尺度不变形、方向不变形和光照不变形等特性，匹配结果较为鲁棒。光流法（Optical Flow）是相对于特征点的另一类跟踪相机运动的方法，它的基本原理是不去计算特征点以及特征描述子，而是直接使用像素块进行匹配，提高了运算效率，而其缺点是光流法只适合匹配相邻的两帧图像来计算运动变化，它要求光强度守恒（Brightness Consistency），所以无法用于重定位等技术实现。 空间定位点空间定位点表示系统随时间跟踪的世界上的重要点。 每个定位点都有可调整的坐标系统（基于其他定位点或参照系），以确保锚定的全息影像保持位置精确。 在定位点的坐标系统中渲染全息影像可以在任何给定时间为你提供最准确的全息影像定位。 这是以不断对全息影像的位置进行小的调整为代价的，因为系统不断地将其移回到基于现实世界的位置。 ARFoundation中的参考点（Reference Point）与ARCore中的Anchor其实是同一概念，锚点的原意是指不让船舶飘移的固定锚，这里用来指将虚拟物体固定在 AR 空间上的一种技术。由于跟踪使用的陀螺仪传感器的特性，误差会随着时间积累，所以需要通过图像检测等来对误差进行修正，此时，如果已存在于空间上的对象不同步进行校正则会出现偏差，锚点的功能即是绑定虚拟物体与 AR 空间位置。被赋予 Anchor 的对象将被视为固定在空间上的特定位置，并自动进行位置校正，锚点可以 确保物体在空间中看起来保持相同的位置和方向，让虚拟物体在 AR 场景中看起来待在原地不动。 参考点的工作原理如下：AR 应用中，摄像头和虚拟物体在现实世界空间中的位置会在帧与帧之间更新，即虚拟物体在现实世界 空间中的姿态每帧都会更新，由于陀螺仪传感器的误差积累，虚拟物体会出现飘移现象，为解决这个问题， 我们需要使用一个参考点将虚拟对象固定在现实空间中，如前所述，这个参考点姿态信息的偏差必须要能用某种方式消除以确保参考点的姿态不会随着时间而发生变化。消除这个偏差的就是视觉校准技术，通过视觉校准能让参考点保持相同的位置与方向，这样，连接到该参考点的虚拟对象也就不会出现飘移。一个参考点上可以 连接一个或多个虚拟对象，参考点和连接到它上面的物体看起来会待在它们在现实世界中的放置位置，随着参考点姿态在每帧中进行调整以适应现实世界空间更新，参考点也将相应地更新物体的姿态，确保这些物体能 够保持它们的相对位置和方向，即使在参考点姿态调整的情况下也能如此，有了参考点，连接到参考点上的虚拟对象就像是固定在现实世界空间中一样。 SLAMSLAM (simultaneous localization and mapping),也称为CML (Concurrent Mapping and Localization), 即时定位与地图构建，或并发建图与定位。 Position_Structure 坐标叠加我们需要把虚拟坐标和现实世界的坐标进行叠加。我们现在接触虚拟信息的方式，无论是电脑、平板还是手机，都是通过屏幕，这样我们感受到的信息其实是2D的。而真实环境的坐标系是3D的，所以，如果我们要让虚拟信息与真实环境无缝融合，首先要做的就是叠加虚拟坐标系与真实坐标系。 几何物理信息交互真实环境中有高低起伏、有障碍物、有遮挡关系，AR可以让虚拟信息跟这些真实环境中的物理信息进行交互。 语义理解随着机器学习和深度学习的发展，虚拟信息可以“理解”真实世界，让二者的融合更趋于自然。上面两步是我们目前已经实现了的技术。未来我们要做的，是语义理解。语义理解加上之前的坐标叠加和交互，我们就可以实现科幻电影般的效果。 (265条消息) 一文彻底搞懂SLAM技术_小麦大叔的博客-CSDN博客 平面检测SLAM构建出了3D点云地图，并估计出了Camera Pose，然而对于AR应用，还无法确定3D模型的摆放位置。比如我们需要在桌面上摆放一个花瓶，我们还需要知道在3D点云地图中，桌面对应的位置，这就需要上面流程图里提到的平面检测。转换为一个数学问题描述：在空间中我们有一系列的点P，并给出一个方向向量 D ，求一个法向量平行于D 的平面并使得所有的点距离该平面的距离之和最小。这是一个非常典型的最小二乘估计问题，因此可以利用已有的数学工具求解，如高斯牛顿，LM算法，SVD分解等等。如果是检测水平面，其中D 是根据重力传感器得到的竖直方向，即平面的法向量方向得以确定； Marker+SLAMSLAM初始化建立的点云世界坐标系是随机的，对于单目SLAM，scale信息是无法确定的，即无法确定点云世界坐标和真实尺寸的比例。在某些情况下，AR应用希望能够和真实的尺寸一一对应，在这种情况下我们提出了利用Marker作为SLAM的初始地图的方法。通过一个事先确定的Marker，建立一个已知scale信息的世界坐标系，在此坐标系的基础上通过SLAM跟踪并扩张地图，那么在叠加3D模型时就可以安装其真实尺寸展示。算法上的区别就在于SLAM首先要去识别Marker，而不是自己去初始化地图，识别Marker的方法也可以借鉴Marker Tracking的相关技术。 SLAM+AR 技术与应用的一些思考-阿里云开发者社区 (aliyun.com) EasyAR运动跟踪的工作原理运动跟踪通过视觉惯性同步定位和建图（VISLAM）技术，计算设备相对于真实空间的位姿关系。在设备移动过程中，通过识别相机图像中显著特征点并跟踪其位置变化，结合设备的IMU数据信息，实时计算当前设备相对于真实世界的位置和姿态。 真实尺度 利用设备的惯导传感器和相机图像数据融合，恢复真实物理尺度，位置的单位是米。 鲁棒准确的运动跟踪 VISLAM算法相比纯视觉SLAM能极大降低长时间跟踪的漂移，且对于光照变化、弱纹理区域和动态物体等更鲁棒。 快速初始化 只需要相机对着应用场景横移1-2次即可实现初始化。初始化完成时的位置定义为世界坐标系的原点，根据重力方向和屏幕朝向，将初始化姿态朝向屏幕。初始化完成后自动开启位姿跟踪。 快速重定位 在设备跟踪丢失后&#x2F;跟踪不佳后快速准确地恢复设备相对于世界坐标系的位姿，重定位前后世界坐标系原点不变，保证跟踪的持续性和准确性。在初始化区域附近具有位姿校正能力从而消除长距离运动产生的累计误差。 点击碰撞 支持点击当前视野内的点云或者水平面。 锚点 当放置虚拟物体时，可以使用锚点确保虚拟物体锚定在特定的区域内，使设备移动中也能保持虚拟物体的稳定。这意味着，即便位姿出现了偏差，虚拟物体也会看起来位于原始放置的位置。你可以调用接口hitTestAgainstPointCloud实现Anchor的创建,每次调用接口hitTestAgainstPointCloud就会自动创建一个Anchor。当Anchors太多而超出内存限制就会自动把老的Anchors释放掉。 你也可以在调用hitTestAgainstHorizontalPlane后调用hitTestAgainstPointCloud为平面创建Anchor. EasyAR 稀疏空间地图功能简介EasyAR 稀疏空间地图( [Sparse Spatial Map](https://help.easyar.cn/EasyAR Sense&#x2F;v4_1&#x2F;ApiReference&#x2F;SparseSpatialMap.html) )用于扫描用户周围环境，生成环境的三维视觉地图，并提供视觉定位跟踪功能。 建立的视觉地图可以 [保存](https://help.easyar.cn/EasyAR Sense&#x2F;v4_1&#x2F;ApiReference&#x2F;SparseSpatialMap.html#savemap) 或多个设备间实时共享。当其他设备加载相应地图，并在加载地图中通过 [定位](https://help.easyar.cn/EasyAR Sense&#x2F;v4_1&#x2F;ApiReference&#x2F;SparseSpatialMap.html#startlocalization) 确定设备相对于地图的位置和姿态，适用于开发持久化AR应用或多人互动AR应用。 EasyAR 稀疏空间地图支持 [加载](https://help.easyar.cn/EasyAR Sense&#x2F;v4_1&#x2F;ApiReference&#x2F;SparseSpatialMap.html#loadmap) 多个地图，在多个地图中定位并返回对应地图的ID和设备相对于该地图的位置和姿态。 稀疏空间地图目前需要稳定的运动跟踪系统(例如EasyAR Motion Tracking &#x2F; ARCore &#x2F; ARKit)提供六自由度的位置和姿态用于建图以及定位成功后的持续跟踪。在建图过程中，稀疏空间地图利用相机图像和对应位姿构建环境1：1的视觉地图。定位过程中，当视觉定位成功后，设备相对地图的位姿通过运动跟踪系统持续更新。 稀疏空间地图建图通过扫描环境并构建三维环境点云，每一个三维点都记录周围的局部视觉信息。定位过程通过将当前相机图像和地图的三维点进行视觉匹配并尝试计算对应位姿来恢复相应的位姿 怎么往稀疏空间添加物体？在ImageTarget下生成物体后，再新建一个物体，赋值这个物体的坐标和欧拉角度，设置父节点为SpatialMap的对象"},{"title":"AR开发-跟踪定位","path":"/2023/02/27/AR开发-跟踪定位/","content":"213213手机背面是Z轴正方向 开始跟踪的点即是坐标原点"},{"title":"数据分析笔记","path":"/2023/02/09/数据分析笔记/","content":"matplotlibimage.png numpy数据分析day02总结.png pandas1.Series 一维，带标签数组 2.DataFrame 二维，Series容器 loc函数：通过行索引 “Index” 中的具体值来取行数据（如取”Index”为”A”的行） iloc函数：通过行号来取行数据（如取第二行的数据） image.png day05总结.png"},{"title":"Linux笔记","path":"/2023/01/02/Linux笔记/","content":"第一课什么是LInux? Linux是一种操作系统 1991年10月，Linux Torvalds发布第一个公开版内核 image-20220907104545952.png Linux目录结构image-20220907104056459.png image-20220907104116027.png**/ linux 文件系统的起点，linux 所有的文件都放在其中。** &#x2F;bin 存放二进制可执行文件，常用命令一般都在这里 &#x2F;etc 存放系统管理和配置文件 &#x2F;home 存放所有普通用户的家目录 &#x2F;usr 存放系统应用程序 &#x2F;opt 额外安装的可选应用程序包所放置的位置。比如，我们可以把 tomcat 等都 安装到这里 &#x2F;proc 虚拟文件系统目录，是系统内存的映射，相当于是存储内存中的信息 &#x2F;root 管理员的家目录 &#x2F;sbin 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用 的系统级别的管理命令和程序。如 ifconfig 等 &#x2F;dev 用于存放硬盘、键盘、鼠标、光驱等各种设备文件 &#x2F;mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂 载其他的文件系统 &#x2F;boot 存放用于系统引导时使用的各种文件 &#x2F;lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 &#x2F;tmp 用于存放各种临时文件 &#x2F;var 用于存放各种服务的日志文件、系统启动日志等 第二课查看及切换目录“三剑客”高级使用 pwd — Print Working Directory – 用途:查看当前工作目录 cd — Change Directory 用途:切换工作目录 格式:cd [目标文件夹位置] 绝对路径与相对路径 绝对路径：以根目录(&#x2F;)起始的路径 相对路径：以当前路径为参照的路径 12[root@zrj pki]# cd /etc/pki/CA/ #绝对路径(以根为起始)[root@zrj pki]# cd CA/ #相对路径(相对于当前目录/etc/pki) . 表示当前目录 .. 表示父目录(也就是上一级目录) 12[root@zrj CA]# cd .. #返回上一级目录[root@zrj /]# pwd #当切到根以后无法再返回上一级（linux 系统以根为起始的） ls列出目录内容&#x2F;文件属性ls列出目录内容&#x2F;文件属性– -l：以长格式显示（显示详细属性） – -A：包括名称以 . 开头的隐藏文档 – -d：显示目录本身(而不是内容)的属性 – -h：提供易读的容量单位(K、M)等 – -R：递归显示内容 1ls -lh /etc/passwd #显示详细属性并加上易读单位(K) 不加-h就是默认以字节为单位,理解为human给人看的 查详细属性 1ls -lhd 目录或文件 创建&#x2F;删除&#x2F;移动目录别名123alias #查看别名列表alias hn=&#x27;hostname&#x27; #命名别名,等号左边不要有空格unalias hn #删除别名 创建 mkdir–Make Directory 删除 rm–Remove -r：递归删除 -f：强制删除 移动 mv–Move 12mv /opt/susu /opt/yiyi #改名 换个地方换个名 cp也可以mv /opt/susu/ /opt/ #移动susu文件夹下的内容，/opt/susu则是表示移动文件夹 复制与通配符cp复制 cp–Copy -r：递归复制整个目录 -f：强制覆盖，不提示 -p：保持源文件属性不变 强制覆盖临时取消别名：在运行命令前，加上 \\ 123cp -r /boot/ /opt/ #递归复制每复制一个就询问一遍，输入y，文件太多时怎么处理呢？#alias查看别名是发现 cp=&#x27;cp -i&#x27; 复制时及使用cp -rf也是会询问 因为-i优先级高于-f\\cp -r /boot/ /opt/ #用\\临时取消别名 复制多个永远把最后一个参数作为目标，其他的所有参数都作为源 1cp -r /boot/ /home/ /etc/passwd /mnt/ #将/boot/ /home/复制到/mnt目录下 通配符 *任意多个字符 ？单个字符 ‘*tab’以tab结尾 ‘tab*‘以tab开头 1ls /boot/vm* #显示以vm开头数据 特殊字符 [a-z]：多个字符或连续范围中的一个，若无则忽略 {a,min,xy}：多组不同的字符串，全匹配 12345678910[redhat@localhost ~]$ touch tty3[redhat@localhost ~]$ touch tty4 #新创建两个tty3,tty4[redhat@localhost ~]$ ls tty[3-8]#连续范围tty3 tty4 #只会找到符合的[redhat@localhost ~]$ ls tty&#123;3,4,5,6,7,8&#125;#多组条件ls: 无法访问&#x27;tty5&#x27;: 没有那个文件或目录ls: 无法访问&#x27;tty6&#x27;: 没有那个文件或目录ls: 无法访问&#x27;tty7&#x27;: 没有那个文件或目录ls: 无法访问&#x27;tty8&#x27;: 没有那个文件或目录#找不到符合的会提示tty3 tty4 重定向与管道操作 &gt;：覆盖重定向 &gt;&gt;：追加重定向 将屏幕显示信息写入文件命令 &gt; file 覆盖 命令&gt;&gt; file 追加 1234567891011[redhat@localhost ~]$ touch redhat.txt #创建一个文件[redhat@localhost ~]$ echo &quot;hello, I&#x27;m Joel&quot; &gt; /var/ftp/Joel.txt #写字符串进文本[redhat@localhost ~]$ ls公共 图片 音乐 redhat.txt vmlinuz-0-rescue-3f6f17037a7c4806bcc68ce95a0c1d7b模板 文档 桌面 tty3 vmlinuz-4.18.0-193.el8.x86_64视频 下载 opt tty4[redhat@localhost ~]$ hostname #hostname命令查看本机的hostnamelocalhost.localdomain[redhat@localhost ~]$ hostname &gt; redhat.txt #将本机hostname写入redhat.txt种[redhat@localhost ~]$ cat redhat.txt #查看文件内容localhost.localdomain cat 加-n 添加行标 管道|:只接受一个输入的命令 1234#一个文件12行 显示8-12行内容：head -12 /etc/passwd/ | tail -5 或cat /etc/passwd/ | head -12 |tail -5 find精确查找文件– 常用条件表示: -type 类型(f 文件【黑】、d 目录【蓝】、l 快捷方式【青】) -name “文档名称” -size +|-文件大小(k、M、G) k小写 -user 用户名 -mtime 修改时间 123456#-type 按照类型查找 [root@localhost ~]# find /dev/ -type l #查找快捷方式#-name &#x27;文档名称&#x27; 查找文件名[root@localhost ~]# find /etc/ -name &#x27;*tab&#x27;-size +或-文件大小(k、M、G)[root@localhost ~]# find /boot/ -size +10M #查找大于 10M 的 不支持-1M，-1G，-1k(太小了) find高级使用wcwc： word count 统计 wc -l /etc/passwd 查看这个文件有多少行 也是查看操作系统有多少用户 123find /etc/ -name &#x27;*tab&#x27; | wc -l #管道给wc表示统计以tab结尾的文件有多少个-exec拓展find的功能 find /home/ -name &#x27;*susu*&#x27; -exec cp -r &#123;&#125; /root \\; #&#123;&#125;将前面的结果放进里面作为复制的对象 \\;表示结束 第三节课 mkdir 只能创建文件夹不管后缀是怎么样，make directory 创建文件1touch [文件名] 创建硬连接ln 1ln [选项] 原文件 /路径/快捷方式名字 颜色是青绿色 删除目录下所有内容删除 &#x2F;root&#x2F;opt 下的所有内容，利用通配符 * 1234rm -rf /root/opt/*#或者cd /root/optrm -rf * grep 查找文本内容语法格式： 1grep [选项] &#x27;匹配模式&#x27; 文本文件... 压缩文件• tar 集成备份工具 红色 用tar就得加f选项，f一定放在最后 -c:创建归档 -x:释放归档 -f:指定归档文件名称 -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理 -t:显示归档中的文件清单 -C(大写):指定释放的位置 ，后面要接释放目标 f:选项必须放在所有选项的最后 1234tar -zcf /路径/压缩包名字 被压缩归档的源数据 #用gzip压缩，可以压多个tar -jcf #bzip2压缩tar -Jcf #使用xz压缩#cf是一定要加的，c：创建归档 f:指定归档文件名称 例子： 12[root@localhost ~]# tar -zcf /opt/abc.tar.gz /home/tar:从成员名中删除开头的&quot;/&quot; 查看： 1tar -tf /opt/bin.tar.bz2 解压缩1234#把压缩的c改成x 不加-z-j-J也可以 直接-xftar -zxf /路径/压缩包名字 -C 解压缩到的位置 #不加-C解压到当前tar -jxftar -Jxf win于linux互传scp方法 win 1234本地文件-&gt;远程文件夹scp local_file remote_username@remote_ip:remote_folder 本地文件-&gt;远程文件scp local_file remote_username@remote_ip:remote_file 1scp get66.pcap root@192.168.1.147:/super linux 123scp /home/zhao/data/test.txt zw@10.150.69.247: /C:/Users/zw/Desktop/summary或scp /home/zhao/data/test.txt zw@10.150.69.247: /C:/Users/zw/Desktop/summary/tt.txt ssh connection deny 可能是因为没有装Oepnssh通过ssh协议实现Windows与Linux之间的文件互传_ssh传输文件 windows到linux_奇迹虎虎的博客-CSDN博客 第四次课grep的查找条件语法格式： 1grep [选项] &#x27;匹配模式&#x27; 文本文件... 匹配模式： ^word：以字符串word开头的 word$：以字符串word结尾的 ​ ^$：匹配空行 例子： 123[root@localhost ~]# grep ^root /etc/passwd # 查找/etc/passwd 包含root开头的行[root@localhost ~]# grep -v ^$ /etc/default/useradd #查看文件非空行[root@localhost ~]# grep -v ^# /etc/login.defs #去除以#开头即去掉注释 1grep -E &#x27;匹配模式1|匹配模式2&#x27; 文本文件 #单引号括住 任意满足一个就将其过滤出来 vim文本编辑器12vim [[/目录/]文件名][root@localhost ~]# vim /opt/ps.txt #打开此文件进行以下操作 若目标不存在，则创建空文件并编辑 先进入的是命令模式： 在命令模式，i键进入输入模式，Esc键返回 在命令模式，:键进入末行模式，Esc键返回 基本操作： 保存并退出 :wq 放弃修改并退出:q! 命令模式下的操作： gg或1G直接到文件首行，10gg或10G跳转到第十行 G到文件末尾 yy复制，5yy往下复制5行，p粘贴 dd删除，10dd删除10行 u撤销，U撤销当前行的所有修改，Ctrl+u撤销一次撤销操作 /word向后查找，?word向前查找，按回车后按n查找下一个，N查找上一个 ZZ保存并退出vim :w /root/newfile 另存为其他文件 :r /etc/filesystems 读入其他文件内容 开关设置 :set nu显示行号 :set nonu不显示行号 与vim相关的配置文件1234vim ~/.vimrc #~家目录下配置set nu # 之后打开文件编辑器都有行标set ai # 都有缩进#记得:wq保存退出才能生效 可视化操作Vim 多行注释 首先按 esc 进入命令行模式下，按下 Ctrl + v ，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写） “I” 键，进入插入模式； 然后输入注释符（ “&#x2F;&#x2F;“、”#” 等）; 最后按下 “Esc” 键。 mount挂载光驱默认在&#x2F;dev&#x2F;sr0，它是块设备不能直接读，要挂载才能读 12mount 设备路径 挂载点目录umount 挂载点目录 #卸载设备，卸载块设备无效 例子： 1mount /dev/cdrom /dvd/ # 将光盘挂载到/dvd/目录 第五次课RPM包没法指定安装位置，要会找，拓展名为.rpm 源码包封装–&gt;rpm包 image.png 查询已安装的软件包 12rpm -q[子选项] [软件名称]rpmquery [子选项] [软件名称] -a：列出已安装的所有软件包 -i：查看指定软件的详细信息 -l：查看指定软件的文件安装清单 查询某个目录&#x2F;文件是哪个rpm包带来的 1rpm -qf [文件路径] 即使目标文件被删除也可以查询，注意后面接文件路径不是软件名。 查询未安装的软件包 12rpm -qpi [RPM包文件] #查看指定软件的详细信息rpm -qpl [RPM包文件] #查看指定软件的文件安装清单 卸载 1rpm -e 强制覆盖安装 1rpm -ivh --force [] –force yum仓库简介解决要安装各种依赖包的问题(一次性装) yum配置解析 基本设置：&#x2F;etc&#x2F;yum.conf 仓库配置：**&#x2F;etc&#x2F;yum.repos.d&#x2F;.repo* 一定以.repo结尾 日志文件：&#x2F;var&#x2F;log&#x2F;yum.log 123456789101112vim /etc/yum.repos.d/dvd.repo #/dvd.repo根据具体改[AppStream]name=rhel8.2baseurl=file:///dvd/AppStream #file://代表本地 /dvd从根开始 路径根据具体来改enabled=1gpgchcek=0[BaseOS]name=rhel8.2baseurl=file:///dvd/BaseOSenabled=1gpgcheck=0:wq 配置网络、源码包的编译和安装配置linux网络配置主机名在root权限下 123[root@localhost ~]# vim /etc/hostname #修改配置文件，永久配置主机名svr7.tedu.cnreboot #重启生效 配置IP红帽是ens160 centos是ens33 修改网卡名 1234567[root@svr7 ~]# vim /etc/default/grub…GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0&quot; #在末尾引号内添加net.ifnames=0 biosdevname=0[root@svr7 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg #重新生成引导文件，使配置文件生效[root@svr7 ~]# reboot #重启 验证，网卡名是否发生变化 1234[root@svr7 ~]# ifconfig #有eth0网卡eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.71.130 netmask 255.255.255.0 broadcast 192.168.71.255 配置IP地址 临时配置： 1ifconfig ens160 192.168.147.7/24 永久配置 12345[root@svr7 ~]# nmcli connection show #查看连接名NAME UUID TYPE DEVIvirbr0 0ace37a8-f7ad-45d6-9088-00b367999c0b bridge virb有线连接 1 02cc8558-b41e-3bc4-817b-243ca95c0417 ethernet eth 重新添加网卡 1[root@svr7 ~]# nmcli connection add type ethernet ifname eth0 con-name eth0\t#添加网卡 配置IP 先不要照抄！ 12配置IP[root@svr7 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.147.7/24 ipv4.gateway 192.168.147.254 connection.autoconnect yes #配置IP地址和网关并实现开机自动连接 注意：这里有两个ip地址要根据自己的修改，在虚拟机中选择VMnet8网卡，选NAT模式，查询子网ip和分配的网关；关闭DHCP，再改，因为打开后就是系统分配了 image.png 第一个ip填子网ip但后面的.0改成.7，加上&#x2F;24，代码例子子网ip是192.168.147.0于是填入192.148.147.7&#x2F;24 第二个ip点击NAT设置查询网关ip填入 image.png 123[root@svr7 ~]# nmcli connection up eth0 #激活eth0[root@svr7 ~]# ifconfig #查看配置的IP[root@svr7 ~]# route -n #查看网关 为本机指定DNS服务器 123[root@svr7 ~]# vim /etc/resolv.conf…nameserver 8.8.8.8 添加次要DNS ping 本机验证 1[root@svr7 ~]#ping 本机ip 本机ip在命令行窗口 1ipconfig /all 以太网适配器…VMnet1下的ipv4地址，后面有(首选) 一般是网关ip的.2改为.1 SSHimage.png 克隆主机A后看克隆机B的ip地址 在A中试着用ssh连B 1ssh root@[ip] 例子： 12345678910111213141516ssh 命令选项 -p 端口：连接到指定的端口-X 启用-X转发，在本机运行对方的图形程序[root@svr7 ~]# ssh root@192.168.4.207…Are you sure you want to continue connecting (yes/no)? yes\t#第一次远程会让输入yesroot@192.168.4.207&#x27;s password: #输入密码Last login: Wed Jul 8 11:24:37 2020[root@pc207 ~]# firefox #运行firefox图形程序，失败Error: GDK_BACKEND does not match available displays退出，使用-X选项登陆，成功[root@pc207 ~]# exit[root@svr7 ~]# ssh -X root@192.168.4.207root@192.168.4.207&#x27;s password: [root@pc207 ~]# firefox 修改默认端口 默认是22，可以进行修改，再连得关防火墙 修改默认端口，pc207主机操作: 123[root@pc207 ~]# vim /etc/ssh/sshd_configPort 8022 #Port原本是注释掉的 取消注释再把22改为8022[root@pc207 ~]# systemctl restart sshd #重启sshd服务，切记selinux需要是宽松或者禁止状态setenforce 0 测试：svr7主机操作，如果测试失败，出现以下问题，请关闭防火墙 123456789[root@svr7 ~]# ssh -p 8022 -X root@192.168.4.207\tssh: connect to host 192.168.4.207 port 8022: No route to host[root@svr7 ~]# systemctl stop firewalld[root@svr7 ~]# getenforce[root@svr7 ~]# setenforce 0[root@svr7 ~]# ssh -p 8022 -X root@192.168.4.207\t#重新测试root@192.168.4.207&#x27;s password: [root@pc207 ~]#[root@pc207 ~]# logout #退出 常用网络工具image.png image.png 1234567891011121314151617C:\\Users\\chan&gt;tracert www.baidu.com通过最多 30 个跃点跟踪到 www.a.shifen.com [183.232.231.172] 的路由: 1 1 ms 1 ms 1 ms 10.253.36.1 2 7 ms 3 ms 3 ms 202.116.36.213 3 12 ms 2 ms 4 ms 10.10.0.253 4 7 ms 10 ms 4 ms 120.236.163.1 5 6 ms 41 ms 7 ms 183.233.56.61 6 9 ms 10 ms 9 ms 120.196.243.21 7 * * * 请求超时。 8 37 ms 13 ms 13 ms 120.241.49.210 9 * * * 请求超时。 10 15 ms 26 ms 14 ms 183.232.231.172跟踪完成。 image.png 1ping -c [数字] -w [限定响应时间] [ip] #限定包数 源码编译安装RPM软件包： rpm -ivh yum -y install 源码包—-开发工具—–&gt;可以执行的程序—–&gt;运行安装 优势： 灵活度较高，自定义较高，可以指定安装位置 获得软件的最新版,及时修复bug 软件功能可按需选择&#x2F;定制,有更多软件可供选择 源码包适用各种平台 准备编译环境，启动yum步骤一：安装开发工具gcc与make 12345678910111213141516171819202122[root@svr7 ~]# yum -y install gcc make #可能会报错 说明没挂光驱和启用yum.repos.d[root@svr7 ~]# mount /dev/cdrom /dvd/[root@svr7 ~]# vim /etc/yum.repos.d/dvd.repo [BaseOS]name=BaseOSbaseurl=file:///dvd/BaseOSgpgcheck=0gpgkey=/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release[AppStream]name=AppStreambaseurl=file:///dvd/AppStreamgpgcheck=0[epel]name=EPELbaseurl=http://mirrors.aliyun.com/epel/$releasever/Everything/$basearchgpgcheck=0enabled=1[httpAppstream]name=aliyun Appstreambaseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/osgpgcheck=0[root@svr7 ~]# yum -y install gcc make\t#安装 查看是否安装成功： 自定义仓库制作仓库索引文件 12createrepos [仓库路径]ls [仓库路径] 发现多了repodata 这就是索引文件 1vim /etc/yum.repos.d/dvd.repo 添加，其中这里设置的仓库路径是/mytools/ 1234[Mytools]name=Mytoolsbaseurl=file:///mytools/gpgcheck=0 清空，重新生成 12yum clean allyum repolist -v 安装一些小玩意小火车 12yum -y install slsl 字符语 12yum -y install cmatrixcmatrix oneko占用前端 1oneko &amp; #在后台进行 这是会出现[1] 数字 1kill all 数字 #杀死对应进程 用户组超级用户id为0,其他从1开始。 每一个用户都会分配一个组，组账号用来区分权限，不用于登录。 基本组 附加组 1/etc/passwd #存放账号 1cat -n /etc/passwd | less #查看账号目录 添加组 12groupadd stuuseradd -u 1111 -d / 用户初始配置文件1# ls -a /etc/skel/ 模板目录，写到这里的东西会作为模板复制到新用户的家目录下。 全局配置文件还有：&#x2F;etc&#x2F;bashrc, &#x2F;etc&#x2F;profile ~&#x2F;.bash_profile：每次登录时执行 ~&#x2F;.bashrc：每次进入新的Bash环境时执行 ~&#x2F;.bash_logout：每次退出登录时执行 echo输出 1# vim /home/[用户名]/.bashrc 打开用户终端时执行的内容 权限与归属解析文件&#x2F;目录权限12# ls -lhd ..权限位 硬连接数 属主 属组 大小 最后修改时间 修改权限chmod [-R] [+-=][rwx] 文件 ... -R递归修改权限 1# chmod u+r / image.png 权限管理目录权限默认为755，文件默认为644，一般文件默认不给x权限 123mkdir -p /opt/susu/yiyi/ling #递归创建文件夹ls -R /opt/susu/yiyi #递归列出 展开/opt/susu以及/opt/susu/yiyils -lhd /opt/susu/yiyi #查看属性 权限位： User–Group–Ohter 各三个字符表示，字符有r(读)&#x2F;w(写)&#x2F;x(执行)&#x2F;- 1chmod 0=--- /opt/susu #修改Ohter权限为--- 递归修改-R 1chmod o+rx /opt/susu/yiyi #加可读可写权限 文件夹的权限可执行是指它的目录下的文件可执行，如果它的父目录没有可执行权限，那么不可移动等操作这个文件夹。 属组1234567mkdir /susu01ls -lhd /susu01groupadd stugrp #创建新组useradd dc #创建新用户id dc #查看用户Idchown dc:stugrp /susu01 #修改归属ls -lhd /susu01 #发现susu的属于的人和属于的组分别变为dc和stugrp 12345[root@localhost ~]# gpasswd -a zhangsan stugrp #加入组[root@localhost ~]# su - zhangsan #切换[zhangsan@localhost ~]$ exit注销[root@localhost ~]# 权限位12345mkdir /student/chown :stugrp /student/chmod g+s /student/ls -lhs /student/ #发现group变成r-smkdir /student/stu2/ #此时新建的子目录组会和/student/一致为stugrp 粘滞位避免在同一个文件夹下不同用户互删文件 12[root@localhost ~]#chmod o+t /public/ #other的x被t覆盖#此时如果一个用户想要rm rf 另一个用户创建的文件不可置信 计划任务启动流程查看进程进程动态排名 1top -d3 #每三秒更新一次进程动态排名 查进程PID号 1234pgrep -l crond#查用户 查lisi的进程 pstree以树形结构展示 比pgrep详细pstree -apu lisi 进程管理123456789101112# sleep 3 #占用前台终端三秒 暂停功能^Z #此时挂起后是停止的[1]+ 已暂停 sleep 3# jobs[1]+ 已暂停 sleep 3# bg 1 #激活后台的sleep 3# sleep 30 &amp; #加&quot;&amp;&quot;直接在后台进行# jobs[1]+ 运行中 sleep 3[2]+ 运行中 sleep 30# fg 2 #把sleep 30恢复到前台# jobs -l #多加显示进程的PID号 Ctrl + z 挂起当前进程 jobs 查看后台任务列表 fg 将后台任务恢复到前台 杀死进程 123456789[root@localhost ~]# kill [PID号][root@localhost ~]# killall sleep #杀死所以sleep名的进程#假设有一个lisi用户在vim list.txt状态[root@localhost ~]# pstree -apu lisibash,4419\tvim,5213 list.txt[root@localhost ~]# kill [-9] 5213 #此时lisi的vim状态终止 -9是暴力删除的方法[root@localhost ~]# pkill -9 -U lisi #强制踢出lisi 此时lisi的终端退出了 日志tail -f 查看 1# tail -f /opt/1.txt image-20221129095411871 服务器搭建搭建ftpFTP：文件传输协议 虚拟机 A（svr7）搭建基本 FTP 服务 安装 vsftpd 软件 1[root@JSever ~]# yum -y install vsftpd 重启 vsftpd 服务 123[root@JSever ~]# systemctl restart vsftpd[root@JSever ~]# systemctl enable vsftpd 允许匿名访问 1[root@JSever ~]# vim /etc/vsftpd/vsftpd.conf anonymous_enable&#x3D;NO 改成YES 客户机访问： 1[root@JClient ~]# firefox ftp://192.168.4.7 默认共享数据的目录：/var/ftp 上传12ftp 192.168.4.5put 文件 必须要用户登录，匿名登陆会permission denied 搭建http服务虚拟机 svr7 作为服务端，搭建 web 服务器 1、安装软件包 1[root@svr7 ~]# yum -y install httpd 2、书写页面内容，重启服务 12[root@svr7 ~]# echo xixhaha &gt; /var/www/html/index.html [root@svr7 ~]# systemctl restart httpd pc207 作为客户端测试，成功 1[root@pc207 ~]# curl 192.168.4.7 3 修改配置文件 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf，改变网页文件存放路径 1234[root@svr7 ~]# vim /etc/httpd/conf/httpd.conf DocumentRoot &quot;/var/www/myweb&quot; DirectoryIndex index.html #默认网站起始页 改变网页文件存放路径 1234[root@svr7 ~]# mkdir /var/www/myweb [root@svr7 ~]# echo wo shi myweb &gt; /var/www/myweb/index.html [root@svr7 ~]# systemctl restart httpd pc207 作为客户端测试，成功[root@pc207 ~]# curl 192.168.4.7 配置一个虚拟站点 • 配置文件路径 – &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf #主配置文件 – &#x2F;etc&#x2F;httpd&#x2F;conf.d&#x2F;*.conf #调用配置文件 为每个虚拟站点添加配置 &lt;VirtualHost *:80&gt; ServerName 此站点的 DNS 名称 DocumentRoot 此站点的网页根目录 &lt;&#x2F;VirtualHost&gt; 虚拟机 svr7 作为服务端操作 123456789[root@svr7 ~]# vim /etc/httpd/conf.d/nsd01.conf NameVirtualHost *:80 #请用机器的 IP 代替\\*号 #开启虚拟主机，在所有 IP 地址上启用 80 端口 &lt;VirtualHost *:80&gt;ServerName www.qq.com #指定访问的域名 DocumentRoot /var/www/qq #指定网页文件路径 ServerName www.baidu.com DocumentRoot /var/www/baidu &lt;/VirtualHost&gt; 12345[root@svr7 ~]# mkdir /var/www/qq[root@svr7 ~]# mkdir /var/www/baidu [root@svr7 ~]# echo wo shi qq &gt; /var/www/qq/index.html[root@svr7 ~]# echo wo shi baidu &gt; /var/www/baidu/index.html [root@svr7 ~]# systemctl restart httpd pc207 测试： 1234[root@pc207 ~]# vim /etc/hosts 192.168.4.7 www.qq.com www.baidu.com[root@pc207 ~]# curl www.qq.com wo shi qq [root@pc207 ~]# curl www.baidu.com 第一个虚拟站点被视为默认站点 若想要原有的初始的话，虚拟站点配置上面另外加： 123&lt;VirtualHost *:80&gt;\tDocumentRoot /var/ftp/ &lt;/VirtualHost&gt;","tags":["笔记","Linux"],"categories":["本科课程"]},{"title":"软件工程导论学习笔记","path":"/2023/01/01/软件工程导论学习笔记/","content":"作业题能力成熟度模型 软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 B.使用标准开发过程（或方法论）构建（或集成）系统 C.管理层寻求更主动地应对系统的开发问题 D.连续地监督和改进标准化的系统开发过程 解析：A基本管理属于2可重复级；C属于已管理级；D改进属于5优化级；B标准属于3已定义级 * 软件能力成熟度模型（CMM image.png的第 4 级（已管理级）的核心是 。 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 B.组织具有标准软件过程 C.对软件过程和产品都有定量的理解和控制 D.先进的新思想和新技术促进过程不断改进 解析：4已管理级关键词：定量，预测 软件过程模型 为了有效地捕获系统需求，应采用 . A.瀑布模型 B.V 模型 C.原型模型 D.螺旋模型 解析： 瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。该模型适用于项目开始时需求已确定的情况。 V 模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。 原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。原型的用途是获知用户的真正需求，因此原型模型可以有效地引发系统需求。 螺旋模型把开发活动和风险管理结合起来，以将风险减到最小并控制风险。 演化模型在获取一组基本的需求后，通过快速分析构造出该软件的一个初始可运行版本，然后逐步演化成为最终软件产品。 增量模型是一种阶段化的软件开发过程模型。在该过程模型中，客户提出系统需求，并指出哪些需求是最重要的。开发团队把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成， 并且能完成特定的功能。其优点包括：能较短时间内向用户提交可完成一些有用的工作产品；逐步增加产品的功能，使用户有较充裕的时间学习和适应新产品；项目失败的风险较低；优先级最高的服务首先交付，然后依次将其他 构件集成进来，这意味着最重要的服务将接受最多的测试。快速发布 喷泉模型是典型的面向对象生命周期模型，是一种以用户需求为动力，以对象作为驱动的模 型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。“喷泉” 一词本 身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程 中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。 系统工程 经济可行性研究的范围包括（ ） A、技术有效性 B、管理制度 C、效益分析 D、开发风险 解析： 经济可行性主要进行成本效益分析，从经济角度，确定系统是否值得开发 技术可行性主要根据系统的功能、性能、约束条件等，分析在现有资源和技术条件下系统能否实现 法律可行性合同责任、侵犯专利权、版权等问题 （多选题）在对协同电子商务平台项目进行技术可行性分析的过程中需要注意哪些方面？ （ ） A、在限制条件下，功能目标是否能达到 B、利用现有技术，性能目标是否能够达到 C、对开发人员数量和质量的要求，并说明能否满足 D、在规定的期限内，开发是否能够完成 解析：根据软件设计文档国家标准（GB8567-2006）的要求，技术可行性章节应该主要包含 以下内容： 1.在当前的限制条件下，该系统的功能目标能否达到 2.利用现有的技术，该系统的功能能否实现 3.对开发人员的数量和质量的要求，并说明这些要求能否满足 4.在规定的期限内，本系统的开发能否完成 除了上述内容之外，技术可行性部分应该对当前开发所使用的主流研发框架和架构做简要的 介绍和说明，不限于图表和文字等方式。 为了分析顾客不同情况下的订票习惯，可采用以下哪种需求获取方式（ ） A、正式访谈 B、非正式访谈 C、调查表 D、观察实践 解析：错选C，使用观察实践，情景分析获取用户在不同场景下的不同需求。 结构化方法和数据流图 面向数据流自顶向下求精过程不包括 A、分析追踪数据流图 B、用户复查 C、细化数据流图 D、实现数据流图 软件工程与软件过程软件软件&#x3D;程序+数据+文档 计算机软件 计算机软件是指计算机系统中的程序及其文档 程序是计算任务的处理对象和处理规则的描述 文档是为了便于了解程序所需的阐明性资料 软件的特点 软件是一种逻辑实体，而不是有形的系统元件，其开发成本和进度难以准确地估算 软件是被开发或被设计的，没有明确的制造过程，一旦开发成功，只需复制即可，但其维护的工作量大 软件的使用没有硬件那样的机械磨损和老化问题 软件不能独立存在，需要依附于一定的环境(如硬件、网络以及其他软件等) 软件必须遵从人为的惯例，并适应已有的技术和系统。 软件需要随接口的不同而改变 软件的分类有多种分类方法。 基础设施类 系统软件 支持软件 应用类 应用软件 软件工程软件工程学科出现的主要原因是软件危机的出现 软件危机 一个合格的软件开发是按时按量按质实现软件 许多软件项目不能满足客户的要求 许多软件项目超出预算和时间安排 image.png image.png 软件工程的定义1968年NATO(北大西洋公约组织)会议上首次提出 计算机科学技术百科全书：软件工程是应用计算机 科学、数学及管理科学等原理，开发软件的工程。 软件工程借鉴传统工程的原则、方法，以提高质量、 降低成本为目的 软件生存周期软件有一个孕育、诞生、成长、成熟、衰亡的生存过程。这个过程即为计算机软件的生存周期 软件生存周期大体可分为如下几个活动： graph LR A(计算机系统工程) ---B(需求分析) B --- C(设计) C ---D(编码) D---E(测试) E---F(运行) F---G(维护) 软件过程模型(8种)image.png image.png 能力成熟度模型能力成熟度模型CMM原本是评估依据，后来用于改进软件管理过程 image.png 能力成熟度模型集成CMMI阶段式模型 (整体能力的划分)image-20220905211312772 连续式模型(某方面能力的衡量)image-20220905211353252.png image-20220905211407538 软件过程模型 软件过程模型 瀑布模型 增量模型 原型模型 螺旋模型 喷泉模型 基于构件的开发模型 形式化方法 特点 首先有完成核心基本需求，再逐步确定非核心；多个增量可叠加 反映系统性质的一个子集 风险驱动的软件过程模型，把开发活动和风险管理结合起来，以将风险减到最小并控制风险 基于面向对象思想、迭代、无间隙。模型各个阶段没有明显界限，开发人员同步进行开发 利用预先包装的构件来构造应用系统 是建立在 严格数学基础上。开发过程重凡是采用严格 的数学语言，具有精确的数学语义的方法，都称为形 式化方法 适用场景 项目开始前需求和解决方案就很明确，短期或中期项目 不完全明确但知道核心需求，急需使用的软件，需求经常变化 要从用户身上了解主要需求，周期是一个环型，可废弃上一个原型或在其基础上追加 适应于面向对象的软件开发过程，以对象为驱动，只用对象和关系实现活动的迭代和无间隙 构件化结构，可以尽量重用已有的组件。 对安全性、可靠性极高 优缺点 缺：缺乏灵活性、维护代价大 各增量构件均为一个可操作产品。融合了瀑布模 型的基本成分（重复地应用）和演化模型的迭代特征，特别适用于需求经常发生变化的软件开发。 用户需要方面，重交互。缩短了开发周期，加快了工程进 度，降低成本。 将原型实现的迭代特征与瀑布模型中控制的和系统化的方面结合起来， 不仅体现了这两种模型的优点，而且增加了风险分析 可以提高软件 项目开发效率，节省开发时间 减少开发、降低风险和成本、需求妥协、快速交付 易于发现需求的歧义性、不完整性和不一致性，易于对分析模型、 设计模型和程序进行验证。 瀑布模型项目需求方案明确，短期小型工程 从下到上很难，不适用需求经常换的 image-20220905211552135 image-20220905211651996 image-20220905211703289 演化模型开发早期对软件需求的认识是模糊的、不确定的，因此软件很难一次开发成功。逐步演化而来 开发的软件，需求不能一次搞清楚，且系统需求比较复杂？ 答案：用演化模型 graph LR A{演化模型}-->B(增量模型) A-->C(原型模型) A-->D(螺旋模型) 增量模型每次增量都可用，有核心需求，急需使用的软件。多个增量可重叠 image-20220905212334175 适用于需求经常发生变化的软件开发 第一个增量通常是核心产品 image-20220905212549792 原型模型原型（prototype）是预期系统的一个可执行版本，反映 了系统性质（如功能、计算结果等）的一个选定的子集。 image-20220905212656390 特点： 用户不能完全准确表达对未来系统的全面要求 开发者对要解决的问题的应用问题模糊不清 一圈出来一个版本 类型： 探索型 实验型 演化型 image-20220905212802183 增量模型和原型模型的区别核心都是迭代，但增量模型强调各增量构建均是一个可操作产品。原型模型不断讨论修改完善。 image-20220905212909013 image-20220905213105101 螺旋模型 有风险机制 image-20220905213228769 image-20220905213239716 image-20220905213315281.png 喷泉模型 像喷泉从下往上，后面的工作在做前面的也没停止 基于面向对象思想，迭代、无间隙 注意，面向对象不是喷泉独有的，其他一些模型也有 基于构件的开发模型image-20220905213500212.png image-20220905213513555.png 形式化模型建立在严格数学基础上 image-20220905213521544.png CASE工具和环境的重要性CASE 已被证明可以加快开发速度,提高应用软件生产率并保证应用软件的可靠品质。计算机专业人员利用计算机使他们的企业提高了效率,企业的各个部门通过使用计算机 提高了生产率和效率,增强了企业的竞争力并使之带来了更多的利润。 系统工程系统工程的任务 识别用户的要求 识别基于计算机系统的整体要求 标识系统的功能和性能范围 确定系统的功能、性能、约束和接口 系统建模和模拟 考虑以下模型： 硬件系统模型 软件系统模型 人机接口模型 数据模型 成本估算及进度安排 需要一定的资金投入和时间约束 进行成本估算 作出进度安排 可行性分析 主要从经济、技术、法律等方面分析所给出的解决方案是否科学。 生成系统规格说明 作为以后开发基于计算机的系统的依据 可行性分析的任务 经济可行性：确定系统是否值得开发 成本 效益 货币的时间价值 投资的回收期 纯收入 技术可行性：分析系统在现有资源和条件下能否实现 风险分析 资源分析 技术分析 法律可行性：是否引起侵权、破坏等责任问题 方法的选择和折衷 需求工程需求工程的具体步骤和任务 需求获取 系统分析人员通过与用户的交流 对现有系统的观察及时对任务进行分析 需求分析与协商： 分析每个需求与其他需求的关系以检查需求的一致性、重叠和遗漏的情况 并根据用户的需求对需求进行排序 系统建模 通过合适的工具和符号系统地描述需求 需求规约 给出对目标软件的各种需求 需求验证 对功能的正确性、完整性和清晰性以及其他需求给予评价 需求管理 对需求工程所有相关活动的规约和控制 制定需求获取策略主要考虑因素 功能需求 考虑系统要做什么，在何时做 在合适及如何修改或升级 性能需求 考虑软件开发的技术性指标 用户或人为因素 考虑用户的类型 需求获取的方法和策略 建立顺畅的通信途径 访谈与调查 亲身实践 会议 头脑风暴 概念建模 原型、仿真 自省 用户行为数据在线采集 设计工程软件设计原则image.png 抽象与逐步求精抽象 在最高层用术语概括性描述 在中间层次用面向过程化方法 在最低层用直接实现的方式 抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面 分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止 随着分解层次的增加，抽象的级别越来越低，也越接近问题的解(算法和数据结构) 模块化模块化：就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成 一个整体，可以完成指定的功能满足用户的需求。 如果一个大型程序仅由一个模块组成，它将很难被人所理解。 “分而治之” 问：程序采用模块化设计，有哪些优点？ 答：程序采用模块化设计，有以下优点： 将问题简化，划分模块可使每一个模块完成单一的功能， 模块之间的联接关系简单，具有独立性； 可以独立的进行模块的编码测试，便于软件开发工作的组织； 把每一个模块要解决的问题局限在有限的范围，减少出错 机会，易于修改和维护； 有助于软件项目的组织管理，一个复杂的大型软件可以由许多程序员分工编写，提高了开发效率； 一个模块可被重复使用，以提高软件产品的复用率； 利于估计工作量和开发成本。 信息隐藏David Parnas在1972年最早提出信息隐藏的观点。 他在其论文中指出：代码模块应该采用定义良好的接口来封装，这些模块的内部结构应该是程序员的私有财产，外部是不可见的。 image.png image.png 功能独立功能独立：功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果。 两个定性标准: 内聚衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高， 每个模块完成一个相对独立的特定子功能。 耦合衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低， 即每个模块和其他模块之间的关系要简单。 内聚紧密程度 image.png 逻辑内聚 image.png 时间内聚：初始化 image.png 过程内聚：按任务的顺序 image.png 通信内聚：模块的功能都要做，但数据集都是同一个(和逻辑内聚区分) image.png 顺序内聚：既要按任务的顺序，一个的输出要作为另一个的输入 image.png 功能内聚：只完成一项工作 image.png 通信内聚和逻辑内聚区分：前者数据集都是同一个，但是逻辑内聚也可以同一个数据集，这时看是否有传入参数来决定执行的操作。 耦合相互依赖程度 image.png image.png 内容耦合 公共耦合 image.png 外部耦合 image.png 控制耦合 image.png 标记耦合 image.png 数据耦合 例如中途调用的函数 image.png 非直接耦合 image.png 标记耦合传的是数据结构的一部分，如数组、字符串等，而数据耦合传的是简单数据 高内聚，低耦合 结构化程序设计方法详细描述处理过程常用工具：图形、表格和语言 图形：程序流程图、N-S图、PAD图 表格：判定表 语言：过程设计语言(PDL) image-20221222113658687.png 结构化分析方法 结构化方法：它以数据流为中心构建软件的分析模型和设计模型 结构化分析与建模：主要思想：抽象与自顶向下的逐层分解（控制复杂性的两个基本手段） 抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面。 分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止。 结构化系统分析模型组成结构有： E-R图 数据流图(DFD) 状态变迁图(STD图) 数据字典(DD) 数据流图主要思想：数据流图描述输入数据流到输出数据流的变换（即加工），用于对系统的功能建模。 符号： ⚪或椭圆 表示加工，也叫数据处理 ▭ 矩形表示数据流的源点或终点，统称外部实体 ＝ 双杠，文件或数据存储 → 箭头表示数据流 使用数据流图进行需求分析的过程： 画出系统的输入和输出。 A. 确定源和宿 B. 确定加工 C. 确定数据流 :输入数据流，输出数据流 D. 顶层图通常没有文件 画出系统内部。 A. 确定加工 ：确定父图中某加工分解而成的子加工 B. 确定数据流 ：沿用或新增 C. 确定文件 D. 确定源和宿 画出加工内部。 重复第 3 步，直至每个尚未分解的加工都足够简单（即不必再分解）。 image.png 1f10dc03d569bb00e848cdecb12578d.jpg 画顶层图 顶层图有唯一的加工：椭圆表示 系统之外的源或宿(外部实体)：矩形表示 image.png 步骤： 确定唯一加工 确定功能需求和外部实体(源或宿) 确定数据流：系统的输入&#x2F;输出信息 画0层图步骤： 确定加工：确定父图中某加工分解而成的子加工 根据功能分解来确定加工：将一个复杂的功能分解成若干个较小的功能，较多应用于高层DFD中的分解 image.png 确定源和宿 image.png 确定数据流 沿用父图 新增数据流 ​ image.png image.png 确定文件 已有文件则应画在子图中 分解子图中，若需要保存某些中间数据以备后用，则可以讲这些数据组成一个新的文件 新文件至少应有一个加工为其写入记录，同时至少存在另一个加工来读该文件。 image.png 画1层图(画加工内部)复杂的加工可以继续分解为一张DFD子图 分解方法： 指定图中的某一个加工看作一个小系统，系统的输入输出流就是这个加工的输入输出流 然后采用画0层图的方法，画出该加工的子图 加工1子图内部，即考试报名内部 image.png 加工2子图，即统计成绩 image.png 总结画分层数据流图的步骤： 画系统的输入和输出 画系统内部 画加工内部 重复第3步，直至每个尚未分解的加工都足够简单 (即不必再分解) 注意：千万不要试图在数据流图中表现分支条件或循环，这样会造 成混乱，画不出正确的数据流图。 检查分层细化时是否保持信息的连续性，即当把一个处理分解成一 系列处理时，分解前和分解后的一系列输入输出数据流必须相同， 这条规则也成为数据流图的数据平衡原则。 审查完整性： 每个加工至少有一个输入数据流和一个输出数据流 分层数据流图，每个文件应至少有一个加工读取该文件，有另一个加工写该文件 画的是数据流而不是控制流 数据字典判定表确定四个区域的内容 image.png 简化标准： 具有相同的操作 有且仅有一个不同的取值，简化后用小横杠表示，如本题简化后第四列第一个 判定树image.png 根节点是加工过 最右边是具体的部分 中间的部分都是影响条件 模块结构图image-20221024114704451.png 注意： 模块之间相连的线段(调用)是没有方向的，有方向的是数据流 结构图基本成分：模块，调用，数据 类树形结构 image.png 扇入是别人调用他的个数 扇出是他调用别人的个数 含义 深度和宽度在一定程度上反映了程序的规模和复杂程度 一个模块的扇出过大通常意味着该模块比较复杂，然而扇出太少可能导致深度增加 一个模块的扇入表示有多少模块可直接调用它，它反映了该模块的复用程度，因此模块的扇入越大越好 面向数据结构的分析与设计什么是面向数据结构的方法面向数据结构的方法是· 以数据结构为中心 · 从输入&#x2F;输出的数据结构导出程序结构的 · 一种软件需求分析与设计的方法 特点· ①以信息对象及其操作作为核心进行需求分析 · ②认为复合信息对象具有层次结构，并且可按顺序、选择、重复3种结构分解为成员对象信息 · ③提供由层次信息结构映射为程序结构的机制，从而为软件设计奠定良好的基础 Jackson图的三种结构顺序元素clip_image002-16726347926341.jpg 1.1.1. 选择元素clip_image004.jpg 1.1.2. 重复元素clip_image006.jpg 面向对象方法基础UMLimage.png image.png image.png image.png UML语言中的关系· 关联 · 依赖 · 泛化 · 实现 · 聚合 · 组合 UML包含的视图(红色为已学)结构化静态视图• 类图(class) • 展示类与类之间的相互联系，如关联、依赖、泛化等。可以把若干个相关类包装在一起作为一个单元(包)，相当于一个子系统。。 • 一个系统可以有多张类图，一个类也可以出现在几张类图中 • 对象图是类的实例。区分：对象图在对象名下面加了下划线，同时显示对象间的实例连结关系 • 类 • 类间关系 • 四种 • 依赖 • —&gt; 被依赖元素的变化会要求或指示依赖元素的改变(例如类A的方法仅仅使用了类B的对象，那么类A依赖于类B) • 访问 • 绑定 • 调用 • 创建 • 派生 • 实例化 • 允许 • 实现 • 精化 • 发送 • 使用 • 关联(聚集、组合) • 对象与其他实例的连接 • 聚集 ——♢ “部分”对象可以是任意整体对象的一部分 • 组合 ——◆ 更强形式的关联，具有强的物主身份，即“整体”对象拥有“部分”对象(例如类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系) • 是一种拥有的关系，它使一个类知道另一個类的属性和方法；如：老师与学生，丈夫与妻子的关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者沒有箭头，单向的关联有一个箭头。 • 泛化 —▷ 继承，由子类指向父类 • 实现 —▷ 类连接到接口，接口是行为规划而不是结构 • 强度：依赖&lt;关联&lt;聚集&lt;组合&lt;泛化&#x3D;实现，类间关系依次增强 属性和操作 • 属性中的变量名要小写 主要版型 • 边界类 • 控制类 • 实体类 设计视图 • 内部结构(internal structure) • 协作图(collaboration) • 构件图(component) 用况视图 • 用况图(use case) • 展示各类外部执行者与系统提供的用况之间的连接。用况图给出用户所感受到的系统行为，但不描述系统如何实现该功能 • 用况–系统的功能，执行者–使用功能的人或外部系统 • 主要元素 • 参与者 • 用例 • 关系 • 关联 ——————————— • 包含 ——&lt;&gt;—— • 扩展 ——&lt;&gt;—— • 泛化 ——————————▷ 动态的 • 状态机视图 状态机图(state machine) 通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。 状态的改变成为迁移(transition)。一个状态迁移还可以有与之相关的动作，该动作指出状态迁移时应做什么。 不是所有的类都要画状态，应当满足这些条件才画 有一些意义明确的状态 其行为受不同的状态所影响和改变 • 活动视图 活动图(activity) 描述完成一个操作(如用况)所需要的活动 由动作状态组成 完成一个动作的活动的规约 一个动作完成时，离开该动作状态 消息发送和接收的规约 • 交互视图 顺序图(sequence) 展示几个对象之间的动态交互关系。 主要显示:对象之间发送消息的顺序，显示对象之间的交互，即系统执行的某一特定点所发生的事 通信图(communication) · 物理的 部署视图 部署图(deployment) · 模型管理 模型管理视图 包图(package) 剖图 包图(package) UML包括哪四种事物？· 1.结构事物 • 类 • 接口 • 用例 • 主动类 • 构件 • 结点等 · 2.动作事物 • 状态等 · 3.组织事物 • 包 · 4.注释事物 • 给建模者提供信息，提供关于任意信息的文本说明，但没有语义作用 面向对象建模用况建模执行者，用况 用况是执行者想要做的事，执行者执行用况 线段带箭头表示发起的方向 注意扩展关系是扩展指向用况 泛化(归纳)关系是子用况指向父用况，类似继承 实验****5 面向对象方法的应用（1） 用况建模 （1） 实验目的 掌握UML用况图的画法，学习在软件构思和需求分析阶段进行用况建模，学会填写相关文档。 （2） 实验原理 ü 统一建模语言 统一建模语言（UML）是一种用来对真实世界物体进行建模的标准标记，这个建模的过程是开发面向对象设计方法的第一步。 UML从考虑系统的不同角度出发，定义了用况****图、类图、对象图、状态图、活动图、序列图、协作图、构件图、部署图等图形，这些图从不同的侧面对系统进行描述。系统模型将这些不同的侧面综合成一致的整体，便于系统的分析和构造。尽管UML和其它开发工具还会设计出许多派生的视图，但上述这些图和其它辅助性的文档是软件开发人员所见的最基本的构造。 UML适用于系统开发过程中从需求规格描述到系统完成后测试的不同阶段。在需求分析阶段，可以用用况来捕获用户需求。通过用况建模，描述对系统感兴趣的外部角色及其对系统（用况）的功能要求。分析和设计阶段主要关心问题域中的主要概念（如类和对象等）和机制，需要识别这些类以及它们相互间的关系，并用UML类图来描述。为实现用况，类之间需要协作，这可以用UML动态模型来描述。 ü 用况模型 用况图定义：由执行者（Actor）、用况（Use Case）以及它们之间的关系构成的用于描述系统功能的静态视图称为用况图。用况图（User Case Diagram）是被称为执行者的外部实体所能观察到的系统功能的模型图，呈现了一些执行者和一些用例，以及它们之间的关系，展示了用况之间以及与执行者之间是怎样相互联系的，主要用于对系统、子系统或类的功能行为进行建模。用况图定义了系统的功能需求，它是从系统的外部看系统功能，并不描述系统内部对功能的具体实现。 用况图由执行者（Actor）、用况（Use Case）、系统边界、箭头组成，用画图的方法来完成。 执行者（Actor） 定义：执行者（Actor）不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此执行者可以是人，可以是事物，也可以是时间或其他系统等等。还有一点要注意的是，参与者不是指人或事物本身，而是表示人或事物当时所扮演的角色。比如小明是图书馆的管理员，他参与图书馆管理系统的交互，这时他既可以作为管理员这个角色参与管理，也可以作为借书者向图书馆借书，在这里小明扮演了两个角色，是两个不同的执行者。 画法：执行者在Visio称为“参与者”，在画图中用简笔人物画来表示，人物下面附上执行者的名称。执行者的命名，通常是一些角色名，或者系统设备名等。 wps1.png 用况 定义：是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定执行者的价值的可观察结果。这是UML对用况的正式定义，对我们初学者可能有点难懂。我们可以这样去理解，用况是执行者想要系统做的事情。 画法：用况在Visio称为“用例”，在画图中用椭圆来表示，椭圆下面附上用况的名称。对于用况的命名，我们可以给用况取一个简单、描述性的名称，一般为带有动作性的词。 wps2.png 系统边界 定义：系统边界是用来表示正在建模系统的边界。边界内表示系统的组成部分，边界外表示系统外部。 画法：可使用Visio的“子系统”画系统边界，因为系统边界的作用有时候不是很明显，所以在画图时可省略。系统边界在画图中用方框来表示，同时附上系统的名称，执行者画在边界的外面，用况画在边界里面。命名时使用系统或子系统的名称就可以了。 wps3.png 用况图中的关系 定义：用况图中可表示执行者和用况之间，用况与用况之间，执行者与执行者之间的多种关系。 关联关系：执行者与用况之间的关系，表示用况是这个执行者发起的，执行者可以行使系统中的这个功能。关联关系在Visio中就称为“关联”，为一条不带箭头的线段。 wps4.png 包含关系：用况与用况之间的关系。基用况必须和被包含用况一起使用才够完整，被包含用况也必然被执行。包含关系在Visio中就称为“包含”，使用带箭头的虚线表示（在线上标注《》），箭头从基用况指向被包含用况。 wps5.png 扩展关系：用况与用况之间的关系。扩展用况是对基用况（被扩展用况）的扩展，即使没有扩展用况的参与，也可以完成一个完整的功能。扩展关系在Visio中就称为“扩展”，使用带箭头的虚线表示（在线上标注《》），箭头从扩展用况指向基用况（被扩展用况）。 wps6.png 泛化关系：同类元素之间的关系，如用况与用况之间，执行者与执行者之间。类似面向对象中的继承关系。泛化关系在Visio中称为“归纳”，用实线+空心三角形表示，空心三角形指向父，子可以继承父所有的行为。 用况图 用况图主要的作用有三个：（1）获取需求；（2）指导测试；（3）还可在整个过程中的其它工作流起到指导作用。 用况图用况图是从程序员角度描述系统的功能？错 静态建模类图和对象图 对象图是类图的实例 类之间的关系有关联、依赖、泛化、实现等 类图是一种静态模型，是其他图的基础 一个系统可以有多张类图，一个类也可以出现在几张类图中 如何用UML表示一个类类又名称，属性和操作组成 名称唯一，一般采用双驼峰命名法 属性，操作首字母通常小写，单驼峰 属性的语法：属性名：类型&#x3D;初始值 例如：maxCount:Interger&#x3D;0 操作的语法：操作名 (参数表)：返回类型 例如：method1(Object par):void 类之间的关系— 关联 –&gt; 依赖 —▷泛化 需要协助 –▷ 实现 重数：表示这个类的多少个实例对象可以与另一个类的一个实例关联 允许一个类与自身关联 状态图和活动图什么是状态图？· 通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。 状态图的组成元素· 状态 · 状态之间的迁移 · 分支 · 状态内的迁移 · 复合状态 活动图什么是活动图？· 描述完成一个操作(如用况)所需要的活动 活动图的组成元素· 活动 · 泳道 · 分支 · 分岔和汇合 · 对象流 1.1. 顺序图1.1.1. 什么是顺序图？展示几个对象之间的动态交互关系 1.1.2. 顺序图1.组成 • ①对象 • ②生命线 • ③激活 • ④消息(其中描述消息语法不是重点) • ⑤组合片段 2.带条件和分支的顺序图 3.带约束的顺序图 4.带循环和自身消息的顺序图 5.创建对象和删除对象的顺序图 结构化控制结构6.带组合片段的顺序图 • 组合片段是矩形的，注意其覆盖的高度和宽度，高度对应时长，宽度对应覆盖的对象 • 框住一个范围，也可以嵌套 7.网上在线订购的顺序图 买饮料的顺序图第九章 基于构件的软件开发什么是构件软件构件是软件系统中具有相对独立功能，可以明确标识，接口由规约指定，与语境有明显依赖关系，可独立部署，且多由第三方提供的可组装软件实体。 可复用构建是指具有可复用价值的构件可变性分析构件应具有较强的通用性和可变性为了满足不同的复用需求，需要在构件复用时可能发生变化的一个或多个位置上标识变化点，同时为变化点附加一个或多个变体 基于构建的软件开发过程领域工程步骤(生产构建)1领域分析 2建立领域特定的基准体系结构模型 3标识候选构件 4泛化和可变性分析 5构件重构 6构件的测试 7构件的包装 8构件的入库 应用系统工程的步骤(使用构件)1建立应用系统的体系结构模型 2寻找候选构件 3评价和选择合适的构件 4构件的修改和特化 5开发未被复用的部分 6构件的组装 7集成测试 8评价被复用的构件，并推荐可能的新构件 clip_image002-16726355802722.jpg 第十章 敏捷软件开发什么是敏捷开发方法敏捷开发是一种基于更紧密的团队协作、能够有效应对快速变化需求、快速交付高质量软件的迭代和增量的新型软件开发方法 代表性的敏捷开发方法Scrum(迭代式增量软件开发过程)为基础的方法论· Scrum · Scrum&#x2F;XP混合 · … 看板方法精益创业极限编程(XP)","tags":["笔记"],"categories":["本科课程"]},{"title":"软件工程导论学习笔记","path":"/2023/01/01/Java+软导笔记/软件工程导论学习笔记/","content":"作业题能力成熟度模型 软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 B.使用标准开发过程（或方法论）构建（或集成）系统 C.管理层寻求更主动地应对系统的开发问题 D.连续地监督和改进标准化的系统开发过程 解析：A基本管理属于2可重复级；C属于已管理级；D改进属于5优化级；B标准属于3已定义级 * 软件能力成熟度模型（CMM image.png的第 4 级（已管理级）的核心是 。 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 B.组织具有标准软件过程 C.对软件过程和产品都有定量的理解和控制 D.先进的新思想和新技术促进过程不断改进 解析：4已管理级关键词：定量，预测 软件过程模型 为了有效地捕获系统需求，应采用 . A.瀑布模型 B.V 模型 C.原型模型 D.螺旋模型 解析： 瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。该模型适用于项目开始时需求已确定的情况。 V 模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。 原型模型允许开发人员快速地构造整个系统或系统的一部分以理解或澄清问题。原型的用途是获知用户的真正需求，因此原型模型可以有效地引发系统需求。 螺旋模型把开发活动和风险管理结合起来，以将风险减到最小并控制风险。 演化模型在获取一组基本的需求后，通过快速分析构造出该软件的一个初始可运行版本，然后逐步演化成为最终软件产品。 增量模型是一种阶段化的软件开发过程模型。在该过程模型中，客户提出系统需求，并指出哪些需求是最重要的。开发团队把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成， 并且能完成特定的功能。其优点包括：能较短时间内向用户提交可完成一些有用的工作产品；逐步增加产品的功能，使用户有较充裕的时间学习和适应新产品；项目失败的风险较低；优先级最高的服务首先交付，然后依次将其他 构件集成进来，这意味着最重要的服务将接受最多的测试。快速发布 喷泉模型是典型的面向对象生命周期模型，是一种以用户需求为动力，以对象作为驱动的模 型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。“喷泉” 一词本 身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程 中不断地完善软件系统；无间隙是指在开发活动之间不存在明显的边界。 系统工程 经济可行性研究的范围包括（ ） A、技术有效性 B、管理制度 C、效益分析 D、开发风险 解析： 经济可行性主要进行成本效益分析，从经济角度，确定系统是否值得开发 技术可行性主要根据系统的功能、性能、约束条件等，分析在现有资源和技术条件下系统能否实现 法律可行性合同责任、侵犯专利权、版权等问题 （多选题）在对协同电子商务平台项目进行技术可行性分析的过程中需要注意哪些方面？ （ ） A、在限制条件下，功能目标是否能达到 B、利用现有技术，性能目标是否能够达到 C、对开发人员数量和质量的要求，并说明能否满足 D、在规定的期限内，开发是否能够完成 解析：根据软件设计文档国家标准（GB8567-2006）的要求，技术可行性章节应该主要包含 以下内容： 1.在当前的限制条件下，该系统的功能目标能否达到 2.利用现有的技术，该系统的功能能否实现 3.对开发人员的数量和质量的要求，并说明这些要求能否满足 4.在规定的期限内，本系统的开发能否完成 除了上述内容之外，技术可行性部分应该对当前开发所使用的主流研发框架和架构做简要的 介绍和说明，不限于图表和文字等方式。 为了分析顾客不同情况下的订票习惯，可采用以下哪种需求获取方式（ ） A、正式访谈 B、非正式访谈 C、调查表 D、观察实践 解析：错选C，使用观察实践，情景分析获取用户在不同场景下的不同需求。 结构化方法和数据流图 面向数据流自顶向下求精过程不包括 A、分析追踪数据流图 B、用户复查 C、细化数据流图 D、实现数据流图 软件工程与软件过程软件软件&#x3D;程序+数据+文档 计算机软件 计算机软件是指计算机系统中的程序及其文档 程序是计算任务的处理对象和处理规则的描述 文档是为了便于了解程序所需的阐明性资料 软件的特点 软件是一种逻辑实体，而不是有形的系统元件，其开发成本和进度难以准确地估算 软件是被开发或被设计的，没有明确的制造过程，一旦开发成功，只需复制即可，但其维护的工作量大 软件的使用没有硬件那样的机械磨损和老化问题 软件不能独立存在，需要依附于一定的环境(如硬件、网络以及其他软件等) 软件必须遵从人为的惯例，并适应已有的技术和系统。 软件需要随接口的不同而改变 软件的分类有多种分类方法。 基础设施类 系统软件 支持软件 应用类 应用软件 软件工程软件工程学科出现的主要原因是软件危机的出现 软件危机 一个合格的软件开发是按时按量按质实现软件 许多软件项目不能满足客户的要求 许多软件项目超出预算和时间安排 image.png image.png 软件工程的定义1968年NATO(北大西洋公约组织)会议上首次提出 计算机科学技术百科全书：软件工程是应用计算机 科学、数学及管理科学等原理，开发软件的工程。 软件工程借鉴传统工程的原则、方法，以提高质量、 降低成本为目的 软件生存周期软件有一个孕育、诞生、成长、成熟、衰亡的生存过程。这个过程即为计算机软件的生存周期 软件生存周期大体可分为如下几个活动： graph LR A(计算机系统工程) ---B(需求分析) B --- C(设计) C ---D(编码) D---E(测试) E---F(运行) F---G(维护) 软件过程模型(8种)image.png image.png 能力成熟度模型能力成熟度模型CMM原本是评估依据，后来用于改进软件管理过程 image.png 能力成熟度模型集成CMMI阶段式模型 (整体能力的划分)image-20220905211312772 连续式模型(某方面能力的衡量)image-20220905211353252.png image-20220905211407538 软件过程模型 软件过程模型 瀑布模型 增量模型 原型模型 螺旋模型 喷泉模型 基于构件的开发模型 形式化方法 特点 首先有完成核心基本需求，再逐步确定非核心；多个增量可叠加 反映系统性质的一个子集 风险驱动的软件过程模型，把开发活动和风险管理结合起来，以将风险减到最小并控制风险 基于面向对象思想、迭代、无间隙。模型各个阶段没有明显界限，开发人员同步进行开发 利用预先包装的构件来构造应用系统 是建立在 严格数学基础上。开发过程重凡是采用严格 的数学语言，具有精确的数学语义的方法，都称为形 式化方法 适用场景 项目开始前需求和解决方案就很明确，短期或中期项目 不完全明确但知道核心需求，急需使用的软件，需求经常变化 要从用户身上了解主要需求，周期是一个环型，可废弃上一个原型或在其基础上追加 适应于面向对象的软件开发过程，以对象为驱动，只用对象和关系实现活动的迭代和无间隙 构件化结构，可以尽量重用已有的组件。 对安全性、可靠性极高 优缺点 缺：缺乏灵活性、维护代价大 各增量构件均为一个可操作产品。融合了瀑布模 型的基本成分（重复地应用）和演化模型的迭代特征，特别适用于需求经常发生变化的软件开发。 用户需要方面，重交互。缩短了开发周期，加快了工程进 度，降低成本。 将原型实现的迭代特征与瀑布模型中控制的和系统化的方面结合起来， 不仅体现了这两种模型的优点，而且增加了风险分析 可以提高软件 项目开发效率，节省开发时间 减少开发、降低风险和成本、需求妥协、快速交付 易于发现需求的歧义性、不完整性和不一致性，易于对分析模型、 设计模型和程序进行验证。 瀑布模型项目需求方案明确，短期小型工程 从下到上很难，不适用需求经常换的 image-20220905211552135 image-20220905211651996 image-20220905211703289 演化模型开发早期对软件需求的认识是模糊的、不确定的，因此软件很难一次开发成功。逐步演化而来 开发的软件，需求不能一次搞清楚，且系统需求比较复杂？ 答案：用演化模型 graph LR A{演化模型}-->B(增量模型) A-->C(原型模型) A-->D(螺旋模型) 增量模型每次增量都可用，有核心需求，急需使用的软件。多个增量可重叠 image-20220905212334175 适用于需求经常发生变化的软件开发 第一个增量通常是核心产品 image-20220905212549792 原型模型原型（prototype）是预期系统的一个可执行版本，反映 了系统性质（如功能、计算结果等）的一个选定的子集。 image-20220905212656390 特点： 用户不能完全准确表达对未来系统的全面要求 开发者对要解决的问题的应用问题模糊不清 一圈出来一个版本 类型： 探索型 实验型 演化型 image-20220905212802183 增量模型和原型模型的区别核心都是迭代，但增量模型强调各增量构建均是一个可操作产品。原型模型不断讨论修改完善。 image-20220905212909013 image-20220905213105101 螺旋模型 有风险机制 image-20220905213228769 image-20220905213239716 image-20220905213315281.png 喷泉模型 像喷泉从下往上，后面的工作在做前面的也没停止 基于面向对象思想，迭代、无间隙 注意，面向对象不是喷泉独有的，其他一些模型也有 基于构件的开发模型image-20220905213500212.png image-20220905213513555.png 形式化模型建立在严格数学基础上 image-20220905213521544.png CASE工具和环境的重要性CASE 已被证明可以加快开发速度,提高应用软件生产率并保证应用软件的可靠品质。计算机专业人员利用计算机使他们的企业提高了效率,企业的各个部门通过使用计算机 提高了生产率和效率,增强了企业的竞争力并使之带来了更多的利润。 系统工程系统工程的任务 识别用户的要求 识别基于计算机系统的整体要求 标识系统的功能和性能范围 确定系统的功能、性能、约束和接口 系统建模和模拟 考虑以下模型： 硬件系统模型 软件系统模型 人机接口模型 数据模型 成本估算及进度安排 需要一定的资金投入和时间约束 进行成本估算 作出进度安排 可行性分析 主要从经济、技术、法律等方面分析所给出的解决方案是否科学。 生成系统规格说明 作为以后开发基于计算机的系统的依据 可行性分析的任务 经济可行性：确定系统是否值得开发 成本 效益 货币的时间价值 投资的回收期 纯收入 技术可行性：分析系统在现有资源和条件下能否实现 风险分析 资源分析 技术分析 法律可行性：是否引起侵权、破坏等责任问题 方法的选择和折衷 需求工程需求工程的具体步骤和任务 需求获取 系统分析人员通过与用户的交流 对现有系统的观察及时对任务进行分析 需求分析与协商： 分析每个需求与其他需求的关系以检查需求的一致性、重叠和遗漏的情况 并根据用户的需求对需求进行排序 系统建模 通过合适的工具和符号系统地描述需求 需求规约 给出对目标软件的各种需求 需求验证 对功能的正确性、完整性和清晰性以及其他需求给予评价 需求管理 对需求工程所有相关活动的规约和控制 制定需求获取策略主要考虑因素 功能需求 考虑系统要做什么，在何时做 在合适及如何修改或升级 性能需求 考虑软件开发的技术性指标 用户或人为因素 考虑用户的类型 需求获取的方法和策略 建立顺畅的通信途径 访谈与调查 亲身实践 会议 头脑风暴 概念建模 原型、仿真 自省 用户行为数据在线采集 设计工程软件设计原则image.png 抽象与逐步求精抽象 在最高层用术语概括性描述 在中间层次用面向过程化方法 在最低层用直接实现的方式 抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面 分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止 随着分解层次的增加，抽象的级别越来越低，也越接近问题的解(算法和数据结构) 模块化模块化：就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成 一个整体，可以完成指定的功能满足用户的需求。 如果一个大型程序仅由一个模块组成，它将很难被人所理解。 “分而治之” 问：程序采用模块化设计，有哪些优点？ 答：程序采用模块化设计，有以下优点： 将问题简化，划分模块可使每一个模块完成单一的功能， 模块之间的联接关系简单，具有独立性； 可以独立的进行模块的编码测试，便于软件开发工作的组织； 把每一个模块要解决的问题局限在有限的范围，减少出错 机会，易于修改和维护； 有助于软件项目的组织管理，一个复杂的大型软件可以由许多程序员分工编写，提高了开发效率； 一个模块可被重复使用，以提高软件产品的复用率； 利于估计工作量和开发成本。 信息隐藏David Parnas在1972年最早提出信息隐藏的观点。 他在其论文中指出：代码模块应该采用定义良好的接口来封装，这些模块的内部结构应该是程序员的私有财产，外部是不可见的。 image.png image.png 功能独立功能独立：功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果。 两个定性标准: 内聚衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高， 每个模块完成一个相对独立的特定子功能。 耦合衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低， 即每个模块和其他模块之间的关系要简单。 内聚紧密程度 image.png 逻辑内聚 image.png 时间内聚：初始化 image.png 过程内聚：按任务的顺序 image.png 通信内聚：模块的功能都要做，但数据集都是同一个(和逻辑内聚区分) image.png 顺序内聚：既要按任务的顺序，一个的输出要作为另一个的输入 image.png 功能内聚：只完成一项工作 image.png 通信内聚和逻辑内聚区分：前者数据集都是同一个，但是逻辑内聚也可以同一个数据集，这时看是否有传入参数来决定执行的操作。 耦合相互依赖程度 image.png image.png 内容耦合 公共耦合 image.png 外部耦合 image.png 控制耦合 image.png 标记耦合 image.png 数据耦合 例如中途调用的函数 image.png 非直接耦合 image.png 标记耦合传的是数据结构的一部分，如数组、字符串等，而数据耦合传的是简单数据 高内聚，低耦合 结构化程序设计方法详细描述处理过程常用工具：图形、表格和语言 图形：程序流程图、N-S图、PAD图 表格：判定表 语言：过程设计语言(PDL) image-20221222113658687.png 结构化分析方法 结构化方法：它以数据流为中心构建软件的分析模型和设计模型 结构化分析与建模：主要思想：抽象与自顶向下的逐层分解（控制复杂性的两个基本手段） 抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面。 分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止。 结构化系统分析模型组成结构有： E-R图 数据流图(DFD) 状态变迁图(STD图) 数据字典(DD) 数据流图主要思想：数据流图描述输入数据流到输出数据流的变换（即加工），用于对系统的功能建模。 符号： ⚪或椭圆 表示加工，也叫数据处理 ▭ 矩形表示数据流的源点或终点，统称外部实体 ＝ 双杠，文件或数据存储 → 箭头表示数据流 使用数据流图进行需求分析的过程： 画出系统的输入和输出。 A. 确定源和宿 B. 确定加工 C. 确定数据流 :输入数据流，输出数据流 D. 顶层图通常没有文件 画出系统内部。 A. 确定加工 ：确定父图中某加工分解而成的子加工 B. 确定数据流 ：沿用或新增 C. 确定文件 D. 确定源和宿 画出加工内部。 重复第 3 步，直至每个尚未分解的加工都足够简单（即不必再分解）。 image.png 1f10dc03d569bb00e848cdecb12578d.jpg 画顶层图 顶层图有唯一的加工：椭圆表示 系统之外的源或宿(外部实体)：矩形表示 image.png 步骤： 确定唯一加工 确定功能需求和外部实体(源或宿) 确定数据流：系统的输入&#x2F;输出信息 画0层图步骤： 确定加工：确定父图中某加工分解而成的子加工 根据功能分解来确定加工：将一个复杂的功能分解成若干个较小的功能，较多应用于高层DFD中的分解 image.png 确定源和宿 image.png 确定数据流 沿用父图 新增数据流 ​ image.png image.png 确定文件 已有文件则应画在子图中 分解子图中，若需要保存某些中间数据以备后用，则可以讲这些数据组成一个新的文件 新文件至少应有一个加工为其写入记录，同时至少存在另一个加工来读该文件。 image.png 画1层图(画加工内部)复杂的加工可以继续分解为一张DFD子图 分解方法： 指定图中的某一个加工看作一个小系统，系统的输入输出流就是这个加工的输入输出流 然后采用画0层图的方法，画出该加工的子图 加工1子图内部，即考试报名内部 image.png 加工2子图，即统计成绩 image.png 总结画分层数据流图的步骤： 画系统的输入和输出 画系统内部 画加工内部 重复第3步，直至每个尚未分解的加工都足够简单 (即不必再分解) 注意：千万不要试图在数据流图中表现分支条件或循环，这样会造 成混乱，画不出正确的数据流图。 检查分层细化时是否保持信息的连续性，即当把一个处理分解成一 系列处理时，分解前和分解后的一系列输入输出数据流必须相同， 这条规则也成为数据流图的数据平衡原则。 审查完整性： 每个加工至少有一个输入数据流和一个输出数据流 分层数据流图，每个文件应至少有一个加工读取该文件，有另一个加工写该文件 画的是数据流而不是控制流 数据字典判定表确定四个区域的内容 image.png 简化标准： 具有相同的操作 有且仅有一个不同的取值，简化后用小横杠表示，如本题简化后第四列第一个 判定树image.png 根节点是加工过 最右边是具体的部分 中间的部分都是影响条件 模块结构图image-20221024114704451.png 注意： 模块之间相连的线段(调用)是没有方向的，有方向的是数据流 结构图基本成分：模块，调用，数据 类树形结构 image.png 扇入是别人调用他的个数 扇出是他调用别人的个数 含义 深度和宽度在一定程度上反映了程序的规模和复杂程度 一个模块的扇出过大通常意味着该模块比较复杂，然而扇出太少可能导致深度增加 一个模块的扇入表示有多少模块可直接调用它，它反映了该模块的复用程度，因此模块的扇入越大越好 面向数据结构的分析与设计什么是面向数据结构的方法面向数据结构的方法是· 以数据结构为中心 · 从输入&#x2F;输出的数据结构导出程序结构的 · 一种软件需求分析与设计的方法 特点· ①以信息对象及其操作作为核心进行需求分析 · ②认为复合信息对象具有层次结构，并且可按顺序、选择、重复3种结构分解为成员对象信息 · ③提供由层次信息结构映射为程序结构的机制，从而为软件设计奠定良好的基础 Jackson图的三种结构顺序元素clip_image002-16726347926341.jpg 1.1.1. 选择元素clip_image004.jpg 1.1.2. 重复元素clip_image006.jpg 面向对象方法基础UMLimage.png image.png image.png image.png UML语言中的关系· 关联 · 依赖 · 泛化 · 实现 · 聚合 · 组合 UML包含的视图(红色为已学)结构化静态视图• 类图(class) • 展示类与类之间的相互联系，如关联、依赖、泛化等。可以把若干个相关类包装在一起作为一个单元(包)，相当于一个子系统。。 • 一个系统可以有多张类图，一个类也可以出现在几张类图中 • 对象图是类的实例。区分：对象图在对象名下面加了下划线，同时显示对象间的实例连结关系 • 类 • 类间关系 • 四种 • 依赖 • —&gt; 被依赖元素的变化会要求或指示依赖元素的改变(例如类A的方法仅仅使用了类B的对象，那么类A依赖于类B) • 访问 • 绑定 • 调用 • 创建 • 派生 • 实例化 • 允许 • 实现 • 精化 • 发送 • 使用 • 关联(聚集、组合) • 对象与其他实例的连接 • 聚集 ——♢ “部分”对象可以是任意整体对象的一部分 • 组合 ——◆ 更强形式的关联，具有强的物主身份，即“整体”对象拥有“部分”对象(例如类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系) • 是一种拥有的关系，它使一个类知道另一個类的属性和方法；如：老师与学生，丈夫与妻子的关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者沒有箭头，单向的关联有一个箭头。 • 泛化 —▷ 继承，由子类指向父类 • 实现 —▷ 类连接到接口，接口是行为规划而不是结构 • 强度：依赖&lt;关联&lt;聚集&lt;组合&lt;泛化&#x3D;实现，类间关系依次增强 属性和操作 • 属性中的变量名要小写 主要版型 • 边界类 • 控制类 • 实体类 设计视图 • 内部结构(internal structure) • 协作图(collaboration) • 构件图(component) 用况视图 • 用况图(use case) • 展示各类外部执行者与系统提供的用况之间的连接。用况图给出用户所感受到的系统行为，但不描述系统如何实现该功能 • 用况–系统的功能，执行者–使用功能的人或外部系统 • 主要元素 • 参与者 • 用例 • 关系 • 关联 ——————————— • 包含 ——&lt;&gt;—— • 扩展 ——&lt;&gt;—— • 泛化 ——————————▷ 动态的 • 状态机视图 状态机图(state machine) 通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。 状态的改变成为迁移(transition)。一个状态迁移还可以有与之相关的动作，该动作指出状态迁移时应做什么。 不是所有的类都要画状态，应当满足这些条件才画 有一些意义明确的状态 其行为受不同的状态所影响和改变 • 活动视图 活动图(activity) 描述完成一个操作(如用况)所需要的活动 由动作状态组成 完成一个动作的活动的规约 一个动作完成时，离开该动作状态 消息发送和接收的规约 • 交互视图 顺序图(sequence) 展示几个对象之间的动态交互关系。 主要显示:对象之间发送消息的顺序，显示对象之间的交互，即系统执行的某一特定点所发生的事 通信图(communication) · 物理的 部署视图 部署图(deployment) · 模型管理 模型管理视图 包图(package) 剖图 包图(package) UML包括哪四种事物？· 1.结构事物 • 类 • 接口 • 用例 • 主动类 • 构件 • 结点等 · 2.动作事物 • 状态等 · 3.组织事物 • 包 · 4.注释事物 • 给建模者提供信息，提供关于任意信息的文本说明，但没有语义作用 面向对象建模用况建模执行者，用况 用况是执行者想要做的事，执行者执行用况 线段带箭头表示发起的方向 注意扩展关系是扩展指向用况 泛化(归纳)关系是子用况指向父用况，类似继承 实验****5 面向对象方法的应用（1） 用况建模 （1） 实验目的 掌握UML用况图的画法，学习在软件构思和需求分析阶段进行用况建模，学会填写相关文档。 （2） 实验原理 ü 统一建模语言 统一建模语言（UML）是一种用来对真实世界物体进行建模的标准标记，这个建模的过程是开发面向对象设计方法的第一步。 UML从考虑系统的不同角度出发，定义了用况****图、类图、对象图、状态图、活动图、序列图、协作图、构件图、部署图等图形，这些图从不同的侧面对系统进行描述。系统模型将这些不同的侧面综合成一致的整体，便于系统的分析和构造。尽管UML和其它开发工具还会设计出许多派生的视图，但上述这些图和其它辅助性的文档是软件开发人员所见的最基本的构造。 UML适用于系统开发过程中从需求规格描述到系统完成后测试的不同阶段。在需求分析阶段，可以用用况来捕获用户需求。通过用况建模，描述对系统感兴趣的外部角色及其对系统（用况）的功能要求。分析和设计阶段主要关心问题域中的主要概念（如类和对象等）和机制，需要识别这些类以及它们相互间的关系，并用UML类图来描述。为实现用况，类之间需要协作，这可以用UML动态模型来描述。 ü 用况模型 用况图定义：由执行者（Actor）、用况（Use Case）以及它们之间的关系构成的用于描述系统功能的静态视图称为用况图。用况图（User Case Diagram）是被称为执行者的外部实体所能观察到的系统功能的模型图，呈现了一些执行者和一些用例，以及它们之间的关系，展示了用况之间以及与执行者之间是怎样相互联系的，主要用于对系统、子系统或类的功能行为进行建模。用况图定义了系统的功能需求，它是从系统的外部看系统功能，并不描述系统内部对功能的具体实现。 用况图由执行者（Actor）、用况（Use Case）、系统边界、箭头组成，用画图的方法来完成。 执行者（Actor） 定义：执行者（Actor）不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此执行者可以是人，可以是事物，也可以是时间或其他系统等等。还有一点要注意的是，参与者不是指人或事物本身，而是表示人或事物当时所扮演的角色。比如小明是图书馆的管理员，他参与图书馆管理系统的交互，这时他既可以作为管理员这个角色参与管理，也可以作为借书者向图书馆借书，在这里小明扮演了两个角色，是两个不同的执行者。 画法：执行者在Visio称为“参与者”，在画图中用简笔人物画来表示，人物下面附上执行者的名称。执行者的命名，通常是一些角色名，或者系统设备名等。 wps1.png 用况 定义：是对包括变量在内的一组动作序列的描述，系统执行这些动作，并产生传递特定执行者的价值的可观察结果。这是UML对用况的正式定义，对我们初学者可能有点难懂。我们可以这样去理解，用况是执行者想要系统做的事情。 画法：用况在Visio称为“用例”，在画图中用椭圆来表示，椭圆下面附上用况的名称。对于用况的命名，我们可以给用况取一个简单、描述性的名称，一般为带有动作性的词。 wps2.png 系统边界 定义：系统边界是用来表示正在建模系统的边界。边界内表示系统的组成部分，边界外表示系统外部。 画法：可使用Visio的“子系统”画系统边界，因为系统边界的作用有时候不是很明显，所以在画图时可省略。系统边界在画图中用方框来表示，同时附上系统的名称，执行者画在边界的外面，用况画在边界里面。命名时使用系统或子系统的名称就可以了。 wps3.png 用况图中的关系 定义：用况图中可表示执行者和用况之间，用况与用况之间，执行者与执行者之间的多种关系。 关联关系：执行者与用况之间的关系，表示用况是这个执行者发起的，执行者可以行使系统中的这个功能。关联关系在Visio中就称为“关联”，为一条不带箭头的线段。 wps4.png 包含关系：用况与用况之间的关系。基用况必须和被包含用况一起使用才够完整，被包含用况也必然被执行。包含关系在Visio中就称为“包含”，使用带箭头的虚线表示（在线上标注《》），箭头从基用况指向被包含用况。 wps5.png 扩展关系：用况与用况之间的关系。扩展用况是对基用况（被扩展用况）的扩展，即使没有扩展用况的参与，也可以完成一个完整的功能。扩展关系在Visio中就称为“扩展”，使用带箭头的虚线表示（在线上标注《》），箭头从扩展用况指向基用况（被扩展用况）。 wps6.png 泛化关系：同类元素之间的关系，如用况与用况之间，执行者与执行者之间。类似面向对象中的继承关系。泛化关系在Visio中称为“归纳”，用实线+空心三角形表示，空心三角形指向父，子可以继承父所有的行为。 用况图 用况图主要的作用有三个：（1）获取需求；（2）指导测试；（3）还可在整个过程中的其它工作流起到指导作用。 用况图用况图是从程序员角度描述系统的功能？错 静态建模类图和对象图 对象图是类图的实例 类之间的关系有关联、依赖、泛化、实现等 类图是一种静态模型，是其他图的基础 一个系统可以有多张类图，一个类也可以出现在几张类图中 如何用UML表示一个类类又名称，属性和操作组成 名称唯一，一般采用双驼峰命名法 属性，操作首字母通常小写，单驼峰 属性的语法：属性名：类型&#x3D;初始值 例如：maxCount:Interger&#x3D;0 操作的语法：操作名 (参数表)：返回类型 例如：method1(Object par):void 类之间的关系— 关联 –&gt; 依赖 —▷泛化 需要协助 –▷ 实现 重数：表示这个类的多少个实例对象可以与另一个类的一个实例关联 允许一个类与自身关联 状态图和活动图什么是状态图？· 通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。 状态图的组成元素· 状态 · 状态之间的迁移 · 分支 · 状态内的迁移 · 复合状态 活动图什么是活动图？· 描述完成一个操作(如用况)所需要的活动 活动图的组成元素· 活动 · 泳道 · 分支 · 分岔和汇合 · 对象流 1.1. 顺序图1.1.1. 什么是顺序图？展示几个对象之间的动态交互关系 1.1.2. 顺序图1.组成 • ①对象 • ②生命线 • ③激活 • ④消息(其中描述消息语法不是重点) • ⑤组合片段 2.带条件和分支的顺序图 3.带约束的顺序图 4.带循环和自身消息的顺序图 5.创建对象和删除对象的顺序图 结构化控制结构6.带组合片段的顺序图 • 组合片段是矩形的，注意其覆盖的高度和宽度，高度对应时长，宽度对应覆盖的对象 • 框住一个范围，也可以嵌套 7.网上在线订购的顺序图 买饮料的顺序图第九章 基于构件的软件开发什么是构件软件构件是软件系统中具有相对独立功能，可以明确标识，接口由规约指定，与语境有明显依赖关系，可独立部署，且多由第三方提供的可组装软件实体。 可复用构建是指具有可复用价值的构件可变性分析构件应具有较强的通用性和可变性为了满足不同的复用需求，需要在构件复用时可能发生变化的一个或多个位置上标识变化点，同时为变化点附加一个或多个变体 基于构建的软件开发过程领域工程步骤(生产构建)1领域分析 2建立领域特定的基准体系结构模型 3标识候选构件 4泛化和可变性分析 5构件重构 6构件的测试 7构件的包装 8构件的入库 应用系统工程的步骤(使用构件)1建立应用系统的体系结构模型 2寻找候选构件 3评价和选择合适的构件 4构件的修改和特化 5开发未被复用的部分 6构件的组装 7集成测试 8评价被复用的构件，并推荐可能的新构件 clip_image002-16726355802722.jpg 第十章 敏捷软件开发什么是敏捷开发方法敏捷开发是一种基于更紧密的团队协作、能够有效应对快速变化需求、快速交付高质量软件的迭代和增量的新型软件开发方法 代表性的敏捷开发方法Scrum(迭代式增量软件开发过程)为基础的方法论· Scrum · Scrum&#x2F;XP混合 · … 看板方法精益创业极限编程(XP)","tags":["笔记"],"categories":["本科课程"]},{"title":"用ChatGPT写一个刷题软件","path":"/2022/12/12/用ChatGPT写一个刷题软件/","content":"起因昨天下午准备复习毛概，但是想到期末考试都是选择题，我就在想能不能做一个刷题脚本。简单考虑了一下，打算做一个网页，如果自己写需要一些时间。emmm，我可以让ChatGPT帮我做一个！ 我在聊天框里大致输入是这样的：“用javascript，写一个做题软件，题库以JSON格式存储，题与题空行间隔，每一题有四个答案，每个答案独立一行，正确答案在题目的最后一行，用户点击选项后有答对或答错的反馈并显示正确答案，还可以点击按钮进入下一题，点击按钮退出程序‘’ 结果就有了这个刷题软件，我将它放到了博客上：接受洗礼吧！ (jjuprising.github.io) 主要功能实现脚本充分利用了dom。 1.程序逻辑大致是首先准备一个题库数组，每个题目是对象的形式，包括题目、选项数组、正确答案，都是字符串的形式。 2.打开页面后会通过伪随机数随机在题库数组中抽取一个元素，通过dom渲染到页面上。每一个选项是一个&lt;li&gt;，监听选项点击事件，通过比对点击的&lt;li&gt;和正确答案(字符串)判断正误。 3.监听”下一题“点击事件，重复抽取题目和监听选项点击的操作 我在原代码上添加了样式调整了布局，同时修改了一个bug，ChatGPT给的代码中，”下一题”事件的选项的变量用错了，用成了旧的。这也说明ChatGPT给出的代码不完全对的，这也是 Stack Overflow ban掉它的原因之一。 题库实现当我手动修改题库数组时，我想到为什么不能将文本转为json呢(主要是想到之前舍长在编辑易班题库的时候通过上传txt就能生成题目)，于是，又借用ChatGPT，弄了一个txt生成json的脚本。 主要利用FileReader()和之前提到的Blob大致逻辑如下： 1.读入文本，通过\\r 分割文本，每行作为一个数组元素 2.遍历每行文本，如果当前行不为空，将其作为一道题。读取题目和四个选项，以及最后一行的答案，将题目添加到题库数组 3.将题库数组转换为JSON字符串，并保存为文件 代码题库12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!-- turnJson.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;turnJson&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;file&quot; id=&quot;file-input&quot;&gt; &lt;script&gt; // 定义题库数组 const quizData = []; // 读取题库文件 const fileInput = document.getElementById(&quot;file-input&quot;); fileInput.addEventListener(&quot;change&quot;, () =&gt; &#123; // 获取题库文件 const file = fileInput.files[0]; // 创建文件阅读器 const reader = new FileReader(); // 监听文件阅读完成事件 reader.addEventListener(&quot;load&quot;, () =&gt; &#123; // 获取文件内容 const txt = reader.result; // 按行分割文本 const lines = txt.split(&quot;\\r &quot;); // 遍历每一行文本 for (let i = 0; i &lt; lines.length; i++) &#123; const line = lines[i]; // 如果当前行不为空，则将其作为一道题目 if (line.trim() !== &quot;&quot;) &#123; // 解析题目内容 const question = line; // 读取四个答案 const answers = []; for (let j = 0; j &lt; 4; j++) &#123; const answerLine = lines[i + j + 1]; answers.push(answerLine); &#125; i += 5; // 解析题目答案 const correctAnswer = lines[i]; // 读取下一行，如果下一行为空行，则说明当前题目已经读取完成 const nextLine = lines[i + 1]; if (nextLine === &quot;&quot;) &#123; i++; &#125; // 将题目添加到题库数组 quizData.push(&#123; question, answers, correctAnswer, &#125;); &#125; &#125; // 将题库数组转换为 json 字符串 const json = JSON.stringify(quizData); // 将 json 字符串保存为文件 const a = document.createElement(&quot;a&quot;); const blob = new Blob([json], &#123; type: &quot;text/json&quot; &#125;); a.href = URL.createObjectURL(blob); a.download = &quot;quiz.json&quot;; a.click(); &#125;); // 读取文件内容 reader.readAsText(file); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 刷题功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;!-- quiz.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;接受洗礼吧！&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;quiz.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;QuizTable&quot;&gt; &lt;h1&gt;单选题&lt;/h1&gt; &lt;div id=&quot;quiz&quot; class=&quot;quiz&quot;&gt; &lt;!-- &lt;p&gt;What is the capital of France?&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Paris&lt;/li&gt; &lt;li&gt;London&lt;/li&gt; &lt;li&gt;Madrid&lt;/li&gt; &lt;li&gt;Rome&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;p id=&quot;result&quot; class=&quot;result&quot;&gt;&lt;/p&gt; &lt;button id=&quot;quit&quot; type=&quot;button&quot;&gt;Quit&lt;/button&gt; &lt;button id=&quot;next&quot; type=&quot;button&quot;&gt;Next&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //设置题目布局 // const body=document.getElementsByName(&quot;body&quot;); // const width=body.width; // const height=body.height; // const QuizTable=document.getElementById(&quot;QuizTable&quot;); // QuizTable.style.left=width/2; // QuizTable.style.top=height/2; // 获取题库数组 const quizData = [ &#123; &quot;question&quot;: &quot;( )标志着毛泽东思想的初步形成.&quot;, &quot;answers&quot;: [ &quot;A.提出并阐述农村包围城市,武装夺取政权思想&quot;, &quot;B.《井冈山的斗争》&quot;, &quot;C.《星星之火,可以燎原》&quot;, &quot;D.《反对本本主义》&quot; ], &quot;correctAnswer&quot;: &quot;A.提出并阐述农村包围城市,武装夺取政权思想&quot; &#125;, //其他题目 ]; // 从题库中随机抽取一道题目 const quizIndex = Math.floor(Math.random() * quizData.length); const quiz = quizData[quizIndex]; console.log(quizIndex); // 显示题目和选项 const quizElement = document.getElementById(&quot;quiz&quot;); quizElement.innerHTML = ` &lt;p&gt;$&#123;quiz.question&#125;&lt;/p&gt; &lt;ul&gt; $&#123;quiz.answers .map( (answer) =&gt; `&lt;li&gt;$&#123;answer&#125;&lt;/li&gt;` ) .join(&quot;&quot;)&#125; &lt;/ul&gt; `; // 监听答案点击事件 const answerElements = quizElement.querySelectorAll(&quot;li&quot;); for (let i = 0; i &lt; answerElements.length; i++) &#123; const answerElement = answerElements[i]; answerElement.addEventListener(&quot;click&quot;, () =&gt; &#123; // 检查答案是否正确 const isCorrect = quiz.correctAnswer === answerElement.innerText; const resultElement = document.getElementById(&quot;result&quot;); if (isCorrect) &#123; resultElement.innerText = &quot;正确的。 答案是: &quot; + quiz.correctAnswer; resultElement.style.color = &quot;green&quot;; &#125; else &#123; resultElement.innerText = &quot;错误的！ 正确答案是: &quot; + quiz.correctAnswer; resultElement.style.color = &quot;red&quot;; &#125; &#125;); &#125; // 监听“下一题”按钮点击事件 const nextButton = document.getElementById(&quot;next&quot;); nextButton.addEventListener(&quot;click&quot;, () =&gt; &#123; // 随机抽取下一道题目 const nextQuizIndex = Math.floor(Math.random() * quizData.length); const nextQuiz = quizData[nextQuizIndex]; console.log(nextQuizIndex); // 显示题目和选项 const quizElement = document.getElementById(&quot;quiz&quot;); quizElement.innerHTML = ` &lt;p&gt;$&#123;nextQuiz.question&#125;&lt;/p&gt; &lt;ul&gt; $&#123;nextQuiz.answers .map( (answer) =&gt; `&lt;li&gt;$&#123;answer&#125;&lt;/li&gt;` ) .join(&quot;&quot;)&#125; &lt;/ul&gt; `; const answerElements = quizElement.querySelectorAll(&quot;li&quot;); for (let i = 0; i &lt; answerElements.length; i++) &#123; const answerElement = answerElements[i]; answerElement.addEventListener(&quot;click&quot;, () =&gt; &#123; // 检查答案是否正确 const isCorrect = nextQuiz.correctAnswer === answerElement.innerText; const resultElement = document.getElementById(&quot;result&quot;); if (isCorrect) &#123; resultElement.innerText = &quot;正确的。 答案是: &quot; + nextQuiz.correctAnswer; resultElement.style.color = &quot;green&quot;; &#125; else &#123; resultElement.innerText = &quot;错误的！ 正确答案是: &quot; + nextQuiz.correctAnswer; resultElement.style.color = &quot;red&quot;; &#125; &#125;); &#125; // 清空答题结果 const resultElement = document.getElementById(&quot;result&quot;); resultElement.innerText = &quot;&quot;; &#125;); // 监听“退出”按钮点击事件 const quitButton = document.getElementById(&quot;quit&quot;); quitButton.addEventListener(&quot;click&quot;, () =&gt; &#123; // 退出程序 window.close(); &#125;); &lt;/script&gt;&lt;/body&gt;","tags":["html","javascript"]},{"title":"数据结构学习笔记","path":"/2022/11/16/数据结构学习笔记/","content":"错题 【栈和队列】栈和队列的共同特点是只允许在端点插入和删除元素。 【循环队列】数组Q[n]用来表示一个循环队列，front为队头元素的前一个位置，rear为队尾元素的位置，计算队列中元素个数的公式为:（rear-front)%n （rear-front+n）%n 。 虽然数学上没错，但负整数求模结果可能因为编译器环境不同而不同。 【KMP】设目标串为s&#x3D;“abcabababaab”，模式串为p&#x3D;“babab”，则KMP模式匹配算法的next数组为[-1,0,1,2] [-1,0,0,1,2] 。 next数组是看当前元素的前面的子串，如p[0]是b，记-1；p[1]为a，前面是b，无相同前后缀，记0；p[2]是b，前面是ba也记0，以此类推。 算法分析的目的是分析算法的效率以求改进 1.请写出单链表的插入和删除算法。 1234567891011121314151617181920212223242526272829303132333435363738394041//插入算法 template &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::Insert(int i,DataType x)&#123;\tNode&lt;T&gt;*p=first-&gt;next;\tNode&lt;T&gt;*s=nullptr;\tint count=0;\twhile(p!=nullptr&amp;&amp;count&lt;i-1)&#123; p=p-&gt;next; count++; &#125;\tif(p==nullptr) throw &quot;插入位置错误！&quot;;\telse&#123; //插入操作 s=new Node&lt;T&gt;; s-&gt;data=x; s-&gt;next=p-&gt;next; p-&gt;next=s;\t&#125;&#125;//删除算法 template &lt;typename DataType&gt;DataType LinkList&lt;DataType&gt;::Delete(int i)&#123;\tNode&lt;DataType&gt;*p=first;\tNode&lt;DataType&gt;*s=nullptr;\tDataType x;\tint count=0;\twhile(p!=nullptr&amp;&amp;count&lt;i-1)&#123; p=p-&gt;next; count++; &#125;\tif(p==nullptr||p-&gt;next==nullptr) throw &quot;删除位置错误！&quot;;\telse&#123; //删除操作 s=p-&gt;next; x=p-&gt;data; p-&gt;next=s-&gt;next; delete s; return x; &#125;&#125; 2.请写出单链表的构造算法。（头插法、尾插法） 1234567891011121314151617181920212223242526272829//头插法template &lt;typename T&gt;LinkList&lt;T&gt;::LinkList(T a[],int n)&#123;\tfirst=new Node&lt;T&gt;;\tfirst-&gt;next=nullptr;//初始化\tfor(int i=0;i&lt;n;i++)&#123; Node&lt;T&gt;* s=nullptr; s=new Node&lt;T&gt;; s-&gt;data=a[i]; s-&gt;next=first-&gt;next; first-&gt;next=s;\t&#125;&#125;//尾插法template &lt;typename T&gt;LinkList&lt;T&gt;::LinkList(T a[],int n)&#123;\tfirst=new Node&lt;T&gt;;\tNode&lt;T&gt;*r=first,*s=nullptr;\tfor(int i=0;i&lt;n;i++)&#123; //遍历数组赋值 s=new Node&lt;T&gt;; s-&gt;data=a[i]; r-&gt;next=s; r=s; &#125;\tr-&gt;next=nullptr;&#125; 3.请写出顺序表的插入和删除算法。 123456789101112131415161718192021222324//注意元素编号和存储位置的关系//插入template &lt;typename T&gt;void Seqlist::Insert(int i,T x)&#123;\tif(length==MaxSize) throw &quot;上溢&quot;; if(i&gt;length+1||i&lt;1) throw &quot;插入位置有误！&quot;;\tfor(int j=length;j&gt;=i;j++)&#123; data[j]=data[j-1];\t&#125;\tdata[i-1]=x;\tlength++;&#125;//删除 template &lt;typename T&gt;T SeqList&lt;T&gt;::Delete(int n)&#123;\tif(length==0) throw “下溢”;\tif(n&gt;Length||n&lt;1) throw &quot;删除位置有误&quot;;\tT x=data[n];\tfor(int i=n;i&lt;Length;i++)&#123; data[i-1]=data[i];\t&#125;\tLength--;\treturn x;&#125; 4.请写出链队列的入队和出队算法。 123456789101112131415161718192021222324//入队 从尾入template &lt;typename T&gt;void LinkQueue::EnQueue(T x)&#123;\tNode&lt;T&gt;*s=nullptr;\ts=new Node&lt;T&gt;;\ts-&gt;data=x;\ts-&gt;next=nullptr;\trear-&gt;next=s;\trear=s;&#125;//出队 从头出template &lt;typename T&gt;T LinkQueue&lt;T&gt;::DeQueue()&#123;\tT x;\tNode&lt;T&gt;*p=nullptr;\tif(rear==front) throw &quot;下溢&quot;;\tp=front-&gt;next;\tx=p-&gt;data;\tfront-&gt;next=p-&gt;next;//摘链\tif(p-&gt;next==nullptr) rear==front;//判空\tdelete p;\treturn x;&#125; 绪论 数据元素是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。 数据项是数据的最小单位，数据元素是讨论数据结构时涉及的最小数据单位。 从逻辑关系上讲，数据结构主要分为集合、线性结构、树结构和图结构。 数据的存储结构主要有顺序存储结构和链接存储结构两种基本方法，所有存储结构都要存储两方面内容：数据元素和数据元素之间的关系 数据元素之间的逻辑关系在顺序存储结构中由存储位置表示，在链接存储结构中由指针表示。 算法具有五个特性，分别是①有零个或多个输入②有一个或多个输出③有穷性④确定性⑤可行性 算法的可行性是描述算法的每一条指令可以转换为某种程序设计语言对应的语句，并在计算机上可以执行。 算法的描述方法通常有自然语言，程序设计语言，流程图和伪代码四种。伪代码被称为算法语言。 算法什么是算法？· 算法是对特定问题求解步骤的一种描述，是指令的有限序列 算法的三个基本特性 有穷性 一个算法必须总是在执行有穷步后结束，且每一步都在有穷时间内完成 确定性 算法中的每一条指令必须有确切的含义，不存在二义性。并且，在任何条件下，对于相同的输入只能得到相同的输出 可行性 描述算法的每一条指令可以转换为某种程序设计语言对应的语句，并在计算机上可以运行 算法有零个或多个输入(算法可以没有输入)，但是必须要有输出，而且输入与输出之间有着某种特定的关系 算法分析–算法效率的度量时间复杂度• 用算法中基本语句的执行次数来度量算法的工作量 • 基本语句可以理解为整个算法中执行次数最多的语句 • 考察方式：只考察当问题规模充分大，算法中基本语句的执行次数在渐近意义下的阶，称为时间复杂度，用大O表示。关注的是增长趋势 • O(1)&lt;O(log_2 n)&lt;O(n)&lt;O(nlog_2 n)&lt;O(n^2)&lt;O(n^3)&lt;…&lt;O(2^n)&lt;O(n!) 空间复杂度• 是指算法在执行过程中需要的辅助空间数量，即除算法本身和输入输出数据所占的空间外，算法临时开辟的存储空间 • S(n)&#x3D;O(f(n)) • 如，用到一个临时存储temp，则空间复杂度为O(n);用到一个n个元素的临时存储的数组，则为O(n) 算法分析–举例非递归算法• ①直接看循环重数 • ②多重求和，分析每次循环都是加1的情况 • ③每次循环为二倍，用等比数列，求多少项，一般是取对数，结果为对数阶 递归算法• 根据递归过程建立递推关系式并求解（求和表达式） 最好、最坏、平均情况• 最好情况：不能代表算法的效率，当出现概率较大时分析 • 最坏情况：最坏能坏到什么程序，实时系统需要分析 • 平均情况：已知输入数据分布情况，通常假设等概率分布 举例：一维数组顺序查找 • 最好：一次找到，O(1) • 最坏：最后才找到，O(n) • 平均：n&#x2F;2，O(n) • 如果算法的时间代价与输入数据有关，则需要分析最好情况、最坏情况、平均情况 数据结构数据结构是相互之间存在一定关系的数据元素的集合 根据视点(是否基于内存)的不同分为逻辑结构• 数据元素之间逻辑关系的整体，如关联方式或邻接关系，取决于实际问题 四类 • 集合 数据元素之间没有关系 • 线性结构 数据元素之间是一对一的线性关系 • 树结构 数据元素之间是一对多的层次关系 • 图结构 数据元素之间多对多的任意关系 存储结构• 数据及其逻辑结构在计算机(内存)中的表示，包括数据元素及其逻辑关系 两种 • 顺序存储结构 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置(下标)表示 • 链接存储结构 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针(地址)表示 抽象数据类型(ADT)线性表线性表的逻辑结构线性表简称表，是n(n≥0)个数据元素的有限序列，线性表中数据元素的个数称为线性表的长度。当n&#x3D;0时称为空表。 一个非空表记为：L&#x3D;(a1,a2,…,an) 。a1称为表头元素，an称为表尾元素。 ak-1称为ak的前驱，ak称为ak-1的后继。除了表头元素和表尾元素，其他元素有且仅有一个前驱和一个后继。 线性表的顺序存储结构及实现顺序表的顺序存储结构 物理位置相邻表示逻辑关系。逻辑上和物理上相邻 任一元素均可随机存取 存储位置的计算： 每个元素占l个存储单元 递推式：$$Loc(a_{i+1})&#x3D;Loc(a_i)+l$$更通用的：$$Loc(a_i)&#x3D;Loc(a_1)+(i-1)\\times{l}$$注意是i-1，举例就知道了 实现查找按位查找 O(1) 12345template &lt;typename DataType&gt;DataType SeqList&lt;DataType&gt;::Get(int i)&#123; if(i&lt;1||i&gt;length) throw &quot;查找位置非法&quot;; //注意要先判断 else return data[i-1];//注意序号是1开始，而存储是从0开始&#125; **按值查找 **O(n) 123456template &lt;typename DataType&gt;DataType SeqList&lt;DataType&gt;::Locate(DataType x)&#123; for(int i=0;i&lt;length;i++) if(data[i]==x) return i+1;//注意返回序号i+1 return 0;//查找失败&#125; 插入 O(n) 注意先判断满足条件①表是否已满，即length&#x3D;&#x3D;MaxSize ②未满，则插入位置是否越界 123456789template &lt;typename DataType&gt;void SeqList&lt;DataType&gt;::Insert(int i,DataType x)&#123; if(length==MaxSize) throw &quot;上溢&quot;; if(i&lt;1||i&gt;length+1) throw &quot;插入位置错误&quot;;//i最大到length，最小到1 for(int j=length;j&gt;=i;j--) data[j]=data[j-1];//从第length-1个后移到下一个，第length个数组元素是空的 data[i-1]=x;//序号i存在数组下标为i-1的位置 length++;//长度加一，别忘了&#125; 平均移动 $\\frac{n}{2}$ 次 删除 O(n) 如插入类似，同样先判定①表是否为空 ②表不空，删除位置是否越界 返回删除元素的值 1234567891011template &lt;typename DataType&gt;DataType SeqList&lt;DataType&gt;::Delete(int i)&#123; DataType x; if(length==0) throw &quot;下溢&quot;; if(i&lt;1||i&gt;length+1) throw &quot;删除位置错误&quot;; x=data[i-1];//i在下标为i-1上，取出位置i的元素 for(int j=i;j&lt;length;j++) data[j-1]=data[j];//从第i个位置往前移，覆盖掉i-1的位置，到length-1移动后结束 length--;//长度减1 return x;&#125; 平均移动 $\\frac{n-1}{2}$ 次 线性表的链式存储结构及实现链表实现123456789//成员变量只有一个 头结点Node&lt;DataType&gt; * first//结点结构包含一个数据域和一个指针域template &lt;typename DataType&gt;struct Node&#123; DataType data;//数据域 Node&lt;DataType&gt; *next;//指针域&#125; 遍历123456789template &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::PrintList()&#123; Node&lt;DataType&gt;*p=first-&gt;next;//工作指针初始化 while(p!=nullptr)&#123; cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\\t&quot;; p=p-&gt;next;//工作指针p后移，注意不能写成p++ &#125; cout&lt;&lt;endl;&#125; 求长度 工作指针从first-&gt;next开始，first不算长度 12345678910template &lt;typename DataType&gt;int LinkList&lt;DataType&gt;::Length()&#123; Node *p=first-&gt;next; int count=0; while(p!=nullptr)&#123; count++; p=p-&gt;next; &#125; return count;&#125; 插入12345678910111213141516template &lt;typename DataType&gt;void LinkList&lt;DataType&gt;::Insert(int i,DataType x)&#123; Node&lt;DataTpe&gt; *p=first,*s=nullptr;//指针初始化 int count=0;//记录遍历位置 while(p!=nullptr&amp;&amp;count&lt;i-1)&#123;//查找i-1位置，插入在其后面就成了第i个元素 p=p-&gt;next;//工作指针后移 count++; &#125; if(p==nullptr) throw &quot;插入位置错误&quot;;//没有找到第i-1个 else&#123;//找到 s=new Node&lt;DataType&gt;;//申请结点s，数据域为x s-&gt;data=x; s-&gt;next=p-&gt;next;//将原本第i个插在s后面 p-&gt;next=s;//将s插入到p之后 &#125;&#125; 删除 和插入类似，都是找到后对下一个位置进行操作，但是当对象为表尾，此时，可插但不可删，因此判断位置除了p==nullptr还多了p-&gt;next==nullptr 123456789101112131415161718template &lt;typename DataType&gt;DataType LinkList&lt;DataType&gt;::Delete(int i)&#123; DataType x; int count=0; Node&lt;DataType&gt; *p=first,*q=nullptr;//工作指针指向头结点 while(p!=nullptr&amp;&amp;count&lt;i-1)&#123; p=p-&gt;next; count++; &#125; if(p==nullptr||p-&gt;next==nullptr) throw &quot;删除位置错误&quot;; else&#123; q=p-&gt;next;//暂存被删结点 x=q-&gt;data; p-&gt;next=q-&gt;next;//摘链 delete q; return x; &#125;&#125; 建立头插法 初始化 123456789101112template &lt;typename DataType&gt;LinkList&lt;DataType&gt;::LinkList(DataType a[],int n)&#123; first=new Node&lt;DataType&gt;; first-&gt;next=nullptr;//初始化一个空链表 for(int i=0;i&lt;n;i++)&#123; Node&lt;DataType&gt; *s=nullptr; s-&gt;data=a[i]; s-&gt;next=first-&gt;next;//插在头结点后 first-&gt;next=s; &#125;&#125; 尾插法 初始化；需要一个尾指针；建立完毕，终端指针指针域用空指针收尾 123456789101112template &lt;typename DataType&gt;LinkList&lt;DataType&gt;::LinkList(DataType a[],int n)&#123; first=new Node&lt;DataType&gt;; Node&lt;DataType&gt; *r=first,*s=nullprt;//尾指针初始化 for(int i=0;i&lt;n;i++)&#123; s=new Node&lt;DataType&gt;; s-&gt;data=a[i]; r-&gt;next=s;//插在尾指针后 r=s;//尾指针后移 &#125; r-&gt;next=nullptr;//建立完毕，空指针收尾&#125; 单链表实现就地逆序1234567891011121314template&lt;class T&gt;void Reverse(Node&lt;T&gt; *f)&#123;\t//头插法,再复制 Node&lt;T&gt; *p=new Node&lt;T&gt;;\tNode&lt;T&gt; *u=new Node&lt;T&gt;;\tp=f-&gt;next;\tf-&gt;next=nullptr;\twhile(p!=NULL)&#123; u=p-&gt;next;//存放后继结点 p-&gt;next=f-&gt;next;//插入头结点下一个节点之前 f-&gt;next=p;//头插 p=u; &#125;&#125; 就地逆序，首先将原链表断开，从第一个结点开始重新头插法，每次插入前要保存后继结点，插完后工作指针指向后保存的后继结点 删除有序链表的一个区间上的元素123456789101112131415161718template &lt;typename T&gt;void deleteBet(Node&lt;T&gt; *first,int mink,int maxk)&#123; Node&lt;T&gt; *p=nullptr;\tNode&lt;T&gt; *q=nullptr; p=first; while(p-&gt;next!nullptr&amp;&amp;p-&gt;next-&gt;data&lt;=mink) p=p-&gt;next; //结束循环时，p的下一个是大于mink的 if(p-&gt;next!=nullptr)&#123; q=p-&gt;next; while(q-&gt;data&lt;maxk)&#123; Node&lt;T&gt; *u=q-&gt;next;//记录下一个 p-&gt;next=q-&gt;next; delete q; q=u;//q移到下一个 &#125; &#125;&#125; 首先判断p的下一个是大于的，然后再申请一个指针q来记录接下来的结点，判断q是否小于maxk是的话要删除q；删除结点需要一个指针u来先记录q后面的结点，将q摘链删除后，让q指向保存好的下一个结点 循环链表两种存储结构的选择按值查找： 顺序表是O(1)，随机存取 链表是O(n)，顺序存取 插入和删除 顺序表O(n) 链表O(1) 存储结构 链表 顺序表 空间上 元素个数变化较大或为止时选择 事先知道线性表的大致长度，使用顺序表空间效率更高 时间上 频繁插入和删除时选择 频繁查找很少插入删除；或操作和元素在表中的位置密切相关 栈和队列队列初始：front&#x3D;rear&#x3D;0 入队：base[rear]&#x3D;x;rear++; 出队：x&#x3D;base[front];front++ 空队标志：front&#x3D;&#x3D;rear; 数组大小为MAXSIZE时，当rear&#x3D;&#x3D;MAXSIZE发生溢出： 若front&#x3D;0，rear&#x3D;&#x3D;MAXSIZE，再入队真溢出 若front≠0，rear&#x3D;&#x3D;MAXSIZE，再入队假溢出(前面还有位置其实) 循环队列 front处不存值，rear存值 插入元素： 123if((rear+1)%MAXSIZE==front) throw &quot;上溢&quot;;rear=(rear+1)%MAXSIZE;data[rear]=x;//插入元素 删除元素： 123if(front==rear) throw &quot;下溢&quot;;front=(front+1)%MAXSIZE;return data[front];//返回出队前的队头元素,front本来是不存值的，放到front相当于出队 注意是(指针+1)%MAXSIZE，不能指针%MAXSIZE，因为要包括移动到下一位，不能停留在MAXSIZE，直接一步到位 队满条件：(rear+1)%MAXSIZE==front; 字符串 字符串简称“串” 任意个连续的字符组成的子序列称为该串的子串 包含子串的串称为主串 KMP看子串即可，当在对比模式串和目标串时，通过模式串可以反应目标串的一些信息 next[j]定义：$$next[j]&#x3D;\\begin{cases}-1&amp; \\text{j&#x3D;0}\\最长公共前后缀的长度&amp; \\text{集合非空}\\0&amp; \\text{其他情况}\\end{cases}$$ 注意找子串前后缀是j之前的，不包括j位置的字符；next[0]&#x3D;-1 设目标串为s&#x3D;“abcabababaab”，模式串为p&#x3D;“babab”，则KMP模式匹配算法的next数组为 [-1,0,0,1,2] 矩阵的压缩存储特殊矩阵对称矩阵原本需要n×n，现在只用n×(n+1)&#x2F;2 存一半+主对角线 三角矩阵上(下)三角，主对角线以下(上)为均为常数c，和对称矩阵类似，但是要多存一个c 现在只有n×(n+1)&#x2F;2+1 存一半+主对角线+一个常数 对角矩阵所有非零元素都集中在以对角线为中心的带状区域，除了主对角线和若干条次对角线的元素外，所有其他元素都为零。 只存非0 树和二叉树 注意树的定义，是有且仅有一个根节点且其余结点配分成互不相交的集合(不能构成回路)。 某结点拥有的子树的个数称为该结点的度；树中各结点度的最大值称为该树的度。 线性结构：前驱-&gt;后继 树的结构：双亲-&gt;孩子 image.png 重点：对于一棵n结点的树，其所有结点的度之和为n-1。 理解：把结点上面的边与它关联，那么除了根节点上面没有边，总共的边数(即度数和)就等于所有结点数-1，因此所有结点的度数和就是总结点数-1即n-1。因此有结点数n&#x3D;分支数+1 习题 已知一颗度为4的树中，度为i(i&gt;&#x3D;1)的结点个数有i个，问该树中有 个叶子结点。 A. 19 B. 21 C. 23 D. 25 解析：设i度结点数为ni个，则本题树的度为4，总结点数n&#x3D;n0+n1+n2+n3+n4,由公式结点数n&#x3D;分支数+1,且度为i(i&gt;&#x3D;1)的结点个数有i个，那么总的分支数为1+n1+2n2+3n3+4n4，联立两式可得叶子节点数n0&#x3D;1+n2+2n3+3n4&#x3D;21 已知一棵度为3的数，度为1的结点有2个，度为2的结点有3个，度为3的结点有4个，问有多少叶子结点。 解析：同理n&#x3D;n0+n1+n2+n3+n4&#x3D;2n1+3n2+4n3+1，解的n0&#x3D;1+n2+2n3&#x3D;12 此类给度数k和一些结点数，求叶子结点的题一般做法都是 1.设i度结点数为ni个，总结点数就是n&#x3D;n0+n1+..+nk 2.利用结点数&#x3D;分支数+1，i度结点有i个分支，因此分支数为∑i×ni求和，所以得n&#x3D;∑i×n+1 3.联立12，带入题目给的相应结点数即可得到结点数n0 二叉树image.png 二叉树的逻辑结构 注意，二叉树和树是两种不同的树结构，二叉树不是度为2的树，也不能说是度小于等于2的树 对于前者，当是一个只有两个结点的斜树时，度为1，只有一个结点时度为0，它们度都不是2，但都是二叉树。 对于后者，树的孩子还必须要有左右之分，及时只有一个结点，也要区分它是左孩子还是右孩子。例如下图，假设是二叉树，则它们是两课不同的二叉树；假设是树，则它们是同一棵树。 ![image-20221214165114732]([JJuprising&#x2F;JJuprising.github.io](Joel Station (jjuprising.github.io) 满二叉树在一棵二叉树中，所有分支结点都存在于左子树和右子树，，并且所有叶子结点都在同一层，这样的二叉树称为满二叉树。 特点： 叶子只出现在最下一层 只有度为0和度为2的结点 在同样深度的二叉树中，满二叉树结点最多，叶子节点最多。 完全二叉树一棵满二叉树必定是一棵完全二叉树。 完全二叉树，是在满二叉树中，从最后一个结点(最右)连续去掉任意个结点(全去掉就是满二叉树)，得到的二叉树。 特点： 深度为k的完全二叉树在k-1层是满二叉树。 叶子结点只能出现在最下两层，且最下层的叶子结点都集中在左侧连续的位置。 如果有度为1的结点，只可能有一个，且该结点只有左孩子。 在结点数相同的情况下，构成的所有二叉树中完全二叉树的深度最小。 二叉树的五个性质对于二叉树 在一棵二叉树中，如果叶子结点的个数为n0,度为2的结点个数为n2，则n0&#x3D;n2+1，即叶子结点数等于度为2的结点数加一。 证明：结点数n&#x3D;分支数+1&#x3D;n1+2*n2+1,n&#x3D;n0+n1+n2，联立得n0&#x3D;n2+1 二叉树的第i层上最多有2i-1个结点(i≥1) 等比数列，首项为1，公比为2，第i层满则有2i-1个 在一棵深度为k的二叉树中，最多有2k-1个结点。 由上面结论深度一定时，满二叉树的结点数是最多的，满二叉树每层的结点数为1,2,4,8…是个公比为2的等比数列，到第k层有2k-1个结点，求和公式1*(1-2k)&#x2F;1-2得2k-1，这也是一个等比数列的性质，即第n项的值减一等于前n-1项的和 对于完全二叉树 具有n个结点的完全二叉树的深度为⌊log2n⌋+1。 由完全二叉树的定义，是由满二叉树从最后一个结点连续去掉任意结点得到，因此一个深度为k的完全二叉树结点数最多是当它是深度为k的满二叉树，最少是当它是深度为k-1的满二叉树，结合上求和公式可得$$2^{k-1}≤n&lt;2^k$$（这里假设深度为k，因此它不为k-1的满二叉树，左边取等或者取大于2k-1-1，右边就是小于等于2k-1） 对于一棵具有n个结点的完全二叉树从1开始按层序编号，则对于编号为i的结点，双亲和孩子编号之间的关系为： 双亲编号为$⌊i&#x2F;2⌋$ 左孩子编号为$2i$，右孩子编号为$2i+1$ 二叉树的遍历遍历操作前序：根左右 中序：左根右 后序：左右根 例题： image-20221213203357221 解析：前序：ABDGCEHF；中序：DGBAEHCF；后序：GDBHEFCA 确定二叉树先序加中序或中序加后序可以确定一棵二叉树，但是先序加后序不可以。 前序开头确定根，中序确定左右子树 如先序：A B C D E F G H I 中序：C D B F E A IHGJ 左子树 先序：BDFEF 中序：CDBFE 再左子树类推，右子树同理 后序尾部确定根，中序确定左右子树 二叉链表前序、中序、后序、层序遍历，数据类型默认为char，注意初始化的方式，递归构造 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;int count1 = 0;struct BiNode //二叉树的结点结构&#123;\tchar data; //数据类型默认为char\tBiNode *lchild, *rchild;&#125;;class BiTree&#123;public:\tBiTree( )&#123;root = Creat(root);&#125; //构造函数，建立一棵二叉树\t~BiTree( )&#123;Release(root);&#125; //析构函数，释放各结点的存储空间\tvoid PreOrder( )&#123;PreOrder(root);&#125; //前序遍历二叉树\tvoid InOrder( )&#123;InOrder(root);&#125; //中序遍历二叉树\tvoid PostOrder( )&#123;PostOrder(root);&#125; //后序遍历二叉树\tvoid LeverOrder( ); //层序遍历二叉树\tvoid CountLeaf1( )&#123;CountLeaf1(root);&#125;\tvoid CountLeaf2( )&#123;cout&lt;&lt;CountLeaf2(root)&lt;&lt;endl;&#125;private:\tBiNode *root; //指向根结点的头指针\tBiNode *Creat(BiNode *bt); //构造函数调用\tvoid Release(BiNode *bt); //析构函数调用\tvoid PreOrder(BiNode *bt); //前序遍历函数调用\tvoid InOrder(BiNode *bt); //中序遍历函数调用\tvoid PostOrder(BiNode *bt); //后序遍历函数调用\tvoid CountLeaf1(BiNode *bt);\tint CountLeaf2(BiNode *bt);&#125;; 前序遍历递归 O(n) 123456789void BiTree::PreOrder(BiNode *bt)&#123;\tif(bt==NULL) return;\telse &#123; cout&lt;&lt;bt-&gt;data&lt;&lt;&quot; &quot;; PreOrder(bt-&gt;lchild); PreOrder(bt-&gt;rchild);\t&#125;&#125; 中序遍历123456789void BiTree::InOrder(BiNode *bt)&#123;\tif (bt==NULL) return; //递归调用的结束条件 else &#123; InOrder(bt-&gt;lchild); //中序递归遍历root的左子树 cout&lt;&lt;bt-&gt;data&lt;&lt;&quot; &quot;; //访问根结点的数据域 InOrder(bt-&gt;rchild); //中序递归遍历root的右子树\t&#125;&#125; 后序遍历123456789void BiTree::PostOrder(BiNode *bt)&#123;\tif (bt==NULL) return; //递归调用的结束条件 else &#123; PostOrder(bt-&gt;lchild); //后序递归遍历root的左子树 PostOrder(bt-&gt;rchild); //后序递归遍历root的右子树 cout&lt;&lt;bt-&gt;data&lt;&lt;&quot; &quot;; //访问根结点的数据域\t&#125;&#125; 层序遍历1234567891011121314151617void BiTree::LeverOrder( )&#123;\tconst int MaxSize=100;\tint front=-1, rear=-1; //采用顺序队列，并假定不会发生上溢\tBiNode *Q[MaxSize], *q;\tif (root==NULL) return;\telse &#123; Q[rear++]=root; while (front!=rear) &#123; q=Q[front++]; cout&lt;&lt;q-&gt;data&lt;&lt;&quot; &quot;; if (q-&gt;lchild!=NULL) Q[rear++]=q-&gt;lchild; if (q-&gt;rchild!=NULL) Q[rear++]=q-&gt;rchild; &#125;\t&#125;&#125; 构造函数——建立二叉树123456789101112131415BiNode *BiTree::Creat(BiNode *bt)&#123;\tchar ch;\tcout&lt;&lt;&quot;请输入创建一棵二叉树的结点数据&quot;&lt;&lt;endl;\tcin&gt;&gt;ch; if (ch==&#x27;#&#x27;) return NULL; else&#123; bt = new BiNode; //生成一个结点 bt-&gt;data=ch; bt-&gt;lchild = Creat(bt-&gt;lchild); //递归建立左子树 bt-&gt;rchild = Creat(bt-&gt;rchild); //递归建立右子树 &#125; return bt;&#125; 析构函数——销毁二叉树123456789void BiTree::Release(BiNode *bt)&#123;\tif (bt != NULL)&#123; Release(bt-&gt;lchild); //释放左子树 Release(bt-&gt;rchild); //释放右子树 delete bt;\t&#125; &#125; 遍历算法应用递归调用深入下一层，返回后还要继续执行 复制 如果是空树，递归结束； 否则，申请新结点，复制根节点 递归复制左子树 递归复制右子树 123456789101112void BiTree::Copy(BiTree T,BiTree &amp;NewT)&#123; if(T==NULL)&#123; NewT=NULL;//置为空 return 0; &#125;else&#123; NewT=new BiNode;//申请空间 NewT-&gt;data=T-&gt;data;//数据域 Copy(T-&gt;lchild,NewT-&gt;lchild);//通过传递NewT-&gt;lchild将它们连接起来 Copy(T-&gt;rchild,NewT-&gt;rchild);//递归结束后，栈的特点返回上一层 &#125; &#125; 计算深度 如果是空树，则深度为0 否则，递归计算左子树的深度记为m，递归计算右子树深度为n，深度取m和n较大者加1 123456789101112int BiTree::Depth(BiTree T)&#123; int m,n; if(T==NULL) return 0;//如果是空树返回0 else&#123; m=Depth(T-&gt;lchild);//递归计算左子树的深度 n=Depth(T-&gt;rchild);//递归计算右子树的深度 if(m&gt;n)//取左右子树深度大的那一个 return (m+1);//加上当前的根节点 else return (n+1); &#125;&#125; 计算结点总数 如果是空树，则结点个数为0 否则，结点个数为左子树的结点个数+右子树的结点个数再+1 123456int BiTree:NodeCount(BiTree T)&#123; if(T==NULL) return 0; else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;lchild)+1;//+1即每轮的根结点&#125; 基本情况：如果是一个叶子结点，左右子树都为空，返回0，那么就是0+0+1就是1，返回到上一层，假设它没有右子树，那么当前的结点数就是1+0+1就是2，正确，返回上一层，再去递归右子树…;这个1加的就是每一轮的根节点 或者 12345678template &lt;class T&gt;void Count(BiNode&lt;T&gt; *br)&#123; if(br!=nullptr)&#123; Count(br-&gt;lchild); count++; Count(br-&gt;rchild); &#125;&#125; 计算叶子递归 如果是空树，则叶子结点个数为0 否则，为左子树叶子结点+右子树的叶子结点 12345678910void BiTree::CountLeaf1(BiNode *bt)&#123;\tif (bt!=NULL)&#123; if(bt-&gt;lchild==NULL &amp;&amp; bt-&gt;rchild==NULL)//叶子左右孩子都为空 count1++; CountLeaf1(bt-&gt;lchild);//不是叶子就继续递归左子树 CountLeaf1(bt-&gt;rchild);//右子树\t&#125; return;&#125; 12345678int BiTree::LeadCount(BiTree *T)&#123; if(T==NULL) return 0; else&#123; if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) return 1;//是叶子结点返回 else return LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild); &#125;&#125; 前序顺序打印叶子(根左右) 12345678910void PreOrderPrint(BiNode *br)&#123;\tif(bt==nullptr) return;\telse&#123; if(bt-&gt;lchild==nullptr&amp;&amp;bt-&gt;rchild==nullptr) cout&lt;&lt;br-&gt;data; PreOrderPrint(br-&gt;lchild); PreOrderPrint(br-&gt;rchild); &#125;&#125; 非递归 123456789101112131415161718192021int BiTree::CountLeaf2(BiNode *bt)&#123;\tconst int MaxSize=100;\tBiNode *S[MaxSize];//利用队列\tint top=-1; int count=0;\twhile(bt!=NULL||top!=-1)\t&#123; while(bt!=NULL) &#123; if(bt-&gt;lchild==NULL &amp;&amp; bt-&gt;rchild==NULL) count++; S[++top]=bt;//入队 bt=bt-&gt;lchild; &#125; if(top!=-1) &#123; bt=S[top--];//出队 bt=bt-&gt;rchild; &#125;\t&#125;\treturn count;&#125; 找结点x的双亲1234567891011template&lt;class T&gt; void BiNode&lt;T&gt;::Parent(BiNode&lt;T&gt; *root,T x)&#123; if(root!=nullptr)&#123; if(root-&gt;data==x) return p; else&#123; p=root;//存双亲 Parent(root-&gt;lchild,x); Parent(root-&gt;rchild,x); &#125; &#125; &#125; 删除以x为根结点的子树123456789101112131415161718192021 template&lt;class T&gt; void release(BiNde&lt;T&gt; T)&#123; if(T!=nullptr)&#123; release(T-&gt;lchild); release(T-&gt;rchild); delete T; &#125; &#125; template&lt;class T&gt;void DelBotmTree(BiNde&lt;T&gt; *root,T x)&#123;\tif(root==nullptr) return;\tif(root-&gt;data==n)&#123; //找到，删除 release(root); root=nullptr;//标记为空，不要了 &#125;\tif(root!=nullptr)&#123; DelBotmTree(root-&gt;lchild,x); DelBotmTree(root-&gt;rchild,x);\t&#125;&#125; 交换左右子树后序遍历的方法进行交换 12345678910111213template&lt;class T&gt;void exchange(BiNode&lt;T&gt; *root)&#123; BiNode&lt;T&gt; *t; if(root==nullptr) return; else&#123; exchange(root-&gt;lchild); exchange(root-&gt;rchild); //交换左右子树 t=root-&gt;lchild; root-&gt;lchild=root-&gt;rchild; root-&gt;rchild=t; &#125;&#125; 左右根，化简为最基本的情况就是左右结点的交换 森林森林是$m(m≥0)$棵互不相交的树的集合。 注意区分树和森林。树删去根节点–&gt;森林；森林增加一个根节点，将森林每一棵树的根节点作为这个根节点的子树–&gt;一棵树 树与二叉树相互转换树的兄弟关系&lt;–&gt;二叉树的双亲与右孩子 树的双亲与长子&lt;–&gt;二叉树的双亲与左孩子 方法： 加“兄弟”线，所有相邻兄弟之间加一条线(兄弟关系变为双亲和右孩子的关系)； 去”孩子“线，去掉结点与其他孩子的线，保留和长子的线(双亲与长子变为双亲与左孩子，和其他兄弟也没“关系”了)； 调整，以根节点为轴顺时针旋转调整，使层次分明。 image-20221214171816832 当二叉树根节点的右子树为空，说明树的根节点是单独的，没有兄弟 树的前序遍历就是二叉树的前序遍历 树的后序遍历就是二叉树的中序遍历 后序是左右根，中序是左根右。原本树的兄弟之间是左右，在二叉树变成了双亲与右孩子，因此是根右 森林转换为二叉树方法： 将森林每棵树转换为二叉树 每棵树根结点视为兄弟相连 调整层次关系 其实由森林和树的定义也可推得方法类似，在第一步完成后，将几颗树的根节点作为兄弟，然后调整，将右兄弟作为右孩子。 image-20221214171747422 树、森林与二叉树的转换方法： 加”孩子“线，将结点y与他的左孩子的右孩子、右孩子的右孩子。。。用线连起来 去线，删去所有双亲与右孩子的连线 层次调整 image-20221214180843999 最优二叉树哈夫曼树不存在度为1的结点 哈夫曼树度只能为0或2，不存在度为1。至少：考虑每层2个结点（除了根结点），则至少为2h-1个 至多：考虑满二叉树，则至多为 (2^h) -1 图图逻辑结构邻接图通过边数的多寡可以将图分为稀疏图和稠密图，稀疏图即边数很少的图 邻接、依附无向图中，两个顶点相连，互为邻接点，称边依附于这两个顶点 有向图中，a指向b，称顶点a邻接到b，顶点b邻接自a，弧依附这两个点。有向边成为弧 完全图无向完全图，任意两个顶点之间都存在边。 n个顶点的无向完全图有 $\\frac{n×(n-1)}{2}$ 条边 每个顶点和其他顶点(n-1个)都有边，算多了一遍结果除2 有向完全图，任意两个顶点都存在方向相反的两条弧。 n个顶点的有向完全图有 $n×(n-1)$ 条弧 任意两点有两条，区分方向，不用除2 度、入度、出度无向图，度 有向图，入度：进入该顶点的弧的数(以该顶点为弧头)；出度，出去的弧的数(以该顶点为弧尾) 性质： 无向图，各顶点的度数和等于边数之和两倍，度数算了两遍的边 有向图，各顶点的入度和等于出度和等于边数之和，有出必有入，有如必有出，一条边提供一个出度一个入度，入度和等于出度和，加和等于边数的2倍，各自就是等于边数和 路径、回路 简单路径：序列中顶点不重复出现的路径 简单回路(简单环)：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路 路径长度： 带权图：路径上边的权值之和 非带权图：路径上边的个数 连通图 无向图中，如果两顶点之间有路径，则称两顶点是连通的 无向图中，如果任意两顶点都是连通的，则称该无向图是连通图 强连通图 强连通顶点，在有向图中，如果a到b和b到a均有路径，则称a和b是强连通的 强连通图，在有向图中，如果任意两个顶点是强连通的，则称有向图是强连通图 强连通分量：非强连通图的极大连通子图**(极大强连通子图就是指一个强连通子图，再加入任何额外的节点都无法保证这个新的图是一个强连通图)** image-20221217153730696 遍历操作算法：BFTraverse 输入：顶点的编号 v 输出：无 队列Q初始化 访问顶点v；修改标志visti[v]&#x3D;1;顶点v入队列Q； while(队列Q非空) 3.1 v&#x3D;队列Q的队头元素出队； 3.2 w&#x3D;顶点v的第一个邻接点； 3.3 while(w存在) ​ 3.1.1 如果w未被访问，则访问它；修改标志vistied[w]&#x3D;1;顶点w入队列Q； ​ 3.1.2 w&#x3D;顶点v的下一个邻接点； 图的存储结构及实现邻接矩阵注意到自己是0，主对角线为0 空间复杂度为O(n2) image-20221217164904968 网图的邻接矩阵可定义为：用权值代替1，主对角都是0，不可达是∞ 实现123456789const int MaxSize=10;template &lt;typename DataType&gt;class MGraph&#123; ...private: DataType vertex[MaxSize];//存放图中顶点的数组 int edge[MaxSize][MaxSize];//存放图中边的数组 int vertexNum,edgeNum;//图的顶点和边数&#125; 构造函数——图的建立1234567891011121314template &lt;typename DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[],int n,int e)&#123; int i,j,k; vertexNum=n;edgeNum=e; for(i=0;i&lt;vertexNum;i++) vertex[i]=a[i];//存储顶点 for(i=0;i&lt;vertexNum;i++)//初始化矩阵 for(j=0;j&lt;vertexNum;j++) edge[i][j]=0; for(k=0;k&lt;edgeNum;k++)&#123; cin&gt;&gt;i&gt;&gt;j;//输入边依附两个顶点的编号 edge[i][j]=edge[j][i];//置有边标志 &#125;&#125; 深度优先遍历 递归栈；按行访问 1234567template &lt;typename DataType&gt;void MGraph&lt;DataType&gt;::DFTraverse(int v)&#123; cout&lt;&lt;vertex[v]&lt;&lt;&quot; &quot;; visited[v]=1;//一个全局遍历，访问置为1 for(int j=0;j&lt;vertexNum;j++) if(vertex[v][j]==1&amp;&amp;visited[j]==0) DFTraver(j);//满足条件：邻接同时未访问过&#125; 广度优先遍历 队列；font指向队头元素的前一个位置，rear指向队尾元素的位置 123456789101112131415161718template &lt;typename DataType&gt;void MGraph&lt;DataType&gt;::BFTraverse(int v)&#123; int w;//记录出队 int j;//序号 int Q[MaxSize];//队列 int front=-1,rear=-1;//初始化队列 cout&lt;&lt;vertex[v];visited[v]=1;//记录已访问 Q[++rear]=v;//被访问顶点入队 while(font!=rear)&#123;//当队列非空 w=Q[++font];//将队头元素出队 for(j=0;j&lt;vertexNum;j++) if(eage[w][j]==1&amp;&amp;visited[j]==0)&#123; Q[++rear]=j;//入队 cout&lt;&lt;vertex[j]&lt;&lt;&quot; &quot;; visited[j]=1;//访问过，记录 &#125; &#125;&#125; 邻接表如果采用邻接矩阵存储稀疏图，会出现什么情况？–&gt;稀疏矩阵 image-20221217170424730 边表中的结点表示什么？–&gt;对应图中的一条边(边表) 设图有n个顶点e条边，邻接表的空间复杂度是：O(n+e) 基础准备： 123456789struct EdgeNode&#123;//定义边表结点。一个结点！ int adjvex;//邻接点域 EdgeNode * next;&#125;template &lt;typename DataType&gt;struct VertexNode&#123;//定义顶点表结点\tDataType vertex; EdgeNode * firstEdge;&#125;; 实现12345678const int MaxSize=10;template &lt;typename DataType&gt;class ALGraph&#123; ...private: VertexNode&lt;DataType&gt; adjlist[MaxSize];//存放顶点表的数组 int vertexNum,edgeNum;//图的顶点数和边数&#125; 构造函数——图的建立 头插法 123456789101112131415161718template &lt;typename DataType&gt;ALGraph&lt;DataType&gt;::ALGraph(DataType a[],int n,int e)&#123; int i,j,k; EdgeNode * s=nullptr; vertexNum=n; edgeNum=e; for(i=0;i&lt;vertexNum;i++)&#123;//输入顶点信息，初始化顶点表 adjlist[i].vertex=a[i]; adjlist[i].firstEdge=nullptr; &#125; for(k=0;k&lt;edgeNum;k++)&#123; cin&gt;&gt;i&gt;&gt;j;//输入边依附的两个顶点的编号 s=new EdgeNode; s-&gt;adjvex=j; s-&gt;next=adjlist[i].firstEdge;//头插法 adjlist[i].firstEdge=s;//类似头指针，要指向第一个 &#125;&#125; 广度优先遍历算法 队列，链表，外层是队列判空，内层是工作指针判空 不能理解为把边表一条一条输出，广度有限有顺序规律的，还是要用队列 12345678910111213141516171819202122template &lt;typename DataType&gt;void ALGraph&lt;DataType&gt;::BFTraverse(int v)&#123; int w;//存出队元素 int j,Q[MaxSize];//顺序队列 int font=-1,rear=-1;//初始化队列 EdgeNode * p=nullptr;//工作指针 cout&lt;&lt;adjlist[v].vertex;visit[v]=1; Q[++rear]=v;//入队 while(font!=rear)&#123;//当队列非空 w=Q[++rear]; p=adjlist[w].firstEdge;//工作指针p指向顶点v的边表 while(p!=nullptr)&#123; j=p-&gt;adjvex; if(visit[j]==0)&#123; cout&lt;&lt;adjlist[j].vertex; visited[j]=1; Q[++rear]=j; &#125; p=p-&gt;next; &#125; &#125;&#125; 最小生成树生成树：连通图的生成树是包含全部顶点的一个极小连通子图 生成树的代价：在无向连通网中，生成树上各边的权值之和 最小生成树：在无向连通网中，代价最小的生成树 Prim算法重复指向操作：在所有$i∈U$、$j∈V-U$的边中找一条代价最小的边$(i,j)$并入集合$TE$，同时$J$并入$U$，直至$U&#x3D;V$为止，此时TE中有$n-1$条边，$T$是一棵最小生成树。 在已存在生成树集合中所有顶点找集合外边的边，取代价最小的那一条，把对应的那个点加入到生成树集合中，直到所有顶点都加入 “把团队成员之外最容易拉到的入伙” 算法：Prim输入：无向连通网G&#x3D;(V，E)输出：最小生成树T&#x3D;(U，TE) 初始化：U &#x3D; {v}； TE&#x3D;{ }； 重复下述操作直到U &#x3D; V： 2.1 在E中寻找最短边(i，j)，且满足i∈U，j∈V-U； 2.2 U &#x3D; U + {j}； 2.3 TE &#x3D; TE + {(i，j)}； 核心代码： 1234567891011121314151617181920void Prim(int v)&#123; int i,j,k; int adjvex[MaxSize];//记录每个成员最短边的邻接点 int lowcost[MaxSize];//记录到所有顶点的最短值 for(i=0;i&lt;vertexNum;i++)&#123;//初始化辅助数组 lowcost[i]=edge[v][i]; adjvex[i]=v;//邻接 &#125; lowcost[v]=0;//已经在团队里的点置为0 for(k=1;k&lt;vertexNum;k++)&#123;//迭代n-1 j=MinEdge(lowcost,vertexNum);//这一步就是找到团队外的最短边，即找数组的最小值，注意判0 cout&lt;&lt;&quot;(&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;adjvex[j]&lt;&lt;&quot;)&quot;&lt;&lt;lowcost[i]&lt;&lt;endl; lowcost[j]=0;//将顶点j加入集合U for(i=0;i&lt;vertexNum;i++) if(edge[i][j]&lt;lowcost[i])&#123; lowcost[i]=edge[i][j]; adjvex[i]=j;//根据新加入的来更新最短的 &#125; &#125;&#125; 完整代码： 123456789101112131415161718192021222324252627282930313233343536int MinEdge(int lowcost[],int num)&#123;\tint min=100; int minNum;\tfor(int i=0;i&lt;num;i++)&#123; if(lowcost[i]!=0&amp;&amp;lowcost[i]&lt;min)&#123; min=lowcost[i]; minNum=i; &#125; &#125;\treturn minNum;&#125;void Prim(int v)&#123;\tint i,j,k;\tint adjvex[MaxSize],lowcost[MaxSize];\tfor(i=0;i&lt;vertexNum;i++)&#123; lowcost[i]=arc[v][i]; //在初始化的过程中对于不可达的点如果不做操作，默认是0，这里的0值就有了两种意义，一种表示是自己到自己，一种是不可达，注意区分 if(lowcost[i]==0&amp;&amp;i!=v) lowcost[i]=10000;//记为无穷大 adjvex[i]=v;\t&#125;\tlowcost[v]=0;\tfor(k=1;k&lt;vertexNum;k++)&#123; j=MinEdge(lowcost,vertexNum);//寻找最短边的邻接点j cout&lt;&lt;j&lt;&lt;adjvex[j]&lt;&lt;lowcost[j]&lt;&lt;endl; lowcost[j]=0; for(i=0;i&lt;vertexNum;i++)&#123; if(arc[i][j]&lt;lowcost[i]&amp;&amp;arc[i][j]!=0)&#123;//说明是不可达的点，此时要判断 lowcost[i]=arc[i][j]; adjvex[i]=j; &#125; &#125; &#125;&#125; 首先将adjvex全置为v，lowcost[i]表示编号为i的点到v的距离，不可达为正无穷。 然后遍历lowcost找到最小的（不包含0，0表示本身），当找到编号j到v的距离最小，那么把编号j的点到其他点的距离和lowcost比较，如果对应的值要小，那么更新lowcost对应值，同时将adjvex改为j。例如设v&#x3D;0，第一轮lowcost[5]是最小的为19（表示编号v到编号5的权值是目前v到所有的邻接点中最小的），那么看邻接矩阵第五列（邻接矩阵的第五列从上到下表示编号5到编号0、编号5到编号1…的权值）从上到下对应的与lowcost的比较，如邻接[1][5]和lowcost[1]比，邻接[2][5]和lowcost[2]比等等，更新lowcost和adjvex） 重复步骤2vertexNum-1次 是一种贪心策略。 image.png 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//图完整代码，包含BFD、DFS、Prim，注意默认是6个顶点9条边，且顶点从0-6#include &lt;iostream&gt;using namespace std;const int MaxSize = 10; //图中最多顶点个数int visited[MaxSize]=&#123;0&#125;;struct element&#123;\tint lowcost, adjvex;&#125;;int MinEdge(int lowcost[],int num)&#123;\tint min=100;\tint minNum; for(int i=0;i&lt;num;i++)&#123; if(lowcost[i]!=0&amp;&amp;lowcost[i]&lt;min)&#123; min=lowcost[i]; minNum=i; &#125; &#125;\treturn minNum;&#125;template &lt;class DataType&gt;class MGraph&#123;public:\tMGraph(DataType a[ ], int n, int e); //构造函数，建立具有n个顶点e条边的图\t~MGraph( ) &#123; &#125; //析构函数为空\tvoid DFSTraverse(int v); //深度优先遍历图\tvoid BFSTraverse(int v); //广度优先遍历图\ttemplate &lt;class T&gt;\tfriend void Prim(MGraph&lt;T&gt; mg);private: DataType vertex[MaxSize]; //存放图中顶点的数组 int arc[MaxSize][MaxSize]; //存放图中边的数组 int vertexNum, arcNum; //图的顶点数和边数&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[ ], int n, int e)&#123;\tint i, j, w=0;\tvertexNum=n; arcNum=e;\tfor (i=0; i&lt;vertexNum; i++) vertex[i]=a[i];\tfor (i=0; i&lt;vertexNum; i++) for (j=0; j&lt;vertexNum; j++) arc[i][j]=0; for (int k=0; k&lt;arcNum; k++) &#123; cout&lt;&lt;&quot;请输入边的两个顶点的序号：&quot;; cin&gt;&gt;i; cin&gt;&gt;j; cout&lt;&lt;&quot;请输入边的权值：&quot;; cin&gt;&gt;w; arc[i][j]=w; arc[j][i]=w; &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFSTraverse(int v)&#123;\tcout &lt;&lt; vertex[v]; visited[v] = 1;\tfor (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &gt;=1 &amp;&amp; visited[j]==0) DFSTraverse(j);&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFSTraverse(int v)&#123;\tint Q[MaxSize];\tint front = -1, rear = -1; //初始化队列,假设队列采用顺序存储且不会发生溢出\tcout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队\twhile (front != rear) //当队列非空时\t&#123; v = Q[++front]; //将队头元素出队并送到v中 for (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &gt;=1 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125;\t&#125;&#125;template &lt;class DataType&gt;void Prim(MGraph&lt;DataType&gt; mg)&#123;\tint i,j,k;\tint adjvex[MaxSize],lowcost[MaxSize];\tint v=0;\tint vertexNum=mg.vertexNum;\tfor(i=0;i&lt;vertexNum;i++)&#123; lowcost[i]=mg.arc[v][i]; if(lowcost[i]==0&amp;&amp;i!=v) lowcost[i]=10000;//记为无穷大 adjvex[i]=v;\t&#125;\tlowcost[v]=0;\tfor(k=1;k&lt;vertexNum;k++)&#123; j=MinEdge(lowcost,mg.vertexNum);//寻找最短边的邻接点j cout&lt;&lt;&quot;(&quot;&lt;&lt;j&lt;&lt;&quot;,&quot;&lt;&lt;adjvex[j]&lt;&lt;&quot;)&quot;&lt;&lt;lowcost[j]&lt;&lt;endl; lowcost[j]=0; for(i=0;i&lt;vertexNum;i++)&#123; if(mg.arc[i][j]&lt;lowcost[i]&amp;&amp;mg.arc[i][j]!=0)&#123; lowcost[i]=mg.arc[i][j]; adjvex[i]=j; &#125; &#125; &#125;&#125; int main()&#123;\tchar ch[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;&#125;;\tMGraph&lt;char&gt; MG(ch, 6, 9);\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0;\tcout&lt;&lt;&quot;深度优先遍历序列是：&quot;;\tMG.DFSTraverse(0);\tcout&lt;&lt;endl;\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0; cout&lt;&lt;&quot;广度优先遍历序列是：&quot;;\tMG.BFSTraverse(0);\tcout&lt;&lt;endl; cout&lt;&lt;&quot;最小生成树的生成过程为：&quot;&lt;&lt;endl; Prim(MG);\tcout&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; Kruskal算法按边的权值排序 初始所有顶点都在集合里，找最短的边加进来，加之前判断是否形成环，是则舍弃选取下一个，直到集合所有顶点都在统一连通分量上(都连通，n-1条边) 最小生成树可能不唯一，比如当有相同的权值边又不至形成环的时候，就可能构造出不同的最小生成树 两种算法比较 算法名 普利姆算法 克鲁斯卡尔算法 算法思想 选择点 选择边 时间复杂度 O(n2) n为顶点数 O(eloge) (e为边数) 适应范围 稠密图 (边多) 稀疏图 (边少) 时间复杂度：普利姆算法每一个顶点都要找其他顶点判断；克鲁斯卡尔选择边，与顶点数无关，边排序 最短路径Dijkstra算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//图 DFS BFS Dijkstra 完整代码#include &lt;iostream&gt;using namespace std;#include&lt;string&gt;const int MaxSize = 10; //图中最多顶点个数int visited[MaxSize]=&#123;0&#125;;struct element&#123;\tint lowcost, adjvex;&#125;;int Min(int dist[],int ver)&#123;\tint min=255,minNum=0;\tfor(int i=0;i&lt;ver;i++)&#123; if(dist[i]&lt;min&amp;&amp;dist[i]&gt;0)&#123; min=dist[i]; minNum=i; &#125;\t&#125;\treturn minNum;&#125;template &lt;class DataType&gt;class MGraph&#123;public:\tMGraph(DataType a[ ], int n, int e); //构造函数，建立具有n个顶点e条边的图\t~MGraph( ) &#123; &#125; //析构函数为空\tvoid DFSTraverse(int v); //深度优先遍历图\tvoid BFSTraverse(int v); //广度优先遍历图\ttemplate &lt;class T&gt;\tfriend void Dijkstra(MGraph&lt;T&gt; MG,int v);private: DataType vertex[MaxSize]; //存放图中顶点的数组 int arc[MaxSize][MaxSize]; //存放图中边的数组 int vertexNum, arcNum; //图的顶点数和边数&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[ ], int n, int e)&#123;\tint i, j, w=0;\tvertexNum=n; arcNum=e;\tfor (i=0; i&lt;vertexNum; i++) vertex[i]=a[i];\tfor (i=0; i&lt;vertexNum; i++) for (j=0; j&lt;vertexNum; j++) arc[i][j]=255; // 假设极大值为255，表示两个顶点不邻接 for (int k=0; k&lt;arcNum; k++) &#123; cout&lt;&lt;&quot;请输入边的两个顶点的序号：&quot;; cin&gt;&gt;i; cin&gt;&gt;j;// arc[i][j]=1; arc[j][i]=1; cout&lt;&lt;&quot;请输入边的权值：&quot;; cin&gt;&gt;w; arc[i][j]=w; arc[j][i]=w; &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFSTraverse(int v)&#123;\tcout &lt;&lt; vertex[v]; visited[v] = 1;\tfor (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &lt;255 &amp;&amp; visited[j]==0) DFSTraverse(j);&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFSTraverse(int v)&#123;\tint Q[MaxSize];\tint front = -1, rear = -1; //初始化队列,假设队列采用顺序存储且不会发生溢出\tcout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队\twhile (front != rear) //当队列非空时\t&#123; v = Q[++front]; //将队头元素出队并送到v中 for (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &lt;255 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125;\t&#125;&#125;template &lt;class DataType&gt;void Dijkstra(MGraph&lt;DataType&gt; MG,int v)&#123;\tint i,k,num,dist[MaxSize];\tstring path[MaxSize];\tfor(int i=0;i&lt;MG.vertexNum;i++)&#123; dist[i]=MG.arc[v][i]; if(dist[i]!=255)&#123; // path[i]=MG.vertex[v]+MG.vertex[i] char直接赋值给string这是不行的 path[i].push_back(MG.vertex[v]);//要用push_back path[i].push_back(MG.vertex[i]); &#125; else path[i]=&quot;&quot;; cout&lt;&lt;&quot;|&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;path[i]&lt;&lt;&quot;|&quot;&lt;&lt;&quot; &quot;;\t&#125;\tcout&lt;&lt;endl;\tfor(num=1;num&lt;MG.vertexNum;num++)&#123; k=Min(dist,MG.vertexNum); cout&lt;&lt;&quot;path&quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;path[k]&lt;&lt;&quot;,&quot;&lt;&lt;dist[k]&lt;&lt;&quot;;&quot;; for(i=0;i&lt;MG.vertexNum;i++)&#123; if(dist[i]&gt;dist[k]+MG.arc[k][i]&amp;&amp;i!=v)&#123;//i!=v不做到达初始点的判断 dist[i]=dist[k]+MG.arc[k][i]; path[i]=path[k]+MG.vertex[i]; &#125; &#125; dist[k]=0; cout&lt;&lt;endl;\t&#125;&#125;int main()&#123;\tchar ch[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;;\tMGraph&lt;char&gt; MG(ch, 5, 7);\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0;\tcout&lt;&lt;&quot;深度优先遍历序列是：&quot;;\tMG.DFSTraverse(0);\tcout&lt;&lt;endl;\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0; cout&lt;&lt;&quot;广度优先遍历序列是：&quot;;\tMG.BFSTraverse(0);\tcout&lt;&lt;endl; cout&lt;&lt;&quot;从顶点&quot;&lt;&lt;ch[0]&lt;&lt;&quot;到各终点的最短路径分别是：&quot;&lt;&lt;endl; Dijkstra(MG,0);\tcout&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125; 有向无环图及其应用概念AOV网（顶点表示活动的网）：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系 AOV网中出现回路意味着活动之间的优先关系是矛盾的 拓扑序列：顶点序列包含所有的点，要满足当且仅当有向图中a到b有一条路径，在顶点序列中a必在b之前。 得AOV网中所有应该存在的前驱和后继关系都能得到满足；拓扑序列不唯一；意义：工程中各个活动必须按照拓扑序列中的顺序进行才是可行的 拓扑排序：对一个有向图构造拓扑序列的过程 image-20221218195618867 这里注意，拓扑序列需要满足当a到b存在路径时a得在b之前即可，不需要序列所有前边的到后边的都得有路径，如这里v0到v1就没有。是一个充分条件 拓扑排序实现 图：带入度的邻接图 栈：入度为0的顶点入栈 算法：TopSort输入：有向图G&#x3D;(V，E)输出：拓扑序列 栈 S 初始化；累加器 count 初始化； 扫描顶点表，将入度为 0 的顶点压栈； 当栈 S 非空时循环3.1 j &#x3D; 栈顶元素出栈；输出顶点 j；count++；3.2 对顶点 j 的每一个邻接点 k 执行下述操作(扫描链表)： 3.2.1 将顶点 k 的入度减 1； 3.2.2 如果顶点 k 的入度为 0，则将顶点 k 入栈； if (count&lt;vertexNum) 输出有回路信息； 123456789101112131415161718192021222324252627282930//结点结构template &lt;class DataType&gt;struct VertexNode&#123; int in;//邻接表增加入度域，方便对入度的操作 DataType vertex;//存顶点 EdgeNode *firstEdge;&#125;;void ALGraph&lt;DataType&gt;::TopSort()&#123; int i,j; int k;//存放邻接点编号 int count=0;//累加器，最后判断是否成环 int S[MaxSize],top=-1;//采用顺序栈并初始化 EdgeNode *p=nullptr;//工作指针 for(i=0;i&lt;vertexNum;i++)//扫描顶点表 if(adjlist[i].in==0) S[++top]=i;//将入度为0的顶点压栈 while(top!=-1)&#123;//栈不空 j=S[top--];//入度为0出栈 cout&lt;&lt;adjlist[j].vertex; count++; p=adjlist[j].firstEdge;//工作指针初始化 while(p!=nullptr)&#123; k=p-&gt;adjvex;//为编号 adjlist[k].in--;//邻接点入度都-1 if(adjlist[k].in==0) S[top++]=k;//入读为0的顶点入栈 p=p-&gt;next;//后移 &#125; if(count&lt;vertexNum) cout&lt;&lt;&quot;有回路&quot;;//拓扑排序一定是有所有点的 &#125;&#125; 如果满足拓扑序列，那么不用担心已出栈的会重复进栈，假设重复进栈，那么就会形成环。 时间复杂度O(n+e) 关键路径AOE网（边表示活动的网）：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的持续时间 AOE网的性质(存在的约束条件)： 只有在进入某顶点的各活动都已经结束，该顶点所代表的事件才能发生 只有在某顶点所代表的事件发生后，从该顶点出发的各活动才能开始 注意活动是可以同时进行的！ 最晚开始时间-最早开始时间就是时间余量，在时间余量做不相干的事也不影响工程进度 关键路径：AOE网中从源点到终点的最长路径。**(也可能不唯一)** 关键活动：关键路径上的活动，即时间余量为0的活动 不按期完成关键活动就会影响整个工程的进度，换言之，要缩短整个工期，必须加快关键活动的进度； 为什么是最长呢？因为最长的都完成了，其他的也肯定完成了，整项工程也就完成了 如何求关键路径呢？–&gt;求关键活动 如何求关键活动呢？关键活动为什么是关键的？关键活动的开始时间不能推迟–&gt;其最早开始时间和最晚开始时间相等 事件(顶点)的最早和最迟如何求ve(j)和vl(j)？ 最早发生时间从ve(1)&#x3D;0开始向后递推，相当于找到这个事件的最长路径 最迟发生时间从vl(n)&#x3D;ve(n)开始向前递推 image-20221223153541781 最早发生时间从前往后推，完成后可以立马开始的那一条。例如左图中Vu到Vj完成了但是下边的还没有完成，Vj不能开始，而当最长的Vx到Vj完成了前面肯定都完成了，可以开始Vj因此最早为88。前边加求最大 最迟发生时间从后往前推，必须开始的时间，晚于这个时间就不能按时完成后边的.如右图，顶点上的数为各事件的最晚发生时间，减去前边活动天数就是允许拖延的事件。Vx的5-2最小为3，说明只允许拖三天就必须要开始了，再晚点开始耗费两天的话就超过Vx的最迟发生时间了，因此Vj最迟时间为3。后边减求最小 活动(边)的最早和最迟最早发生时间等于弧尾事件的最早发生时间 最迟发生时间等于弧头事件的最晚发生时间减去这条弧的长度 问题 n个顶点的无向图，采用邻接表存储： 统计出度为0的顶点个数 123456789101112131415int SunZero(MGraph mg)&#123;\tint count;//统计有多少个\tfor(int i=0;i&lt;mg.vertexNum;i++)&#123; int tag=0;//标记 for(int j=0;i&lt;mg.vertexNum;j++)&#123; if(edge[i][j]!=0)&#123; tag=1; break; &#125; &#125; if(tag==0) count++;\t&#125; return count;&#125; 查找技术关键码：可以标识一个记录的某个数据项 如何评价查找算法的效率呢？：和关键码的比较次数 平均查找长度：查找算法进行的关键码比较次数的数学期望值 线性表的查找技术顺序查找(线性查找)思想：从表的一端到另一端，逐个比较 以下代码默认待查表索引0处不存值。 123456int SeqSearch(int r[],int n,int k)&#123; int i=n; while(i&gt;0&amp;&amp;r[i]!=k) i--; return i;//若没查到返回值是0&#125; 从后往前，注意判断是否越界 改进版：尽头设置哨兵，免去判越界 1234567int LineSearch::SeqSearch2(int k)&#123; int i=n; data[0]=k;//设置哨兵 while(data[i]!=k)//免去判越界 i--; return i;//同样查不到返回的是0&#125; 算法 顺序查找 优点 算法简单、使用面广。对存储(线或链)、有序性无要求 缺点 查找效率低，特别是元素多的时候 折半查找(对半查找、二分查找)思想：如其名 先排好序！ 非递归12345678910int LineSearch::BinSearch1(int k)&#123; int mid,low=1,high=n;//1开始记录的 while(low&lt;=high)&#123;//如果没找到，low会超过high，结束循环 mid=(high+low)/2; if(k&lt;data[mid]) high=mid-1; else if(k&gt;data[mid]) low=mid+1; else return mid;//查找成功，返回元素序号 &#125; return 0;//查找失败，返回0&#125; 递归12345678910int LineSearch::BinSearch2(int low,int high,int k)&#123; int mid; if(low&gt;high) return 0;//递归的边界条件 else&#123; mid=(low+high)/2; if(k&gt;data[mid]) BinSearch2(mid+1,high,k); else if(k&lt;data[mid]) BinSearch2(low,mid-1,k); else return mid;//查找成功返回序号 &#125;&#125; 树表的查找技术二叉排序树定义 一棵空的二叉树 或者满足： 若它的左子树不空，则左子树上所有结点的值均小于根结点的值 若它的右子树不空，则右子树上所有结点的值均小于根结点的值 它的左右子树都是而二叉排序树 二叉排序树的中序序列即是升序序列 存储：二叉链表 二叉树排序树的实现123456789class BiSortTree&#123;public: ...private: BiNode&lt;int&gt; *InsertBST(BiNode&lt;int&gt; *bt , int x); BiNode&lt;int&gt; *SearchBST(BiNode&lt;int&gt; *bt, int k); void Release(BiNode&lt;DataType&gt; *bt); BiNode&lt;int&gt; *root; &#125; 查找 找不到的情况 找到的情况 比当前小的情况 比当前大的情况 123456BiNode&lt;int&gt; * BiSortTree::SearchBST(BiNode&lt;int&gt;* bt,int k)&#123;//k是查找值 if(bt==nullptr) return nullptr; if(bt-&gt;data==k) return bt;//找到了 if(bt&gt;data&gt;k) return SearchBST(bt-&gt;lchild,k);//大于查找值，查左树 else return SearchBST(bt-&gt;rchild,k);//小于查找值，查右s&#125; 插入思路： 若二叉排序树为空树，则新插入的结点为新的根结点； 否则，新插入的结点必为一个新的叶子结点，其插入位置由查找过程得到。 比当前结点小，则插入它的左子树；否则插入右子树 核心： 递归 链表插入结点 1234567891011BiNode&lt;int&gt;* BiSortTree::InsertBST(BiNode&lt;int&gt; *bt,int x)&#123; if(bt==nullptr)&#123; //为空插入 BiNode&lt;int&gt; *s=new BiNode&lt;int&gt;; s-&gt;data=x; s-&gt;lchild=s-&gt;rchild=nullptr; bt=s;//新结点上树 return bt; &#125;else if(bt-&gt;data&gt;x) bt-&gt;lchild=InsertBST(bt-&gt;lchild,x); else bt-&gt;rchild=InsertBST(bt-&gt;rchild,x);//注意这里不是单纯的递归函数就可以了，需要赋值的，因为会插入结点改变树&#125; 注意有返回值，返回值为新结点，赋值给传入树的左&#x2F;右子树 构造建立在插入的基础上 （1）每次插入的新结点都是二叉排序树上新的叶子结点;（2）找到插入位置后，不必移动其它结点，仅需修改某个结点的指针；（3）在左子树&#x2F;右子树的查找过程与在整棵树上查找过程相同；（4）新插入的结点没有破坏原有结点之间的关系。 12345BiSortTree::BiSortTree(int a[],int n)&#123; root=nullptr; for(int i=0;i&lt;n;i++) root=InsertBST(root,a[i]);&#125; 删除 删除后仍要保持二叉排序树的特性 当删除分支节点就破坏了原有的链接关系，需要重新修改指针 分三种情况： 被删除的结点是叶子结点 则将它的双亲结点相应的指针域值置为空，比如p是f的左孩子，现在删除p则f-&gt;lchild=nullptr; 被删除的结点只有左子树或者只有右子树 把删除结点的左(右)子树代替它的位置即可，比如p是f的左孩子，而p不是叶子，它有右子树，这是删除p，则f-&gt;lchile=p-&gt;rchild 这里不管是怎么样，有左子树还是右子树，都是代替它的位置，因为由性质可知左子树所有元素都小于根节点，右子树都大于它，因此代替后不会影响它的有序性 被删除的结点既有左子树，又有右子树 分两种情况：当p是f的左孩子，删p时则以f的左子树中的最大值结点替换之，最大值就在左子树的最右下；当p是f的有孩子，则以f右子树的最小值替换它，在最左下 这样保证了我的左子树都小于我，右子树都大于我，因此选左边的最大或右边的最小 注意特殊情况，当最大&#x2F;最小就是被删除结点的孩子时 1234567891011121314151617181920212223242526272829303132//注意，下面默认p是f的左孩子，右孩子同理不失一般性，但是要另写template &lt;typename DataType&gt;void BiSortTree::DeleteBST(BiNode&lt;int&gt; *p,BiNode&lt;int&gt; *f)&#123; if((p-&gt;lchild==nullptr)&amp;&amp;(p-rchild==nullptr))&#123; //p为叶子 f-&gt;lchild=NULL;//先置为空 delete p;//再删除 return; &#125; if(p-&gt;rchild==nullptr)&#123; //p只有左子树 f-&gt;lchild=p-&gt;lchild; delete p; returnl &#125; if(p-&gt;lchild==nullptr)&#123; //p只有右子树 f-&gt;lchild=p-&gt;rchild; delete p; return; &#125; //找左子树最大的，找最右下 BiNode&lt;int&gt; *par=p,*s=p-&gt;lchild; while(s-&gt;rchild!=nullptr)&#123; par=s;//工作指针 s=s-&gt;rchild; &#125; p-&gt;data=s-&gt;data;//修改值 if(par==p) par-&gt;rchild=s-&gt;lchild; else par-&gt;lchild=s-&gt;lchild;//挂到par delete s;&#125; 给定结点的深度123456void Level(BiNode *root,BiNode *p)&#123; if(root==nullptr) return 0; if(p==root) return 1; else if(p-&gt;data&lt;root-&gt;data) return Level(root-&gt;lchild,p)+1;//每递归一次说明多了一层 else return Level(root-&gt;rchild,p)+1;&#125; 平均查找长度查找成功的平均查找长度为：∑（本层高度*本层元素个数）&#x2F;节点总数 查找不成功的平均查找长度：∑（本层高度*本层补上的叶子个数）&#x2F;补上的叶子总数 平衡二叉树 平衡因子：该结点的左子树的深度减去右子树的深度 平衡二叉树： 一棵空的二叉排序树，或者同时满足： 根结点的左子树和右子树的深度最多相差1 根结点的左子树和右子树都是平衡二叉树 插入一个结点会影响哪些结点的平衡因子？ 最小不平衡子树：以距离插入结点最近的、且平衡因子的绝对值大于 1 的结点为根的子树 且入且判断，一旦失衡立即调整；只调整最小不平衡子树，并且不影响其他结点；充分利用二叉排序树的性质来作调整 LL型 B结点带左子树一起上升 A成为B的右孩子(因为A大于B) B结点原来的右子树作为A的左子树 image-20221220165706645 RR型 B结点带右子树一起上升 A结点成为B的左孩子 原来B的左子树做A的右子树 image-20221220165423429 LR型 C结点穿过A、B结点上升 B结点成为C的左孩子，A结点成为C的右孩子(因为B是小于C的，而A是大于C的) 原来C结点的左子树作为B的右子树，C结点的右子树作为A的左子树 image-20221220164736781 RL型image-20221220165952142 一个原则，上升后根据二叉排序树的性质进行调整 散列表的查找技术 散列表：采用散列技术存储查找集合的连续存储空间。 散列函数：将关键码映射为散列表中适当存储位置的函数 散列地址：由散列函数所得的存储地址 散列函数的设计： 计算简单。不应太大计算量，降低茶轴效率 函数值(即散列地址)分布均匀，相同概率散列到散列表中，减少冲突 两个方面是矛盾的，根据具体情况选择一个合理的方案 image-20221220171726174 常见的散列函数 散列函数 直接定址法 平方取中法 除留余数法 形式 H(key)&#x3D;a×key+b 对关键码平方后，按散列表大小，取中间的若干位作为散列地址。 H(key)&#x3D;key mod p 例子 关键码集合为{10, 30, 50, 70, 80, 90}，选取的散列函数为H(key)&#x3D;key&#x2F;10，则10存在下标为1，30在2… 要求散列地址为 2 位，则(1234)2＝1522756，(1235)2＝1525225，分别取27，52 散列表长为15，设计H(key)&#x3D; key mod 13 适用 事先知道关键码，关键码集合不是很大且连续性较好 事先不知道关键码的分布且关键码的位数不是很大 最简单、最常用，不要求事先知道关键码的分布 以下关于哈希查找的叙述中错误的是（A ）。 A. 用拉链法解决冲突易引起堆积现象 B. 用线性探测法解决冲突易引起堆积现象 C. 哈希函数选得好可以减少冲突现象 D. 哈希函数H(k)&#x3D;k MOD p，p通常取小于等于表长的素数 处理冲突的方法开放寻址法 闭散列表：用开放定址法处理冲突得到的散列表 原理： 1）计算散列地址：j &#x3D; H(key) 2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录； 3）如果在地址 j 发生冲突，则寻找一个空的散列地址，存储key对应的记录； 如何寻找一个空的散列地址？ 线性探测法 二次探测法 随机探测法等 线性探测法当发生冲突时，寻找空散列表地址的公式为：Hi&#x3D;(H(key)＋di) % m （di&#x3D;1，2，…，m-1) 这个di是设定的，比如设定为1，那么当冲突时就往后试探一位，再冲突再试探，直到有空位 堆积：非同义词对同一个散列地址争夺的现象 算法：Search输入：闭散列表ht[ ]，待查值k输出：如果查找成功，则返回记录的存储位置，否则返回查找失败的标志-1 1. 计算散列地址 j； 2. 探测下标i初始化：i &#x3D; j； 1. 执行下述操作，直到 ht[i] 为空： 2.3.1 若 ht[i] 等于 k，则查找成功，返回记录在散列表中的下标； 3.2 否则，i 指向下一单元； 4. 查找失败，返回失败标志-1； 123456789int HashTabel::Search(int k)&#123; int i,j=H(k);//计算散列地址 i=j;//设置比较的起始位置 while(ht[i]!=0)&#123; if(ht[i]==k) return i;//查找成功 else i=(i+1)%m;//向后探测一个位置 &#125; return -1;//查找失败&#125; 二次探测法以冲突位置为中心，跳跃式寻找空的散列地址。 Hi&#x3D;(H(key)＋di) % m （di &#x3D; 12,-12,,22,,-22,,… , q2,,-q2,(q≤m&#x2F;2)） 拉链法开散列表：用拉链法处理冲突得到的散列表 同义词子表：所有散列地址相同的记录构成的单链表。(拉链一样链起来) 对于给定的关键码key执行下述操作： （1）计算散列地址：j &#x3D; H(key) （2）将key对应的记录插入(头插法)到同义词子表 j 中； 12345678910111213//用拉链法处理冲突，散列表的构造过程如下j=H(k);Node&lt;int&gt; *p=ht[i];while(p!=nullptr)&#123; if(p-&gt;data==k) break; else p=p-&gt;next;&#125;if(p==null)&#123; q=new Node&lt;int&gt;; q-&gt;data=k; q-&gt;next=ht[j]; ht[j]=q;&#125; image-20221220195949858 排序技术 稳定性：原序列中，a&#x3D;b且a在b之前，排序后a仍在b之前，称排序算法稳定；否则称为不稳定 趟：排序过程中，将待排序的记录序列扫描一遍称为一趟 插入排序直接插入排序代码12345678910void Sort::InsertSort()&#123; int i,j,temp; for(i=1;i&lt;length;i++)&#123;//⭐排序进行length-1趟 temp=data[i];//暂存每一轮的目标记录 for(j=i-1;j&gt;=0&amp;&amp;temp&lt;data[j];j--)&#123; data[j+1]=data[j]; &#125; data[j+1]=temp;//每一轮退出上述循环时，j会--，即只有j+1个位置是空的，故插入位置为j+1 &#125;&#125; 情况分析最好情况： 待排序序列都是正序。 每趟只需与有序序列最后一个记录比较一次，移动两次记录。 比较次数：$n-1$ ，移动次数：$2(n-1)$ 最坏情况： 待排序记录为逆序 第i个记录要和前面i-1个记录比较，每次执行一次移动 比较次数：$\\frac{n(n-1)}{2}$ ， 移动次数： $\\frac{(n+4)(n-1)}{2}$ 平均情况： 各种可能 插入第i个记录需要比较有序区中全部记录的一半 比较次数：$\\frac{n(n-1)}{4}$， 移动次数：$\\frac{(n+4)(n-1)}{4}$ ⭐希尔排序改进点①当待排序记录基本有序，直接插入排序的效率很高（怎么使得排序记录基本有序） ②直接插入排序简单，在记录个数少时效率也很高（怎么使得排序的记录少） ③让元素跨度大一些以更早地到达最终位置 关键问题①如何分割待排序记录，使得基本有序:不能是逐段分割，而是将相距某个增量的记录组成一个子序列 ②子序列内怎么进行直接插入排序 123456temp = r[i]; j = i - d; while (j &gt; 0 &amp;&amp; temp &lt; data[j]) &#123; data[j + d] = data[j]; j = j - d;&#125;data[j + d] = temp; image-20221221113526097 代码123456789101112void Sort::ShellSort()&#123; int i,j,temp;//暂存 for(d=length/2;d&gt;0;d--)&#123;//增量为d进行直接插入排序 for(i=d;i&lt;length;i++)&#123;//进行一趟希尔排序 temp=data[i]; for(j=i-d;j&gt;0&amp;&amp;data[j]&gt;temp;j=j-d)//至关重要的 data[j+d]=data[j];//记录后移d个单位 data[j+d]=temp; &#125; &#125;&#125; 一趟希尔排序就是在增量d的情况下把所有子序列都拍好的结果 交换排序⭐起泡排序每轮冒出一个最大(小)的 基本思路 两两比较记录，如果反序则交换，直到没有反序的记录为止 关键问题①在一趟排序中，多个记录位于最终位置时如何记载？ • 用exchange标记每次交换的位置，则最终exchange之后所有记录都是有序 ②如何确定有序区的范围 • 用bound记录，每一轮bound等于上一轮最终的exchange ③如何判别起泡排序结束？ • 当exchange为0 ④进入循环之前exchange初值为？ • [0-length-1]时，exchange&#x3D;length-1 代码123456789101112131415161718void Sort::BubbleSort()&#123; int j;//位置 int exchange;//记录每次交换的位置 int bound;//记录有序区范围 int temp;//暂存 exchange=length-1;//先记下范围，后面赋值给bound while(exchange!=0)&#123;//结束条件exchange=0，全有序了 bound=exchange; exchange=0; for(j=0;j&lt;bound;j++) if(data[j]&gt;data[j+1])&#123; temp=data[j]; data[j]=data[j+1]; data[j+1]=temp; exchange=j;//记录每次交换的位置 &#125; &#125;&#125; ⭐快速排序基本思想选一个轴值，将待排序记录划分成两部分，左侧记录均小于或等于轴值，右侧记录均大于或等于轴值，然后分别对这两部分重复上述过程，直到整个序列有序。 关键问题①如何选择轴值？ 多种，最简单选第一个记录 ②在待排序序列中如何进行划分 ③如何处理划分得到的两个待排序子序列 ④如何判别快排结束 对序列进行一次划分，再分别对左右两个子序列进行快排，再对…快排 直到每个分区只有一个记录 image-20221221115949199 123456789101112131415161718192021222324252627282930313233//一次划分int Sort::Parttition(int first,int last)&#123; int i=first;//左侧 int j=last;//右侧 int temp; while(i&lt;j)&#123; while(i&lt;j&amp;&amp;data[j]&gt;=data[i]) j--; if(i&lt;j)&#123; temp=data[i]; data[i]=data[j]; data[j]=temp; i++;//注意这里 &#125; while(i&lt;j&amp;&amp;data[i]&lt;=data[j]) i++; if(i&lt;j)&#123; temp=data[i]; data[i]=data[j]; data[j]=temp; j--; &#125; &#125; return i;//返回轴值最终位置&#125;//递归void Sort::QuickSort(int first,int last)&#123; if(first&gt;=last) return;//区间长度为1，递归结束 else&#123; int pivot=Partition(first,last);//一次划分 QuickSort(first,pivot-1);//左侧快排 QuickSort(pivot+1,last);//右侧快排 &#125;&#125; 选择排序简单选择排序代码1234567891011121314void Sort::SelectSort()&#123; int index,i,temp; for(int i=0;i&lt;length;i++)&#123;//进行length-1趟简单选择排序 index=i; for(int j=i+1;j&lt;length)&#123;//在无序区中选取最小记录 if(data[j]&lt;data[index]) index=j; &#125; if(index!=i)&#123; temp=data[i]; data[i]=data[index]; data[index]=temp; &#125; &#125;&#125; ⭐堆排序堆的实质满是足如下性质的完全二叉树：二叉树中任一非叶子结点均小于(大于)它的孩子结点 大根堆：ki≥k2i且ki≥k2i+1 从最后一个非叶子结点开始调整，即从 n&#x2F;2开始，n&#x2F;2-1…到1 堆存储数组是层序遍历形式 堆调整中左孩子是什么表示的$2×i+1$：存储从data[0]开始，所以左孩子是$2×i+1$，右孩子是$2×i+2$ 重建堆 1234567891011121314151617181920212223242526272829//堆调整 仅是对一个元素进行调整，堆排序需要反复调用推调整void Sort::Sift(int k,int last)&#123; int i,j,temp; i=k;//i是被调整结点 j=2*i+1;//j是i的左孩子 while(j&lt;=last)&#123; if(j&lt;last&amp;&amp;data[j+1]&gt;data[j]) j++;//j指向左右孩子的较大者 if(data[i]&gt;data[j]) break;//说明已经是堆 else&#123; temp=data[j]; data[j]=data[i]; data[i]=temp; i=j;j=2*i+1;//被调整结点位于结点J的位置 &#125; &#125;&#125;//堆排序void Sort::HeapSort()&#123; int i,temp; for(i=ceil(length/2)-1;i&gt;=0;i--) //从最后一个分支结点(即最后一个非叶子结点)至根结点调整 Sift(i,length-1); for(i=1;i&lt;length;i++)&#123; temp=data[0]; data[0]=data[length-1]; data[length-1]=temp; Sift(0,length-i-1);//重建堆 &#125;&#125; 当i从1开始的堆排序，注意有好几处不同 12345678910111213141516171819202122232425//堆排序//堆调整void Sift(int k,int r[],int n)&#123;\tint i,j,temp;\ti=k;j=2*i;//去+1\twhile(j&lt;=n)&#123;//还没到叶子 if(j&lt;n&amp;&amp;r[j]&lt;r[j+1]) j++;//j指向左右孩子的较大者 if(r[i]&gt;r[j]) break;//已经是堆 else&#123; temp=r[i]; r[i]=r[j]; r[j]=temp; i=j;j=2*i;//去+1 &#125; &#125;&#125; void HeapSort(int r[],int n)&#123;\tint i,temp;\tfor(i=n/2;i&gt;=1;i--)//去eil\t//从最后一个分支结点至根结点调整 Sift(i,r,n);\tfor(i=1;i&lt;n;i++)&#123;//1 temp=r[1];r[1]=r[n-i+1];r[n-i+1]=temp;//n-i+1 1 Sift(1,r,n-i);//重建堆 1 &#125; 各种排序的比较image-20221209142457790 排序方法 平均情况 最好情况 最坏情况 直接插入排序 O(n2) O(n) O(n2) 希尔排序 O(nlog2n)~O(n2) O(n1.3) O(n2) 起泡排序 O(n2) O(n) O(n2) 快速排序 O(nlog2n) O(nlog2n) O(n2) 简单选择排序 O(n2) O(n2) O(n2) 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) image-20221221183614599 image-20221209142555586 image-20221209142741177 image-20221209142925247 image-20221209143059040","tags":["笔记"],"categories":["本科课程"]},{"title":"课本Dijkstra算法Cpp实现及改正","path":"/2022/11/16/Dijkstra算法C++实现/","content":"01点17分，又是一个与奇怪问题较量的夜晚，这一次，我又成功解决了。 起因是发现数据结构书上关于Dijkstra算法的实现有点错误，想要自己更正一下，通过在不同位置插入输出字符来调试代码，找到了几处错漏。 96行的char直接赋值给string出现乱码，两种办法，一是string+&#x3D;char，另一种是string.puch_back(char) 107行，由于是无向图，有可能路径会重复连上两次，我们要让路径不再逆向连接，例如A起始，默认第一轮是已知AB最短为10，在判断最短路径时，没有排除A，到时AB又连上A，变成ABA，而这个ABA是在path[0]上的，虽然每轮输出最短路径时就不需要输出path[起始点]，这样子的错误也是无妨，只需要跳过path[起始点]即可，但是在调试过程中发现这个错漏，还是从根本上修正，可以把它改成有向图，把初始化的arc[j][i]&#x3D;w去掉。 (自己的问题)输出结果为?，发现原来是经典for循环是其他变量在递增时还是写了i++…导致循环出不来 还有一个注意点需要补充，就是可变参数友元函数的声明: 12345678910111213template &lt;class DataType&gt;class MGraph&#123; ... template &lt;class T&gt; friend void Dijkstra(MGraph&lt;T&gt; MG,int v);//友元函数声明，注意不可是DataType，会和类冲突，得换掉，这里是T&#125;//函数实现template &lt;class DataType&gt;void Dijkstra(MGraph&lt;DataType&gt; MG,int v)&#123;//这里可以是DataType ...&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//图 DFS BFS Dijkstra 完整代码#include &lt;iostream&gt;using namespace std;#include&lt;string&gt;const int MaxSize = 10; //图中最多顶点个数int visited[MaxSize]=&#123;0&#125;;struct element&#123;\tint lowcost, adjvex;&#125;;int Min(int dist[],int ver)&#123;\tint min=255,minNum=0;\tfor(int i=0;i&lt;ver;i++)&#123; if(dist[i]&lt;min&amp;&amp;dist[i]&gt;0)&#123; min=dist[i]; minNum=i; &#125;\t&#125;\treturn minNum;&#125;template &lt;class DataType&gt;class MGraph&#123;public:\tMGraph(DataType a[ ], int n, int e); //构造函数，建立具有n个顶点e条边的图\t~MGraph( ) &#123; &#125; //析构函数为空\tvoid DFSTraverse(int v); //深度优先遍历图\tvoid BFSTraverse(int v); //广度优先遍历图\ttemplate &lt;class T&gt;\tfriend void Dijkstra(MGraph&lt;T&gt; MG,int v);private: DataType vertex[MaxSize]; //存放图中顶点的数组 int arc[MaxSize][MaxSize]; //存放图中边的数组 int vertexNum, arcNum; //图的顶点数和边数&#125;;template &lt;class DataType&gt;MGraph&lt;DataType&gt;::MGraph(DataType a[ ], int n, int e)&#123;\tint i, j, w=0;\tvertexNum=n; arcNum=e;\tfor (i=0; i&lt;vertexNum; i++) vertex[i]=a[i];\tfor (i=0; i&lt;vertexNum; i++) for (j=0; j&lt;vertexNum; j++) arc[i][j]=255; // 假设极大值为255，表示两个顶点不邻接 for (int k=0; k&lt;arcNum; k++) &#123; cout&lt;&lt;&quot;请输入边的两个顶点的序号：&quot;; cin&gt;&gt;i; cin&gt;&gt;j;// arc[i][j]=1; arc[j][i]=1; cout&lt;&lt;&quot;请输入边的权值：&quot;; cin&gt;&gt;w; arc[i][j]=w; // arc[j][i]=w;//改成有向图，使得路径不重复 &#125;&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::DFSTraverse(int v)&#123;\tcout &lt;&lt; vertex[v]; visited[v] = 1;\tfor (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &lt;255 &amp;&amp; visited[j]==0) DFSTraverse(j);&#125;template &lt;class DataType&gt;void MGraph&lt;DataType&gt;::BFSTraverse(int v)&#123;\tint Q[MaxSize];\tint front = -1, rear = -1; //初始化队列,假设队列采用顺序存储且不会发生溢出\tcout &lt;&lt; vertex[v]; visited[v] = 1; Q[++rear] = v; //被访问顶点入队\twhile (front != rear) //当队列非空时\t&#123; v = Q[++front]; //将队头元素出队并送到v中 for (int j = 0; j &lt; vertexNum; j++) if (arc[v][j] &lt;255 &amp;&amp; visited[j] == 0 ) &#123; cout &lt;&lt; vertex[j]; visited[j] = 1; Q[++rear] = j; &#125;\t&#125;&#125;template &lt;class DataType&gt;void Dijkstra(MGraph&lt;DataType&gt; MG,int v)&#123;\tint i,k,num,dist[MaxSize];\tstring path[MaxSize];\tfor(int i=0;i&lt;MG.vertexNum;i++)&#123; dist[i]=MG.arc[v][i]; if(dist[i]!=255)&#123; // path[i]=MG.vertex[v]+MG.vertex[i] char直接赋值给string这是不行的 path[i].push_back(MG.vertex[v]);//要用push_back path[i].push_back(MG.vertex[i]); &#125; else path[i]=&quot;&quot;; cout&lt;&lt;&quot;|&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;path[i]&lt;&lt;&quot;|&quot;&lt;&lt;&quot; &quot;;\t&#125;\tcout&lt;&lt;endl;\tfor(num=1;num&lt;MG.vertexNum;num++)&#123; k=Min(dist,MG.vertexNum); cout&lt;&lt;&quot;path&quot;&lt;&lt;k&lt;&lt;&quot; &quot;&lt;&lt;path[k]&lt;&lt;&quot;,&quot;&lt;&lt;dist[k]&lt;&lt;&quot;;&quot;; for(i=0;i&lt;MG.vertexNum;i++)&#123; if(dist[i]&gt;dist[k]+MG.arc[k][i])&#123; dist[i]=dist[k]+MG.arc[k][i]; path[i]=path[k]+MG.vertex[i]; &#125; &#125; dist[k]=0; cout&lt;&lt;endl;\t&#125;&#125;int main()&#123;\tchar ch[]=&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;&#125;;\tMGraph&lt;char&gt; MG(ch, 5, 7);\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0;\tcout&lt;&lt;&quot;深度优先遍历序列是：&quot;;\tMG.DFSTraverse(0);\tcout&lt;&lt;endl;\tfor (int i=0; i&lt;MaxSize; i++) visited[i]=0; cout&lt;&lt;&quot;广度优先遍历序列是：&quot;;\tMG.BFSTraverse(0);\tcout&lt;&lt;endl; cout&lt;&lt;&quot;从顶点&quot;&lt;&lt;ch[0]&lt;&lt;&quot;到各终点的最短路径分别是：&quot;&lt;&lt;endl; Dijkstra(MG,0);\tcout&lt;&lt;endl; system(&quot;pause&quot;); return 0;&#125;","tags":["C++"]},{"title":"爱心特效","path":"/2022/11/14/爱心特效/","content":"原网站是：https://www.manyuan.ltd 在原网站的基础上作了修改，可以添加自定义文字，关键在于和爱心中心的相对位置需要随着界面的大小改变而改变，另外我将它部署到了我的博客上作为展示(github-hexo 如何添加自定义网页 - 简书 (jianshu.com)）。 自定义的爱心效果：就这个爱心嘛 (jjuprising.github.io) image.png 由于原本的画布是有做根据页面动态更新大小的，使得爱心总是位于界面的中央，这个功能非常好，因此我的想法在这个基础上获取画布的长宽，再加入微调值使得文字可以位于爱心的中央，同时能够保持和爱心的相对位置不变。此外，为了解决手机端适配的问题，在head中加上了最后一行META(令人惊讶的是，原网站没有这一句，但是依然可以适配手机页面，值得我去研究研究)。再者，我在尝试自己插入bgm时发现了audio设置auto还是无法自动播放的问题，最终参考原网站代码添加了播放检测的脚本解决了问题。 当然，这种方法是比较笨的，需要根据效果手动微整，也是目前我能想到的解决办法。而且，手机适配也做得一般，爱心会显示不全，且设置的字体加载不出来，效果差强人意，有待优化。 自定义修改的位置： 修改文字：在div元素中修改 手动微调：在代码的第299行，修改最后±的数值即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.0 Transitional//EN&quot;&gt;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt; 就这个爱心嘛 &lt;/TITLE&gt; &lt;META NAME=&quot;Generator&quot; CONTENT=&quot;EditPlus&quot;&gt; &lt;META NAME=&quot;Author&quot; CONTENT=&quot;&quot;&gt; &lt;META NAME=&quot;Keywords&quot; CONTENT=&quot;&quot;&gt; &lt;META NAME=&quot;Description&quot; CONTENT=&quot;&quot;&gt; &lt;META name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=3.0, minimum-scale=1.0, user-scalable=yes&quot;&gt; &lt;!--适配手机 content参数依次 显示大小 初始大小 最大大小 最小大小 是否支持用户缩放 --&gt; &lt;style&gt; html, body &#123; height: 100%; padding: 0; margin: 0; background: #000;&#125;canvas &#123; position: absolute; width: 100%; height: 100%;&#125;div&#123; position: absolute; width: 100%; height: 100%;&#125;audio&#123; display: none;&#125; &lt;/style&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;canvas id=&quot;pinkboard&quot; &gt;&lt;/canvas&gt; &lt;div id=&quot;text&quot; style=&quot;font-family: \\534E\\6587\\884C\\6977;&quot;&gt;5 2 0&lt;/div&gt; &lt;audio id=&quot;music&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; preload=&quot;auto&quot; src=&quot;http://music.163.com/song/media/outer/url?id=9442015.mp3&quot;&gt; &lt;/audio&gt; &lt;script&gt; // music window.onload = function()&#123; setInterval(&quot;toggleSound()&quot;,1);&#125;function toggleSound() &#123; var music = document.getElementById(&quot;music&quot;);//获取ID if (music.paused) &#123; //判读是否播放 music.paused=false; music.play(); //没有就播放 &#125; &#125;//--创建页面监听，等待微信端页面加载完毕 触发音频播放document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123; function audioAutoPlay() &#123; var audio = document.getElementById(&#x27;music&#x27;); audio.play(); document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function () &#123; audio.play(); &#125;, false); &#125; audioAutoPlay();&#125;);//--创建触摸监听，当浏览器打开页面时，触摸屏幕触发事件，进行音频播放document.addEventListener(&#x27;touchstart&#x27;, function () &#123; function audioAutoPlay() &#123; var audio = document.getElementById(&#x27;music&#x27;); audio.play(); &#125; audioAutoPlay();&#125;); /* * Settings */var settings = &#123; particles: &#123; length: 500, // maximum amount of particles duration: 2, // particle duration in sec velocity: 100, // particle velocity in pixels/sec effect: -0.75, // play with this for a nice effect size: 30, // particle size in pixels &#125;,&#125;;/* * RequestAnimationFrame polyfill by Erik M?ller */(function()&#123;var b=0;var c=[&quot;ms&quot;,&quot;moz&quot;,&quot;webkit&quot;,&quot;o&quot;];for(var a=0;a&lt;c.length&amp;&amp;!window.requestAnimationFrame;++a)&#123;window.requestAnimationFrame=window[c[a]+&quot;RequestAnimationFrame&quot;];window.cancelAnimationFrame=window[c[a]+&quot;CancelAnimationFrame&quot;]||window[c[a]+&quot;CancelRequestAnimationFrame&quot;]&#125;if(!window.requestAnimationFrame)&#123;window.requestAnimationFrame=function(h,e)&#123;var d=new Date().getTime();var f=Math.max(0,16-(d-b));var g=window.setTimeout(function()&#123;h(d+f)&#125;,f);b=d+f;return g&#125;&#125;if(!window.cancelAnimationFrame)&#123;window.cancelAnimationFrame=function(d)&#123;clearTimeout(d)&#125;&#125;&#125;());/* * Point class */var Point = (function() &#123; function Point(x, y) &#123; this.x = (typeof x !== &#x27;undefined&#x27;) ? x : 0; this.y = (typeof y !== &#x27;undefined&#x27;) ? y : 0; &#125; Point.prototype.clone = function() &#123; return new Point(this.x, this.y); &#125;; Point.prototype.length = function(length) &#123; if (typeof length == &#x27;undefined&#x27;) return Math.sqrt(this.x * this.x + this.y * this.y); this.normalize(); this.x *= length; this.y *= length; return this; &#125;; Point.prototype.normalize = function() &#123; var length = this.length(); this.x /= length; this.y /= length; return this; &#125;; return Point;&#125;)();/* * Particle class */var Particle = (function() &#123; function Particle() &#123; this.position = new Point(); this.velocity = new Point(); this.acceleration = new Point(); this.age = 0; &#125; Particle.prototype.initialize = function(x, y, dx, dy) &#123; this.position.x = x; this.position.y = y; this.velocity.x = dx; this.velocity.y = dy; this.acceleration.x = dx * settings.particles.effect; this.acceleration.y = dy * settings.particles.effect; this.age = 0; &#125;; Particle.prototype.update = function(deltaTime) &#123; this.position.x += this.velocity.x * deltaTime; this.position.y += this.velocity.y * deltaTime; this.velocity.x += this.acceleration.x * deltaTime; this.velocity.y += this.acceleration.y * deltaTime; this.age += deltaTime; &#125;; Particle.prototype.draw = function(context, image) &#123; function ease(t) &#123; return (--t) * t * t + 1; &#125; var size = image.width * ease(this.age / settings.particles.duration); context.globalAlpha = 1 - this.age / settings.particles.duration; context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size); &#125;; return Particle;&#125;)();/* * ParticlePool class */var ParticlePool = (function() &#123; var particles, firstActive = 0, firstFree = 0, duration = settings.particles.duration; function ParticlePool(length) &#123; // create and populate particle pool particles = new Array(length); for (var i = 0; i &lt; particles.length; i++) particles[i] = new Particle(); &#125; ParticlePool.prototype.add = function(x, y, dx, dy) &#123; particles[firstFree].initialize(x, y, dx, dy); // handle circular queue firstFree++; if (firstFree == particles.length) firstFree = 0; if (firstActive == firstFree ) firstActive++; if (firstActive == particles.length) firstActive = 0; &#125;; ParticlePool.prototype.update = function(deltaTime) &#123; var i; // update active particles if (firstActive &lt; firstFree) &#123; for (i = firstActive; i &lt; firstFree; i++) particles[i].update(deltaTime); &#125; if (firstFree &lt; firstActive) &#123; for (i = firstActive; i &lt; particles.length; i++) particles[i].update(deltaTime); for (i = 0; i &lt; firstFree; i++) particles[i].update(deltaTime); &#125; // remove inactive particles while (particles[firstActive].age &gt;= duration &amp;&amp; firstActive != firstFree) &#123; firstActive++; if (firstActive == particles.length) firstActive = 0; &#125; &#125;; ParticlePool.prototype.draw = function(context, image) &#123; // draw active particles if (firstActive &lt; firstFree) &#123; for (i = firstActive; i &lt; firstFree; i++) particles[i].draw(context, image); &#125; if (firstFree &lt; firstActive) &#123; for (i = firstActive; i &lt; particles.length; i++) particles[i].draw(context, image); for (i = 0; i &lt; firstFree; i++) particles[i].draw(context, image); &#125; &#125;; return ParticlePool;&#125;)();/* * Putting it all together */(function(canvas) &#123; var context = canvas.getContext(&#x27;2d&#x27;), particles = new ParticlePool(settings.particles.length), particleRate = settings.particles.length / settings.particles.duration, // particles/sec time; // get point on heart with -PI &lt;= t &lt;= PI function pointOnHeart(t) &#123; return new Point( 160 * Math.pow(Math.sin(t), 3), 130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25 ); &#125; // creating the particle image using a dummy canvas var image = (function() &#123; var canvas = document.createElement(&#x27;canvas&#x27;), context = canvas.getContext(&#x27;2d&#x27;); canvas.width = settings.particles.size; canvas.height = settings.particles.size; // helper function to create the path function to(t) &#123; var point = pointOnHeart(t); point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350; point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350; return point; &#125; // create the path context.beginPath(); var t = -Math.PI; var point = to(t); context.moveTo(point.x, point.y); while (t &lt; Math.PI) &#123; t += 0.01; // baby steps! point = to(t); context.lineTo(point.x, point.y); &#125; context.closePath(); // create the fill context.fillStyle = &#x27;#ea80b0&#x27;; context.fill(); // create the image var image = new Image(); image.src = canvas.toDataURL(); return image; &#125;)(); // render that thing! function render() &#123; // next animation frame requestAnimationFrame(render); // update time var newTime = new Date().getTime() / 1000, deltaTime = newTime - (time || newTime); time = newTime; // clear canvas context.clearRect(0, 0, canvas.width, canvas.height); // create new particles var amount = particleRate * deltaTime; for (var i = 0; i &lt; amount; i++) &#123; var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random()); var dir = pos.clone().length(settings.particles.velocity); particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y); &#125; // update and draw particles particles.update(deltaTime); particles.draw(context, image); &#125; // handle (re-)sizing of the canvas function onResize() &#123; var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random()); canvas.width = canvas.clientWidth; canvas.height = canvas.clientHeight; div=document.getElementById(&#x27;text&#x27;); div.style.left=canvas.width/2-56; div.style.top=canvas.height/2.3; div.style.fontSize=50; div.style.color=&quot;white&quot;; &#125; window.onresize = onResize; // delay rendering bootstrap setTimeout(function() &#123; onResize(); render(); &#125;, 10);&#125;)(document.getElementById(&#x27;pinkboard&#x27;)); &lt;/script&gt; &lt;/BODY&gt;&lt;/HTML&gt;","tags":["教程","html"]},{"title":"如何写申报书和管理项目","path":"/2022/11/03/如何写申报书和管理项目/","content":"计划类文档的体例和内容关系简介&#x2F;摘要 研究背景 现存问题 主要研究内容 创新点 实验结果&#x2F;核心成果 项目背景问题的背景(技术的应用场景？系统的使用环境？)–&gt;对核心问题的凝练表述(一个词组&#x2F;一句话)–&gt;理论重要性(问题本身在理论上未能完善解决)、社会意义、应用价值(如能完善，可能获得的收益) 相关工作调研(角度:研究领域、产业领域；国内、国外；论文、产品、专利；) 解决项目拟研究问题的核心技术(不止一个)的发展沿革及现状 应用要素本身如有与核心技术配合构成系统的情况(从系统角度对相关研究发展加以概述) 核心技术有没有已经做了或用别的技术来解决了这个问题的 你这么做又可以解决什么其他的问题 问题描述&#x2F;拟研究问题 选择合适的套路：(数学模型法、场景描述法、系统构成法(功能需求、性能需求)) 严谨、准确、无歧义的描述(独立于解决方案) 留扣子:将问题解决的核心方法要素&#x2F;需求进行解构分析(–&gt;潜移默化地催眠读者，尽可能使之对后续的研究内容、技术路线有顺理成章的认同感) 研究内容(总分总结构)从技术面对问题解决方案进行结构，逐一分析 技术方案(路线、重点、难点)(与主要研究内容的区别是：研究内容着重讲做什么；技术路线着重讲怎么做) 重点：如果实现了，至少基本解决了提出的问题(保底) 难点：如果实现了，能较好地解决提出的问题(锦上添花) 可行性分析理论可行性 (类比：核心技术在其他领域的应用，从功能和性能上，是否与拟研究应用的要求相吻合) (着重方案合理性&#x2F;避重就轻) 条件可行性 (研究基础、物质条件、非物质条件) 研究计划&#x2F;进度安排研究内容的逻辑理论、研究路线的细节理清–&gt;每季度的进度规划(+阶段性成果或进度检验标准) 甘特图 预期成果研究生：专利+论文 本科生：软著&#x2F;专利+比赛作品&#x2F;论文 经费资料费、软著费、专利费 申报书印象分加分技巧： 排版有条理(分点罗列、层次清晰) 适当加粗&#x2F;高亮显示一些关键词句 主次分明、详略得当 图表化展示核心概念、思路、方法、过程、原理 切记直接挪用CSDN、知乎、百度百科等(带水印) 风格要统一 参考文献统一国标标准 工作量(字数和内容) 字数一万多差不多得了，内容要精妙 从申报书到论文&#x2F;作品： ​ 申报书(体例框架、基本图、表等素材)–&gt;引言、相关工作、问题描述(迭代优化)–&gt;解决方案、实验验证 以上笔记来自杨欢老师的线上课堂，向杨欢老师致谢。 本科申报书格式是本人参考之前的活动策划案、师兄师姐的申报书自己设定的一个格式。 大标题如国内外研究现状：黑体、四号、一倍行距 正文：中文宋体、小四，英文TImes New Roman 标题序号：1.-&gt;1.1-&gt;(1)-&gt;缩进两个，1)-&gt;① 行距：正文固定值20磅，段前段后0.5行 图片嵌入性单倍行距，一定要是矢量图如SVG，比PNG清晰很多倍 如果用draw.io导出svg要在全选在文本栏下取消勾选自动换行和格式化文本否则插入到word会乱","tags":["项目","经验分享"]},{"title":"解决rehl8 Unable to read consumer identity的问题","path":"/2022/11/02/解决rehl8-Unable-to-read-consumer-identity的问题/","content":"看看现在的时间吧01:00……本来想着今天能早点睡了，结果被这个问题折磨了一个多小时(尝试百度，然后CSDN上各种牛鬼蛇神的答案折磨) 感谢susu老师的录屏，经过几步简单的操作让我今晚能安心入眠。 起因在进行源码编译安装的开头 1234[root@localhost ~]# yum -y install gcc makeUnable to read consumer identityThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.Error: There are no enabled repos. 哈哈出现了这个问题”This system is not registered to Red Hat” 其实就是需要换一下国内源，而用CentOS应该是没有问题的，这里就介绍以下rehl8的解决办法。 新解决办法2023.1.2 好像阿里云的epel被删了，所以如果配置的阿里云的会失效了 挂好光驱之后 配置内容： 12345678910[AppStream]name=rhel8.2baseurl=file:///dvd/AppStreamenabled=1gpgcheck=0[BaseOS]name=rhel8.2baseurl=file:///dvd/BaseOSenabled=1gpgcheck=0 应该是可以用yum的了… 旧解决办法(！epel失效！)先挂好光驱临时挂载 12[root@localhost ~]# mkdir /dvd/[root@localhost ~]# mount /dev/cdrom /dvd/ #把光驱挂到/dvd下 至关重要的一步！！修改配置文件，这里进行换源 1[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo 直接复制粘贴以下内容，但是注意如果你的不是挂载&#x2F;dvd&#x2F;下的，在注释的地方要作相应变动。 123456789101112131415161718[BaseOS]name=BaseOSbaseurl=file:///dvd/BaseOS #具体路径修改gpgcheck=1gpgkey=/etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial[AppStream]name=AppStreambaseurl=file:///dvd/AppStream #具体路径修改gpgcheck=0[epel]name=EPELbaseurl=http://mirrors.aliyun.com/epel/$releasever/Everything/$basearchgpgcheck=0enabled=1[httpAppstream]name=aliyun Appstreambaseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/osgpgcheck=0 记得ESC+:wq保存~ 这一步设置之后就可以解决问题了！ 重启之后都要重新mount，不太方便，接着进行： 永久挂载 1234[root@localhost ~]# vim /etc/fstab#在末尾添加 空格分隔即可/dev/cdrom /dvd/ iso9660 defaults 0 0[root@localhost ~]# reboot #重启一下 检查挂好没 1[root@localhost ~]# mount #看最后是否有 /dev/sr0 on /dvd.... 开始装编译器123456789101112131415[root@localhost ~]# yum clean /all #清一下缓存[root@localhost ~]# yum repolist -v #重新加载一下[root@localhost ~]# yum -y install gcc gcc-c++ makeUpdating Subscription Management repositories.Unable to read consumer identityThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.上次元数据过期检查：0:00:37 前，执行于 2022年11月02日 星期三 00时55分25秒。错误： 问题 1: cannot install the best candidate for the job - nothing provides libgcc &gt;= 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64 - nothing provides libgomp = 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64 问题 2: cannot install the best candidate for the job - nothing provides libstdc++ = 8.5.0-4.el8_5 needed by gcc-c++-8.5.0-4.el8_5.x86_64(尝试添加 &#x27;--skip-broken&#x27; 来跳过无法安装的软件包 或 &#x27;--nobest&#x27; 来不只使用最佳选择的软件包) 这时候报错了。 确实，又报错了哈哈，应该是版本问题，还好susu也有讲，按照提示加上’–nobest’即可。 1[root@localhost ~]# yum -y install --nobest gcc gcc-c++ make 搞掂！舒服了~ Zzz 对了，这时候别忘了拍张快照，一劳永逸：）","tags":["Linux"]},{"title":"Java学习笔记","path":"/2022/09/29/Java学习笔记/","content":"错题 通过super可调用父类构造函数。对 构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的 一般在创建新对象时，系统会自动调用构造函数。对 【单选题】下面赋值语句不合法的是___D___。 A.Long a&#x3D;(Long)(long)3; B.Long b&#x3D;3L; C. Long c&#x3D;Long.parseLong(“3”); D.Long d&#x3D;(Long )3; 下面赋值语句不合法的是 D。在Java中，”Long”类是原始数据类型long的包装类，必须使用关键字”new”来构造包装类，才能创建有效的对象。从长值3创建Long对象的正确方法如下： 1Long d = new Long(3); 其他三个选项都是从长值3创建Long对象的有效方法。选项A从将整数值3转换为长值，然后再转换为Long的结果创建Long对象。选项B从长值3L创建Long对象。选项C通过调用Long类的parseLong方法，从字符串值”3”创建Long对象。 【单选题】java语言中，在定义类时不能使用的修饰符是____B______。 A.public B.private C.abstract D.final 答案是 B：private。在 Java 语言中，private 是一种访问修饰符，它只能在类的内部使用，不能用于定义类。 A 选项：public。public 是一种访问修饰符，它表示在任何地方都能够访问。定义类时可以使用 public 修饰符。 C 选项：abstract。abstract 是一种修饰符，它用于定义抽象类和抽象方法。定义类时可以使用 abstract 修饰符。 D 选项：final。final 是一种修饰符，它表示类不能被继承，方法不能被重写。定义类时可以使用 final 修饰符。 在Java语言中，下面关于Math类的常见操作不正确的描述是_____D__B___。 A.执行Math.ceil(-10.5) 语句的结果是-10.0 B.执行Math.round(10.5) 语句的结果是11.0 (答案是11，没有小数点！) C.执行Math.floor(-10.5) 语句的结果是-11.0 D.执行Math.round(-10.5) 语句的结果是-10 Math.round 不完全是四舍五入，当刚好为负数且刚好0.5，舍入到正无穷方向上的整数。如Math.round(-20.5)结果为-20 【单选题】执行下面程序段后，输出结果是___C______。 int a&#x3D;4,b&#x3D;6,c&#x3D;8; System.out.println(++a*b—c ); A.11 B.16 C.22 D.23 注意后面的—前两个应该是b的后缀，而不是后两个是c的前缀，由于是后缀，无影响，而a的前缀加了用，因此是5×6-8结果为22，而且b的值变为5，a为5。 下面概念中，不属于面向对象程序设计的是_____A_____。 A.过程调用 B.对象 C.类 D.继承 文本框获得焦点时回车和按钮单击，都属于ActionEvent事件，也就是说文本框和按钮可以作为ActionEvent事件的事件源。 而选择框的选中，和下拉列表的选中，都是在触发ItemEvent事件。 不同类型的事件的监听器要实现的接口不同，对于ActionEvent事件，这个接口是 ActionListener，实现其中的actionPerformed方法，方法传入的也是ActionEvent对象。 而对于ItemEvent事件，则要实现的是ItemListener接口，实现其中的itemStateChanged方法，方法传入的是ItemEvent对象。 下面关于java.sql包中接口和类的描述不正确的是__B__。 A.Connection 接口：表示数据库连接 B.DriverManager类：表示驱动器 (错，JDBC 的管理层，作用于用户和驱动程序之间。) C.ResultSet接口：表示SQL查询语句返回的结果集 D.Statement接口：负责执行SQL语句 在Java语言中，下面用于执行存储过程SQL语句的是___B___。 A.Statement B.CallableStatement C.createStatement D.PreparedStatement Statement 对象有三种:(Statement)对象用于执行不带参数的简单 SQL语句; (PreparedStatement)对象继承Statement，用于执行带或不带参数的预编译 SOL语句:(CallableStatement) 对象继承PreparedStatement，用于执行对数据库存储过程的调用 在Java语言中，下面关于Scanner类描述错误的是_____D__C___。 A.Scanner类可以方便的完成输入流的输入操作 B.Scanner sc&#x3D;new Scanner(System.in);&#x2F;&#x2F;从标准输入中扫描 C.Scanner类位于javax.util包中，使用时需要import导入**(是java.util)** D.Scanner可以扫描指定的文件. D是对的，C是错的。 在Java语言中，下面不属于ComponentEvent的子类是____D______。 A.InputEvent B.FocusEvent C.WindowEvent D.ItemEvent ItemEvent不属于ComponentEvent的子类。 在Java语言中，下面关于组件定义错误的是____ D_____。 A.TextField tf&#x3D;new TextField(3);&#x2F;&#x2F;int型指定列宽 B.Timer tr&#x3D;new Timer(); C.JFileChooser jf&#x3D;new JFileChooser(); D.TextArea ta&#x3D;new TextArea(3); 在Java语言中，以下____C____项是接口B的正确定义。 A.interface B{ void print(){ };} B.abstract interface B{void print(){}} C.interface B {void print();} D.interface B extend A { void print(){}}&#x2F;&#x2F;A为已定义接口 12345public interface Paintable&#123; void draw();//没有&#123;&#125;，可省略public abstract关键字&#125;interface intf1&#123;&#125;interface intf2 extends intf1&#123;&#125;//接口继承接口 下面概念中，不属于面向对象程序设计的是_____A_____。 A.过程调用 B.对象 C.类 D.继承 在Java语言中，成员变量中被static关键字修饰的变量，叫 B A.变量 B.类变量 （静态变量的成员变量） C.实例变量 D.整型变量 在Java语言中，下面关于String类的常见操作不正确的描述是______B____。 A.假设 s =&quot;class&quot;;则执行char c = s.charAt(1)语句后变量c的值是l B.indexOf方法是查找特定字符或字符串在当前字符串中的起始位置，如果不存在则返回0 。（返回-1） C.concat方法的作用是进行字符串的连接，将两个字符串连接以后形成一个新的字符串 D.equals方法的作用是判断两个字符串对象的内容是否相同 charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 下面关于try catch语句中异常类排列顺序正确的说法是____B______。 A.父类异常在前，子类异常在后 B.父类异常在后，子类异常在前 C.父类和子类异常排列顺序前后无影响 D.只能有子类异常 已知Integer.MAX_VALUE 的值为2147483647，在执行“Integer max1&#x3D;Integer.MAX_VALUE,max2&#x3D; max1+1;”语句后，max2等于____A______。 A.-2147483648 B.2147483647 C.0 D.2147483648 在Java语言中，Person类有一个成员变量age被protected修饰，下面关于age说法不正确的是___C_______。 A.能被Person的子类访问。 B.能被Person类所在同一个包中的其它类访问。 C.能被Person类所在包之外的其它类访问。 D.不能被Person类所在包之外的其它类访问。 protected 访问控制符能被用于方法和成员变量 声明为protected的方法和成员变量能被同一个包里的所有类所访问，就像默认修饰符package一样能被该类的子类所访问，子类可以和父类不在一个包中。另一个包中的子类只能通过子类或其子类的引用来访问父类中受保护的成员。同一包中的子类没有此限制。这样可以确保来自其他包的类只访问属于其继承层次结构一部分的成员 下面哪项不属于Statement接口提供的3个执行SQL语句的方法______A____。 A.executeDelete(String sql) B.executeUpdate(String sql) C.executeQuery(String sql) D.execute(String sql) 在Java语言中，下面关于RandomAccessFile描述错误的是_____D_____。 A.实现DataInput和DataOutput接口 B.getFilePointer()方法：返回此文件中的当前偏移量 C.readFloat()方法：从此文件读取一个 float D.writeChar(int v)：按双字节值将char写入该文件，先写低字节(将一个字符作为一个两个字节的值写入基础输出流，其中高字节在前。) 在Java语言中，下面相关描述错误的是____B______。 A.File类对象对应于系统中的一个目录或文件 B.CharArrayReader 是一个把字符数组作为源的输出流的实现.(输入流) C.FileInputStream：以字节流方式读取 D.FileReader：把文件转换为字符流读入 下面关于Java事件描述错误的是_____A_____。 A.只有外部操作会产生事件 B.可以通过继承EventObject类编写自定义事件类 C.事件处理的三要素包括事件源、事件以及事件监听器 D.要在事件源上注册事件监听器 在Java语言中，下面关于Applet描述错误的是A。 A.Applet能执行任何本地计算机上的程序(错误) B.Applet的生命周期中有四个状态：初始态、运行态、停止态和消亡态 C.Applet的init()方法在Applet的生存周期中只调用一次 D.Applet应用程序必须嵌入在HTML页面中，才能得到解释执行 此外，Applet是Java类，且通常情况下不能进行文件的I&#x2F;O操作 在Java语言中，下面关于List不正确的描述是_______B___。 A.List是在java.util包中 B.List是一个类（是接口） C.List具有get(int index)方法 D.List是一个接口 List，Set，Map都是接口 在Java语言中，类Double定义在以下的哪个包中_____C_____。 A.java.io B.javax.lang C.java.lang D.java.util 在Java语言中，下面关于接口错误描述的是___A___。 A.接口不仅包括方法的特征，还有方法的实现。 B.接口只允许public 和abstract修饰。 C.接口中的属性只能被public 、final、static修饰。 D.一个类可以实现多个接口。 接口中的属性只能被public 、final、static修饰，而且必须赋值，因为是常量，在后面不能改变，否则会报错，不会给默认值的 在Java语言中，执行下列程序段后，i的结果是____D______。 int i; for(i&#x3D;0;i&lt;10;i++) { if (i&gt;4){ continue;}&#x2F;&#x2F; 一直跳过 if(i&gt;7 ){ System.out.println(i); break;} } A.6 B.8 C.9 D.10 在Java语言中，下面关于颜色定义不合法的是___B_______。 A.Color c1&#x3D;new Color(0xffffff) B.Color c2&#x3D;new Color(Color.BLUE) C.Color c3&#x3D;new Color(0,0,255) D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f) Color 是 Java 中的一个类，可以用来表示颜色。在 Java 中，可以使用以下几种方法来定义颜色： 使用 16 进制 RGB 值来定义颜色，例如 A.Color c1&#x3D;new Color(0xffffff)。 使用 24 位 RGB 值来定义颜色，例如 C.Color c3&#x3D;new Color(0,0,255)。 使用浮点型 RGB 值来定义颜色，例如 D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f)。 B.Color c2&#x3D;new Color(Color.BLUE) 中的 Color.BLUE 是预定义的颜色常量，它表示蓝色。这种方式并不能用来定义颜色，因此 B 选项是不合法的。 下面不属于Java语言中常见事件类型的是____C______。 A.KeyEvent B.MouseEvent C.TouchEvent D.ItemEvent 在Java语言中，下面不符合数组定义格式的是___D_______。 A.int []a&#x3D;new int [3]; B.int b[]&#x3D;{1,2,3}; C.int c[]&#x3D;new int [3]; D.int e[3]&#x3D;new int [3]; 在 Java 中，数组是用于存储一组相同类型的数据的数据结构。在 Java 中，可以使用以下几种方法来定义数组： 使用 new 运算符来定义数组，例如 A.int []a&#x3D;new int [3]; 和 C.int c[]&#x3D;new int [3];。 使用 {} 来定义数组并初始化数组元素，例如 B.int b[]&#x3D;{1,2,3};。 在Java语言中，下面变量命名不合法的有 C A.$fn B.p5p C.static D._user 必须以字母、下划线、或者美元符$开头； 在Java语言中，下面不属于JDBC的主要功能是A A.解析SQL语句 B.处理数据库的返回结果 C.建立与数据库或者其他数据源的连接 D.向数据库发送SQL命令 在Java语言中，下面用于执行简单的不带参数的SQL语句是 A A.Statement B.PreparedStatement C.CallableStatement D.createStatement 定义int A&#x3D;5，执行“System.out.println(“a&#x3D;”+((A&lt;5)?5.1:4));” 语句的结果是 B A.a&#x3D;5.1 B.a&#x3D;4.0 C.a&#x3D;5 D.a&#x3D;4 三目运算符后面类型不同需要类型升级 在Java语言中，下面关于包描述不正确的是 C A.包提供了访问权限和命名的管理机制 B.包是Java提供的一种区别类的名字空间的机制 C.类只能访问其所在包中的所有类 D.包是类的组织方式，是一组相关类和接口的集合 (1)具有public权限的类能被所有包中的类访问,与所在的包无关(2)具有缺省权限的类只能被所在包中的类访问,不能再其包外访问 定义char x&#x3D;’a’，下面赋值语句不合法的有 B A.float b&#x3D;x； B.byte c&#x3D;x; C.double d&#x3D;x; D.int a&#x3D;x; 应该为 byte c&#x3D;(byte)x; 在Java语言中，下面关于异常的错误描述是_____D_____。 A.异常是java提供的用于处理程序中错误的一种机制 B.java.lang. Exception类是所有异常的父类 C.java.lang.NullPointerException是空指针异常类 D.当异常产生时，程序会自动跳转到异常处理程序 在Java语言中，下面关于File类描述错误的是 A A.执行File f&#x3D;new File(“e:\\txx.txt”)语句的结果是在e盘上创建了一个txx.txt文件 B.File类对象对应于系统中的一个目录和文件 C.File类对象描述文件名、可否读写等属性，但不读写文件 D.一旦创建，File对象表示的抽象路径名将不会改变 File f&#x3D;new File;创建的是一个对象 在Java语言中，下面关于AWT组件描述错误的是 C A.Choice:制作用于单选的下拉列表 B.与菜单相关的类主要有三个: MenuBar、Menu、Menultem C.Panel类可作为容器容纳其它组件，也可以独立存在 D.Canvas:代表屏幕上一块空白的矩形区域 Panel类可作为容器容纳其它组件，也可以独立存在必须在窗体容器中使用，无法脱离窗体显示 substring()截取字符串，从索引0开始计数 12345678910String Str = new String(&quot;This is text&quot;); System.out.print(&quot;返回值 :&quot; ); System.out.println(Str.substring(4) );//4开始到最后 System.out.print(&quot;返回值 :&quot; ); System.out.println(Str.substring(4, 10) );//含头不含尾//结果返回值 : is text返回值 : is te public int index0f(int ch,int fromlndex): 返回从 fromlndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 编译JavaApplication源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为D A. .html B. .Java C. .exe D. .class 字符串比较。Java中，使用”&#x3D;&#x3D;”比较字符串时，判断的是两个字符串是否存放在相同的位置。 12345678例如：x = &quot;Hello&quot;; y = &quot;Hello&quot;;x == y; //就是Truex == &quot;Hello&quot;; //也是True如果 String z=new String(x);x==z;//结果就是false 在Java语言中，关于final修饰符的说法不正确的是 C A.fnal成员变量表示常量，只能被赋值一次，赋值后值不再改变 B.final类不能被继承，没有子类，fnal类中的方法默认是final的 C.final能用于修饰构造方法 D.final方法不能被子类的方法覆盖，但可以被继承 final修饰的类，为最终类，该类不能被继承。如String 类；final修饰的方法可以被继承和重载，但不能被重写、覆盖；final修饰的变量不能被修改，是个常量 main是static，所以不能直接调用非静态的方法 方法重载就是一个类中有多个同名但有不同形参和方法体的方法 对 Java String类 trim() 方法用于删除字符串的头尾空白符 大题模板集合类ArrayList12345678910111213List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); //第一种 Iterator&lt;String&gt; iterator=list.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); iterator.remove();//移除 &#125; //第二种 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); list.remove(i)//移除 &#125; TreeSet截取部分输出 it=tree.SubSet(头,尾).iterator(); it=tree.headSet(边界).iterator(); 12345678910111213141516171819TreeSet&lt;UpdateStu&gt;tree =new TreeSet&lt;&gt;();UpdateStu stu1=new UpdateStu(&quot;李同学&quot;, 01011);UpdateStu stu2=new UpdateStu(&quot;陈同学&quot;,01021);...;tree.add(stu1);tree.add(stu2);tree.add(stu3);tree.add(stu4);Iterator&lt;UpdateStu&gt; it=tree.iterator();it=tree.headSet(stu2).iterator();System.out.println(&quot;截取前面部分的集合：&quot;);while(it.hasNext())&#123;\tSystem.out.println(it.next()); &#125;it=tree.subSet(stu2, stu3).iterator();System.out.println(&quot;截取中间部分的集合&quot;);while(it.hasNext())&#123;\tSystem.out.println(it.next());&#125; 文件存取字节流创建–输入–读取1File file=new File(&quot;MyFile.txt&quot;); 写入文件： 1234FileOutputStream outputStream=new FileOutputStream(file);//创建输出流byte buy[]=&quot;Java程序设计&quot;.getBytes();//准备字节数组outputStream.write(buy);//写入outputStream.close(); FileOutputStream里放file，准备byte[]是字符串.getBytes()，写入用write 读取 1234FileInputStream inputStream=new FileInputStream(file);//准备输入流byte byt[]=new byte[1024];//准备字节数组接收int len=inputStream.read(byt);//read读取inputStream.close(); 读取用read，返回值是长度 文件信息 1234System.out.println(&quot;文件长度：&quot;+file.length()+&quot;字节&quot;);System.out.println(&quot;文件路径：&quot;+file.getAbsolutePath());SimpleDateFormat simpleDateFormat=new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;);System.out.println(&quot;修改时间&quot;+simpleDateFormat.format(file.lastModified())); (缓存)字符流写入 12345FileWriter fw=new FileWriter(file);BufferedWriter bw=new BufferedWriter(fw);String str=&quot;你好&quot;;bw.write(str);//写入字符串bw.newLine();//写入换行符 FileWriter里放file，Buffered里放FW，写入用write，换行符newLine() 读取 123456FileReader fr=new FileReader(file);BufferedReader br=new BufferedReader(fr);String tmp=null;//缓存临时字符串while ((tmp=br.readLine())!=null) &#123;\tSystem.out.println(tmp);//输出每一行&#125; FileReader里放file，BufferedReader里放FR，读取每一行用br.readLine()，字符串存 Swing事件监听123456789101112131415161718192021222324252627class MyJDialog extends JDialog&#123;\tpublic MyJDialog(MyFrame frame) &#123;//参数是MyFrame super(frame,&quot;这是一个对话框&quot;,flase);//窗体、标题、是否阻塞 Container container=getContentPane();//获取主窗体 container.add(new JLabel(&quot;这是一个对话框&quot;));//在容器中添加标签 setBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\t&#125;&#125;public class MyFrame extends JFrame&#123;\tpublic MyFrame() &#123; Container container=getContentPane();//获取窗体主容器 bl.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; new MyJDialog(MyFrame.this).setVisible(true); &#125; &#125;); container.add(bl); setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MyFrame();\t&#125;&#125; 组件.addAcitonListener里边new Actionlistener 多线程消费生产栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ms&#123;\tprivate Thread consume;\tprivate Thread product;\tprivate Random random=new Random();\tprivate int count=0;\tprivate Stack&lt;Integer&gt; st=new Stack&lt;Integer&gt;();\tpublic ms() &#123; product=new Thread(new Runnable() &#123; public void run() &#123; while(true) &#123; try &#123; if(count&lt;10) &#123; int s=random.nextInt(1000); st.push(s); count++; System.out.println(&quot;生产数据&quot;+s); Thread.sleep(1); &#125; else Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;); product.start(); consume=new Thread(new Runnable() &#123; public void run() &#123; while(true) &#123; try &#123; if(count&gt;0) &#123; int s=st.pop(); count--; System.out.println(&quot;消费数据：&quot;+s); Thread.sleep(1); &#125; else Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;); consume.start();\t&#125;&#125;public class Lab14_4&#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new ms();\t&#125;&#125; 网络通信TCP 双向通信服务器端接收用BufferReader 12345678910111213141516171819202122class MySever&#123; public ServerSocket sever;//创建热线 public Socket socket;//客服 private PrintWriter writer;//输出流 void start()&#123; //绑定端口 server=new ServerSocket(8998); while(true)&#123; socket=server.accept();//等待接收，阻塞 //套接字客服传信息，用缓存输入流，里边是InputStreamReader，再里边是socket.getInputStream BufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream)); writer=new PrintWriter(socket.getOutputStream,true); while(true)&#123;//又一个 //字符串接数据 readerLine() String message=reader.readerLine(); wrter.println(&quot;收到，谢谢你！&quot;); &#125; reader.close();//先关流 socket.close(); &#125; &#125;&#125; socket.getInputStream就是文件存取的file，类比一下，而InputStreamReader就是FileReader 客户端发出用PrintWriter 12345678910111213141516171819202122232425262728class MyClient&#123; Socket socket;//套接字 private PrintWriter writer;//写数据，用PrintWriter而不是Buffer private BufferedReader reader;//输入流，读取 public MyClient()&#123; //一些修饰，如swing之类的 //传数据 String message=&quot;hello&quot;;//准备数据 writer.println(message);//传输即可 &#125; //连接另外写一个函数 public void connect()&#123; socket=new Socket(&quot;127.0.0.1&quot;,8998);//绑定ip和端口 writer=new PrintWriter(socket.getOutputStream(),true);//创建流，一层就够了 //接收信息 reader=new BufferedReader(new InputStreamReader(socket.getInpuString)); //准备线程 readThread=new Thread(new Runnable() &#123; @Override public void run() &#123; String message=reader.reaLine(); syso(message); &#125; &#125; &#125;&#125; connect里：绑定端口指定ip，准备流 构造里：writer.println传数据 UDP服务器端1234567891011121314151617181920212223242526272829303132333435//指定地址//实例化，绑定端口//加入组//构造里配置，run里边接收/发送//准备DataPackage，字符转字节数组，发送socket.send()class Notification extends Thread&#123; int port;//端口 InetAddress iAddress=null;//ip MulticastSocket socket=null;//MulticastSocket socket String weather=new String();//发送的信息 public Receive() &#123; //配置 //指定地址 try &#123; port=9898; iAddress=InetAddress.getByName(&quot;224.255.10.0&quot;);//getByName返回的InetAddress MulticastSocket socket=new MulticastSocket(port); socket.setTimeToLive(1); socket.joinGroup(iAddress); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; @Override public void run() &#123; // 发送信息 //准备 DatagramPacket packet=null; byte data[]=weather.getBytes();//字符转字节数组 packet=new DatagramPacket(data, data.length, iAddress, port); socket.send(packet); sleep(100); &#125;&#125; 构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组 run()里边：准备包，字符转字节数组，实例化DatagramPacket，socket.send(packet) 客户机端1234567891011121314151617181920212223242526272829303132class Receive implements Runnable&#123; int port;//端口 InetAddress group=null;//ip MulticastSocket socket=null;//MulticastSocket socket public Receive() &#123; //配置 //指定地址 try &#123; port=9898; group=InetAddress.getByName(&quot;224.255.10.0&quot;);//getByName返回的InetAddress MulticastSocket socket=new MulticastSocket(port); socket.joinGroup(group); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; @Override public void run() &#123; byte bty[]=new byte[1024]; DatagramPacket packet=new DatagramPacket(bty, bty.length, group, port); try &#123; socket.receive(packet); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; String message=new String(packet.getData(), 0, packet.getLength()); System.out.println(message); &#125;&#125; 构造里边：构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组 run()里边：准备字节数组，实例化DatagramPacket，socket.receive(packet)，然后new String(packet.getData(), packet.getLength())packet转字符 main函数当作类外的函数来看待 1、包内访问权限和protected有何不同？(p98) 包内访问权限介于private和protected之间 包外的派生类，可以在派生类内部调用基类的protected成员 包外的派生类，无法在派生类内部调用基类的包内访问成员 当两个包在同一个项目之中时，可以通过完整类目继承包外的基类访问 1234package Lab2;class newClass extends Lab1.myClass&#123;//包名.类名 &#125; 当两个包在不同的项目之中时，将基类项目导出为.jar，将该.jar文件复制到派生类所在的项目文件夹中，然后右键点击选择”add building path”添加到构建路径，然后代码与上面相同。 2、所有数组都能排序吗？ 错误。排序要有一定依据，没有指定依据无法排序。如类型为类的数组，可比较的属性不止一种（implements比较器)。 3、接口 接口的本质是标准，是设计者、实现者，调用者之间的桥梁 类内实现的可比较器Comparable，由被比较的类implements实现，重写compareTo函数 类外实现的可比较器Comparator，由另外一个类implements实现，重写compare函数 如果是一次性的考虑用匿名内部类来实现比较器。否则这个只用一次的有名字的类可能会对代码理解造成困扰。 基本输入输出范例代码1234Scanner sc=new Scanner(System.in);int n=sc.nextInt();String str1=sc.next();System.out.println(&quot;欢迎&quot;+n+&quot;号同学&quot;+str1); 第四章 流程控制循环语句foreach语句123for(元素类型x:遍历对象obj)&#123; 引用了x的java语句;&#125; 例子：遍历一维数组 1234567891011121314151617public class Repetition&#123; public static void main(String args[])&#123; int arr[]=&#123;5,13,96&#125;; System.out.println(&quot;一维数组中的元素分别为：&quot;); //x的类型与arr元素的类型相同 。for循环依次取出arr中的值并赋给x for(int x:arr)&#123; System.out.println(x); &#125; &#125;&#125;/*输出结果：一维数组中的元素分别为：51396*/ 第五章 数组数组的基本操作数组排序 Arrays.sort(arr); Arrays.parallelSort(arr);多线程排序，数据量大于一百万 复制数组copyof()方法语法：int a[]=Arrays.copyOf(arr,int newlength); newlength：复制后新数组的长度 ！注：不能直接a=b，数组名是指针常量（常指针） 第六章 类和对象面向对象概述封装 避免外部操作对内部数据的影响，提高程序的可维护性 提高工作效率，把无需调用者关心的内容隐藏，简化编程，知道面对外部的接口能调用即可 类对于人来说， public：学历、知识（别人抢不走的） protected：身体等 public：很多 protected同包其他类或子类(继承)可见，其他包的类或子类不可见；private都不可见，只有本类可见。 this 关键字this关键字用于表示本类当前的对象，只能在本类中使用。 123public void setName(String name)&#123;//定义一个setName()的方法 this.name=name;//将参数值赋予类中的成员变量&#125; 类的构造方法 Java类内的属性值不支持默认值，不能直接定义 int count=0 应使用默认构造函数初始化 12345678910public class eggCake&#123; int eggCount; public EggCake(int eggCount)&#123;//有参构造 this.eggCount=eggCount; &#125; public EggCake()&#123; //设置鸡蛋灌饼里蛋的个数为1 this(1); &#125;&#125; 静态12345678910public class Lab2_1&#123; public static void main(String[] args)&#123; new Lab2_1().show();//临时无名对象 //如果是show.()直接调用会报错，除非把show 声明为静态函数，说这是上面的方法，调用类内成员函数 &#125; void show()&#123; System.out.println(&quot;Hello!&quot;) &#125;&#125; 类内静态成员共用一份空间 如果函数 对象对象的销毁12345678910public class Lab2_1&#123; public static void main(String[] args)&#123; Lab2_1 l2=new Lab2_1(); //l2=null; 销毁对象 之后如果是l2.show();那么会报错NullPointerException &#125;//超过作用域 对象l2销毁 void show()&#123; System.out.println(&quot;Hello!&quot;) &#125;&#125; 第七章 继承、多态、抽象类与接口类的继承extends 关键字语法：CHild extends Parents super 关键字Object 类Object类是一切类的基类，隐含的继承 如果没声明，toString()一定是调用自Object类，输出是字符编号。 输出字符串自动会调用toString()函数，应当重写以达到需要的输出目的。 重写只能保持或扩大访问权限，如原本是Public不能改成Private。 123456789101112131415161718public class Student&#123; String name; int age; public Student(String name,int age)&#123; this.name=name; this.age=age; &#125; @Override//加这个帮助检查重写的函数名是否正确 public String toString()&#123; return &quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁。&quot;; &#125; public static void main(String[] args)&#123; Student s1=new Student(&quot;张三&quot;,16); System.out.println(s1);//就是System.out.println(s1.toString()); &#125;&#125; 对象的类型转换需要基类对象的任何地方，都可以用派生类对象替代 向上转型向下转型instanceof关键字判断对象类型方法的重载 函数的返回值类型不属于重载的依据 final 关键字最终的、终态 多态抽象类与接口抽象类 只要类中有一个抽象方法，此类就是抽象类 抽象类不能实例化，抽象类存在的目的就是为了被继承 c++中全是抽象方法就叫纯虚类 接口 只能声明，不能实现 第9章 异常处理异常与错误： 一个不好的问题发生了，如果对该问题提前有应对措施，就是异常处理； 如果没有任何准备，就是错误。 12345678910try&#123; //想要正确执行，但是不可控的语句段 //数据输入输出、网络连接、文件读写、数据库连接访问&#125;catch(Exception e)&#123; //可以有多个catch语句，捕获不同的异常 //必须是小范围异常(异常类)在前，Exception必须放在最后，Exception是所有异常的基类，范围最大&#125;finally&#123; //不管是否有捕获异常，都想要执行的代码&#125; 第10章 字符串String类，字符常量存储。 创建12char a[]=&#123;&#x27;g&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;d&#x27;&#125;;String s = new String(a);//相当于String s = new String(&quot;good&quot;) 截取 12char a[]=&#123;&#x27;g&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;d&#x27;&#125;;String s = new String(a,1,2);//相当于String s = new String(&quot;oo&quot;) 字符串连接int+&#39;&#39;把int转为String类型 获取字符串信息12System.out.println(s[0]);//是错误的System.out.println(s.charAt[0]);//才对 字符串的查找indexOf(String s) 区分大小写 123String str=&quot;We are students&quot;;int size=str.indexOf(&quot;a&quot;);int size2=str.toLowerCase().indexOf(&quot;a&quot;);//转为小写再查找，这个toLowerCase()或toUpperCase()是生成新的字符串对象，不会修改原来的字符串 字符串操作获取字符串substring(int beginIndex) 12String str=&quot;Hello World&quot;;String substr=str.substring(3); 字符串替换replace() replaceAll()支持正则表达式 判断相等equals()而不是用== 123456String s1=&quot;abc&quot;;String s2=&quot;abc&quot;;String s3=new String(&quot;abc&quot;);String s4=new String(&quot;abc&quot;);System.out.println(s1==s2);//结果是trueSystem.out.println(s3==s4);//结果是false 如果直接等号赋值，就是基本数据类型，用==可以判断；当用new，把变量当对象来看待，两个对象不可能相等，因此只能用equals()来判断相等。 equals在基本数据类型比较的是值，引用数据类型对象、数组、函数比较的是地址，如果要比较值需要重写equals。String是已经重写好equals了的 没重写之前两者都是比较地址，重写之后前者比较地址后者比较值 比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。 12345678@Overridepublic boolean equals(Object obj) &#123; if (obj instanceof Person) &#123; Person person = (Person) obj; return name.equalsIgnoreCase(person.getName().trim()); &#125; return false;&#125; 正则表达式12String regex1=&quot;[a-zA-Z_$]+[a-zA-Z_$]*&quot;;//String regex2=&quot;[1-9][0-9]&#123;4,10&#125;*&quot;;//qq号码规则 使用： 12345678910111213141516171819202122232425262728293031323334353637package lesson5;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegExp &#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 String contentString=&quot;1998,1239,12,144&quot;; //1.\\\\d表示一个任意的数字 String regString=&quot;\\\\d\\\\d\\\\d\\\\d&quot;;//找四个连续的数字,分组的话是(//d)(//d) //2.创建模式对象[即正则表达式对象] Pattern pattern=Pattern.compile(regString); //3.创建匹配器 //说明：创建匹配器matcher，按照正则表达式的规则去匹配content字符串 Matcher matcher=pattern.matcher(contentString); //4.开始匹配 /* * match.find()完成的任务 (考虑分组，如(//d//d)(//d//d)) * 1. 根据给定的规则，定位满足规则的字符串（如1999,分组即(19)(99)) * 2. 找到时，将字符串的开始的索引记录到matcher对象的属性 int[] groups; * 2.1groups[0]=0，把该子字符串的结束的索引+1的值记录到group[1]=35,+1是因为取字符串左闭右开 * 2.2 记录第一组()匹配的字符串的区间group[2]=0,group[3]=2 * 2.3 记录第二组()匹配的字符串的区间group[4]=2,group[5]=4 * 2.4 如果有更多分组以此类推 * 3. 同时记录oldLast的值为子字符串的结束的索引+1的值即5，那下一次执行find时，从5开始匹配 */ while(matcher.find()) &#123; System.out.println(&quot;找到：&quot;+matcher.group(0));//group(0)记录找到的字符串开头,同时可以找到结尾 System.out.println(&quot;第一组()的值： &quot;+matcher.group(1));//19 System.out.println(&quot;第二组()的值： &quot;+matcher.group(2));//99 &#125;\t&#125;&#125; 元字符检索特殊字符要用转义符号\\\\，在java的正则表达式中两个\\\\代表其他语言一个\\ 字符匹配符 符号 含义 实例 说明 匹配输入 [ ] 匹配任意一个 [efgh] e,f,g,h任意一个 e,f,g,h [^ ] 排除 [^abc] 除了abc之外的任意一个字符包括数字和特殊符号 d,f,p . 匹配除 以外的任何字符 a..b a开头b结尾中间任意两个字符 aaab,a#*b \\\\d 匹配单个数字字符相当于{0-9} \\\\d&#123;3&#125;&#123;\\\\d&#125;? 包含3个或4个数字的字符串 123,9876 \\\\D 匹配单个非数字字符，相当于[^0-9] \\\\D&#123;\\\\d&#125;* 以单个非数字字符开头后接任意个数字的字符串 a,A342 \\\\w 匹配单个数字、大小英文写字母，下划线，相当于[0-9a-zA-Z_] \\\\d&#123;3&#125;\\\\w&#123;4&#125; 以3个数字字符开头的任意长度为7的数字字母字符串 234abcd、1234Pe \\\\W 匹配单个非数字、大小写字母和下划线字符，相当于[^0-9a-zA-Z_] \\\\W+\\\\d&#123;2&#125; 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 \\\\s 匹配任何空白字符(空格，制表符等) \\\\S 匹配任何非空白字符 \\\\. 匹配除 之外的所有字符 区分大小写 默认区分大小写，如模式串写&quot;abc&quot;匹配出来abc而(?i)abc表示不区分大小写,a(?i)bc是bc不区分大小写 常用类库Integer类能在int类型和String类型之间互相转换。 123int num = Integer.parseInt(&quot;456&quot;);//返回包含在由str指定的字符串中的数字的等价整数值Integer iNum=Integer.valueOf(&quot;456&quot;);//返回保存指定的String值的Integer对象iNum.equal(num);//比较，返回值是true Double类是Number类的子类，都是对浮点数进行操作。Double类在对象中包装一个基本类型为double的值，每个Double类的对象都包含一个double类型的字段。可将String和double相互转换。 123Double dNum=Double.valueOf(&quot;3.14&quot;);Double.isNaN(dNum.doubleValue());//是否返回非数字(NaN)值dNum.intValue();//转为int类型 Boolean类当 String 的参数值在不区分大小写的时候等于 “true” ，则 Boolean.valueOf(String) 返回值为 true； 1234Boolean b1=Boolean.valueOf(&quot;true&quot;);Boolean b2=Boolean.valueOf(&quot;ok&quot;);b1.booleanValue();//将Boolean对象的值以对应的boolean值返回，值为trueb2.booleanValue();//值为false Character类字符大小转小写 1234Character mychar1=Character.valueOf(&#x27;A&#x27;);//返回保存指定char值的Character对象Character.isUpperCase(mychar1);//判断是否为大写字母Character.toUpperCase(mychar1);//转为大写Character.toLowerCase(mychar1);//转小写，不改变原来字符串 第12章 集合类graph LR A[集合类]-->集合类概述 A-->Collection接口 A-->List集合 A-->Set集合 A-->Map集合 集合类概述集合与数组 容器 数组 集合 长度 长度固定 长度可变 存放的东西 存放基本数据类型 存放对象的引用 graph LR HashMap-->A[Map] TreeMap-->A HashSet-->B[Set] TreeSet-->B ArrayList-->C[List] LinkedList-->C C-->D[Collection] B-->D A-->Java.lang.Object D-->Java.lang.Object Collection 接口1Collection&lt;类名&gt; list=new ArrayList&lt;&gt;();//尖括号只能呢是类，比如不能放int要放integer 方法： add(E e) remove(Object o) isEmpty() iterator() size() 返回int型 遍历集合通过迭代器(Iterator)来实现，只读且向前。Collection接口中的iterator()方法可返回在此Collection进行迭代的迭代器。 可以用foreach，可读可写，但是不能break，除非抛出异常。遍历修改迭代器(ListIterator) 12345678910111213import java.util.*;public class Muster&#123; public static void main(String args[])&#123; Collection&lt;String&gt; list=new ArrayList(); list.add(&quot;《Java从入门到精通》&quot;); list.add(&quot;《java实战》&quot;); lteratior&lt;String&gt; it=list.lterator(); while(it.hasNext())&#123; String str=(String)it.next();//获取集合中的元素 System.out.println(str); &#125; &#125;&#125; List集合 List集合中的元素允许重复，各元素的顺序就是对象插入的顺序。类似Java数组，用户通过使用索引(元素在集合中的位置)来访问集合 List接口继承Collection接口，包含其所有方法。还定义两个重要的方法： get(int index)：获取指定索引位置的元素 set(int index,Object obj)：将集合中指定索引位置index的对象修改为指定的对象obj List接口的实现类属于有序集合，不是自动排序的意思 ArrayList类 可变的数组，允许重复 允许null LinkedList类链表结构保存对象 类 ArrayList LinkedList 优点 根据索引快速访问 便于向集合插入和删除对象 缺点 插入或删除对象速度较慢 随机访问效率较低 动态数组，索引存取 链表，存取有序，不是存到链表头就是链表尾 实例化 12List&lt;E&gt; list=new ArrayList&lt;&gt;();List&lt;E&gt; list2=new LinkedList&lt;&gt;(); 开头是List，后面别忘了&lt;&gt; Set集合Set集合传入的Collection对象不能有重复值 Set接口实现的类： HashSet类，由哈希表(HashMap实例)支持。允许null TreeSet类，还实现了Java.util.SortedSet接口 类 HashSet TreeSet 区别 不保证Set集合的迭代顺序和顺序的恒久不变 按自然顺序递增，也可按比较器实现排序 1Set&lt;类名&gt; set=new TreeSet&lt;&gt;(); 必须可比较，传入的对象的类必须是包装类(默认字典顺序)或者实现comparable接口的类 HashSet哈希存储，计算哈希值散列导不同位置，存取位置不能保证，效率高 TreeSet树存储，按照树结构对元素进行比较，放到合适位置，这也就说明，元素会按照树的性质去存储，那么也就无法保证存和取元素的顺序。但是元素可以在存储的时候根据自身的大小排好序，从而可以很轻易的找到最大值，最小值，以及给定一个元素，找到比他大和比他小元素等操作。 问：在定义对象类型时，应该定义为基类或接口的类型，还是派生类的类型？ 创建的时候类型不确定，先定义为基类；或如果定义为接口给别人调用就声明为基类。要专门调用派生类具有的功能直接声明为派生类。 但是定义为基类无法调用子类特有的成员，如subSet()是TresSet特有的，定义为基类时无法调用，除非强制转型为子类。 12Set&lt;Integer&gt; set=new TreeSet&lt;&gt;();TreeSet set2=((TreeSet&lt;Interger&gt;)set.)subSet(3,10); TreeSet增加的方法: first() 返回此Set集合第一个(最低)元素 last() 返回当前最后一个(最高)元素 comparator() 返回进行排序的比较器，若自然顺序则null headSet(E toElement) 返回一个新Set集合是toElement对象(不包含)之前的所有对象 subSet(E fromElement,E toElement) 返回Set集合是fromElement对象与toElement之间的所有对象，含头不含尾 tailSet(E fromElement) 返回包含fromElement之后所有对象 含头不含尾 Map集合没有继承Collection接口，每个对象是键值(&lt;key,value&gt;)的形式。 每个key只能映射一个value；类要可比较；iterator()的next()输出的仅是key值 Map接口除集合方法的特殊方法 put(K key,V value) containsKey(Object key) 若包含指定key的映射关系返回true containsValue(Object value) 若将一个或多个key映射到指定值，返回true get(Object key) 返回对象对应的值，否则null values() 返回该集合所有值对象形成的Collection对象，用iterator()遍历输出 类 HashMap TreeMap 特点1 允许nul值和null键，键唯一 不允许值对象null(要排序的原因) 映射 通过哈希表 具有一定顺序 优缺 不保证顺序不变；快速访问 添加、删除、定位性能差；顺序排序 运用的时候使用HashMap类实现Map集合，当需要顺序输出时再创建一个完成相同映射关系的TreeMap类实例 12Map&lt;String,String&gt; map=new HashMap();map.put(&quot;1001&quot;,&quot;java从入门到精通&quot;); 如果key传入的是像Integer，String这样本身有序的，就会按字典序排列，而不是按哈希码。 原理：add()时用hashcode找哈希地址，用equal()看是否有存东西。如果是false就先并排放；若是true说明有了不用重复存。取值的时候找哈希地址，如果存在多个用equal()取具体的那一个。以上哈希码相同的情况为哈希冲突，同一个哈希地址可以存放多个不同对象。 优点：不用全部遍历，找到哈希地址再判断哪个是需要的取出即可。 第13章 枚举类型与泛型将“填空题”变为“选择题” 12345678910111213141516171819202122232425262728//声明为int/String类型方便switch case用//接口interface SeasonInterface&#123; int Spring=1,SUMMER=2,AUTUMN=3,WINTER=4; //开头隐含的public static final&#125;//枚举enum SeasonEnum&#123; SPRING,SUMMER,AUTUMN,WINTER&#125;public class SeasonDemo&#123; public static void printSeason1(int season)&#123; switch(season)&#123; case SeasonInterface.SPRING: System.out.println(&quot;这是春季&quot;); break; case SeasonInterface.SUMMER: System.out.println(&quot;这是夏季&quot;); break; case SeasonInterface.AUTUMN: System.out.println(&quot;这是秋季&quot;); break; case SeasonInterface.WINTER: System.out.println(&quot;这是冬季&quot;); break; &#125; &#125;&#125; 问：接口和枚举如何选择？ 接口一般是给别人来实现，功能可以更强大，如果不需要实现直接用枚举就行。 枚举优点：简单，运行效率高，类型安全 枚举类型中的构造方法在枚举类型中，可以添加构造方法，但是规定这个构造方法必须被private修饰符所修饰。用于提示枚举值更加详细的含义、 泛型向上向下转型123父类 a=new 子类();//向上转型子类 b=(子类)a;//向下转型子类 b=new 父类();//！这是不可行的！ 例子： 1234567891011121314151617public class Test&#123; private Object b; public Object getB()&#123; return b; &#125; public void setB(Object b)&#123; this.b=b; &#125; public static void main(String[] args)&#123; Test t=new Test(); t.setB(Boolean.valueOf(true));//向上转型 System.out.println(t.getB()); t.setB(Float.valueOf(&quot;12.3&quot;)); Float f=(Float)t.getB();//向下转型 System.out.println(f); &#125;&#125; 定义泛型类Object类为最上层的类，为了通用通常使传入的值与返回的值都以Object类型为主(Object太大了，不能统统用Object类)。当需要使用这些实例时，必须正确地将该实例转换为原来的类型，否则运行时将会发生ClassCaseException为了预防，Java提供泛型机制： 1类型&lt;T&gt; 高级用法泛型限制对泛型类的实例类型做了限制 12345678public class LimitClass&lt;T extends List&gt;&#123; public static void main(Stirng[] args)&#123; //可以实例化已经实现List接口的类 LimitClass&lt;ArrayList&gt; l1=new LimitClass&lt;ArrayList&gt;(); //这句是错误的，因为HashMap类没有实现List()接口 LimitClass&lt;HashMap&gt; l3=new LimitClass&lt;HashMap&gt;(); &#125;&#125; &lt;T extends Serializable&gt; 序列化，泛型必须是Serializable的子类，可传Integer或String 泛型通配符123A&lt;?&gt; a;A&lt;? extends anyClass&gt; a;A&lt;?&gt; a= new List&lt;&gt;;//这样是不可以的，实例化需要要具体的类型 第14章 lambda表达式与流处理将lambda表达式用来简化表示匿名函数，也就是没有名字的函数，提高开发效率。 例子： 1234567891011121314//函数式接口interface A&#123; void action();&#125;//使用匿名类创建对象A a=new A()&#123; public void action()&#123; System.out.println(&quot;创建了接口的匿名对象&quot;); &#125;&#125;;//使用lambda表达式创建A a=()-&gt;&#123; System.out.println(&quot;创建了接口的匿名对象&quot;);&#125;; lamba表达式： 1234()-&gt;结果表达式参数-&gt;结果表达式//多形参(参数1,参数2,...,参数n)-&gt;结果表达式 例子： 1234567891011121314151617//函数式接口interface AdditionInterface&#123; int add(int a,int b);&#125;public class ParamterDemo&#123; public static void main(String[] args)&#123; //lamba 表达式实现加法接口，返回参数相加的值(自动加return) AdditionInterface np=(x,y)-&gt;x+y; int result=np.add(15,26);//调用接口方法 System.out.println(&quot;相加结果：&quot;+result);//输出相加结果 //而同一个接口可以实现不同的方法,关键在于接口的实现方式 AdditionInterface np2=(a,b)-&gt;a*b; result=np2.add(a,b); System.out.println(&quot;相乘结果：&quot;+result);//输出相乘结果 &#125;&#125; 注意： lamba表达式不能修改局部变量的值，只能使用 方法的引用引用静态方法(复制一个已有的函数实现接口，甚至可以不需要这个已有函数内部是如何实现的) 类名::静态方法名 1234interface StaticMethodInterface&#123;\tint method(int a,int b);&#125;public class StaticM Function接口Function&lt;T,R&gt;,T:被操作的类型，可以理解为方法的参数类型；R：操作结果类型，方法的返回类型。 Iterator&lt;T&gt;只读！ ListIterator&lt;T&gt;才能修改list的元素 流处理Stream流只能被消费一次，之后失效 数据过滤12345678910111213//数据转化为流public class FilerDemo&#123; public static void main(String[] args)&#123; List&lt;Employee&gt; list=Employee.getEmpList(); Stream&lt;Employee&gt; stream=list.stream(); stream=stream.filter(people-&gt;people.getAge()&gt;30);//过滤出符合条件的数据 List&lt;Employee&gt; result=stream.collect(Collectors.toList());//将流对象重新封装成一个List集合 List&lt;Employee&gt; result2=list.stream().filter(p-&gt;p.getDept().equals(&quot;开发部&quot;)).peek(p-&gt;p.setSalary(p.getSalary()*10)).collect(Collect.toList());//过滤得到符合的让其工资翻十倍 for(Employee emp:result)&#123; System.out.println(emp);//输出员工信息 &#125; &#125;&#125; filter(predicate类)用lamba表达式不需要管类型，直接放进去 peek(consumer类型)和map()一个里面不用返回值，一个需要。 collect() 收集重新归类。 第15章 I&#x2F;O(输入与输出)graph LR A[I/O]-->输入/输出流 A-->File类 A-->文件输入/输出流 A-->带缓存的输入/输出流 A-->数据输入/输出流 输入&#x2F;输出流程序从指向源的输入流中读取源中的数据。 各种数据源通过输入流传递到目的地 源通过数据流传递到各种数据输出目标 InputStream类用来处理字节，不适合处理字符。而Java字符是Unicode编码，双字节，用Reader类处理。但注意Reader类不是InputStream的替换者，只是在处理字符串时简化了编程。 read(byte[] b);返回值是读取到的字节数 File类File类是java.io包中唯一代表磁盘文件本身的类。因为是代表磁盘，操作要用try catch语句 三种构造方式： 123File(String pathname)File(String parent,String child)File(File f,String child) 12345678910111213141516171819import java.io.File;public class FileTest&#123; public static void main(String[] args)&#123; File file=new File(&quot;word.txt&quot;);//相对路径，是在项目目录下创建而不是在所在包类,此时是在内存中创建对象 //File file2=new File(&quot;D:\\\\1.txt&quot;);//绝对路径 if(file.exists())&#123;//如果存在 file.delete(); System.out.println(&quot;文件已删除&quot;); &#125;else&#123; try&#123; file.createNewFile();//这一步才真正在磁盘中创建文件 System.out.println(&quot;文件已创建&quot;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; File类创建的是一个文件对象！说是在磁盘创建是错误的；除了在内存中的操作，其他都是不保证成功的， getName() 文件名称 length() 文件的长度(以字节为单位) isHidden() 判断是否隐藏文件，返回布尔值 文件输入&#x2F;输出流FileInputStream与FileOutputStream类 是字节流，读取写入参数得是字节byte，读取汉字容易乱码 创建一个FileOutputStream对象时，可以指定不存在的文件，但是不能是已被其他程序打开的文件 文件输入流FileInputStream类实现！读取！，用read(byte[] b)，从磁盘输入到目的地 文件输出流FileOutputStream类实现！写入！，用write(byte[] b)，从程序输出到磁盘 案例： 1234567891011121314151617181920212223public class FileStreamDemo&#123; public static void main(String[] args)&#123; File file=new File(&quot;D:\\\\word.txt&quot;);//创建文件对象 //写入 try&#123; FileOutputStream out=new FileOutputStream(File);//创建输出对象 byte buy[]=&quot;我有一只小毛驴&quot;.getBytes();//写入内容的字节数组，字符串转转字节 out.write(buy);//将字节写入到文件 out.close();//关闭流 &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; try&#123; FileInputStream in=new FileInputStream(file);//创建输入流 byte byt[]=new byte[1024];//缓存字节流 int len=in.read(byt[]);//字节转字符串要用 System.out.println(&quot;文件的信息是：&quot;+new String(byt,0,len));//字节转为字符串输出 in.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; FileReader和FileWriter 是字符流，读取写入参数字符串即可 123456789101112File file=new File(&quot;D:\\\\word.txt&quot;);//创建文件对象//写入FileWriter fw=new FileWriter(file);String word=&quot;我有一只小毛驴&quot;;fw.write(word);fw.close();//读取FileReader fr=new FileReade(file);char ch[]=new char[1024];//缓存字符数组int len=fr.read(ch);System.out.println(&quot;文件的信息是：&quot;+new String(ch,0,len));//字节转为字符串输出fr.close(); 带缓存的输入&#x2F;输出流缓存是I&#x2F;O的一种性能优化。缓存流增加了内存缓冲区，使得在流上执行skip()、mark()和reset()方法都成为可能。 BufferedReader与BufferedWriter类分别继承Reader类和Writer类，以行为单位进行输入&#x2F;输出 读取文件过程： 文件–&gt;InputStream–&gt;InputStreamReader–&gt;BufferedReader–&gt;字符数据 BufferReader类常用的方法： read() 读取单个字符 readLine() 读取一个文本行，返回字符串型。若无返回null BufferWriter类的方法都返回void: write(String s, int off, int len) 写入字符串的一部分 flush() 刷新流的缓存 newLine() 写入一个行分隔符 在使用BufferedWriter类的Writer()方法时，数据首先进入缓存区，没有立刻被写入输出流。如果想立即将缓存区中的数据写入输出流，一定要调用flush() 1BufferedReader br = new BufferedReader(new FileReader(file));//缓存输入流 实例基本文件操作1234567891011121314151617181920212223242526272829303132333435public class test2 &#123;\tpublic static void main(String[] args) &#123; String content[]= &#123;&quot;好久不见&quot;,&quot;最近好吗&quot;,&quot;常联系&quot;&#125;; File file=new File(&quot;word.txt&quot;); try &#123; BufferedWriter bWriter=new BufferedWriter(new FileWriter(file));//文件字符输出流转缓冲输出流 for (int k = 0; k &lt; content.length; k++) &#123; bWriter.write(content[k]);//写入字符串 bWriter.newLine();//写入一个换行符 &#125; bWriter.close();//关闭缓冲输出流 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; try &#123; BufferedReader bReader=new BufferedReader(new FileReader(file));//文件字符输入流转缓冲输入流 String tmpString=null;//作为缓冲的临时字符串 int i=1;//行数 //从文件重读取一行，如果读出内容不为null，则进入循环 while ((tmpString=bReader.readLine())!=null) &#123; System.out.println(&quot;第&quot;+i+&quot;行：&quot;+tmpString); i++; &#125; bReader.close(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;\t&#125;&#125;输出：第1行：好久不见第2行：最近好吗第3行：常联系 获取网页源代码12345678910111213141516171819202122232425262728293031import java.io.*;import java.net.*;public class GetPageCode&#123;\tpublic static void main(String[] args) throws IOException &#123; // TODO 自动生成的方法存根 URL page = null; try &#123; page = new URL(&quot;https://www.qq.com&quot;); &#125; catch (MalformedURLException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; HttpURLConnection conn = (HttpURLConnection) page.openConnection(); InputStreamReader in = new InputStreamReader(conn.getInputStream()); BufferedReader buff = new BufferedReader(in); String tmp=null; int i=1; //从流中读出一行，如果内容不为null，则进入循环 while ((tmp=buff.readLine())!=null) &#123; System.out.println(tmp); i++; &#125; &#125;&#125; 第16章 反射与注释实现访问、检测和修改描述Java对象本身信息的功能。 getCLass()是Object类定义的，任何类都可以用，获取类信息 12345678910Class newC=hashSet.getClass();//获取hashSet的描述信息，假设hashSet是一本书，那newC是书的目录，作者等等基本信息但不包括内容//查构造方法Constructor[] constructors=mewC.getDeclaredConstructor;for(Constructor constructor:constructors)&#123; System.out.println(constructor);//找到构造函数foreach遍历显示&#125;declarednewC=newC.getDeclaredConstructors(); 1234Field[] declaredFields=demClass.getDeclaredFields(); for(Field field:declaredFields) &#123; System.out.println(field); &#125; 1234567891011121314151617181920212223242526272829//查成员方法 用户输入参数Method[] declaredMethods=demClass.getDeclaredMethods(); for(Method method:declaredMethods) &#123; System.out.println(method); &#125; Scanner scanner=new Scanner(System.in); String key=scanner.next(); for(Method method:declaredMethods) &#123; if(key.equals(&quot;size&quot;)&amp;&amp;key.equals(method.getName())) &#123; try &#123; System.out.println(method.invoke(hashSet)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (key.equals(&quot;add&quot;) &amp;&amp; key.equals(method.getName())) &#123;//作判断才知道用户要做那个 String addString = scanner.next(); try &#123; System.out.println(method.invoke(hashSet, addString)); for (String hash : hashSet) &#123; System.out.print(hash+&quot; &quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; scanner.close(); 第18章 Swing程序设计Swing概述graph LR javax.swing.JLabel-->D[javax.swing.JComponent] Javax.swing.JPanel-->D javax.swing.JDialog-->A[java.awt.Dialog] javax.swing.JFrame-->B[java.awt.Frame] A-->C[java.awt.Window] B-->C D-->E[java.awt.Container] C-->E E-->F[java.awt.Component] F-->java.lang.Object 由Swing包的层次结构和继承关系可知 Dialog和Frame都在awt.Window里 而JDialog在awt.Dialog里，JFrame在awt.Frame里 JPanel和JLabel在swing.JComponent里 它们都在awt.Container里，最顶层是java.lang.Object Swing常用窗体 public JFrame(String title); 默认不可见窗体，可以标题 将窗体转为容器 12JFrame jf=new JFrame(&quot;登录&quot;);Container container=jf.getContentPane(); container.add();container.remove() 添加；删除容器中的组件 container 是主容器，组件都在这个范围内 JLabel 内容可以用html标签 setBounds(距离左边x,距离上边y,宽度,高度) 设置窗体左上角的坐标和大小，对于JFrame是设置距离屏幕的位置，对于container里的就是相对灰色的container位置 setLocation(int x,int y); setSize(int width, int height); 设置窗体宽高 setVisibale(boolean b); 是否可见 setDefaultCloseOperation(int operation); 设置关闭方式 默认是DISPOSE_ON_CLOSE 窗体关闭释放窗体资源，窗体消失但程序不停止 EXIT_ON_CLOSE 窗体关闭，释放窗体资源并关闭程序 Jdialog 对话框 public JDialog(Frame f, Sring title,boolean mode)设置model为true时，打开对话框时，阻塞主窗体不可操作。 JButton单击事件 1234567891011121314151617181920212223242526272829303132333435class MyJDialog extends JDialog&#123;\tpublic MyJDialog(MyFrame frame) &#123; super(frame,&quot;第一个JDialog窗体&quot;,true);//调用父类构造方法，参数：父类窗体,标题，是否阻塞父窗体 Container container=getContentPane();//获取主窗体 container.add(new JLabel(&quot;这是一个对话框&quot;));//在容器中添加标签 setBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\t&#125;&#125;public class MyFrame extends JFrame&#123;\tpublic MyFrame() &#123; Container container=getContentPane();//获取窗体主容器 container.setLayout(null);//窗体使用绝对布局 JButton bl=new JButton(&quot;弹出对话框&quot;); bl.setBounds(10, 10, 100, 21);//按钮坐标大小 bl.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 MyJDialog dialog=new MyJDialog(MyFrame.this);//创建对话框，传参是当前窗体 dialog.setVisible(true); &#125; &#125;); container.add(bl); setSize(200, 200); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//关闭窗体停止程序 setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MyFrame();\t&#125;&#125; 常用布局管理器null 绝对布局 硬性指定位置和大小，组件位置通过绝对坐标的方式来指定 首先取消布局管理器：Container.setLayout(null) 设置每个组件在容器的位置和大小：Component.setBounds(int x,int y,int width,int height) 12345678910111213141516171819202122public class AbsolutePosition extends JFrame&#123;\tpublic AbsolutePosition() &#123; setTitle(&quot;绝对布局&quot;); setLayout(null);//取消布局管理器 setBounds(0,0,300,150); Container container=getContentPane(); JButton b1=new JButton(&quot;按钮1&quot;); JButton b2=new JButton(&quot;按钮2&quot;); b1.setBounds(10,30,80,30);//设置按钮位置和大小 b2.setBounds(60,70,100,20); container.add(b1); container.add(b2); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new AbsolutePosition();\t&#125;&#125; FlowLayout 流布局管理器 流布局组件从左到右摆放。当组件占据了当前行的所有空间时，溢出的到下一行 默认情况，行组件排列方式为居中对齐，可以通过设置更改 FlowLayout类具有以下常用的构造方法 public FlowLayout() public FlowLayout(int alignment) public FlowLayout(int alignment,int horizGap,int vertGap) alignment参数表示排列方式，可以设置为Flowlayout.LEFT、FlowLayout.CENTER或FlowLayout.RIGHT horizGap,vertGap这两个参数以像素为单位指定组件之间的水平间隔和垂直间隔 123456789101112131415161718public class FlowLayoutPosition extends JFrame&#123;\tpublic FlowLayoutPosition() &#123; setTitle(&quot;流布局管理器&quot;); Container container=getContentPane(); setLayout(new FlowLayout(FlowLayout.RIGHT,10,10)); for (int i = 0; i &lt; 10; i++) &#123; container.add(new Button(&quot;button&quot;+i)); &#125; setSize(300,200); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new FlowLayoutPosition();\t&#125;&#125; BorderLayout 边界布局管理器 Swing创建窗体默认是边界布局管理器 边界布局管理器把容器分为东、南、西、北、中5个区域 当组件添加时，需要使用BorderLayout类中的成员变量指定其区域 BorderLayout.NORTH 北 BorderLayout.SOUTH 南 BorderLayout.EAST 东 BorderLayout.WEST 西 BorderLayout.CENTER 中 ———–NORTH———– WEST—CENTER—-EAST ———–SOUTH———– add(组件，成员变量) 12345678910111213141516171819202122232425public class BorderLayoutPosition extends JFrame&#123;\tpublic BorderLayoutPosition() &#123; setTitle(&quot;边界布局管理器&quot;); Container container=getContentPane(); setLayout(new BorderLayout());//使用边界布局管理器 JButton centerButton=new JButton(&quot;中&quot;); JButton northButton=new JButton(&quot;北&quot;); JButton southButton=new JButton(&quot;南&quot;); JButton westButton=new JButton(&quot;西&quot;); JButton eastButton=new JButton(&quot;东&quot;); container.add(centerButton,BorderLayout.CENTER); container.add(eastButton,BorderLayout.EAST); container.add(westButton,BorderLayout.WEST); container.add(southButton,BorderLayout.SOUTH); container.add(northButton,BorderLayout.NORTH); setSize(350,200); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BorderLayoutPosition();\t&#125;&#125; GridLayout 网格布局管理器 划分为网格，组件可以按行、列进行排序 网格个数由行数和列数决定，每个网格大小相同 组件从网格左上角开始，从左到右从上到下被添加到网格中 每个组件都会填满整个网格 改变窗体大小，组件大小也会随之改变 构造方法 public GridLayout(int rows, int columns) public GridLayout(int rows, int columns, int horizGap, int vertGap) rows和columns只有一个可以是0，被用于一行或一列排列任意多个组件 1234567891011121314151617public class GridLayoutPosition extends JFrame&#123;\tpublic GridLayoutPosition() &#123; Container container=getContentPane(); setLayout(new GridLayout(7,3,5,5));//7行3列网格，组件水平间距5像素，垂直间距5像素 for (int i = 0; i &lt; 20; i++) &#123; container.add(new JButton(&quot;button&quot;+i)); &#125; setSize(300,300); setTitle(&quot;网格布局管理器&quot;); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根\t&#125;&#125; 常用面板JPanel 面板必须在窗体容器中使用，无法脱离窗体显示 1Jpanel p1=new JPanel(new GridLayout(1,4,10,10));//初始化面板，使用1行4列的网格布局，组件水平间隔10像素，垂直间隔10像素 JScrollPane 滚动面板1234Container c=getContentPane();JTextArea ta=new JTextArea(20,50);//创建文本区域组件，文本域默认大小为20行、50列JScrollPane sp=new JScrollPane(ta);//创建滚动面板，并将其文本域放到滚动面板中c.add(sp); 图片路径123Icon con=new ImageIcon(&quot;src/注意.png&quot;);//使用字符串作为路径，是以项目文件夹为根目录URL url=MyImageIcon.class.getResourse(&quot;注意.png&quot;);//getResourse是以类所在文件夹为根目录Icon icon=new ImageIcon(url);//创建Icon对象 当用new File()时相对路径是相对于项目的路径，例如JavaSE下面有src，src下面有包，包里有类，当在类中用new File()相对路径访问src下的文件时应该是 1File file=new File(&quot;src/[文件名]&quot;); 事件监听器ActionEvent动作事件动作事件监听器 相关定义 实现方式 事件名 ActionEvent 事件源 JButton、JList、JTextField等组件 监听接口 ActionListener 添加监听方法 addActionListener() 删除监听方法 removeActionListener() 123456789JButton b1=new JButton(&quot;按钮&quot;);bl.addActionListener(new ActionListener() &#123; @Override\tpublic void actionPerformed(ActionEvent e) &#123;\t// 要触发的动作 &#125;&#125;); 或者用类调用接口的方法： 1234567891011public class SimpleEvent extends JFrame&#123; private JButton jb=new JButton(&quot;我是按钮&quot;); public SimpleEvent()&#123; jb.addActionListener(new jbAction()); &#125; class jbAction implements ActionListener&#123; public void actionPerformed(ActionEvent arg0)&#123; jb.setText(&quot;我被点击了&quot;); &#125; &#125;&#125; jbAction实现ActionListner接口，同时在该内部类中实现actionPerform()方法，这个方法中定义当用户单击该按钮后实现怎样的功能 KeyEvent键盘事件KeyEvent类负责捕获键盘事件，可以通过为组件添加实现了KeyListener接口的监听器类来处理相应的键盘事件。 KeyListerner接口3个抽象方法 12345678public interface KeyListener extends EventListener&#123; //发生击键事件时触发 public void keyTyped(KeyEvent e); //按键被按下时被触发 public void ketPressed(KeyEvent e); //案件被释放时被触发 public void keyReleased(KeyEvent e);&#125; KeyEvent类中的常用方法 getKeyChar() 获得与此事件中的键相关联的字符 123456textField=new JTextField();textField.addKeyListener(new KeyAdapter()&#123;//文本框添加键盘事件的监听 public void keyPressed(KeyEvent e)&#123;//按键按下时触发 //实现的功能 &#125;&#125;) MouseEvent鼠标事件所有组件都能发生鼠标事件。添加MouseListener接口监听，有5个抽象对象 1234567public interface MouseListener extends EventListener&#123; public void mouseEntered(MouseEvent e);//光标移入组件时触发 public void mousePressed(MouseEvent e);//鼠标按键按下 public void mouseReleased(MouseEvent e);//鼠标按键释放时被触发 public void mouseClicked(MouseEvent e);//发生单击事件被触发 public void mouseExited(MouseEvent e);//光标移出组件时被触发&#125; 注意单击事件如果按键在移除组件之后才被释放，则不会触发单机事件 MouseEvent类中的常用方法 getSource() 获得触发此次事件的组件对象，返回值为Object类型 getButton() 获得按键的int值 getClickCount() 获得单击按钮的次数 按键的int值： 静态常量 常量值 代表的键 BUTTON1 1 鼠标左键 BUTTON2 2 鼠标滚轮 BUTTON3 3 鼠标右键 123456789101112131415161718192021private void mouseOper(MouseEvent e)&#123; int i=e.getButton();//获得按键的int值 if(i==MouseEvent.BUTTON1) System.out.println(&quot;按下的是鼠标左键&quot;); else if(i==MouseEvent.BUTTON2) System.out.println(&quot;按下的是鼠标滚轮&quot;); else if(i==MouseEvent.BUTTON3) System.out.println(&quot;按下的是鼠标右键&quot;);&#125;public MouseEvent_Example()&#123; final JLable label=new JLable(); label.addMouseListener(new MouseListener()&#123; public void mouseEntered(MouseEvent e)&#123; System.out.println(&quot;光标移入组件&quot;); &#125; public void mousePressed(MouseEvent e)&#123; System.out.print(&quot;鼠标按键被按下&quot;); mouseOper(e); &#125; &#125;)&#125; 第二十章 多线程多种活动同时进行的思想称为并发，而将完成的每一件事情称为线程 CPU在一个时间片中执行某个进程，然后下一个时间片又跳至另一个进程中去执行。由于CPU转换较快，好像同时执行一样 创建线程 Thread类是java.lang包中的一个类 完成线程真正功能的代码放在类的run()方法里 start()方法会启动线程，线程自动执行run()方法里的代码。 如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()前，Thread对象只是实例，不是真正的线程 主方法线程由Java虚拟机负责启动 如果start()方法调用一个已经启动的线程，抛出IllegalThreadStateException异常 实现Runnable()接口当要继承其他非Thread类，通过Runnable接口来实现多线程 1234567891011121314151617public class Threadtest extends Object implements Runnable&#123; @Override\tpublic void run() &#123; // TODO 自动生成的方法存根 String string=Thread.currentThread().getName(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(string+&quot;第&quot;+i+&quot;次操作&quot;); &#125;\t&#125;\tpublic static void main(String[] args) &#123; Threadtest threadtest=new Threadtest(); Thread t1=new Thread(threadtest,&quot;线程1&quot;);//第二个是Thread的名字，一般是Thread(String name) Thread t2=new Thread(new Threadtest(),&quot;线程2&quot;);//匿名方式 t1.start(); t2.start();\t&#125;&#125; 实现Runnable()接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联 使用Runnable接口启动新的线程步骤如下： 建立Runnable对象 使用参数为Runnable对象的构造方法创建Thread实例 调用start()方法启动线程 123456Thread thread=new Thread(new Runnable()&#123; @Override public void run()&#123; &#125;&#125;) Swing与Thread结合实例 1234567891011121314151617181920212223242526272829303132333435363738public class SwingAndThread extends JFrame&#123;\tint count=0;//图像横坐标\tpublic SwingAndThread() &#123; setBounds(300,200,250,100); Container container=getContentPane();//主容器 container.setLayout(null); Icon icon=new ImageIcon(&quot;src/1.gif&quot;); JLabel jLabel=new JLabel(icon); jLabel.setBounds(10,10,200,50); Thread thread=new Thread() &#123;//匿名线程对象 public void run() &#123; while (true) &#123; jLabel.setBounds(count,10,200,50);//将标签的横坐标用变量表示 try &#123; Thread.sleep(500);//休眠500毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; count+=4;//横坐标每次增加4 if(count&gt;=200) &#123; count=10;//到达最右边时使其回到最左边 &#125; &#125; &#125; &#125;; thread.start(); container.add(jLabel); setVisible(true); setDefaultCloseOperation(EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new SwingAndThread();\t&#125;&#125; 线程的生命期 出生状态就是线程被创建时处于的状态，在用户使用该线程实例调用start()方法之前线程都是出生状态。 当调用start()方法后，线程处于就绪状态(可执行状态) 当线程得到系统资源进入运行状态。 处于运行状态调用Thread类中的wait()方法时，进入等待状态。进入等待状态必须由其他的线程调用notify()唤醒，自己无法唤醒自己，notifyAll()方法将所有处于等待状态下的线程唤醒 sleep()休眠状态，时间到了会自动唤醒，区别于等待状态。 线程中运行状态下发出输入&#x2F;输出请求时，该线程将进入阻塞状态。等待输入输出结束时线程进入就绪状态 当线程的run()方法执行完毕时，线程进入死亡状态。 graph TD 出生-->A[就绪] A-->B[运行] B-->A B-->C[等待] B-->D[休眠] B-->E[阻塞] B-->死亡 C-->A D-->A E-->A 操作线程的方法线程的加入join()方法加入到另外一个线程。例如存在一个线程A，现在需要插入B要求线程B先执行完毕，然后再执行线程A，调用join()，类似插入队伍。 当某个线程使用join()加入另外一个线程时，另一个线程会等待该线程执行完毕后再继续执行。 使用方法：在某一个线程A的run函数中使用B.join()插入B线程。 插入到主线程： 123456789101112public static void main(Stirng[] args)&#123; 类 A=new 类();&#125;public 类&#123; 线程实例化; 线程.start; try&#123; 线程.join();//这样就插入到主线程 &#125;catch(..)&#123; e.printStackTrace(); &#125;&#125; 线程的优先级 每个线程具有各自的优先级，可以表明在程序中该线程的重要性 系统根据优先级决定首先使哪个线程进入运行状态 123456789101112131415161718192021222324252627282930313233343536public class Priority implements Runnable&#123;\tString nameString;\tpublic Priority(String name) &#123; this.nameString=name;\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 String tmpString=&quot;&quot;; for (int i = 0; i &lt; 50000; i++) &#123; tmpString+=i;//进行50000次字符拼接 &#125; System.out.println(nameString+&quot;线程完成任务&quot;);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Thread aThread=new Thread(new Priority(&quot;A&quot;)); aThread.setPriority(1); Thread bThread=new Thread(new Priority(&quot;B&quot;)); bThread.setPriority(3); Thread cThread=new Thread(new Priority(&quot;C&quot;)); cThread.setPriority(7); Thread dThread=new Thread(new Priority(&quot;D&quot;)); dThread.setPriority(10); aThread.start(); bThread.start(); cThread.start(); dThread.start();\t&#125;&#125;//结果D线程完成任务B线程完成任务C线程完成任务A线程完成任务 由输出结果，不一定按优先级，知识作为CPU的参考依据。执行顺序由CPU决定 线程同步线程安全线程安全问题来源于两个线程同时存取单一对象的数据 线程同步机制 解决资源共享问题 同步块 synchronized(Object)&#123;&#125; 通常将共享资源的操作放置在synchronized定义的区域内，当其他线程获取这个锁时，就必须等待锁被释放后才可以进入该区域。其中Object有标志位，0和1，若为0，表示此同步块内存在其他线程，这是当前线程处于就绪状态，直到同步块中的线程执行完同步块代码后，该对象标志位设置为1，当前线程开始执行同步块。 在run()里边添加同步块： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SynchronizedTest implements Runnable&#123;\tint num=10;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (true) &#123; synchronized (this) &#123; if (num&gt;0) &#123; try &#123; Thread.sleep(100);//使当前线程休眠100毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;——票数&quot;+num--); &#125; &#125; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 //实例化类对象 SynchronizedTest test=new SynchronizedTest(); //以该类对象分别实例化4个线程 Thread tA=new Thread(test,&quot;线程一&quot;); Thread tB=new Thread(test,&quot;线程二&quot;); Thread tC=new Thread(test,&quot;线程三&quot;); tA.start(); tB.start(); tC.start();\t&#125;&#125;//结果线程一——票数10线程一——票数9线程一——票数8线程一——票数7线程一——票数6线程一——票数5线程一——票数4线程一——票数3线程一——票数2线程一——票数1 如果不加同步块结果会出现负数 线程中执行n++结果不一定正确，因为n++不是原子操作，其中包含三步包括取值，加一，赋值，中间可能会被打断，导致结果不一定准确。可以加入锁解决 1234567synchronized(Object)&#123; try&#123; n++; aomicinteger.incrementAndGet(); longAdder.increment(); &#125;&#125; 同步方法 在方法前面用synchronized关键字修饰方法： 1synchronized void f()&#123;&#125; 同上面的例子实现一样的功能，不过运用同步方法而不是同步块： 12345678910111213141516171819202122232425262728293031323334public class SynchronizedTest implements Runnable&#123;\tint num=10;\tpublic synchronized void doit() &#123;//定义同步方法 if (num&gt;0) &#123; try &#123; Thread.sleep(100);//使当前线程休眠100毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;——票数&quot;+num--); &#125;\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (true) &#123; doit(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 //实例化类对象 SynchronizedTest test=new SynchronizedTest(); //以该类对象分别实例化4个线程 Thread tA=new Thread(test,&quot;线程一&quot;); Thread tB=new Thread(test,&quot;线程二&quot;); Thread tC=new Thread(test,&quot;线程三&quot;); tA.start(); tB.start(); tC.start();\t&#125;&#125; 网络通信网络程序设计基础在TCP&#x2F;IP协议栈中，有两个高级协议，即传输控制协议(Transmission Control Protocol，TCP)与用户数据传输报协议(User Datagram Protocol，UDP) 高级协议 TCP UDP 特点 以固接连线为基础，从一端送至连接的另一端 以发送数据包的方式进行，向若干目标发送数据或接受来自若干源的数据 数据顺序 数据能够送达，且抵达数据的顺序&#x3D;送出时的顺序 不保证抵达的顺序&#x3D;送出时的顺序 类比 就像打电话，必须先拨号给对方，等两端确定连接后，互相才能听到对方说法，也知道对方回应的是什么 邮递员送信，可以寄出很多信给同一个人，且每封信相对独立。各封信到达的顺序并不重要，收信人接收信件的顺序也不能保证与寄出信件的顺序相同 TCP是面向连接的可靠协议，效率低，保证确实送达。UDP是面向无连接的不可靠协议，效率高，不保证数据可靠的传输。 一些防火墙或路由器可能设置不允许UDP数据传输协议 端口类似营业厅的窗口，提供某些服务 HTTP 80 FTP 21 Tomcat 8080 MySQL 3306 套接字套接字(Socket)用于将应用程序与端口连接起来。 客户端(应用程序&lt;–&gt;Socket&lt;–&gt;Port&lt;-)-(-&gt;Port&lt;–&gt;Socket&lt;–&gt;应用程序)服务器 类似插座一样连接电器与电线 TCP程序TCP协议进行通信的两个应用程序有主次之分，一个称为服务器程序，另一个称为客户机程序，服务端与客户端的交互过程如下： 服务器程序创建一个SeverSocket(服务器端套接字)对象，调用accept()方法等待客户机来连接 客户端程序创建一个Socket对象，请求与服务器建立连接 服务器接受客户机的连接请求，同时创建一个新的Socket对象与客户建立连接。随后服务器继续等待新的请求 SeverSocket可以理解为售后部门的电话；服务器端运行的Socket可以理解为客服人员；客户端运行的Socket可以理解为顾客 IntetAddress类这是一个与ip地址相关的类，可以获取ip地址，主机地址等信息，常用方法： getByName(String host) 返回InterAddress 获取Host项对应的InterAddress对象 getHostAddress() 返回String 获取InterAddress对象所包含的IP地址 getHostName() String 获取此ip地址的主机名 getLocalHost() InterAddress 返回本地主机的InterAddress对象 123456789101112131415161718192021public class Address &#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 InetAddress ip;//创建对象 try &#123; ip=InetAddress.getLocalHost();//实例化对象 String localname=ip.getHostName();//获取本机名 String localip=ip.getHostAddress();//获取本机ip地址 System.out.println(&quot;本机名：&quot;+localname); System.out.println(&quot;本机IP地址：&quot;+localip); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;&#125;//结果本机名：LAPTOP-6G798SAR本机IP地址：192.168.4.1 SeverSocket类服务器套接字 SeverSocket(int port)：绑定到接口port的服务器套接字 当服务器向输出流写入信息时，客户端通过相应的输入流就能读取，反之亦然 注意accept()方法会阻塞线程的继续指行，直至接收到客户的呼叫 12yu=server.accept();System.out.println(&quot;连接中&quot;); 如果没有客户呼叫服务机，那么“连接中”语句不会执行 TCP网络程序设计单项通信的例子，客户机通过输出流发送数据，服务器通过输入流接收数据： 服务器端： 12345678910111213141516171819202122232425262728293031323334public class MyServer &#123;\tprivate ServerSocket server;//服务器套接字\tprivate Socket socket;//客户机套接字\tvoid start() &#123; try &#123; server=new ServerSocket(8998);//服务器启用8998端口 System.out.println(&quot;服务器套接字已经创建成功&quot;); while (true) &#123; System.out.println(&quot;等待客户机的连接&quot;); socket=server.accept();//服务器监听客户机连接 BufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream())); while (true) &#123; String message=reader.readLine();//读取一行文本 if(&quot;exit&quot;.equals(message)) &#123; System.out.println(&quot;客户机退出&quot;); break;//停止接受信息 &#125; System.out.println(&quot;客户机：&quot;+message); &#125; reader.close(); socket.close(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 MyServer tcp=new MyServer(); tcp.start();\t&#125;&#125; 客户机端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyClient extends JFrame&#123;\tprivate PrintWriter writer;//根据套接字字节流创建的字符输出流\tSocket socket;\tprivate JTextArea area=new JTextArea();//展示信息的文本域\tprivate JTextField text=new JTextField();//发送信息的文本框 public MyClient() &#123; setTitle(&quot;向服务器送数据&quot;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Container container=getContentPane(); JScrollPane scrollPane=new JScrollPane(area); getContentPane().add(scrollPane,BorderLayout.CENTER); container.add(text,&quot;South&quot;); text.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 writer.println(text.getText().trim());//将文本框中的信息写入流 area.append(text.getText()+&#x27; &#x27;);//将文本框中的信息显示到文本域中 text.setText(&quot;&quot;);//清空 &#125; &#125;);\t&#125;\tprivate void connect() &#123; area.append(&quot;尝试连接 &quot;); try &#123; socket=new Socket(&quot;127.0.0.1&quot;,8998);//连接本地计算机的8998接口 writer=new PrintWriter(socket.getOutputStream(),true); area.append(&quot;完成连接 &quot;); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 MyClient client=new MyClient(); client.setSize(200,200); client.setVisible(true); client.connect();//连接服务器\t&#125;&#125; UDP程序UDP通信基本模式： 将数据打包（数据包），然后将数据包发往目的地 接收别人发来的数据包，然后查看数据包 发送数据包： 创建：使用DatagramSocket()创建一个数据包套接字。 打包：使用DatagramPacker(byte[] buf, int offset, int length, InetAddress address, int port)创建要发送的数据包。 发送：使用DatagramSocket()类的send()方法发送数据包。 接收数据包： 创建：使用DatagramSocket(int port)创建数据包套接字，绑定到指定的接口。 准备包：使用DatagramPacket(byte[] buf, int length)创建字节数组来接收数据包。 接收：使用DatagramPocket类的receive()方法接收UDP包。 DatagramPacket类数据包，构造方法： DatagramPacket(byte[] buf, int length) 指定包的内存空间和大小 DatagramPacket(byte[] buf, int length,InetAddress address,int port) 多指定了数据包的目标地址和端口 发送数据需指定接收方的Socket地址和端口号 DatagramSocket类 DatagramSocket() DatagramSocket(int port) DatagramSocket(int port, InetAddress addr) 适用多块网卡有多个IP地址 接收时要指定端口号一般用第二种，发送时不知道用第一种。 UDP网络程序设计下面创建一个广播数据报程序，原理类似电台广播。广播电台需要在指定的波段和频率上广播信号，接收者也要将收音机调到指定的波段、频率，才可以收听广播内容。 广播主机程序不断向外播出信息： image-20221224205156462 123456789101112131415161718192021222324252627282930313233343536373839404142public class Notification extends Thread&#123;\tString weather=&quot;节目预报：八点有大型晚会，请收听&quot;;//发送的信息\tint port=9898;\tInetAddress iaddress=null;\tMulticastSocket socket=null;//多点广播套接字，是一种DatagramPacket @SuppressWarnings(&quot;deprecation&quot;)\tpublic Notification() &#123; try &#123; iaddress=InetAddress.getByName(&quot;224.255.10.0&quot;);//广播组地址 socket=new MulticastSocket(port);//实例化 socket.setTimeToLive(1);//指定发送范围是本地网络 socket.joinGroup(iaddress);//加入广播组 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic void run() &#123; while (true) &#123; DatagramPacket packet=null;//数据包 byte data[]=weather.getBytes();//字符串消息的字节数组 packet=new DatagramPacket(data,data.length,iaddress, port);//将数据打包 System.out.println(weather); try &#123; socket.send(packet); sleep(3000); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Notification w=new Notification(); w.start();//启动线程\t&#125;&#125; 接收广播程序： image-20221224205211236 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Receive extends JFrame implements Runnable,ActionListener&#123;\tint port;//端口\tInetAddress group=null;//广播组地址\tMulticastSocket socket=null;//多点广播套接字对象\tJButton inceBtn=new JButton(&quot;开始接收&quot;);\tJButton stopBtn=new JButton(&quot;停止接收&quot;);\tJTextArea inceAr=new JTextArea(10,10);\tJTextArea inced=new JTextArea(10,10);\tThread thread;\tboolean stop=false;//停止接收信息状态 public Receive() &#123; //界面设计 setTitle(&quot;广播数据报&quot;); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); thread=new Thread(this); inceBtn.addActionListener(this);//绑定按钮ince的单击事件 stopBtn.addActionListener(this);//绑定按钮stop的单击事件 inceAr.setForeground(Color.blue); JPanel north=new JPanel(); north.add(inceBtn);//将按钮添加到north面板 north.add(stopBtn); add(north,BorderLayout.NORTH);//将north放置在窗体上部 JPanel center=new JPanel();//创建面板对象center center.setLayout(new GridLayout(1,2));//设置面板布局 center.add(inceAr);//将文本域添加到面板上 center.add(inced); add(center,BorderLayout.CENTER);//设置面板布局 validate();//刷新 //UDP部分 port=9898; try &#123; group=InetAddress.getByName(&quot;224.255.10.0&quot;);//指定接收地址 socket=new MulticastSocket(port);//绑定 socket.joinGroup(group);//加入广播组 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; setBounds(100,50,360,380); setVisible(true);\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (stop==false) &#123; byte data[]=new byte[1024];//创建缓存字节数组 DatagramPacket packet=null; packet=new DatagramPacket(data,data.length,group, port);//待接收数据包 try &#123; socket.receive(packet);//接收数据包 //获取数据包中的内容 String message=new String(packet.getData(),0,packet.getLength()); inceAr.setText(&quot;正在接收的内容： &quot;+message);//将接收内容显示在文本域中 inced.append(message+&quot; &quot;);//每条信息为一行 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125;\t&#125;\t@Override\tpublic void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource()==inceBtn) &#123;//单击inceBtn按钮触发的事件 inceBtn.setBackground(Color.red);//设置按钮颜色 stopBtn.setBackground(Color.yellow); if (!(thread.isAlive())) &#123;//线程不处于”新建状态” thread=new Thread(this); &#125; thread.start();//启动线程 stop=false;//开始接收信息 &#125; if (e.getSource()==stopBtn) &#123;//单击stop按钮触发的事件 inceBtn.setBackground(Color.yellow); stopBtn.setBackground(Color.red); stop=true; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Receive receive=new Receive(); receive.setSize(460,200);\t&#125;&#125;","tags":["编程语言"]},{"title":"Java学习笔记","path":"/2022/09/29/Java+软导笔记/Java学习笔记/","content":"错题 通过super可调用父类构造函数。对 构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的 一般在创建新对象时，系统会自动调用构造函数。对 【单选题】下面赋值语句不合法的是___D___。 A.Long a&#x3D;(Long)(long)3; B.Long b&#x3D;3L; C. Long c&#x3D;Long.parseLong(“3”); D.Long d&#x3D;(Long )3; 下面赋值语句不合法的是 D。在Java中，”Long”类是原始数据类型long的包装类，必须使用关键字”new”来构造包装类，才能创建有效的对象。从长值3创建Long对象的正确方法如下： 1Long d = new Long(3); 其他三个选项都是从长值3创建Long对象的有效方法。选项A从将整数值3转换为长值，然后再转换为Long的结果创建Long对象。选项B从长值3L创建Long对象。选项C通过调用Long类的parseLong方法，从字符串值”3”创建Long对象。 【单选题】java语言中，在定义类时不能使用的修饰符是____B______。 A.public B.private C.abstract D.final 答案是 B：private。在 Java 语言中，private 是一种访问修饰符，它只能在类的内部使用，不能用于定义类。 A 选项：public。public 是一种访问修饰符，它表示在任何地方都能够访问。定义类时可以使用 public 修饰符。 C 选项：abstract。abstract 是一种修饰符，它用于定义抽象类和抽象方法。定义类时可以使用 abstract 修饰符。 D 选项：final。final 是一种修饰符，它表示类不能被继承，方法不能被重写。定义类时可以使用 final 修饰符。 在Java语言中，下面关于Math类的常见操作不正确的描述是_____D__B___。 A.执行Math.ceil(-10.5) 语句的结果是-10.0 B.执行Math.round(10.5) 语句的结果是11.0 (答案是11，没有小数点！) C.执行Math.floor(-10.5) 语句的结果是-11.0 D.执行Math.round(-10.5) 语句的结果是-10 Math.round 不完全是四舍五入，当刚好为负数且刚好0.5，舍入到正无穷方向上的整数。如Math.round(-20.5)结果为-20 【单选题】执行下面程序段后，输出结果是___C______。 int a&#x3D;4,b&#x3D;6,c&#x3D;8; System.out.println(++a*b—c ); A.11 B.16 C.22 D.23 注意后面的—前两个应该是b的后缀，而不是后两个是c的前缀，由于是后缀，无影响，而a的前缀加了用，因此是5×6-8结果为22，而且b的值变为5，a为5。 下面概念中，不属于面向对象程序设计的是_____A_____。 A.过程调用 B.对象 C.类 D.继承 文本框获得焦点时回车和按钮单击，都属于ActionEvent事件，也就是说文本框和按钮可以作为ActionEvent事件的事件源。 而选择框的选中，和下拉列表的选中，都是在触发ItemEvent事件。 不同类型的事件的监听器要实现的接口不同，对于ActionEvent事件，这个接口是 ActionListener，实现其中的actionPerformed方法，方法传入的也是ActionEvent对象。 而对于ItemEvent事件，则要实现的是ItemListener接口，实现其中的itemStateChanged方法，方法传入的是ItemEvent对象。 下面关于java.sql包中接口和类的描述不正确的是__B__。 A.Connection 接口：表示数据库连接 B.DriverManager类：表示驱动器 (错，JDBC 的管理层，作用于用户和驱动程序之间。) C.ResultSet接口：表示SQL查询语句返回的结果集 D.Statement接口：负责执行SQL语句 在Java语言中，下面用于执行存储过程SQL语句的是___B___。 A.Statement B.CallableStatement C.createStatement D.PreparedStatement Statement 对象有三种:(Statement)对象用于执行不带参数的简单 SQL语句; (PreparedStatement)对象继承Statement，用于执行带或不带参数的预编译 SOL语句:(CallableStatement) 对象继承PreparedStatement，用于执行对数据库存储过程的调用 在Java语言中，下面关于Scanner类描述错误的是_____D__C___。 A.Scanner类可以方便的完成输入流的输入操作 B.Scanner sc&#x3D;new Scanner(System.in);&#x2F;&#x2F;从标准输入中扫描 C.Scanner类位于javax.util包中，使用时需要import导入**(是java.util)** D.Scanner可以扫描指定的文件. D是对的，C是错的。 在Java语言中，下面不属于ComponentEvent的子类是____D______。 A.InputEvent B.FocusEvent C.WindowEvent D.ItemEvent ItemEvent不属于ComponentEvent的子类。 在Java语言中，下面关于组件定义错误的是____ D_____。 A.TextField tf&#x3D;new TextField(3);&#x2F;&#x2F;int型指定列宽 B.Timer tr&#x3D;new Timer(); C.JFileChooser jf&#x3D;new JFileChooser(); D.TextArea ta&#x3D;new TextArea(3); 在Java语言中，以下____C____项是接口B的正确定义。 A.interface B{ void print(){ };} B.abstract interface B{void print(){}} C.interface B {void print();} D.interface B extend A { void print(){}}&#x2F;&#x2F;A为已定义接口 12345public interface Paintable&#123; void draw();//没有&#123;&#125;，可省略public abstract关键字&#125;interface intf1&#123;&#125;interface intf2 extends intf1&#123;&#125;//接口继承接口 下面概念中，不属于面向对象程序设计的是_____A_____。 A.过程调用 B.对象 C.类 D.继承 在Java语言中，成员变量中被static关键字修饰的变量，叫 B A.变量 B.类变量 （静态变量的成员变量） C.实例变量 D.整型变量 在Java语言中，下面关于String类的常见操作不正确的描述是______B____。 A.假设 s =&quot;class&quot;;则执行char c = s.charAt(1)语句后变量c的值是l B.indexOf方法是查找特定字符或字符串在当前字符串中的起始位置，如果不存在则返回0 。（返回-1） C.concat方法的作用是进行字符串的连接，将两个字符串连接以后形成一个新的字符串 D.equals方法的作用是判断两个字符串对象的内容是否相同 charAt() 方法用于返回指定索引处的字符。索引范围为从 0 到 length() - 1。 下面关于try catch语句中异常类排列顺序正确的说法是____B______。 A.父类异常在前，子类异常在后 B.父类异常在后，子类异常在前 C.父类和子类异常排列顺序前后无影响 D.只能有子类异常 已知Integer.MAX_VALUE 的值为2147483647，在执行“Integer max1&#x3D;Integer.MAX_VALUE,max2&#x3D; max1+1;”语句后，max2等于____A______。 A.-2147483648 B.2147483647 C.0 D.2147483648 在Java语言中，Person类有一个成员变量age被protected修饰，下面关于age说法不正确的是___C_______。 A.能被Person的子类访问。 B.能被Person类所在同一个包中的其它类访问。 C.能被Person类所在包之外的其它类访问。 D.不能被Person类所在包之外的其它类访问。 protected 访问控制符能被用于方法和成员变量 声明为protected的方法和成员变量能被同一个包里的所有类所访问，就像默认修饰符package一样能被该类的子类所访问，子类可以和父类不在一个包中。另一个包中的子类只能通过子类或其子类的引用来访问父类中受保护的成员。同一包中的子类没有此限制。这样可以确保来自其他包的类只访问属于其继承层次结构一部分的成员 下面哪项不属于Statement接口提供的3个执行SQL语句的方法______A____。 A.executeDelete(String sql) B.executeUpdate(String sql) C.executeQuery(String sql) D.execute(String sql) 在Java语言中，下面关于RandomAccessFile描述错误的是_____D_____。 A.实现DataInput和DataOutput接口 B.getFilePointer()方法：返回此文件中的当前偏移量 C.readFloat()方法：从此文件读取一个 float D.writeChar(int v)：按双字节值将char写入该文件，先写低字节(将一个字符作为一个两个字节的值写入基础输出流，其中高字节在前。) 在Java语言中，下面相关描述错误的是____B______。 A.File类对象对应于系统中的一个目录或文件 B.CharArrayReader 是一个把字符数组作为源的输出流的实现.(输入流) C.FileInputStream：以字节流方式读取 D.FileReader：把文件转换为字符流读入 下面关于Java事件描述错误的是_____A_____。 A.只有外部操作会产生事件 B.可以通过继承EventObject类编写自定义事件类 C.事件处理的三要素包括事件源、事件以及事件监听器 D.要在事件源上注册事件监听器 在Java语言中，下面关于Applet描述错误的是A。 A.Applet能执行任何本地计算机上的程序(错误) B.Applet的生命周期中有四个状态：初始态、运行态、停止态和消亡态 C.Applet的init()方法在Applet的生存周期中只调用一次 D.Applet应用程序必须嵌入在HTML页面中，才能得到解释执行 此外，Applet是Java类，且通常情况下不能进行文件的I&#x2F;O操作 在Java语言中，下面关于List不正确的描述是_______B___。 A.List是在java.util包中 B.List是一个类（是接口） C.List具有get(int index)方法 D.List是一个接口 List，Set，Map都是接口 在Java语言中，类Double定义在以下的哪个包中_____C_____。 A.java.io B.javax.lang C.java.lang D.java.util 在Java语言中，下面关于接口错误描述的是___A___。 A.接口不仅包括方法的特征，还有方法的实现。 B.接口只允许public 和abstract修饰。 C.接口中的属性只能被public 、final、static修饰。 D.一个类可以实现多个接口。 接口中的属性只能被public 、final、static修饰，而且必须赋值，因为是常量，在后面不能改变，否则会报错，不会给默认值的 在Java语言中，执行下列程序段后，i的结果是____D______。 int i; for(i&#x3D;0;i&lt;10;i++) { if (i&gt;4){ continue;}&#x2F;&#x2F; 一直跳过 if(i&gt;7 ){ System.out.println(i); break;} } A.6 B.8 C.9 D.10 在Java语言中，下面关于颜色定义不合法的是___B_______。 A.Color c1&#x3D;new Color(0xffffff) B.Color c2&#x3D;new Color(Color.BLUE) C.Color c3&#x3D;new Color(0,0,255) D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f) Color 是 Java 中的一个类，可以用来表示颜色。在 Java 中，可以使用以下几种方法来定义颜色： 使用 16 进制 RGB 值来定义颜色，例如 A.Color c1&#x3D;new Color(0xffffff)。 使用 24 位 RGB 值来定义颜色，例如 C.Color c3&#x3D;new Color(0,0,255)。 使用浮点型 RGB 值来定义颜色，例如 D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f)。 B.Color c2&#x3D;new Color(Color.BLUE) 中的 Color.BLUE 是预定义的颜色常量，它表示蓝色。这种方式并不能用来定义颜色，因此 B 选项是不合法的。 下面不属于Java语言中常见事件类型的是____C______。 A.KeyEvent B.MouseEvent C.TouchEvent D.ItemEvent 在Java语言中，下面不符合数组定义格式的是___D_______。 A.int []a&#x3D;new int [3]; B.int b[]&#x3D;{1,2,3}; C.int c[]&#x3D;new int [3]; D.int e[3]&#x3D;new int [3]; 在 Java 中，数组是用于存储一组相同类型的数据的数据结构。在 Java 中，可以使用以下几种方法来定义数组： 使用 new 运算符来定义数组，例如 A.int []a&#x3D;new int [3]; 和 C.int c[]&#x3D;new int [3];。 使用 {} 来定义数组并初始化数组元素，例如 B.int b[]&#x3D;{1,2,3};。 在Java语言中，下面变量命名不合法的有 C A.$fn B.p5p C.static D._user 必须以字母、下划线、或者美元符$开头； 在Java语言中，下面不属于JDBC的主要功能是A A.解析SQL语句 B.处理数据库的返回结果 C.建立与数据库或者其他数据源的连接 D.向数据库发送SQL命令 在Java语言中，下面用于执行简单的不带参数的SQL语句是 A A.Statement B.PreparedStatement C.CallableStatement D.createStatement 定义int A&#x3D;5，执行“System.out.println(“a&#x3D;”+((A&lt;5)?5.1:4));” 语句的结果是 B A.a&#x3D;5.1 B.a&#x3D;4.0 C.a&#x3D;5 D.a&#x3D;4 三目运算符后面类型不同需要类型升级 在Java语言中，下面关于包描述不正确的是 C A.包提供了访问权限和命名的管理机制 B.包是Java提供的一种区别类的名字空间的机制 C.类只能访问其所在包中的所有类 D.包是类的组织方式，是一组相关类和接口的集合 (1)具有public权限的类能被所有包中的类访问,与所在的包无关(2)具有缺省权限的类只能被所在包中的类访问,不能再其包外访问 定义char x&#x3D;’a’，下面赋值语句不合法的有 B A.float b&#x3D;x； B.byte c&#x3D;x; C.double d&#x3D;x; D.int a&#x3D;x; 应该为 byte c&#x3D;(byte)x; 在Java语言中，下面关于异常的错误描述是_____D_____。 A.异常是java提供的用于处理程序中错误的一种机制 B.java.lang. Exception类是所有异常的父类 C.java.lang.NullPointerException是空指针异常类 D.当异常产生时，程序会自动跳转到异常处理程序 在Java语言中，下面关于File类描述错误的是 A A.执行File f&#x3D;new File(“e:\\txx.txt”)语句的结果是在e盘上创建了一个txx.txt文件 B.File类对象对应于系统中的一个目录和文件 C.File类对象描述文件名、可否读写等属性，但不读写文件 D.一旦创建，File对象表示的抽象路径名将不会改变 File f&#x3D;new File;创建的是一个对象 在Java语言中，下面关于AWT组件描述错误的是 C A.Choice:制作用于单选的下拉列表 B.与菜单相关的类主要有三个: MenuBar、Menu、Menultem C.Panel类可作为容器容纳其它组件，也可以独立存在 D.Canvas:代表屏幕上一块空白的矩形区域 Panel类可作为容器容纳其它组件，也可以独立存在必须在窗体容器中使用，无法脱离窗体显示 substring()截取字符串，从索引0开始计数 12345678910String Str = new String(&quot;This is text&quot;); System.out.print(&quot;返回值 :&quot; ); System.out.println(Str.substring(4) );//4开始到最后 System.out.print(&quot;返回值 :&quot; ); System.out.println(Str.substring(4, 10) );//含头不含尾//结果返回值 : is text返回值 : is te public int index0f(int ch,int fromlndex): 返回从 fromlndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。 编译JavaApplication源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为D A. .html B. .Java C. .exe D. .class 字符串比较。Java中，使用”&#x3D;&#x3D;”比较字符串时，判断的是两个字符串是否存放在相同的位置。 12345678例如：x = &quot;Hello&quot;; y = &quot;Hello&quot;;x == y; //就是Truex == &quot;Hello&quot;; //也是True如果 String z=new String(x);x==z;//结果就是false 在Java语言中，关于final修饰符的说法不正确的是 C A.fnal成员变量表示常量，只能被赋值一次，赋值后值不再改变 B.final类不能被继承，没有子类，fnal类中的方法默认是final的 C.final能用于修饰构造方法 D.final方法不能被子类的方法覆盖，但可以被继承 final修饰的类，为最终类，该类不能被继承。如String 类；final修饰的方法可以被继承和重载，但不能被重写、覆盖；final修饰的变量不能被修改，是个常量 main是static，所以不能直接调用非静态的方法 方法重载就是一个类中有多个同名但有不同形参和方法体的方法 对 Java String类 trim() 方法用于删除字符串的头尾空白符 大题模板集合类ArrayList12345678910111213List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); //第一种 Iterator&lt;String&gt; iterator=list.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); iterator.remove();//移除 &#125; //第二种 for (int i = 0; i &lt; list.size(); i++) &#123; System.out.println(list.get(i)); list.remove(i)//移除 &#125; TreeSet截取部分输出 it=tree.SubSet(头,尾).iterator(); it=tree.headSet(边界).iterator(); 12345678910111213141516171819TreeSet&lt;UpdateStu&gt;tree =new TreeSet&lt;&gt;();UpdateStu stu1=new UpdateStu(&quot;李同学&quot;, 01011);UpdateStu stu2=new UpdateStu(&quot;陈同学&quot;,01021);...;tree.add(stu1);tree.add(stu2);tree.add(stu3);tree.add(stu4);Iterator&lt;UpdateStu&gt; it=tree.iterator();it=tree.headSet(stu2).iterator();System.out.println(&quot;截取前面部分的集合：&quot;);while(it.hasNext())&#123;\tSystem.out.println(it.next()); &#125;it=tree.subSet(stu2, stu3).iterator();System.out.println(&quot;截取中间部分的集合&quot;);while(it.hasNext())&#123;\tSystem.out.println(it.next());&#125; 文件存取字节流创建–输入–读取1File file=new File(&quot;MyFile.txt&quot;); 写入文件： 1234FileOutputStream outputStream=new FileOutputStream(file);//创建输出流byte buy[]=&quot;Java程序设计&quot;.getBytes();//准备字节数组outputStream.write(buy);//写入outputStream.close(); FileOutputStream里放file，准备byte[]是字符串.getBytes()，写入用write 读取 1234FileInputStream inputStream=new FileInputStream(file);//准备输入流byte byt[]=new byte[1024];//准备字节数组接收int len=inputStream.read(byt);//read读取inputStream.close(); 读取用read，返回值是长度 文件信息 1234System.out.println(&quot;文件长度：&quot;+file.length()+&quot;字节&quot;);System.out.println(&quot;文件路径：&quot;+file.getAbsolutePath());SimpleDateFormat simpleDateFormat=new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;);System.out.println(&quot;修改时间&quot;+simpleDateFormat.format(file.lastModified())); (缓存)字符流写入 12345FileWriter fw=new FileWriter(file);BufferedWriter bw=new BufferedWriter(fw);String str=&quot;你好&quot;;bw.write(str);//写入字符串bw.newLine();//写入换行符 FileWriter里放file，Buffered里放FW，写入用write，换行符newLine() 读取 123456FileReader fr=new FileReader(file);BufferedReader br=new BufferedReader(fr);String tmp=null;//缓存临时字符串while ((tmp=br.readLine())!=null) &#123;\tSystem.out.println(tmp);//输出每一行&#125; FileReader里放file，BufferedReader里放FR，读取每一行用br.readLine()，字符串存 Swing事件监听123456789101112131415161718192021222324252627class MyJDialog extends JDialog&#123;\tpublic MyJDialog(MyFrame frame) &#123;//参数是MyFrame super(frame,&quot;这是一个对话框&quot;,flase);//窗体、标题、是否阻塞 Container container=getContentPane();//获取主窗体 container.add(new JLabel(&quot;这是一个对话框&quot;));//在容器中添加标签 setBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\t&#125;&#125;public class MyFrame extends JFrame&#123;\tpublic MyFrame() &#123; Container container=getContentPane();//获取窗体主容器 bl.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; new MyJDialog(MyFrame.this).setVisible(true); &#125; &#125;); container.add(bl); setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MyFrame();\t&#125;&#125; 组件.addAcitonListener里边new Actionlistener 多线程消费生产栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class ms&#123;\tprivate Thread consume;\tprivate Thread product;\tprivate Random random=new Random();\tprivate int count=0;\tprivate Stack&lt;Integer&gt; st=new Stack&lt;Integer&gt;();\tpublic ms() &#123; product=new Thread(new Runnable() &#123; public void run() &#123; while(true) &#123; try &#123; if(count&lt;10) &#123; int s=random.nextInt(1000); st.push(s); count++; System.out.println(&quot;生产数据&quot;+s); Thread.sleep(1); &#125; else Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;); product.start(); consume=new Thread(new Runnable() &#123; public void run() &#123; while(true) &#123; try &#123; if(count&gt;0) &#123; int s=st.pop(); count--; System.out.println(&quot;消费数据：&quot;+s); Thread.sleep(1); &#125; else Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125;&#125;); consume.start();\t&#125;&#125;public class Lab14_4&#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new ms();\t&#125;&#125; 网络通信TCP 双向通信服务器端接收用BufferReader 12345678910111213141516171819202122class MySever&#123; public ServerSocket sever;//创建热线 public Socket socket;//客服 private PrintWriter writer;//输出流 void start()&#123; //绑定端口 server=new ServerSocket(8998); while(true)&#123; socket=server.accept();//等待接收，阻塞 //套接字客服传信息，用缓存输入流，里边是InputStreamReader，再里边是socket.getInputStream BufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream)); writer=new PrintWriter(socket.getOutputStream,true); while(true)&#123;//又一个 //字符串接数据 readerLine() String message=reader.readerLine(); wrter.println(&quot;收到，谢谢你！&quot;); &#125; reader.close();//先关流 socket.close(); &#125; &#125;&#125; socket.getInputStream就是文件存取的file，类比一下，而InputStreamReader就是FileReader 客户端发出用PrintWriter 12345678910111213141516171819202122232425262728class MyClient&#123; Socket socket;//套接字 private PrintWriter writer;//写数据，用PrintWriter而不是Buffer private BufferedReader reader;//输入流，读取 public MyClient()&#123; //一些修饰，如swing之类的 //传数据 String message=&quot;hello&quot;;//准备数据 writer.println(message);//传输即可 &#125; //连接另外写一个函数 public void connect()&#123; socket=new Socket(&quot;127.0.0.1&quot;,8998);//绑定ip和端口 writer=new PrintWriter(socket.getOutputStream(),true);//创建流，一层就够了 //接收信息 reader=new BufferedReader(new InputStreamReader(socket.getInpuString)); //准备线程 readThread=new Thread(new Runnable() &#123; @Override public void run() &#123; String message=reader.reaLine(); syso(message); &#125; &#125; &#125;&#125; connect里：绑定端口指定ip，准备流 构造里：writer.println传数据 UDP服务器端1234567891011121314151617181920212223242526272829303132333435//指定地址//实例化，绑定端口//加入组//构造里配置，run里边接收/发送//准备DataPackage，字符转字节数组，发送socket.send()class Notification extends Thread&#123; int port;//端口 InetAddress iAddress=null;//ip MulticastSocket socket=null;//MulticastSocket socket String weather=new String();//发送的信息 public Receive() &#123; //配置 //指定地址 try &#123; port=9898; iAddress=InetAddress.getByName(&quot;224.255.10.0&quot;);//getByName返回的InetAddress MulticastSocket socket=new MulticastSocket(port); socket.setTimeToLive(1); socket.joinGroup(iAddress); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; @Override public void run() &#123; // 发送信息 //准备 DatagramPacket packet=null; byte data[]=weather.getBytes();//字符转字节数组 packet=new DatagramPacket(data, data.length, iAddress, port); socket.send(packet); sleep(100); &#125;&#125; 构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组 run()里边：准备包，字符转字节数组，实例化DatagramPacket，socket.send(packet) 客户机端1234567891011121314151617181920212223242526272829303132class Receive implements Runnable&#123; int port;//端口 InetAddress group=null;//ip MulticastSocket socket=null;//MulticastSocket socket public Receive() &#123; //配置 //指定地址 try &#123; port=9898; group=InetAddress.getByName(&quot;224.255.10.0&quot;);//getByName返回的InetAddress MulticastSocket socket=new MulticastSocket(port); socket.joinGroup(group); &#125; catch (UnknownHostException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; &#125; @Override public void run() &#123; byte bty[]=new byte[1024]; DatagramPacket packet=new DatagramPacket(bty, bty.length, group, port); try &#123; socket.receive(packet); &#125; catch (IOException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; String message=new String(packet.getData(), 0, packet.getLength()); System.out.println(message); &#125;&#125; 构造里边：构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组 run()里边：准备字节数组，实例化DatagramPacket，socket.receive(packet)，然后new String(packet.getData(), packet.getLength())packet转字符 main函数当作类外的函数来看待 1、包内访问权限和protected有何不同？(p98) 包内访问权限介于private和protected之间 包外的派生类，可以在派生类内部调用基类的protected成员 包外的派生类，无法在派生类内部调用基类的包内访问成员 当两个包在同一个项目之中时，可以通过完整类目继承包外的基类访问 1234package Lab2;class newClass extends Lab1.myClass&#123;//包名.类名 &#125; 当两个包在不同的项目之中时，将基类项目导出为.jar，将该.jar文件复制到派生类所在的项目文件夹中，然后右键点击选择”add building path”添加到构建路径，然后代码与上面相同。 2、所有数组都能排序吗？ 错误。排序要有一定依据，没有指定依据无法排序。如类型为类的数组，可比较的属性不止一种（implements比较器)。 3、接口 接口的本质是标准，是设计者、实现者，调用者之间的桥梁 类内实现的可比较器Comparable，由被比较的类implements实现，重写compareTo函数 类外实现的可比较器Comparator，由另外一个类implements实现，重写compare函数 如果是一次性的考虑用匿名内部类来实现比较器。否则这个只用一次的有名字的类可能会对代码理解造成困扰。 基本输入输出范例代码1234Scanner sc=new Scanner(System.in);int n=sc.nextInt();String str1=sc.next();System.out.println(&quot;欢迎&quot;+n+&quot;号同学&quot;+str1); 第四章 流程控制循环语句foreach语句123for(元素类型x:遍历对象obj)&#123; 引用了x的java语句;&#125; 例子：遍历一维数组 1234567891011121314151617public class Repetition&#123; public static void main(String args[])&#123; int arr[]=&#123;5,13,96&#125;; System.out.println(&quot;一维数组中的元素分别为：&quot;); //x的类型与arr元素的类型相同 。for循环依次取出arr中的值并赋给x for(int x:arr)&#123; System.out.println(x); &#125; &#125;&#125;/*输出结果：一维数组中的元素分别为：51396*/ 第五章 数组数组的基本操作数组排序 Arrays.sort(arr); Arrays.parallelSort(arr);多线程排序，数据量大于一百万 复制数组copyof()方法语法：int a[]=Arrays.copyOf(arr,int newlength); newlength：复制后新数组的长度 ！注：不能直接a=b，数组名是指针常量（常指针） 第六章 类和对象面向对象概述封装 避免外部操作对内部数据的影响，提高程序的可维护性 提高工作效率，把无需调用者关心的内容隐藏，简化编程，知道面对外部的接口能调用即可 类对于人来说， public：学历、知识（别人抢不走的） protected：身体等 public：很多 protected同包其他类或子类(继承)可见，其他包的类或子类不可见；private都不可见，只有本类可见。 this 关键字this关键字用于表示本类当前的对象，只能在本类中使用。 123public void setName(String name)&#123;//定义一个setName()的方法 this.name=name;//将参数值赋予类中的成员变量&#125; 类的构造方法 Java类内的属性值不支持默认值，不能直接定义 int count=0 应使用默认构造函数初始化 12345678910public class eggCake&#123; int eggCount; public EggCake(int eggCount)&#123;//有参构造 this.eggCount=eggCount; &#125; public EggCake()&#123; //设置鸡蛋灌饼里蛋的个数为1 this(1); &#125;&#125; 静态12345678910public class Lab2_1&#123; public static void main(String[] args)&#123; new Lab2_1().show();//临时无名对象 //如果是show.()直接调用会报错，除非把show 声明为静态函数，说这是上面的方法，调用类内成员函数 &#125; void show()&#123; System.out.println(&quot;Hello!&quot;) &#125;&#125; 类内静态成员共用一份空间 如果函数 对象对象的销毁12345678910public class Lab2_1&#123; public static void main(String[] args)&#123; Lab2_1 l2=new Lab2_1(); //l2=null; 销毁对象 之后如果是l2.show();那么会报错NullPointerException &#125;//超过作用域 对象l2销毁 void show()&#123; System.out.println(&quot;Hello!&quot;) &#125;&#125; 第七章 继承、多态、抽象类与接口类的继承extends 关键字语法：CHild extends Parents super 关键字Object 类Object类是一切类的基类，隐含的继承 如果没声明，toString()一定是调用自Object类，输出是字符编号。 输出字符串自动会调用toString()函数，应当重写以达到需要的输出目的。 重写只能保持或扩大访问权限，如原本是Public不能改成Private。 123456789101112131415161718public class Student&#123; String name; int age; public Student(String name,int age)&#123; this.name=name; this.age=age; &#125; @Override//加这个帮助检查重写的函数名是否正确 public String toString()&#123; return &quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁。&quot;; &#125; public static void main(String[] args)&#123; Student s1=new Student(&quot;张三&quot;,16); System.out.println(s1);//就是System.out.println(s1.toString()); &#125;&#125; 对象的类型转换需要基类对象的任何地方，都可以用派生类对象替代 向上转型向下转型instanceof关键字判断对象类型方法的重载 函数的返回值类型不属于重载的依据 final 关键字最终的、终态 多态抽象类与接口抽象类 只要类中有一个抽象方法，此类就是抽象类 抽象类不能实例化，抽象类存在的目的就是为了被继承 c++中全是抽象方法就叫纯虚类 接口 只能声明，不能实现 第9章 异常处理异常与错误： 一个不好的问题发生了，如果对该问题提前有应对措施，就是异常处理； 如果没有任何准备，就是错误。 12345678910try&#123; //想要正确执行，但是不可控的语句段 //数据输入输出、网络连接、文件读写、数据库连接访问&#125;catch(Exception e)&#123; //可以有多个catch语句，捕获不同的异常 //必须是小范围异常(异常类)在前，Exception必须放在最后，Exception是所有异常的基类，范围最大&#125;finally&#123; //不管是否有捕获异常，都想要执行的代码&#125; 第10章 字符串String类，字符常量存储。 创建12char a[]=&#123;&#x27;g&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;d&#x27;&#125;;String s = new String(a);//相当于String s = new String(&quot;good&quot;) 截取 12char a[]=&#123;&#x27;g&#x27;,&#x27;o&#x27;,&#x27;o&#x27;,&#x27;d&#x27;&#125;;String s = new String(a,1,2);//相当于String s = new String(&quot;oo&quot;) 字符串连接int+&#39;&#39;把int转为String类型 获取字符串信息12System.out.println(s[0]);//是错误的System.out.println(s.charAt[0]);//才对 字符串的查找indexOf(String s) 区分大小写 123String str=&quot;We are students&quot;;int size=str.indexOf(&quot;a&quot;);int size2=str.toLowerCase().indexOf(&quot;a&quot;);//转为小写再查找，这个toLowerCase()或toUpperCase()是生成新的字符串对象，不会修改原来的字符串 字符串操作获取字符串substring(int beginIndex) 12String str=&quot;Hello World&quot;;String substr=str.substring(3); 字符串替换replace() replaceAll()支持正则表达式 判断相等equals()而不是用== 123456String s1=&quot;abc&quot;;String s2=&quot;abc&quot;;String s3=new String(&quot;abc&quot;);String s4=new String(&quot;abc&quot;);System.out.println(s1==s2);//结果是trueSystem.out.println(s3==s4);//结果是false 如果直接等号赋值，就是基本数据类型，用==可以判断；当用new，把变量当对象来看待，两个对象不可能相等，因此只能用equals()来判断相等。 equals在基本数据类型比较的是值，引用数据类型对象、数组、函数比较的是地址，如果要比较值需要重写equals。String是已经重写好equals了的 没重写之前两者都是比较地址，重写之后前者比较地址后者比较值 比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。 12345678@Overridepublic boolean equals(Object obj) &#123; if (obj instanceof Person) &#123; Person person = (Person) obj; return name.equalsIgnoreCase(person.getName().trim()); &#125; return false;&#125; 正则表达式12String regex1=&quot;[a-zA-Z_$]+[a-zA-Z_$]*&quot;;//String regex2=&quot;[1-9][0-9]&#123;4,10&#125;*&quot;;//qq号码规则 使用： 12345678910111213141516171819202122232425262728293031323334353637package lesson5;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegExp &#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 String contentString=&quot;1998,1239,12,144&quot;; //1.\\\\d表示一个任意的数字 String regString=&quot;\\\\d\\\\d\\\\d\\\\d&quot;;//找四个连续的数字,分组的话是(//d)(//d) //2.创建模式对象[即正则表达式对象] Pattern pattern=Pattern.compile(regString); //3.创建匹配器 //说明：创建匹配器matcher，按照正则表达式的规则去匹配content字符串 Matcher matcher=pattern.matcher(contentString); //4.开始匹配 /* * match.find()完成的任务 (考虑分组，如(//d//d)(//d//d)) * 1. 根据给定的规则，定位满足规则的字符串（如1999,分组即(19)(99)) * 2. 找到时，将字符串的开始的索引记录到matcher对象的属性 int[] groups; * 2.1groups[0]=0，把该子字符串的结束的索引+1的值记录到group[1]=35,+1是因为取字符串左闭右开 * 2.2 记录第一组()匹配的字符串的区间group[2]=0,group[3]=2 * 2.3 记录第二组()匹配的字符串的区间group[4]=2,group[5]=4 * 2.4 如果有更多分组以此类推 * 3. 同时记录oldLast的值为子字符串的结束的索引+1的值即5，那下一次执行find时，从5开始匹配 */ while(matcher.find()) &#123; System.out.println(&quot;找到：&quot;+matcher.group(0));//group(0)记录找到的字符串开头,同时可以找到结尾 System.out.println(&quot;第一组()的值： &quot;+matcher.group(1));//19 System.out.println(&quot;第二组()的值： &quot;+matcher.group(2));//99 &#125;\t&#125;&#125; 元字符检索特殊字符要用转义符号\\\\，在java的正则表达式中两个\\\\代表其他语言一个\\ 字符匹配符 符号 含义 实例 说明 匹配输入 [ ] 匹配任意一个 [efgh] e,f,g,h任意一个 e,f,g,h [^ ] 排除 [^abc] 除了abc之外的任意一个字符包括数字和特殊符号 d,f,p . 匹配除 以外的任何字符 a..b a开头b结尾中间任意两个字符 aaab,a#*b \\\\d 匹配单个数字字符相当于{0-9} \\\\d&#123;3&#125;&#123;\\\\d&#125;? 包含3个或4个数字的字符串 123,9876 \\\\D 匹配单个非数字字符，相当于[^0-9] \\\\D&#123;\\\\d&#125;* 以单个非数字字符开头后接任意个数字的字符串 a,A342 \\\\w 匹配单个数字、大小英文写字母，下划线，相当于[0-9a-zA-Z_] \\\\d&#123;3&#125;\\\\w&#123;4&#125; 以3个数字字符开头的任意长度为7的数字字母字符串 234abcd、1234Pe \\\\W 匹配单个非数字、大小写字母和下划线字符，相当于[^0-9a-zA-Z_] \\\\W+\\\\d&#123;2&#125; 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 \\\\s 匹配任何空白字符(空格，制表符等) \\\\S 匹配任何非空白字符 \\\\. 匹配除 之外的所有字符 区分大小写 默认区分大小写，如模式串写&quot;abc&quot;匹配出来abc而(?i)abc表示不区分大小写,a(?i)bc是bc不区分大小写 常用类库Integer类能在int类型和String类型之间互相转换。 123int num = Integer.parseInt(&quot;456&quot;);//返回包含在由str指定的字符串中的数字的等价整数值Integer iNum=Integer.valueOf(&quot;456&quot;);//返回保存指定的String值的Integer对象iNum.equal(num);//比较，返回值是true Double类是Number类的子类，都是对浮点数进行操作。Double类在对象中包装一个基本类型为double的值，每个Double类的对象都包含一个double类型的字段。可将String和double相互转换。 123Double dNum=Double.valueOf(&quot;3.14&quot;);Double.isNaN(dNum.doubleValue());//是否返回非数字(NaN)值dNum.intValue();//转为int类型 Boolean类当 String 的参数值在不区分大小写的时候等于 “true” ，则 Boolean.valueOf(String) 返回值为 true； 1234Boolean b1=Boolean.valueOf(&quot;true&quot;);Boolean b2=Boolean.valueOf(&quot;ok&quot;);b1.booleanValue();//将Boolean对象的值以对应的boolean值返回，值为trueb2.booleanValue();//值为false Character类字符大小转小写 1234Character mychar1=Character.valueOf(&#x27;A&#x27;);//返回保存指定char值的Character对象Character.isUpperCase(mychar1);//判断是否为大写字母Character.toUpperCase(mychar1);//转为大写Character.toLowerCase(mychar1);//转小写，不改变原来字符串 第12章 集合类graph LR A[集合类]-->集合类概述 A-->Collection接口 A-->List集合 A-->Set集合 A-->Map集合 集合类概述集合与数组 容器 数组 集合 长度 长度固定 长度可变 存放的东西 存放基本数据类型 存放对象的引用 graph LR HashMap-->A[Map] TreeMap-->A HashSet-->B[Set] TreeSet-->B ArrayList-->C[List] LinkedList-->C C-->D[Collection] B-->D A-->Java.lang.Object D-->Java.lang.Object Collection 接口1Collection&lt;类名&gt; list=new ArrayList&lt;&gt;();//尖括号只能呢是类，比如不能放int要放integer 方法： add(E e) remove(Object o) isEmpty() iterator() size() 返回int型 遍历集合通过迭代器(Iterator)来实现，只读且向前。Collection接口中的iterator()方法可返回在此Collection进行迭代的迭代器。 可以用foreach，可读可写，但是不能break，除非抛出异常。遍历修改迭代器(ListIterator) 12345678910111213import java.util.*;public class Muster&#123; public static void main(String args[])&#123; Collection&lt;String&gt; list=new ArrayList(); list.add(&quot;《Java从入门到精通》&quot;); list.add(&quot;《java实战》&quot;); lteratior&lt;String&gt; it=list.lterator(); while(it.hasNext())&#123; String str=(String)it.next();//获取集合中的元素 System.out.println(str); &#125; &#125;&#125; List集合 List集合中的元素允许重复，各元素的顺序就是对象插入的顺序。类似Java数组，用户通过使用索引(元素在集合中的位置)来访问集合 List接口继承Collection接口，包含其所有方法。还定义两个重要的方法： get(int index)：获取指定索引位置的元素 set(int index,Object obj)：将集合中指定索引位置index的对象修改为指定的对象obj List接口的实现类属于有序集合，不是自动排序的意思 ArrayList类 可变的数组，允许重复 允许null LinkedList类链表结构保存对象 类 ArrayList LinkedList 优点 根据索引快速访问 便于向集合插入和删除对象 缺点 插入或删除对象速度较慢 随机访问效率较低 动态数组，索引存取 链表，存取有序，不是存到链表头就是链表尾 实例化 12List&lt;E&gt; list=new ArrayList&lt;&gt;();List&lt;E&gt; list2=new LinkedList&lt;&gt;(); 开头是List，后面别忘了&lt;&gt; Set集合Set集合传入的Collection对象不能有重复值 Set接口实现的类： HashSet类，由哈希表(HashMap实例)支持。允许null TreeSet类，还实现了Java.util.SortedSet接口 类 HashSet TreeSet 区别 不保证Set集合的迭代顺序和顺序的恒久不变 按自然顺序递增，也可按比较器实现排序 1Set&lt;类名&gt; set=new TreeSet&lt;&gt;(); 必须可比较，传入的对象的类必须是包装类(默认字典顺序)或者实现comparable接口的类 HashSet哈希存储，计算哈希值散列导不同位置，存取位置不能保证，效率高 TreeSet树存储，按照树结构对元素进行比较，放到合适位置，这也就说明，元素会按照树的性质去存储，那么也就无法保证存和取元素的顺序。但是元素可以在存储的时候根据自身的大小排好序，从而可以很轻易的找到最大值，最小值，以及给定一个元素，找到比他大和比他小元素等操作。 问：在定义对象类型时，应该定义为基类或接口的类型，还是派生类的类型？ 创建的时候类型不确定，先定义为基类；或如果定义为接口给别人调用就声明为基类。要专门调用派生类具有的功能直接声明为派生类。 但是定义为基类无法调用子类特有的成员，如subSet()是TresSet特有的，定义为基类时无法调用，除非强制转型为子类。 12Set&lt;Integer&gt; set=new TreeSet&lt;&gt;();TreeSet set2=((TreeSet&lt;Interger&gt;)set.)subSet(3,10); TreeSet增加的方法: first() 返回此Set集合第一个(最低)元素 last() 返回当前最后一个(最高)元素 comparator() 返回进行排序的比较器，若自然顺序则null headSet(E toElement) 返回一个新Set集合是toElement对象(不包含)之前的所有对象 subSet(E fromElement,E toElement) 返回Set集合是fromElement对象与toElement之间的所有对象，含头不含尾 tailSet(E fromElement) 返回包含fromElement之后所有对象 含头不含尾 Map集合没有继承Collection接口，每个对象是键值(&lt;key,value&gt;)的形式。 每个key只能映射一个value；类要可比较；iterator()的next()输出的仅是key值 Map接口除集合方法的特殊方法 put(K key,V value) containsKey(Object key) 若包含指定key的映射关系返回true containsValue(Object value) 若将一个或多个key映射到指定值，返回true get(Object key) 返回对象对应的值，否则null values() 返回该集合所有值对象形成的Collection对象，用iterator()遍历输出 类 HashMap TreeMap 特点1 允许nul值和null键，键唯一 不允许值对象null(要排序的原因) 映射 通过哈希表 具有一定顺序 优缺 不保证顺序不变；快速访问 添加、删除、定位性能差；顺序排序 运用的时候使用HashMap类实现Map集合，当需要顺序输出时再创建一个完成相同映射关系的TreeMap类实例 12Map&lt;String,String&gt; map=new HashMap();map.put(&quot;1001&quot;,&quot;java从入门到精通&quot;); 如果key传入的是像Integer，String这样本身有序的，就会按字典序排列，而不是按哈希码。 原理：add()时用hashcode找哈希地址，用equal()看是否有存东西。如果是false就先并排放；若是true说明有了不用重复存。取值的时候找哈希地址，如果存在多个用equal()取具体的那一个。以上哈希码相同的情况为哈希冲突，同一个哈希地址可以存放多个不同对象。 优点：不用全部遍历，找到哈希地址再判断哪个是需要的取出即可。 第13章 枚举类型与泛型将“填空题”变为“选择题” 12345678910111213141516171819202122232425262728//声明为int/String类型方便switch case用//接口interface SeasonInterface&#123; int Spring=1,SUMMER=2,AUTUMN=3,WINTER=4; //开头隐含的public static final&#125;//枚举enum SeasonEnum&#123; SPRING,SUMMER,AUTUMN,WINTER&#125;public class SeasonDemo&#123; public static void printSeason1(int season)&#123; switch(season)&#123; case SeasonInterface.SPRING: System.out.println(&quot;这是春季&quot;); break; case SeasonInterface.SUMMER: System.out.println(&quot;这是夏季&quot;); break; case SeasonInterface.AUTUMN: System.out.println(&quot;这是秋季&quot;); break; case SeasonInterface.WINTER: System.out.println(&quot;这是冬季&quot;); break; &#125; &#125;&#125; 问：接口和枚举如何选择？ 接口一般是给别人来实现，功能可以更强大，如果不需要实现直接用枚举就行。 枚举优点：简单，运行效率高，类型安全 枚举类型中的构造方法在枚举类型中，可以添加构造方法，但是规定这个构造方法必须被private修饰符所修饰。用于提示枚举值更加详细的含义、 泛型向上向下转型123父类 a=new 子类();//向上转型子类 b=(子类)a;//向下转型子类 b=new 父类();//！这是不可行的！ 例子： 1234567891011121314151617public class Test&#123; private Object b; public Object getB()&#123; return b; &#125; public void setB(Object b)&#123; this.b=b; &#125; public static void main(String[] args)&#123; Test t=new Test(); t.setB(Boolean.valueOf(true));//向上转型 System.out.println(t.getB()); t.setB(Float.valueOf(&quot;12.3&quot;)); Float f=(Float)t.getB();//向下转型 System.out.println(f); &#125;&#125; 定义泛型类Object类为最上层的类，为了通用通常使传入的值与返回的值都以Object类型为主(Object太大了，不能统统用Object类)。当需要使用这些实例时，必须正确地将该实例转换为原来的类型，否则运行时将会发生ClassCaseException为了预防，Java提供泛型机制： 1类型&lt;T&gt; 高级用法泛型限制对泛型类的实例类型做了限制 12345678public class LimitClass&lt;T extends List&gt;&#123; public static void main(Stirng[] args)&#123; //可以实例化已经实现List接口的类 LimitClass&lt;ArrayList&gt; l1=new LimitClass&lt;ArrayList&gt;(); //这句是错误的，因为HashMap类没有实现List()接口 LimitClass&lt;HashMap&gt; l3=new LimitClass&lt;HashMap&gt;(); &#125;&#125; &lt;T extends Serializable&gt; 序列化，泛型必须是Serializable的子类，可传Integer或String 泛型通配符123A&lt;?&gt; a;A&lt;? extends anyClass&gt; a;A&lt;?&gt; a= new List&lt;&gt;;//这样是不可以的，实例化需要要具体的类型 第14章 lambda表达式与流处理将lambda表达式用来简化表示匿名函数，也就是没有名字的函数，提高开发效率。 例子： 1234567891011121314//函数式接口interface A&#123; void action();&#125;//使用匿名类创建对象A a=new A()&#123; public void action()&#123; System.out.println(&quot;创建了接口的匿名对象&quot;); &#125;&#125;;//使用lambda表达式创建A a=()-&gt;&#123; System.out.println(&quot;创建了接口的匿名对象&quot;);&#125;; lamba表达式： 1234()-&gt;结果表达式参数-&gt;结果表达式//多形参(参数1,参数2,...,参数n)-&gt;结果表达式 例子： 1234567891011121314151617//函数式接口interface AdditionInterface&#123; int add(int a,int b);&#125;public class ParamterDemo&#123; public static void main(String[] args)&#123; //lamba 表达式实现加法接口，返回参数相加的值(自动加return) AdditionInterface np=(x,y)-&gt;x+y; int result=np.add(15,26);//调用接口方法 System.out.println(&quot;相加结果：&quot;+result);//输出相加结果 //而同一个接口可以实现不同的方法,关键在于接口的实现方式 AdditionInterface np2=(a,b)-&gt;a*b; result=np2.add(a,b); System.out.println(&quot;相乘结果：&quot;+result);//输出相乘结果 &#125;&#125; 注意： lamba表达式不能修改局部变量的值，只能使用 方法的引用引用静态方法(复制一个已有的函数实现接口，甚至可以不需要这个已有函数内部是如何实现的) 类名::静态方法名 1234interface StaticMethodInterface&#123;\tint method(int a,int b);&#125;public class StaticM Function接口Function&lt;T,R&gt;,T:被操作的类型，可以理解为方法的参数类型；R：操作结果类型，方法的返回类型。 Iterator&lt;T&gt;只读！ ListIterator&lt;T&gt;才能修改list的元素 流处理Stream流只能被消费一次，之后失效 数据过滤12345678910111213//数据转化为流public class FilerDemo&#123; public static void main(String[] args)&#123; List&lt;Employee&gt; list=Employee.getEmpList(); Stream&lt;Employee&gt; stream=list.stream(); stream=stream.filter(people-&gt;people.getAge()&gt;30);//过滤出符合条件的数据 List&lt;Employee&gt; result=stream.collect(Collectors.toList());//将流对象重新封装成一个List集合 List&lt;Employee&gt; result2=list.stream().filter(p-&gt;p.getDept().equals(&quot;开发部&quot;)).peek(p-&gt;p.setSalary(p.getSalary()*10)).collect(Collect.toList());//过滤得到符合的让其工资翻十倍 for(Employee emp:result)&#123; System.out.println(emp);//输出员工信息 &#125; &#125;&#125; filter(predicate类)用lamba表达式不需要管类型，直接放进去 peek(consumer类型)和map()一个里面不用返回值，一个需要。 collect() 收集重新归类。 第15章 I&#x2F;O(输入与输出)graph LR A[I/O]-->输入/输出流 A-->File类 A-->文件输入/输出流 A-->带缓存的输入/输出流 A-->数据输入/输出流 输入&#x2F;输出流程序从指向源的输入流中读取源中的数据。 各种数据源通过输入流传递到目的地 源通过数据流传递到各种数据输出目标 InputStream类用来处理字节，不适合处理字符。而Java字符是Unicode编码，双字节，用Reader类处理。但注意Reader类不是InputStream的替换者，只是在处理字符串时简化了编程。 read(byte[] b);返回值是读取到的字节数 File类File类是java.io包中唯一代表磁盘文件本身的类。因为是代表磁盘，操作要用try catch语句 三种构造方式： 123File(String pathname)File(String parent,String child)File(File f,String child) 12345678910111213141516171819import java.io.File;public class FileTest&#123; public static void main(String[] args)&#123; File file=new File(&quot;word.txt&quot;);//相对路径，是在项目目录下创建而不是在所在包类,此时是在内存中创建对象 //File file2=new File(&quot;D:\\\\1.txt&quot;);//绝对路径 if(file.exists())&#123;//如果存在 file.delete(); System.out.println(&quot;文件已删除&quot;); &#125;else&#123; try&#123; file.createNewFile();//这一步才真正在磁盘中创建文件 System.out.println(&quot;文件已创建&quot;); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; File类创建的是一个文件对象！说是在磁盘创建是错误的；除了在内存中的操作，其他都是不保证成功的， getName() 文件名称 length() 文件的长度(以字节为单位) isHidden() 判断是否隐藏文件，返回布尔值 文件输入&#x2F;输出流FileInputStream与FileOutputStream类 是字节流，读取写入参数得是字节byte，读取汉字容易乱码 创建一个FileOutputStream对象时，可以指定不存在的文件，但是不能是已被其他程序打开的文件 文件输入流FileInputStream类实现！读取！，用read(byte[] b)，从磁盘输入到目的地 文件输出流FileOutputStream类实现！写入！，用write(byte[] b)，从程序输出到磁盘 案例： 1234567891011121314151617181920212223public class FileStreamDemo&#123; public static void main(String[] args)&#123; File file=new File(&quot;D:\\\\word.txt&quot;);//创建文件对象 //写入 try&#123; FileOutputStream out=new FileOutputStream(File);//创建输出对象 byte buy[]=&quot;我有一只小毛驴&quot;.getBytes();//写入内容的字节数组，字符串转转字节 out.write(buy);//将字节写入到文件 out.close();//关闭流 &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; try&#123; FileInputStream in=new FileInputStream(file);//创建输入流 byte byt[]=new byte[1024];//缓存字节流 int len=in.read(byt[]);//字节转字符串要用 System.out.println(&quot;文件的信息是：&quot;+new String(byt,0,len));//字节转为字符串输出 in.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; FileReader和FileWriter 是字符流，读取写入参数字符串即可 123456789101112File file=new File(&quot;D:\\\\word.txt&quot;);//创建文件对象//写入FileWriter fw=new FileWriter(file);String word=&quot;我有一只小毛驴&quot;;fw.write(word);fw.close();//读取FileReader fr=new FileReade(file);char ch[]=new char[1024];//缓存字符数组int len=fr.read(ch);System.out.println(&quot;文件的信息是：&quot;+new String(ch,0,len));//字节转为字符串输出fr.close(); 带缓存的输入&#x2F;输出流缓存是I&#x2F;O的一种性能优化。缓存流增加了内存缓冲区，使得在流上执行skip()、mark()和reset()方法都成为可能。 BufferedReader与BufferedWriter类分别继承Reader类和Writer类，以行为单位进行输入&#x2F;输出 读取文件过程： 文件–&gt;InputStream–&gt;InputStreamReader–&gt;BufferedReader–&gt;字符数据 BufferReader类常用的方法： read() 读取单个字符 readLine() 读取一个文本行，返回字符串型。若无返回null BufferWriter类的方法都返回void: write(String s, int off, int len) 写入字符串的一部分 flush() 刷新流的缓存 newLine() 写入一个行分隔符 在使用BufferedWriter类的Writer()方法时，数据首先进入缓存区，没有立刻被写入输出流。如果想立即将缓存区中的数据写入输出流，一定要调用flush() 1BufferedReader br = new BufferedReader(new FileReader(file));//缓存输入流 实例基本文件操作1234567891011121314151617181920212223242526272829303132333435public class test2 &#123;\tpublic static void main(String[] args) &#123; String content[]= &#123;&quot;好久不见&quot;,&quot;最近好吗&quot;,&quot;常联系&quot;&#125;; File file=new File(&quot;word.txt&quot;); try &#123; BufferedWriter bWriter=new BufferedWriter(new FileWriter(file));//文件字符输出流转缓冲输出流 for (int k = 0; k &lt; content.length; k++) &#123; bWriter.write(content[k]);//写入字符串 bWriter.newLine();//写入一个换行符 &#125; bWriter.close();//关闭缓冲输出流 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; try &#123; BufferedReader bReader=new BufferedReader(new FileReader(file));//文件字符输入流转缓冲输入流 String tmpString=null;//作为缓冲的临时字符串 int i=1;//行数 //从文件重读取一行，如果读出内容不为null，则进入循环 while ((tmpString=bReader.readLine())!=null) &#123; System.out.println(&quot;第&quot;+i+&quot;行：&quot;+tmpString); i++; &#125; bReader.close(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125;\t&#125;&#125;输出：第1行：好久不见第2行：最近好吗第3行：常联系 获取网页源代码12345678910111213141516171819202122232425262728293031import java.io.*;import java.net.*;public class GetPageCode&#123;\tpublic static void main(String[] args) throws IOException &#123; // TODO 自动生成的方法存根 URL page = null; try &#123; page = new URL(&quot;https://www.qq.com&quot;); &#125; catch (MalformedURLException e) &#123; // TODO 自动生成的 catch 块 e.printStackTrace(); &#125; HttpURLConnection conn = (HttpURLConnection) page.openConnection(); InputStreamReader in = new InputStreamReader(conn.getInputStream()); BufferedReader buff = new BufferedReader(in); String tmp=null; int i=1; //从流中读出一行，如果内容不为null，则进入循环 while ((tmp=buff.readLine())!=null) &#123; System.out.println(tmp); i++; &#125; &#125;&#125; 第16章 反射与注释实现访问、检测和修改描述Java对象本身信息的功能。 getCLass()是Object类定义的，任何类都可以用，获取类信息 12345678910Class newC=hashSet.getClass();//获取hashSet的描述信息，假设hashSet是一本书，那newC是书的目录，作者等等基本信息但不包括内容//查构造方法Constructor[] constructors=mewC.getDeclaredConstructor;for(Constructor constructor:constructors)&#123; System.out.println(constructor);//找到构造函数foreach遍历显示&#125;declarednewC=newC.getDeclaredConstructors(); 1234Field[] declaredFields=demClass.getDeclaredFields(); for(Field field:declaredFields) &#123; System.out.println(field); &#125; 1234567891011121314151617181920212223242526272829//查成员方法 用户输入参数Method[] declaredMethods=demClass.getDeclaredMethods(); for(Method method:declaredMethods) &#123; System.out.println(method); &#125; Scanner scanner=new Scanner(System.in); String key=scanner.next(); for(Method method:declaredMethods) &#123; if(key.equals(&quot;size&quot;)&amp;&amp;key.equals(method.getName())) &#123; try &#123; System.out.println(method.invoke(hashSet)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; if (key.equals(&quot;add&quot;) &amp;&amp; key.equals(method.getName())) &#123;//作判断才知道用户要做那个 String addString = scanner.next(); try &#123; System.out.println(method.invoke(hashSet, addString)); for (String hash : hashSet) &#123; System.out.print(hash+&quot; &quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; scanner.close(); 第18章 Swing程序设计Swing概述graph LR javax.swing.JLabel-->D[javax.swing.JComponent] Javax.swing.JPanel-->D javax.swing.JDialog-->A[java.awt.Dialog] javax.swing.JFrame-->B[java.awt.Frame] A-->C[java.awt.Window] B-->C D-->E[java.awt.Container] C-->E E-->F[java.awt.Component] F-->java.lang.Object 由Swing包的层次结构和继承关系可知 Dialog和Frame都在awt.Window里 而JDialog在awt.Dialog里，JFrame在awt.Frame里 JPanel和JLabel在swing.JComponent里 它们都在awt.Container里，最顶层是java.lang.Object Swing常用窗体 public JFrame(String title); 默认不可见窗体，可以标题 将窗体转为容器 12JFrame jf=new JFrame(&quot;登录&quot;);Container container=jf.getContentPane(); container.add();container.remove() 添加；删除容器中的组件 container 是主容器，组件都在这个范围内 JLabel 内容可以用html标签 setBounds(距离左边x,距离上边y,宽度,高度) 设置窗体左上角的坐标和大小，对于JFrame是设置距离屏幕的位置，对于container里的就是相对灰色的container位置 setLocation(int x,int y); setSize(int width, int height); 设置窗体宽高 setVisibale(boolean b); 是否可见 setDefaultCloseOperation(int operation); 设置关闭方式 默认是DISPOSE_ON_CLOSE 窗体关闭释放窗体资源，窗体消失但程序不停止 EXIT_ON_CLOSE 窗体关闭，释放窗体资源并关闭程序 Jdialog 对话框 public JDialog(Frame f, Sring title,boolean mode)设置model为true时，打开对话框时，阻塞主窗体不可操作。 JButton单击事件 1234567891011121314151617181920212223242526272829303132333435class MyJDialog extends JDialog&#123;\tpublic MyJDialog(MyFrame frame) &#123; super(frame,&quot;第一个JDialog窗体&quot;,true);//调用父类构造方法，参数：父类窗体,标题，是否阻塞父窗体 Container container=getContentPane();//获取主窗体 container.add(new JLabel(&quot;这是一个对话框&quot;));//在容器中添加标签 setBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\t&#125;&#125;public class MyFrame extends JFrame&#123;\tpublic MyFrame() &#123; Container container=getContentPane();//获取窗体主容器 container.setLayout(null);//窗体使用绝对布局 JButton bl=new JButton(&quot;弹出对话框&quot;); bl.setBounds(10, 10, 100, 21);//按钮坐标大小 bl.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 MyJDialog dialog=new MyJDialog(MyFrame.this);//创建对话框，传参是当前窗体 dialog.setVisible(true); &#125; &#125;); container.add(bl); setSize(200, 200); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//关闭窗体停止程序 setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new MyFrame();\t&#125;&#125; 常用布局管理器null 绝对布局 硬性指定位置和大小，组件位置通过绝对坐标的方式来指定 首先取消布局管理器：Container.setLayout(null) 设置每个组件在容器的位置和大小：Component.setBounds(int x,int y,int width,int height) 12345678910111213141516171819202122public class AbsolutePosition extends JFrame&#123;\tpublic AbsolutePosition() &#123; setTitle(&quot;绝对布局&quot;); setLayout(null);//取消布局管理器 setBounds(0,0,300,150); Container container=getContentPane(); JButton b1=new JButton(&quot;按钮1&quot;); JButton b2=new JButton(&quot;按钮2&quot;); b1.setBounds(10,30,80,30);//设置按钮位置和大小 b2.setBounds(60,70,100,20); container.add(b1); container.add(b2); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new AbsolutePosition();\t&#125;&#125; FlowLayout 流布局管理器 流布局组件从左到右摆放。当组件占据了当前行的所有空间时，溢出的到下一行 默认情况，行组件排列方式为居中对齐，可以通过设置更改 FlowLayout类具有以下常用的构造方法 public FlowLayout() public FlowLayout(int alignment) public FlowLayout(int alignment,int horizGap,int vertGap) alignment参数表示排列方式，可以设置为Flowlayout.LEFT、FlowLayout.CENTER或FlowLayout.RIGHT horizGap,vertGap这两个参数以像素为单位指定组件之间的水平间隔和垂直间隔 123456789101112131415161718public class FlowLayoutPosition extends JFrame&#123;\tpublic FlowLayoutPosition() &#123; setTitle(&quot;流布局管理器&quot;); Container container=getContentPane(); setLayout(new FlowLayout(FlowLayout.RIGHT,10,10)); for (int i = 0; i &lt; 10; i++) &#123; container.add(new Button(&quot;button&quot;+i)); &#125; setSize(300,200); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setVisible(true);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new FlowLayoutPosition();\t&#125;&#125; BorderLayout 边界布局管理器 Swing创建窗体默认是边界布局管理器 边界布局管理器把容器分为东、南、西、北、中5个区域 当组件添加时，需要使用BorderLayout类中的成员变量指定其区域 BorderLayout.NORTH 北 BorderLayout.SOUTH 南 BorderLayout.EAST 东 BorderLayout.WEST 西 BorderLayout.CENTER 中 ———–NORTH———– WEST—CENTER—-EAST ———–SOUTH———– add(组件，成员变量) 12345678910111213141516171819202122232425public class BorderLayoutPosition extends JFrame&#123;\tpublic BorderLayoutPosition() &#123; setTitle(&quot;边界布局管理器&quot;); Container container=getContentPane(); setLayout(new BorderLayout());//使用边界布局管理器 JButton centerButton=new JButton(&quot;中&quot;); JButton northButton=new JButton(&quot;北&quot;); JButton southButton=new JButton(&quot;南&quot;); JButton westButton=new JButton(&quot;西&quot;); JButton eastButton=new JButton(&quot;东&quot;); container.add(centerButton,BorderLayout.CENTER); container.add(eastButton,BorderLayout.EAST); container.add(westButton,BorderLayout.WEST); container.add(southButton,BorderLayout.SOUTH); container.add(northButton,BorderLayout.NORTH); setSize(350,200); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new BorderLayoutPosition();\t&#125;&#125; GridLayout 网格布局管理器 划分为网格，组件可以按行、列进行排序 网格个数由行数和列数决定，每个网格大小相同 组件从网格左上角开始，从左到右从上到下被添加到网格中 每个组件都会填满整个网格 改变窗体大小，组件大小也会随之改变 构造方法 public GridLayout(int rows, int columns) public GridLayout(int rows, int columns, int horizGap, int vertGap) rows和columns只有一个可以是0，被用于一行或一列排列任意多个组件 1234567891011121314151617public class GridLayoutPosition extends JFrame&#123;\tpublic GridLayoutPosition() &#123; Container container=getContentPane(); setLayout(new GridLayout(7,3,5,5));//7行3列网格，组件水平间距5像素，垂直间距5像素 for (int i = 0; i &lt; 20; i++) &#123; container.add(new JButton(&quot;button&quot;+i)); &#125; setSize(300,300); setTitle(&quot;网格布局管理器&quot;); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根\t&#125;&#125; 常用面板JPanel 面板必须在窗体容器中使用，无法脱离窗体显示 1Jpanel p1=new JPanel(new GridLayout(1,4,10,10));//初始化面板，使用1行4列的网格布局，组件水平间隔10像素，垂直间隔10像素 JScrollPane 滚动面板1234Container c=getContentPane();JTextArea ta=new JTextArea(20,50);//创建文本区域组件，文本域默认大小为20行、50列JScrollPane sp=new JScrollPane(ta);//创建滚动面板，并将其文本域放到滚动面板中c.add(sp); 图片路径123Icon con=new ImageIcon(&quot;src/注意.png&quot;);//使用字符串作为路径，是以项目文件夹为根目录URL url=MyImageIcon.class.getResourse(&quot;注意.png&quot;);//getResourse是以类所在文件夹为根目录Icon icon=new ImageIcon(url);//创建Icon对象 当用new File()时相对路径是相对于项目的路径，例如JavaSE下面有src，src下面有包，包里有类，当在类中用new File()相对路径访问src下的文件时应该是 1File file=new File(&quot;src/[文件名]&quot;); 事件监听器ActionEvent动作事件动作事件监听器 相关定义 实现方式 事件名 ActionEvent 事件源 JButton、JList、JTextField等组件 监听接口 ActionListener 添加监听方法 addActionListener() 删除监听方法 removeActionListener() 123456789JButton b1=new JButton(&quot;按钮&quot;);bl.addActionListener(new ActionListener() &#123; @Override\tpublic void actionPerformed(ActionEvent e) &#123;\t// 要触发的动作 &#125;&#125;); 或者用类调用接口的方法： 1234567891011public class SimpleEvent extends JFrame&#123; private JButton jb=new JButton(&quot;我是按钮&quot;); public SimpleEvent()&#123; jb.addActionListener(new jbAction()); &#125; class jbAction implements ActionListener&#123; public void actionPerformed(ActionEvent arg0)&#123; jb.setText(&quot;我被点击了&quot;); &#125; &#125;&#125; jbAction实现ActionListner接口，同时在该内部类中实现actionPerform()方法，这个方法中定义当用户单击该按钮后实现怎样的功能 KeyEvent键盘事件KeyEvent类负责捕获键盘事件，可以通过为组件添加实现了KeyListener接口的监听器类来处理相应的键盘事件。 KeyListerner接口3个抽象方法 12345678public interface KeyListener extends EventListener&#123; //发生击键事件时触发 public void keyTyped(KeyEvent e); //按键被按下时被触发 public void ketPressed(KeyEvent e); //案件被释放时被触发 public void keyReleased(KeyEvent e);&#125; KeyEvent类中的常用方法 getKeyChar() 获得与此事件中的键相关联的字符 123456textField=new JTextField();textField.addKeyListener(new KeyAdapter()&#123;//文本框添加键盘事件的监听 public void keyPressed(KeyEvent e)&#123;//按键按下时触发 //实现的功能 &#125;&#125;) MouseEvent鼠标事件所有组件都能发生鼠标事件。添加MouseListener接口监听，有5个抽象对象 1234567public interface MouseListener extends EventListener&#123; public void mouseEntered(MouseEvent e);//光标移入组件时触发 public void mousePressed(MouseEvent e);//鼠标按键按下 public void mouseReleased(MouseEvent e);//鼠标按键释放时被触发 public void mouseClicked(MouseEvent e);//发生单击事件被触发 public void mouseExited(MouseEvent e);//光标移出组件时被触发&#125; 注意单击事件如果按键在移除组件之后才被释放，则不会触发单机事件 MouseEvent类中的常用方法 getSource() 获得触发此次事件的组件对象，返回值为Object类型 getButton() 获得按键的int值 getClickCount() 获得单击按钮的次数 按键的int值： 静态常量 常量值 代表的键 BUTTON1 1 鼠标左键 BUTTON2 2 鼠标滚轮 BUTTON3 3 鼠标右键 123456789101112131415161718192021private void mouseOper(MouseEvent e)&#123; int i=e.getButton();//获得按键的int值 if(i==MouseEvent.BUTTON1) System.out.println(&quot;按下的是鼠标左键&quot;); else if(i==MouseEvent.BUTTON2) System.out.println(&quot;按下的是鼠标滚轮&quot;); else if(i==MouseEvent.BUTTON3) System.out.println(&quot;按下的是鼠标右键&quot;);&#125;public MouseEvent_Example()&#123; final JLable label=new JLable(); label.addMouseListener(new MouseListener()&#123; public void mouseEntered(MouseEvent e)&#123; System.out.println(&quot;光标移入组件&quot;); &#125; public void mousePressed(MouseEvent e)&#123; System.out.print(&quot;鼠标按键被按下&quot;); mouseOper(e); &#125; &#125;)&#125; 第二十章 多线程多种活动同时进行的思想称为并发，而将完成的每一件事情称为线程 CPU在一个时间片中执行某个进程，然后下一个时间片又跳至另一个进程中去执行。由于CPU转换较快，好像同时执行一样 创建线程 Thread类是java.lang包中的一个类 完成线程真正功能的代码放在类的run()方法里 start()方法会启动线程，线程自动执行run()方法里的代码。 如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()前，Thread对象只是实例，不是真正的线程 主方法线程由Java虚拟机负责启动 如果start()方法调用一个已经启动的线程，抛出IllegalThreadStateException异常 实现Runnable()接口当要继承其他非Thread类，通过Runnable接口来实现多线程 1234567891011121314151617public class Threadtest extends Object implements Runnable&#123; @Override\tpublic void run() &#123; // TODO 自动生成的方法存根 String string=Thread.currentThread().getName(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(string+&quot;第&quot;+i+&quot;次操作&quot;); &#125;\t&#125;\tpublic static void main(String[] args) &#123; Threadtest threadtest=new Threadtest(); Thread t1=new Thread(threadtest,&quot;线程1&quot;);//第二个是Thread的名字，一般是Thread(String name) Thread t2=new Thread(new Threadtest(),&quot;线程2&quot;);//匿名方式 t1.start(); t2.start();\t&#125;&#125; 实现Runnable()接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联 使用Runnable接口启动新的线程步骤如下： 建立Runnable对象 使用参数为Runnable对象的构造方法创建Thread实例 调用start()方法启动线程 123456Thread thread=new Thread(new Runnable()&#123; @Override public void run()&#123; &#125;&#125;) Swing与Thread结合实例 1234567891011121314151617181920212223242526272829303132333435363738public class SwingAndThread extends JFrame&#123;\tint count=0;//图像横坐标\tpublic SwingAndThread() &#123; setBounds(300,200,250,100); Container container=getContentPane();//主容器 container.setLayout(null); Icon icon=new ImageIcon(&quot;src/1.gif&quot;); JLabel jLabel=new JLabel(icon); jLabel.setBounds(10,10,200,50); Thread thread=new Thread() &#123;//匿名线程对象 public void run() &#123; while (true) &#123; jLabel.setBounds(count,10,200,50);//将标签的横坐标用变量表示 try &#123; Thread.sleep(500);//休眠500毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; count+=4;//横坐标每次增加4 if(count&gt;=200) &#123; count=10;//到达最右边时使其回到最左边 &#125; &#125; &#125; &#125;; thread.start(); container.add(jLabel); setVisible(true); setDefaultCloseOperation(EXIT_ON_CLOSE);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 new SwingAndThread();\t&#125;&#125; 线程的生命期 出生状态就是线程被创建时处于的状态，在用户使用该线程实例调用start()方法之前线程都是出生状态。 当调用start()方法后，线程处于就绪状态(可执行状态) 当线程得到系统资源进入运行状态。 处于运行状态调用Thread类中的wait()方法时，进入等待状态。进入等待状态必须由其他的线程调用notify()唤醒，自己无法唤醒自己，notifyAll()方法将所有处于等待状态下的线程唤醒 sleep()休眠状态，时间到了会自动唤醒，区别于等待状态。 线程中运行状态下发出输入&#x2F;输出请求时，该线程将进入阻塞状态。等待输入输出结束时线程进入就绪状态 当线程的run()方法执行完毕时，线程进入死亡状态。 graph TD 出生-->A[就绪] A-->B[运行] B-->A B-->C[等待] B-->D[休眠] B-->E[阻塞] B-->死亡 C-->A D-->A E-->A 操作线程的方法线程的加入join()方法加入到另外一个线程。例如存在一个线程A，现在需要插入B要求线程B先执行完毕，然后再执行线程A，调用join()，类似插入队伍。 当某个线程使用join()加入另外一个线程时，另一个线程会等待该线程执行完毕后再继续执行。 使用方法：在某一个线程A的run函数中使用B.join()插入B线程。 插入到主线程： 123456789101112public static void main(Stirng[] args)&#123; 类 A=new 类();&#125;public 类&#123; 线程实例化; 线程.start; try&#123; 线程.join();//这样就插入到主线程 &#125;catch(..)&#123; e.printStackTrace(); &#125;&#125; 线程的优先级 每个线程具有各自的优先级，可以表明在程序中该线程的重要性 系统根据优先级决定首先使哪个线程进入运行状态 123456789101112131415161718192021222324252627282930313233343536public class Priority implements Runnable&#123;\tString nameString;\tpublic Priority(String name) &#123; this.nameString=name;\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 String tmpString=&quot;&quot;; for (int i = 0; i &lt; 50000; i++) &#123; tmpString+=i;//进行50000次字符拼接 &#125; System.out.println(nameString+&quot;线程完成任务&quot;);\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Thread aThread=new Thread(new Priority(&quot;A&quot;)); aThread.setPriority(1); Thread bThread=new Thread(new Priority(&quot;B&quot;)); bThread.setPriority(3); Thread cThread=new Thread(new Priority(&quot;C&quot;)); cThread.setPriority(7); Thread dThread=new Thread(new Priority(&quot;D&quot;)); dThread.setPriority(10); aThread.start(); bThread.start(); cThread.start(); dThread.start();\t&#125;&#125;//结果D线程完成任务B线程完成任务C线程完成任务A线程完成任务 由输出结果，不一定按优先级，知识作为CPU的参考依据。执行顺序由CPU决定 线程同步线程安全线程安全问题来源于两个线程同时存取单一对象的数据 线程同步机制 解决资源共享问题 同步块 synchronized(Object)&#123;&#125; 通常将共享资源的操作放置在synchronized定义的区域内，当其他线程获取这个锁时，就必须等待锁被释放后才可以进入该区域。其中Object有标志位，0和1，若为0，表示此同步块内存在其他线程，这是当前线程处于就绪状态，直到同步块中的线程执行完同步块代码后，该对象标志位设置为1，当前线程开始执行同步块。 在run()里边添加同步块： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SynchronizedTest implements Runnable&#123;\tint num=10;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (true) &#123; synchronized (this) &#123; if (num&gt;0) &#123; try &#123; Thread.sleep(100);//使当前线程休眠100毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;——票数&quot;+num--); &#125; &#125; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 //实例化类对象 SynchronizedTest test=new SynchronizedTest(); //以该类对象分别实例化4个线程 Thread tA=new Thread(test,&quot;线程一&quot;); Thread tB=new Thread(test,&quot;线程二&quot;); Thread tC=new Thread(test,&quot;线程三&quot;); tA.start(); tB.start(); tC.start();\t&#125;&#125;//结果线程一——票数10线程一——票数9线程一——票数8线程一——票数7线程一——票数6线程一——票数5线程一——票数4线程一——票数3线程一——票数2线程一——票数1 如果不加同步块结果会出现负数 线程中执行n++结果不一定正确，因为n++不是原子操作，其中包含三步包括取值，加一，赋值，中间可能会被打断，导致结果不一定准确。可以加入锁解决 1234567synchronized(Object)&#123; try&#123; n++; aomicinteger.incrementAndGet(); longAdder.increment(); &#125;&#125; 同步方法 在方法前面用synchronized关键字修饰方法： 1synchronized void f()&#123;&#125; 同上面的例子实现一样的功能，不过运用同步方法而不是同步块： 12345678910111213141516171819202122232425262728293031323334public class SynchronizedTest implements Runnable&#123;\tint num=10;\tpublic synchronized void doit() &#123;//定义同步方法 if (num&gt;0) &#123; try &#123; Thread.sleep(100);//使当前线程休眠100毫秒 &#125; catch (InterruptedException e) &#123; // TODO: handle exception e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+&quot;——票数&quot;+num--); &#125;\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (true) &#123; doit(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 //实例化类对象 SynchronizedTest test=new SynchronizedTest(); //以该类对象分别实例化4个线程 Thread tA=new Thread(test,&quot;线程一&quot;); Thread tB=new Thread(test,&quot;线程二&quot;); Thread tC=new Thread(test,&quot;线程三&quot;); tA.start(); tB.start(); tC.start();\t&#125;&#125; 网络通信网络程序设计基础在TCP&#x2F;IP协议栈中，有两个高级协议，即传输控制协议(Transmission Control Protocol，TCP)与用户数据传输报协议(User Datagram Protocol，UDP) 高级协议 TCP UDP 特点 以固接连线为基础，从一端送至连接的另一端 以发送数据包的方式进行，向若干目标发送数据或接受来自若干源的数据 数据顺序 数据能够送达，且抵达数据的顺序&#x3D;送出时的顺序 不保证抵达的顺序&#x3D;送出时的顺序 类比 就像打电话，必须先拨号给对方，等两端确定连接后，互相才能听到对方说法，也知道对方回应的是什么 邮递员送信，可以寄出很多信给同一个人，且每封信相对独立。各封信到达的顺序并不重要，收信人接收信件的顺序也不能保证与寄出信件的顺序相同 TCP是面向连接的可靠协议，效率低，保证确实送达。UDP是面向无连接的不可靠协议，效率高，不保证数据可靠的传输。 一些防火墙或路由器可能设置不允许UDP数据传输协议 端口类似营业厅的窗口，提供某些服务 HTTP 80 FTP 21 Tomcat 8080 MySQL 3306 套接字套接字(Socket)用于将应用程序与端口连接起来。 客户端(应用程序&lt;–&gt;Socket&lt;–&gt;Port&lt;-)-(-&gt;Port&lt;–&gt;Socket&lt;–&gt;应用程序)服务器 类似插座一样连接电器与电线 TCP程序TCP协议进行通信的两个应用程序有主次之分，一个称为服务器程序，另一个称为客户机程序，服务端与客户端的交互过程如下： 服务器程序创建一个SeverSocket(服务器端套接字)对象，调用accept()方法等待客户机来连接 客户端程序创建一个Socket对象，请求与服务器建立连接 服务器接受客户机的连接请求，同时创建一个新的Socket对象与客户建立连接。随后服务器继续等待新的请求 SeverSocket可以理解为售后部门的电话；服务器端运行的Socket可以理解为客服人员；客户端运行的Socket可以理解为顾客 IntetAddress类这是一个与ip地址相关的类，可以获取ip地址，主机地址等信息，常用方法： getByName(String host) 返回InterAddress 获取Host项对应的InterAddress对象 getHostAddress() 返回String 获取InterAddress对象所包含的IP地址 getHostName() String 获取此ip地址的主机名 getLocalHost() InterAddress 返回本地主机的InterAddress对象 123456789101112131415161718192021public class Address &#123;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 InetAddress ip;//创建对象 try &#123; ip=InetAddress.getLocalHost();//实例化对象 String localname=ip.getHostName();//获取本机名 String localip=ip.getHostAddress();//获取本机ip地址 System.out.println(&quot;本机名：&quot;+localname); System.out.println(&quot;本机IP地址：&quot;+localip); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;&#125;//结果本机名：LAPTOP-6G798SAR本机IP地址：192.168.4.1 SeverSocket类服务器套接字 SeverSocket(int port)：绑定到接口port的服务器套接字 当服务器向输出流写入信息时，客户端通过相应的输入流就能读取，反之亦然 注意accept()方法会阻塞线程的继续指行，直至接收到客户的呼叫 12yu=server.accept();System.out.println(&quot;连接中&quot;); 如果没有客户呼叫服务机，那么“连接中”语句不会执行 TCP网络程序设计单项通信的例子，客户机通过输出流发送数据，服务器通过输入流接收数据： 服务器端： 12345678910111213141516171819202122232425262728293031323334public class MyServer &#123;\tprivate ServerSocket server;//服务器套接字\tprivate Socket socket;//客户机套接字\tvoid start() &#123; try &#123; server=new ServerSocket(8998);//服务器启用8998端口 System.out.println(&quot;服务器套接字已经创建成功&quot;); while (true) &#123; System.out.println(&quot;等待客户机的连接&quot;); socket=server.accept();//服务器监听客户机连接 BufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream())); while (true) &#123; String message=reader.readLine();//读取一行文本 if(&quot;exit&quot;.equals(message)) &#123; System.out.println(&quot;客户机退出&quot;); break;//停止接受信息 &#125; System.out.println(&quot;客户机：&quot;+message); &#125; reader.close(); socket.close(); &#125; &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 MyServer tcp=new MyServer(); tcp.start();\t&#125;&#125; 客户机端： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyClient extends JFrame&#123;\tprivate PrintWriter writer;//根据套接字字节流创建的字符输出流\tSocket socket;\tprivate JTextArea area=new JTextArea();//展示信息的文本域\tprivate JTextField text=new JTextField();//发送信息的文本框 public MyClient() &#123; setTitle(&quot;向服务器送数据&quot;); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Container container=getContentPane(); JScrollPane scrollPane=new JScrollPane(area); getContentPane().add(scrollPane,BorderLayout.CENTER); container.add(text,&quot;South&quot;); text.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 writer.println(text.getText().trim());//将文本框中的信息写入流 area.append(text.getText()+&#x27; &#x27;);//将文本框中的信息显示到文本域中 text.setText(&quot;&quot;);//清空 &#125; &#125;);\t&#125;\tprivate void connect() &#123; area.append(&quot;尝试连接 &quot;); try &#123; socket=new Socket(&quot;127.0.0.1&quot;,8998);//连接本地计算机的8998接口 writer=new PrintWriter(socket.getOutputStream(),true); area.append(&quot;完成连接 &quot;); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 MyClient client=new MyClient(); client.setSize(200,200); client.setVisible(true); client.connect();//连接服务器\t&#125;&#125; UDP程序UDP通信基本模式： 将数据打包（数据包），然后将数据包发往目的地 接收别人发来的数据包，然后查看数据包 发送数据包： 创建：使用DatagramSocket()创建一个数据包套接字。 打包：使用DatagramPacker(byte[] buf, int offset, int length, InetAddress address, int port)创建要发送的数据包。 发送：使用DatagramSocket()类的send()方法发送数据包。 接收数据包： 创建：使用DatagramSocket(int port)创建数据包套接字，绑定到指定的接口。 准备包：使用DatagramPacket(byte[] buf, int length)创建字节数组来接收数据包。 接收：使用DatagramPocket类的receive()方法接收UDP包。 DatagramPacket类数据包，构造方法： DatagramPacket(byte[] buf, int length) 指定包的内存空间和大小 DatagramPacket(byte[] buf, int length,InetAddress address,int port) 多指定了数据包的目标地址和端口 发送数据需指定接收方的Socket地址和端口号 DatagramSocket类 DatagramSocket() DatagramSocket(int port) DatagramSocket(int port, InetAddress addr) 适用多块网卡有多个IP地址 接收时要指定端口号一般用第二种，发送时不知道用第一种。 UDP网络程序设计下面创建一个广播数据报程序，原理类似电台广播。广播电台需要在指定的波段和频率上广播信号，接收者也要将收音机调到指定的波段、频率，才可以收听广播内容。 广播主机程序不断向外播出信息： image-20221224205156462 123456789101112131415161718192021222324252627282930313233343536373839404142public class Notification extends Thread&#123;\tString weather=&quot;节目预报：八点有大型晚会，请收听&quot;;//发送的信息\tint port=9898;\tInetAddress iaddress=null;\tMulticastSocket socket=null;//多点广播套接字，是一种DatagramPacket @SuppressWarnings(&quot;deprecation&quot;)\tpublic Notification() &#123; try &#123; iaddress=InetAddress.getByName(&quot;224.255.10.0&quot;);//广播组地址 socket=new MulticastSocket(port);//实例化 socket.setTimeToLive(1);//指定发送范围是本地网络 socket.joinGroup(iaddress);//加入广播组 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;\t&#125;\tpublic void run() &#123; while (true) &#123; DatagramPacket packet=null;//数据包 byte data[]=weather.getBytes();//字符串消息的字节数组 packet=new DatagramPacket(data,data.length,iaddress, port);//将数据打包 System.out.println(weather); try &#123; socket.send(packet); sleep(3000); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Notification w=new Notification(); w.start();//启动线程\t&#125;&#125; 接收广播程序： image-20221224205211236 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Receive extends JFrame implements Runnable,ActionListener&#123;\tint port;//端口\tInetAddress group=null;//广播组地址\tMulticastSocket socket=null;//多点广播套接字对象\tJButton inceBtn=new JButton(&quot;开始接收&quot;);\tJButton stopBtn=new JButton(&quot;停止接收&quot;);\tJTextArea inceAr=new JTextArea(10,10);\tJTextArea inced=new JTextArea(10,10);\tThread thread;\tboolean stop=false;//停止接收信息状态 public Receive() &#123; //界面设计 setTitle(&quot;广播数据报&quot;); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); thread=new Thread(this); inceBtn.addActionListener(this);//绑定按钮ince的单击事件 stopBtn.addActionListener(this);//绑定按钮stop的单击事件 inceAr.setForeground(Color.blue); JPanel north=new JPanel(); north.add(inceBtn);//将按钮添加到north面板 north.add(stopBtn); add(north,BorderLayout.NORTH);//将north放置在窗体上部 JPanel center=new JPanel();//创建面板对象center center.setLayout(new GridLayout(1,2));//设置面板布局 center.add(inceAr);//将文本域添加到面板上 center.add(inced); add(center,BorderLayout.CENTER);//设置面板布局 validate();//刷新 //UDP部分 port=9898; try &#123; group=InetAddress.getByName(&quot;224.255.10.0&quot;);//指定接收地址 socket=new MulticastSocket(port);//绑定 socket.joinGroup(group);//加入广播组 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; setBounds(100,50,360,380); setVisible(true);\t&#125;\t@Override\tpublic void run() &#123; // TODO 自动生成的方法存根 while (stop==false) &#123; byte data[]=new byte[1024];//创建缓存字节数组 DatagramPacket packet=null; packet=new DatagramPacket(data,data.length,group, port);//待接收数据包 try &#123; socket.receive(packet);//接收数据包 //获取数据包中的内容 String message=new String(packet.getData(),0,packet.getLength()); inceAr.setText(&quot;正在接收的内容： &quot;+message);//将接收内容显示在文本域中 inced.append(message+&quot; &quot;);//每条信息为一行 &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125;\t&#125;\t@Override\tpublic void actionPerformed(ActionEvent e) &#123; // TODO 自动生成的方法存根 if (e.getSource()==inceBtn) &#123;//单击inceBtn按钮触发的事件 inceBtn.setBackground(Color.red);//设置按钮颜色 stopBtn.setBackground(Color.yellow); if (!(thread.isAlive())) &#123;//线程不处于”新建状态” thread=new Thread(this); &#125; thread.start();//启动线程 stop=false;//开始接收信息 &#125; if (e.getSource()==stopBtn) &#123;//单击stop按钮触发的事件 inceBtn.setBackground(Color.yellow); stopBtn.setBackground(Color.red); stop=true; &#125;\t&#125;\tpublic static void main(String[] args) &#123; // TODO 自动生成的方法存根 Receive receive=new Receive(); receive.setSize(460,200);\t&#125;&#125;","tags":["编程语言"]},{"title":"pytorch深度学习笔记","path":"/2022/09/27/pytorch深度学习笔记/","content":"dir()函数，能让我们知道工具箱以及工具箱中的分隔区有什么东西。 help()函数，能让我们知道每个工具是如何使用的，工具的使用方法。 help(a)或者a?? 三个区域编写代码： pycharm的python文件 整体运行，python文件的块是所有行的代码，适用大型项目 每次都是整体运行 pycharm的python 控制台 以任意行为块(Shift+Enter)，变量属性在右边查看 出现错误可阅读性大大降低 Jupyter notebook 同python控制台，Shift+Enter执行块 可以直接修改块中的错误，阅读性加强 环境需要配置 加载数据一堆数据–&gt;Dataset(提供一种方式去获取数据及其label)–&gt;Dataloader(为后面的网络提供不同的数据形式) Dataset： 如何获取每一个数据及其label 告诉我们总共有多少数据 数据的组织形式 文件夹名就是一个label ocr 图片 对应图片的文字坐标信息 图片名就是label 实战案例： image-Snipaste_2022-09-24_23-31-33 1234567891011121314151617181920212223242526272829303132from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir # 数据集文件夹 self.label_dir = label_dir # 数据集标签 self.path = os.path.join(root_dir, label_dir) # 拼接路径 这里正好文件夹名就是标签名 self.img_path = os.listdir(self.path) # 将文件夹下图片转换成列表 def __getitem__(self, idx): # idx是索引 img_name = self.img_path[idx] # 获取单张图片名字 img_item_path = os.path.join(self.root_dir, self.label_dir, img_name) # 拼接获得单张图的地址 img = Image.open(img_item_path) # 图片读取 label = self.label_dir # 获取标签 return img, label def __len__(self): return len(self.img_path) # 长度即数据集的列表长度root_dir = &quot;dataset/train&quot; # 大路径ants_label_dir = &quot;ants&quot; # 蚂蚁标签bees_label_dir = &quot;bees&quot; # 蜜蜂标签ants_dataset = MyData(root_dir, ants_label_dir) # 实例化蚂蚁bees_dataset = MyData(root_dir, bees_label_dir) # 实例化蜜蜂train_dataset = ants_dataset + bees_dataset # 拼接数据集 https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io Tensorboard看模块的代码：按住Ctrl，点模块 打开窗口，不接--port默认打开6006端口的 1tensorboard --logdir=logs --port=6007 add_scalar12345678from torch.utils.tensorboard import SummaryWriterwriter=SummaryWriter(&quot;logs&quot;)for i in range(100): writer.add_scalar(&quot;标题&quot;,y轴,x轴)writer.close() 重新画删掉Logs文件下下的所有文件，在终端Ctrl+c结束后重新打开窗口 add_image()opencv读取到的数据是numpy型 从PIL到numpy，需要在add_image()中指定shape中每一个数字&#x2F;维表示的含义，默认是CHW即通道-高度-宽度，如果导入图片是HWC就要加入说明，见案例： 1234567891011121314151617import numpy as npfrom torch.utils.tensorboard import SummaryWriterfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;)image_path = &quot;data/train/ants_image/0013035.jpg&quot;img_PIL = Image.open(image_path) # 打开图片img_array = np.array(img_PIL) # 转成numpy型print(type(img_array)) # 验证时numpy型print(img_array.shape) # 检查图片的形状，发现是HWC，即高度-宽度-通道writer.add_image(&quot;test&quot;, img_array, dataformats=&quot;HWC&quot;) # HWC对应图片的形状for i in range(100): writer.add_scalar(&quot;y=2*x&quot;,3*i,i)writer.close() Transformtransform.py工具箱，有toTensor，resize等工具，用于处理图片输出想要的图片结果 transform的使用 tensor数据类型 在括号内Ctrl+P查看要输入的参数 tensor数据类型ToTensor&amp;Normalize123456789101112131415161718192021from PIL import Imagefrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transformswriter=SummaryWriter(&quot;logs&quot;)img=Image.open(&quot;dataset/val/ants/800px-Meat_eater_ant_qeen_excavating_hole.jpg&quot;)print(img)#ToTensortrans_totensor=transforms.ToTensor()img_tensor=trans_totensor(img) # 转成tensor类型writer.add_image(&quot;ToTensor&quot;,img_tensor)# Normalizeprint(img_tensor[0][0][0])trans_norm=transforms.Normalize([3,0.5,0.5],[0.5,0.5,0.5]) # 标准差img_norm=trans_norm(img_tensor)print(img_norm[0][0][0])writer.add_image(&quot;Normalize&quot;,img_norm,1)writer.close() resize()12345678910#接上面代码# Resizeprint(img.size) # 原图的大小(800, 534)trans_resize = transforms.Resize((512, 512)) # 改大小# img PIL -&gt; resize -&gt; img_resize PILimg_resize = trans_resize(img)# img_resize PIL -&gt; totensor -&gt; img_resize tensorimg_resize=trans_totensor(img_resize)writer.add_image(&quot;Resize&quot;,img_resize,0)print(img_resize) Compose()Compose()中的参数需要一个列表。Python中，列表的表示形式为[数据1，数据2，…]。在Compose中，数据需要是transforms类型，所以得到的： 1Compose([transforms参数1,transforms参数2,...]) 将几步打包成一步： 1234567# Compose - resize - 2trans_resize_2 = transforms.Resize(512) # 只改了宽 没改长# PIL -&gt; PIL -&gt; tensortran_compose = transforms.Compose([trans_resize_2, trans_totensor])img_resize_2 = tran_compose(img)writer.add_image(&quot;Resize&quot;, img_resize_2, 1)writer.close() RandomCrop()随机裁剪出一部分 12345678trans_random = transforms.RandomCrop(512) # PIL -&gt; PIL -&gt; tensortran_compose_2 = transforms.Compose([trans_random, trans_totensor])for i in range(10): # 设置不同步数 img_crop=trans_compose_2(img) writer.add_image(&quot;RandomCrop&quot;, img_resize_2, 1)writer.close() 总结 关注输入和输出 多看官方文档 PyTorch 关注方法需要什么参数 不知道返回值的时候： &#96;&#96;&#96;pythonprint()print(type())调试12345678910111213141516171819202122232425262728 # torchvision数据集的使用官网文档的torchvision.datasets下有很多数据集可以使用torchvision.models提供训练好的模型torchvision.transform上面讲了torchvision.utils提供小工具```pythonimport torchvisiontrain_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/data1&quot;,train=True,download=True) # 下载训练集test_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/test1&quot;,train=False,download=True) # 下载测试集print(test_set[0]) # ( , )的形式，发现第一个是图片第二个是targetprint(test_set.classes) # 查看图片有哪些类型(调式看test_set有calsses属性)img,target=test_set[0] #接收( , )print(img)print(target)print(test_set.classes[target])img.show() 和transform联动1234567891011121314import torchvisionfrom torch.utils.tensorboard import SummaryWriterdataset_transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) # 设置transformstrain_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/data1&quot;,train=True,transform=dataset_transform,download=True) # 加入transforms参数test_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/test1&quot;,train=False,transform=dataset_transform,download=True)writer=SummaryWriter(&#x27;p10&#x27;)for i in range(10): img,target = test_set[i] writer.add_image(&quot;test_set&quot;,img,i)writer.close() 结果： image-20220927212823149 DataLoader12345678910111213141516171819202122import torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriter# 准备测试数据集test_data = torchvision.datasets.CIFAR10(&quot;./dataset/test1&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)# 测试数据集中第一张照片及targetimg, target = test_data[0]print(img.shape)print(target)writer = SummaryWriter(&quot;dataloader&quot;)step = 0for data in test_loader: imgs, targets = data # test_loader返回值是batch_size设定的一组图片打包的img和target writer.add_images(&quot;test_data&quot;, imgs, step) step = step + 1writer.close() image-20220929211159838 神经网络torch.nn，Neural Network。 nn.Module是所有神经网络的基类 123456789101112131415import torchimport torch.nn as nnimport torch.nn.functional as Fclass Model(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 20, 5) self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): # 隐藏层 x = F.relu(self.conv1(x)) # 经过一次卷积然后一次非线性 return F.relu(self.conv2(x)) # 输出 卷积操作image.png 各种参数 image.png Stride Stirde&#x3D;1表示卷积核在输入图像上移动一格，对应格相乘得到数；从左到右，到边界回到最左向下移动Stride然后重复操作 padding image.png 123456789101112131415161718192021222324252627282930313233import torchimport torch.nn.functional as Finput=torch.tensor([[1,2,0,3,1], [0,1,2,3,1], [3,2,3,1,1], [5,2,3,1,1], [2,1,0,1,1]])kernel=torch.tensor([[1,2,1], [0,1,0], [2,1,0]])print(input.shape) # 只有两个参数，不能直接放进卷积，要reshapeinput=torch.reshape(input,(1,1,5,5)) # 5X5矩阵kernel=torch.reshape(kernel,(1,1,3,3))print(input.shape)print(kernel.shape) # 变成四个参数output=F.conv2d(input,kernel,stride=1,padding=1)print(output)# 输出# torch.Size([5, 5])# torch.Size([1, 1, 5, 5])# torch.Size([1, 1, 3, 3])# tensor([[[[ 1, 3, 4, 10, 8],# [ 7, 14, 14, 17, 9],# [ 9, 18, 18, 17, 9],# [15, 17, 14, 8, 7],# [14, 13, 9, 7, 4]]]]) 卷积层nn.Conv1d一维卷积，nn.Conv2d二维卷积层… 彩色图像一般是三通道 123CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#x27;zeros&#x27;, device=None, dtype=None)# 参数表 输入通道数，输出通道数，卷积核大小，卷积操作步径大小，边缘填充，卷积核距离...后面都是默认参数 卷积层示例(动图要梯子才能刷出来) out_channels设置为2时会生成两个卷积核，得到两个叠加的输出。(一般卷积操作会不断增加channels数) 例子： 12345678910111213141516171819202122232425262728293031323334353637import torchimport torchvision.datasetsfrom torch import nnfrom torch.nn import Conv2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(Tudui, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) def forward(self, x): x = self.conv1(x) return xmyModule = MyModule()writer = SummaryWriter(&quot;logs2&quot;)step = 0for data in dataLoader: imgs, targets = data output = myModule(imgs) print(imgs.shape) print(output.shape) # torch.Size([64,3,32,32]) writer.add_images(&quot;input&quot;, imgs, step) # torch.Size([64,6,30,30]) -&gt; [xxx,3,30,30] output = torch.reshape(output, (-1, 3, 30, 30)) # 原本输出通道数变两倍，这一步相当于切开放到一个 writer.add_images(&quot;output&quot;, output, step) step = step + 1 image.png 池化层ceil_mode floor向下取整，ceiling向上取整。默认false不够对应不取值 image.png 实现： 123456789101112131415161718192021222324252627282930313233343536# 最大池化import torchfrom torch import nnfrom torch.nn import MaxPool2dinput = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]], dtype=torch.float32) # 声明一下类型否则报错input = torch.reshape(input, (-1, 1, 5, 5))print(input.shape)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=False) # 注意ceil_mode def forward(self,input): output=self.maxpool1(input) return outputmyModule = MyModule()output = myModule(input)print(output)# 当ceilmode设置为false结果：# torch.Size([1, 1, 5, 5])# tensor([[[[2.]]]])# 当ceilmode设置为true结果：# torch.Size([1, 1, 5, 5])# tensor([[[[2., 3.],# [5., 1.]]]]) 最大池化目的为了保持原先数据的特征同时减少数据量，加快训练速度。例如720p也能大致看明白1080p视频内容 例子： 12345678910111213141516171819202122232425262728293031323334353637# 最大池化import torchimport torchvisionfrom torch import nnfrom torch.nn import MaxPool2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True) def forward(self, input): output = self.maxpool1(input) return outputmyModule = MyModule()writer = SummaryWriter(&quot;Logs_maxpool&quot;)step = 0for data in dataLoader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, step) output = myModule(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() image.png 可以看到输出图片变模糊了 非线性激活 Non-linear用到ReLu()或Sigmoid() 1234567891011121314151617181920212223242526272829303132333435import torchimport torchvisionfrom torch import nnfrom torch.nn import Sigmoid, ReLUfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.relu = ReLU() self.sigmoid1 = Sigmoid() def forward(self, input): output = self.sigmoid1(input) return outputMyModule = MyModule()writer = SummaryWriter(&quot;logs_relu&quot;)step = 0for data in dataLoader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, global_step=step) output = MyModule(imgs) writer.add_images(&quot;output&quot;, output, global_step=step) step += 1writer.close() image.png 主要目的在网络中引入更多非线性特征，才能训练出符合更多特征的模型。 线性层及其他层1CLASS torch.nn.Linear(in_features,out_features,biass=True) biass表示要不要设置偏振b image.png flattten()展平成一行 CRAF10小实战及Sequential()image.png 1、由公式计算第一步卷积得到padding是2(默认设置stride为1) image.png 通过对每一步的解析，我们建立出一个简单的模型，代码如下： 123456789101112131415161718192021222324252627282930313233343536import torchfrom torch import nnfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequentialfrom torch.utils.tensorboard import SummaryWriterclass MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xmyModule = MyModule()print(myModule)input = torch.ones((64, 3, 32, 32)) # torch提供的一个假设的输入output = myModule(input)print(output.shape)writer = SummaryWriter(&quot;logs_seq2&quot;)writer.add_graph(myModule,input)writer.close() image.png","tags":["python","深度学习"],"categories":["深度学习"]},{"title":"python学习笔记","path":"/2022/09/24/python学习笔记/","content":"部分来源：廖雪峰的官方网站 函数函数的参数使用默认参数解决调用时缺少实参问题,一定必选参数在前，默认参数在后 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 12&gt;&gt;&gt; power(5)25 定义默认参数要牢记一点：默认参数必须指向不变对象！ 如： 123def add_end(L=[]): L.append(&#x27;END&#x27;)#向list尾插入 return L 12&gt;&gt;&gt; add_end()[&#x27;END&#x27;] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;]&gt;&gt;&gt; add_end()[&#x27;END&#x27;, &#x27;END&#x27;, &#x27;END&#x27;] 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append(&#x27;END&#x27;) return L 可变参数可变参数就是传入的参数个数是可变的 我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 模块创建模块 新建一个.py文件，不要和python自带重名 导入模块12import 模块名称 [as别名]from 模块名称 import 函数/变量/类 例子： 1234567#导入整个import mathprint(math.pi)#导入部分from math import piprint(pi) 导入自定义模块要先将自定义模块所在文件下设置为源文件夹（Sources Root） 第三方模块123pip install 模块名 #在小黑窗在线安装import 模块名 #在python文件使用 例子： 12345678910import scheduleimport timedef job(): print(&quot;hhh&quot;)schedule.every(3).seconds.do(job)#每三秒执行一次while True: schedule.run_pending()#启动 time.sleep(1)#停一秒 以主程序运行12if __name__==&#x27;__main__&#x27;:\tpass 例子： 1234567#calc2.pydef add(a,b)\treturn a+bif __name__==&#x27;__main__&#x27;\tprintf(add(10,20))#只有当运行calc2.py时才会输出，当其作为模块引入到其他文件执行时不输出 包python程序结构： graph LR A(Python程序)-->B(包1) A-->C(包2) A-->D(包3) B-->E(模块A) B-->F(模块B) C-->G(模块A) C-->H(模块B) 包与目录的区别 包(package)包含_init_.py文件 目录(directory)里通常不包含_init_.py文件 导入同目录下的包里的模块： 12import package.module_A as ma #别名print(ma.a) 使用import导入时只能跟包名和模块名 想要导入变量用from: 1from package.moudle_A import a image-20220923230121039 graph LR A(模块与包)-->B(模块) A-->C(包) B-->D(避免函数名/变量名重名) B-->E(自定义模块) B-->F(第三方模块) E-->G(一个.py文件称为一个模块) F-->H(安装:pip install 模块名) F-->I(使用:from ...import 模块名) C-->J(避免模块名重名) C-->K(包含__init__.py文件) 面向对象类和实例12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&#x27;%s: %s&#x27; % (self.name, self.score)) 注意：特殊方法“__init__”前后分别有两个下划线！！！ 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 12345&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)&gt;&gt;&gt; bart.name&#x27;Bart Simpson&#x27;&gt;&gt;&gt; bart.score59 继承和多态继承我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印： 123class Animal(object): def run(self): print(&#x27;Animal is running...&#x27;) 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承： 12345class Dog(Animal): passclass Cat(Animal): pass 在括号放父类 多态在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行： 123&gt;&gt;&gt; b = Animal()&gt;&gt;&gt; isinstance(b, Dog)False 例子： 1234567891011def run_twice(animal): animal.run() animal.run() &gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 获取对象信息使用type()首先，我们来判断对象类型，使用type()函数： 基本类型都可以用type()判断： 123456&gt;&gt;&gt; type(123)&lt;class &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&#x27;str&#x27;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &#x27;NoneType&#x27;&gt; 使用isinstance()对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。 我们回顾上次的例子，如果继承关系是： 1object -&gt; Animal -&gt; Dog -&gt; Husky 那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象： 12&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; h = Husky() 然后，判断： 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Animal)True 使用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： 12&gt;&gt;&gt; dir(&#x27;ABC&#x27;)[&#x27;__add__&#x27;, &#x27;__class__&#x27;,..., &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;,..., &#x27;zfill&#x27;] 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; &#x27;ABC&#x27;.__len__()3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法： 1234567&gt;&gt;&gt; class MyDog(object):... def __len__(self):... return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100","tags":["编程语言","python"],"categories":["编程"]},{"title":"js导出json文件","path":"/2022/09/06/js导出json文件/","content":"12345678910111213141516171819202122232425262728293031323334function saveJSON(data, filename) &#123; if (!data) &#123; alert(&quot;保存的数据为空&quot;); return; &#125; if (!filename) filename = &quot;json.json&quot;; if (typeof data === &quot;object&quot;) &#123; data = JSON.stringify(data, undefined, 4); &#125; var blob = new Blob([data], &#123; type: &quot;text/json&quot; &#125;), e = document.createEvent(&quot;MouseEvents&quot;), a = document.createElement(&quot;a&quot;); a.download = filename; a.href = window.URL.createObjectURL(blob); a.dataset.downloadurl = [&quot;text/json&quot;, a.download, a.href].join(&quot;:&quot;); e.initMouseEvent( &quot;click&quot;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null ); a.dispatchEvent(e);&#125; BlobBlob，Binary Large Object的缩写，代表二进制类型的大对象。通俗点说，就是Blob对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作File对象一样操作Blob对象，实际上，File继承自Blob。 从字符串创建 Blob12let myBlobParts = [&#x27;&lt;html&gt;&lt;h2&gt;Hello Semlinker&lt;/h2&gt;&lt;/html&gt;&#x27;]; // an array consisting of a single DOMStringlet myBlob = new Blob(myBlobParts, &#123;type : &#x27;text/html&#x27;, endings: &quot;transparent&quot;&#125;); // the blob 从类型化数组和字符串创建 Blob12let hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 &quot;hello&quot;let blob = new Blob([hello, &#x27; &#x27;, &#x27;semlinker&#x27;], &#123;type: &#x27;text/plain&#x27;&#125;); 鼠标事件Document.createEvent()创建一个指定类型的事件。其返回的对象必须先初始化并可以被传递给element.dispatchEvent 语法1var event = document.createEvent(type); event 就是被创建的 Event 对象。 type 是一个字符串，表示要创建的事件类型。事件类型可能包括&quot;UIEvents&quot;, &quot;MouseEvents&quot;, &quot;MutationEvents&quot;, 或者 &quot;HTMLEvents&quot;。 MouseEvent.initMouseEvent()已弃用的特性，建议查阅相关文档改进 MouseEvent.initMouseEvent() - Web API 接口参考 | MDN (mozilla.org) EventTarget.dispatchEvent向一个指定的事件目标派发一个事件, 并以合适的顺序同步调用目标元素相关的事件处理函数。标准事件处理规则 (包括事件捕获和可选的冒泡过程) 同样适用于通过手动的使用dispatchEvent()方法派发的事件。 语法1cancelled = !target.dispatchEvent(event) 参数 event 是要被派发的事件对象。 target 被用来初始化事件和决定将会触发目标。","tags":["JavaScript","前端"],"categories":["编程"]},{"title":"微信小程序学习笔记","path":"/2022/08/24/微信小程序学习记录/","content":"Keys云数据库查询获取不到数据 云数据库get出来是空数组，一般是因为没有打开权限，修改为”所有用户可读即可”。 image.png where条件查询要添加查询的索引，如果传入的是undefined会获取该数据集合的全部记录 调试！调试！调试！，如果获取到undefined注意多调试，可能是对象属性的问题，例如一般返回res，而res下还有一层data,因此获取想要的字段数据一般是res.data[0].[字段名] 异步同步问题特别是数据库的请求是异步的这个千万注意。 解决办法：网上大致用Promise 我也没有自己研究，我的解决办法是涉及到数据库的写成一个函数然后调用函数的时候设置2秒延时执行。 123setTimeout(()=&gt; //调用数据库 ,2000) 请求数据限制云数据库请求记录数据有20段的限制(偶然发现获取到的数据少了一些才查到这个规则)，建议把多的数据打包成数组放在一个字段里。 网上有分页方法还没学会，但是显然是提前打包好数据更为省事。 数组值传递的时候变字符串在查bug的时候发现数组totalIncomeKeep=[ , , ]在经过options传值后变成了totalIncomeKeep= , , ,，查了一下是字符串类型。刚开始尝试 JSON.parse()但是发现他是把将数组字符串转为数组对象。 ​ 应该使用totalIncomeKeep.split(&quot;,&quot;)，传过来的字符串就是按“，”分割的，这是直接用str.split(&quot;,&quot;)就成了！ 实用组件模板1.返回前页1234wx.navigateBack(&#123;\tdelta:4//delta值就是往前返回几页&#125;) 2.输入框+滑动两种输入数值方式​ input和text同行,同时滑动块根据输入框动态改变，当输入值小于滑动范围时会提示过小(大)。 image-20220816220009337 wxml12345678910&lt;view wx:if=&#x27;&#123;&#123;!changeStatus&#125;&#125;&#x27; class=&quot;view-contain-ti&quot;&gt; &lt;!-- 设置面积 --&gt; &lt;!-- &lt;text class=&quot;text-ti&quot;&gt;设置民宿面积&lt;/text&gt; --&gt; &lt;view style=&quot;display:flex;align-items:center&quot;&gt; &lt;text&gt;设置民宿面积(平方米):&lt;/text&gt;&lt;input class=&quot;inputl&quot; bindinput=&quot;usernameInput&quot; placeholder=&quot;输入5-500的数字&quot; value=&quot;&#123;&#123;inputValue&#125;&#125;&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;intro&quot;&gt; &lt;slider bindchange=&quot;sliderchange&quot; min=&quot;&#123;&#123;minValue&#125;&#125;&quot; max=&quot;&#123;&#123;maxValue&#125;&#125;&quot; block-size=&quot;20&quot; value=&quot;&#123;&#123;areaValue&#125;&#125;&quot; show-value /&gt; &lt;/view&gt;&lt;/view&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//实时获取数据 usernameInput: function (e) &#123; let value = this.validateNumber(e.detail.value); if(value&lt;=500&amp;&amp;value&gt;=5)&#123; this.setData(&#123; areaValue: value &#125;) &#125;else if(value&lt;5)&#123; wx.showToast(&#123; title: &quot;面积设置过小！&quot;, // 提示的内容 icon: &quot;none&quot;, // 图标，默认success image: &quot;&quot;, // 自定义图标的本地路径，image 的优先级高于 icon duration: 700, // 提示的延迟时间，默认1500 mask: false, // 是否显示透明蒙层，防止触摸穿透 &#125;) this.setData(&#123; areaValue: 5 &#125;) &#125;else if(value&gt;500)&#123; wx.showToast(&#123; title: &quot;面积设置过大！&quot;, // 提示的内容 icon: &quot;none&quot;, // 图标，默认success image: &quot;&quot;, // 自定义图标的本地路径，image 的优先级高于 icon duration: 700, // 提示的延迟时间，默认1500 mask: false, // 是否显示透明蒙层，防止触摸穿透 &#125;) this.setData(&#123; areaValue: 500 &#125;) &#125;else&#123; this.setData(&#123; areaValue: 5, inputValue:&#x27;&#x27; &#125;) &#125; &#125;, //数字限制 validateNumber(val) &#123; return val.replace(/\\D/g, &#x27;&#x27;) &#125;, /** * slider滑动监听事件,滑动选择面积大小 */ sliderchange: function (e) &#123; this.setData(&#123; textValue: &#x27;设置民宿面积:&#x27; + e.detail.value + &#x27; 平方米&#x27;, areaValue: e.detail.value, inputValue:e.detail.value &#125;) console.log(`当前值`, this.data.areaValue) &#125;, 3.自定义弹窗​ 通过wx:if控制view的显隐实现弹窗效果，可以关注一下wxss的相关样式 wxml1234567891011121314&lt;view wx:if=&#x27;&#123;&#123;showModal&#125;&#125;&#x27;&gt; &lt;view class=&#x27;mask_layer&#x27; bindtap=&#x27;modal_click_Hidden&#x27; /&gt; &lt;view class=&#x27;modal_box&#x27;&gt; &lt;view class=&quot;title&quot;&gt;标题&lt;/view&gt; &lt;view class=&#x27;content&#x27;&gt;&lt;!-- 弹窗内容--&gt; &lt;text class=&#x27;modalMsg&#x27;&gt;&lt;/text&gt; &lt;/view&gt; &lt;view class=&#x27;btn1&#x27;&gt; &lt;view bindtap=&#x27;modal_click_Hidden&#x27; class=&#x27;cancel&#x27;&gt;取消&lt;/view&gt; &lt;view bindtap=&#x27;Sure&#x27; class=&#x27;Sure&#x27;&gt;确定&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.mask_layer &#123; width: 100%; height: 100%; position: fixed; z-index: 999; left:0;top:0; background: #000; opacity: 0.5; overflow: hidden;&#125;.modal_box &#123; width: 76%; overflow: hidden; position: fixed; top: 50%; left: 0; z-index: 1001; background: #fafafa; margin: -150px 12% 0 12%; border-radius: 3px;&#125;.title &#123; padding: 15px; text-align: center; background-color: gazure;&#125;.content &#123; overflow-y: scroll; /*超出父盒子高度可滚动*/&#125;.input_show1&#123; margin: 0 auto; width: 80%; margin-left: 10%; font-size: 32rpx; text-align: center; &#125;.btn1 &#123; width: 100%; margin-top: 65rpx; display: flex; flex-direction: row; align-items: center; justify-content: space-between; box-sizing: border-box; background-color: white;&#125;.cancel &#123; width: 100%; padding: 10px; text-align: center; color: black;&#125;.Sure &#123; width: 100%; padding: 10px; color: #44b549; background-color: white; border-left: 1px solid #d0d0d0; text-align: center;&#125;.modalMsg &#123; text-align: center; margin-top: 45rpx; display: block;&#125; js123456789101112131415showCancelOrder: function() &#123; this.setData(&#123; showModal:true &#125;) &#125;, //取消 modal_click_Hidden: function () &#123; this.setData(&#123; showModal: false, &#125;) &#125;, // 确定 Sure: function () &#123; &#125;, 4.数据可视化点击后显示坐标点的信息 image-20220817224609612 ​ 下载echarts的微信小程序版本：echarts-for-weixin ，地址在：https://github.com/ecomfe/echarts-for-weixin，下载后解压，只需要其中的ec-canvas文件夹。 ​ 在需要引用echarts的页面json文件中，添加echarts引用（注意echarts的相对路径）： 123456&#123; &quot;usingComponents&quot;: &#123; &quot;ec-canvas&quot;: &quot;../../ec-canvas/ec-canvas&quot; &#125;, &quot;navigationBarTitleText&quot;: &quot;详情&quot;&#125; ​ 在需要引用echarts的js文件中，引入echars.js： 1import * as echarts from &#x27;../../ec-canvas/echarts&#x27;; wxml12345&lt;!--wxml--&gt;&lt;view class=&quot;echart_panel&quot;&gt; &lt;ec-canvas id=&quot;mychart&quot; canvas-id=&quot;mychart-line&quot; ec=&quot;&#123;&#123; ec &#125;&#125;&quot; &gt;&lt;/ec-canvas&gt;&lt;/view&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!--js--&gt;//在外部import * as echarts from &#x27;../../components/ec-canvas/echarts&#x27;;const app = getApp();let chart;//在PageonLoad:function()&#123; this.initChart();&#125;/**设置图表映射 */ initChart: function (xData, yData) &#123; this.ecComponent = this.selectComponent(&#x27;#mychart&#x27;); var that = this; var option = &#123; grid: &#123; containLabel: true &#125;, tooltip: &#123;//重写图表提示内容 show: true, trigger: &#x27;axis&#x27;, position: [&#x27;50%&#x27;, &#x27;30%&#x27;], formatter: function (params) &#123; return params[0].axisValue + &#x27;: &#x27; + params[0].data + &#x27;元&#x27; &#125; &#125;, xAxis: &#123; type: &#x27;category&#x27;, name:&#x27;时间&#x27;, data: xData,//异步请求的数据 nameTextStyle: &#123; fontSize: 10 &#125;, splitLine: &#123; show: true &#125; &#125;, yAxis: &#123; type: &#x27;value&#x27;, title: &#x27;收益&#x27;, name:&#x27;元&#x27;, axisLabel: &#123; formatter: function (p) &#123;//重写y坐标数值单位 return p; &#125; &#125;, nameTextStyle: &#123; fontSize: 15 &#125; &#125;, series: [&#123; name: &#x27;总收益&#x27;, data: yData,//异步请求的数据 type: &#x27;line&#x27;, label: &#123; show: true &#125; &#125;], dataPointShape: true, //是否在图标上显示数据点标志 &#125;; //echarts会继承父元素的宽高,所以我们一定要设置echarts组件父元素的高度。 var myChart = that.ecComponent.init((canvas, width, height) =&gt; &#123; const chart = echarts.init(canvas, null, &#123; width: width, height: height, &#125;); //此处为折线图的点击事件，点击展示折点信息 chart.on(&#x27;click&#x27;, function (handler, context) &#123; var handlerValue = handler.name + &#x27; : &#x27; + handler.value+&#x27;元&#x27; wx.showToast(&#123; title: handlerValue, icon: &#x27;none&#x27;, duration: 1200, mask: true &#125;) &#125;); //给echarts 设置数据及配置项（图表类型、数据量等） chart.setOption(option); return chart; &#125;); &#125;, wxss12345&lt;!-- wxss --&gt;.echart_panel &#123; width: 100%; height: 700rpx; &#125; 5.循环渲染多选框同时根据条件显示样式​ 设定的样式至少有五种，根据选项设定的权重来显示不同的样式（大于两种）。只在网上查到了运用三目运算符，没有多想，误以为只能设置两种。后来想到可以嵌套。！ image-20220818131332986 wxml123456789101112&lt;view class=&quot;every_tab&quot;&gt; &lt;checkbox-group bindchange=&quot;checkboxChange3&quot; class=&quot;select&quot;&gt; &lt;!-- 循环时外层是items 内层的单个对象是item--&gt; &lt;label class=&quot;cell&quot; wx:for=&quot;&#123;&#123;items&#125;&#125;&quot; wx:if=&quot;&#123;&#123;index&gt;78&#125;&#125;&quot; wx:key=&quot;value&quot;&gt; &lt;!-- 三目运算符嵌套 根据items数组内对象的weight属性条件来显示样式--&gt; &lt;view class=&quot;&#123;&#123;item.weight==1?&#x27;weight1&#x27;:(item.weight==2?&#x27;weight2&#x27;:(item.weight==3?&#x27;weight3&#x27;:(item.weight==4?&#x27;weight4&#x27;:&#x27;weight5&#x27;)))&#125;&#125;&quot;&gt; &#123;&#123;item.name&#125;&#125; &lt;checkbox value=&quot;&#123;&#123;item.value&#125;&#125;&quot; checked=&quot;&#123;&#123;item.checked&#125;&#125;&quot; /&gt; &lt;/view&gt; &lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; wxss123456789101112131415161718.weigth1&#123; color: black;&#125;.weight2&#123; color: green;&#125;.weight3&#123; color: aqua;&#125;.weight3&#123; color: blue;&#125;.weight4&#123; color: blueviolet;&#125;.weight5&#123; color: purple;&#125; js12345678910111213141516171819202122232425262728data:&#123; items: [ &#123; value: &#x27;1&#x27;, weight: 1, name: &#x27;床品每客一换&#x27; &#125;, &#123; value: &#x27;2&#x27;, weight: 1, name: &#x27;行李寄存&#x27; &#125;, &#123; value: &#x27;3&#x27;, weight: 2, name: &#x27;自助入住&#x27; &#125;, &#123; value: &#x27;4&#x27;, weight: 2, name: &#x27;保安&#x27; &#125;, &#123; value: &#x27;5&#x27;, weight: 3, name: &#x27;管家式服务&#x27; &#125;, &#123; value: &#x27;6&#x27;, weight: 4, name: &#x27;床品一天一换&#x27; &#125;,&#125;, /*设施多选框 */ checkboxChange(e) &#123; console.log(&#x27;checkbox发生change事件，携带value值为：&#x27;, e.detail.value) const items = this.data.items const values = e.detail.value for (let i = 0, lenI = 6; i &lt; lenI; ++i) &#123; items[i].checked = false for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) &#123;//遍历 if (items[i].value === values[j]) &#123; items[i].checked = true; break; &#125; &#125; &#125; this.setData(&#123; items &#125;) &#125;, 6.进度条 属性 类型 默认值 必填 说明 percent number 否 百分比0~100 show-info boolean false 否 在进度条右侧显示百分比 image-20220824003057165 wxml1234&lt;view class=&quot;progress-box&quot;&gt; &lt;text &gt;进度：&lt;/text&gt; &lt;progress percent=&quot;&#123;&#123;persent&#125;&#125;&quot; show-info stroke-width=&quot;3&quot; /&gt;&lt;/view&gt; wxss1234.progress-box&#123; width:85%; margin-left:70rpx;&#125; 7.搜索框首页的搜索框，点击后进入搜索页面 image-20220824113910534.png image-20220824113842731.png Searchinput组件首先在components文件下准备一个Searchinput组件 Searchinput.wxml12345&lt;view class=&quot;search_input&quot;&gt; &lt;navigator url=&quot;/pages/search/index&quot; open-type=&quot;navigate&quot; class=&quot;Searchinput_navigator&quot;&gt; &lt;text &gt;搜索&lt;/text&gt; &lt;/navigator&gt;&lt;/view&gt; Searchinput.wxss123456789.search_input .Searchinput_navigator &#123; height: 100%; display: flex; justify-content: center; align-items: center; background-color: white; border-radius: 50rpx; color: #666;&#125; Searchinput.js不需要修改 然后再添加一个search界面 search界面search.wxml123456789101112131415161718192021222324252627&lt;view class=&quot;page&quot;&gt; &lt;view class=&quot;page__bd&quot;&gt; &lt;view class=&quot;weui-search-bar&quot;&gt; &lt;view class=&quot;weui-search-bar__form&quot;&gt; &lt;view class=&quot;weui-search-bar__box&quot;&gt; &lt;icon class=&quot;weui-icon-search_in-box&quot; type=&quot;search&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;input type=&quot;text&quot; class=&quot;weui-search-bar__input&quot; placeholder=&quot;搜索&quot; value=&quot;&#123;&#123;inputVal&#125;&#125;&quot; focus=&quot;&#123;&#123;inputShowed&#125;&#125;&quot; bindinput=&quot;inputTyping&quot; /&gt; &lt;view class=&quot;weui-icon-clear&quot; wx:if=&quot;&#123;&#123;inputVal.length &gt; 0&#125;&#125;&quot; bindtap=&quot;clearInput&quot;&gt; &lt;icon type=&quot;clear&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;label class=&quot;weui-search-bar__label&quot; hidden=&quot;&#123;&#123;inputShowed&#125;&#125;&quot; bindtap=&quot;showInput&quot;&gt; &lt;icon class=&quot;weui-icon-search&quot; type=&quot;search&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;view class=&quot;weui-search-bar__text&quot;&gt;搜索&lt;/view&gt; &lt;/label&gt; &lt;/view&gt; &lt;view class=&quot;weui-search-bar__cancel-btn&quot; hidden=&quot;&#123;&#123;!inputShowed&#125;&#125;&quot; bindtap=&quot;hideInput&quot;&gt;取消&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;weui-cells searchbar-result&quot; wx:if=&quot;&#123;&#123;inputVal.length &gt; 0&#125;&#125;&quot; wx:for=&quot;&#123;&#123;search_list1&#125;&#125;&quot; wx:key=&quot;dessay_id&quot;&gt; &lt;navigator url=&quot;/pages/essays_detail/index?essay_id=&#123;&#123;item.dessay_id&#125;&#125;&quot; class=&quot;weui-cell&quot; hover-class=&quot;weui-cell_active&quot;&gt; &lt;view class=&quot;weui-cell__bd&quot;&gt; &lt;view&gt;&#123;&#123;item.dessay_title&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; search.wxss​ 这里需要添加weui，可以上网上(或者到仓库里)找然后修改文件路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** Tencent is pleased to support the open source community by making* WeUI-WXSS available.* * Copyright (C) 2017 THL A29 Limited, a Tencent company.* All rights reserved.* * Licensed under the MIT License (the &quot;License&quot;); you may not use* this file except in compliance with the License. You may obtain a copy of* the License at* * http://opensource.org/licenses/MIT* * Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.* See the License for the specific language governing permissions and* limitations under the License.*/@import &quot;base/reset.wxss&quot;;@import &quot;widget/weui-cell/weui-cell.wxss&quot;;@import &quot;./widget/weui-searchbar/weui-searchbar.wxss&quot;;page &#123; background-color: white; padding: 20rpx;&#125;.search_row &#123; height: 60rpx; display: flex;&#125;.search_row input &#123; background-color: #dedede; flex: 1; height: 100%; padding-left: 30rpx;&#125;.search_row button &#123; background-color: white; width: 100rpx; height: 100%; font-size: 28rpx; padding: 0; margin: 0 10rpx; display: flex; justify-content: center; align-items: center;&#125;.search_content &#123; margin-top: 30rpx;&#125;.search_content .search_item &#123; background-color: white; font-size: 26rpx; padding: 15rpx 10rpx; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;&#125; search.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Page(&#123; /** * 页面的初始数据 */ data: &#123; inputVal: &#x27;&#x27;, inputShowed: false, search_list1: [], &#125;, showInput: function () &#123; this.setData(&#123; inputShowed: true &#125;); &#125;, hideInput: function () &#123; this.setData(&#123; inputVal: &quot;&quot;, inputShowed: false &#125;); &#125;, clearInput: function () &#123; this.setData(&#123; inputVal: &quot;&quot; &#125;); &#125;, inputTyping: function (e) &#123; this.setData(&#123; inputVal: e.detail.value &#125;); //连接数据库 const db = wx.cloud.database() var that = this db.collection(&#x27;essays_detail&#x27;).where(&#123; //使用正则查询，实现对搜索的模糊查询 dessay_title: db.RegExp(&#123; regexp: e.detail.value, //从搜索栏中获取的value作为规则进行匹配。 options: &#x27;i&#x27;, //大小写不区分 &#125;), &#125;).limit(10).get(&#123; success: res =&gt; &#123; that.setData(&#123; search_list1: res.data &#125;) &#125; &#125;) &#125; &#125;) 8.分类栏image-20220824115856124.png 在component文件夹下准备Cater组件： Cater.wxml1234567&lt;view&gt;&lt;scroll-view class=&quot;tab-list&quot; scroll-x scroll-with-animation&gt;&lt;view wx:for=&quot;&#123;&#123;tabs&#125;&#125;&quot; wx:key=&quot;id&quot; class=&quot;tab-item &#123;&#123;item.isActive ? &#x27;active&#x27;:&#x27;&#x27;&#125;&#125;&quot; data-index=&quot;&#123;&#123;index&#125;&#125;&quot; bindtap=&quot;handleItemTap&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;&lt;/scroll-view&gt;&lt;slot&gt;&lt;/slot&gt; &lt;/view&gt; Cater.wxss12345678910111213141516171819202122.tab-list &#123; width: 100%; height: 88rpx; border-bottom: 1rpx solid #e5e5e5; display: inline-block; white-space: nowrap; &#125; .tab-item &#123; width: 188rpx; height: 85rpx; display: inline-block; line-height: 85rpx; vertical-align: middle; text-align: center; &#125; .active &#123; color: red; border-bottom: 5rpx solid red; &#125; Cater.js123456789101112131415161718192021222324252627282930313233343536Component(&#123; properties:&#123; tabs:&#123; type:Array, value:[] &#125; &#125;, data: &#123; &#125;, //组件.js存放事件回到函数在methods中 methods:&#123; handleItemTap(e)&#123; /* 1 1 绑定点击事件 2 获取被点击的索引 3 获取原数组 4 对数组循环 1 给每一个循环性 选中属性 改为 false 2 给 当前的索引的 项添加激活选中效果就可以了 */ // 2 获取索引 const &#123;index&#125;=e.currentTarget.dataset; // 传递事件给父组件 this.triggerEvent(&quot;itemChange&quot;,&#123;index&#125;); // 3 获取data中的数组 // 解构 对 复杂类型进行结构 复制了一份 变量引用而已 let &#123;tabs&#125;=this.data; // 4 循环数组 tabs.forEach((v,i) =&gt;i===index?v.isActive=true:v.isActive=false ) this.setData(&#123; tabs &#125;) &#125;, &#125; &#125;) 然后在需要添加分类栏的界面： index.json先引入Cater组件 12345678910&#123; &quot;usingComponents&quot;: &#123; &quot;Cater&quot;:&quot;../../components/Cater/Cater&quot; &#125;, &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;enablePullDownRefresh&quot;:true, &quot;onReachBottomDistance&quot;:50, &quot;backgroundColor&quot;: &quot;#efefef&quot;, &quot;backgroundTextStyle&quot;: &quot;dark&quot;&#125; index.wxml12345&lt;!-- 分类栏 --&gt; &lt;Cater tabs=&quot;&#123;&#123;tabs&#125;&#125;&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Cater&gt; &lt;!-- 以下根据点击分类呈现相应的内容显示在block中--&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[0].isActive&#125;&#125;&quot;&gt;&lt;/block&gt; &lt;block wx:if=&quot;&#123;&#123;tabs[1].isActive&#125;&#125;&quot;&gt;&lt;/block&gt; index.js1234567891011121314151617181920212223242526272829303132data: &#123; tabs: [&#123; id: 1, name: &quot;推荐&quot;, isActive:true &#125;, &#123; id: 2, name: &quot;文创&quot;, isActive:false &#125;, &#123; id: 3, name: &quot;时装&quot;, isActive:false &#125;, &#123; id: 4, name: &quot;节目&quot;, isActive:false &#125; ] &#125;,handleItemChange(e)&#123; const &#123;index&#125;=e.detail; let &#123;tabs&#125;=this.data; // 4 循环数组 tabs.forEach((v,i) =&gt;i===index?v.isActive=true:v.isActive=false ) this.setData(&#123; tabs &#125;) &#125;, 9.地图颜色块图例颜色快图例.png wxml123456789101112131415161718&lt;!-- 图例 --&gt; &lt;view class=&quot;btm_tool&quot;&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label1&quot;&gt;111&lt;/view&gt;&lt;view &gt;1级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label2&quot;&gt;111&lt;/view&gt;&lt;view &gt;2级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label3&quot;&gt;111&lt;/view&gt;&lt;view &gt;3级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label4&quot;&gt;111&lt;/view&gt;&lt;view &gt;4级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label5&quot;&gt;111&lt;/view&gt;&lt;view &gt;5级&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; wxss1234567891011121314151617181920.btm_tool &#123; border-top: 1rpx #ccc; position: fixed; left: 0; bottom: 20rpx; width: 100%; height: 100rpx; background-color: #fff; display: flex; z-index:200;&#125;.btm_tool .tool_item &#123; flex: 6; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; font-size: 20px;&#125; 10.收藏功能​ 在文章详情页点击“收藏”，就会在收藏夹”喜爱“界面出现文章的入口。 image-20220824115856124.png image-20220824115546637.png image-20220824115827795.png 在需要添加收藏功能的页面： wxml12345&lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;iconfont &#123;&#123;isCollect?&#x27;icon-shoucang1&#x27;:&#x27;icon-shoucang&#x27;&#125;&#125;&quot; bindtap=&quot;handleCollect&quot;&gt;&lt;/view&gt; &lt;view&gt;收藏&lt;/view&gt;&lt;/view&gt; wxss1234567891011.tool_item &#123; flex: 2; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative;&#125;.tool_item .icon-shoucang1 &#123; color: orange;&#125; js1234567891011121314151617181920212223242526272829303132333435363738394041 data: &#123; // 是否被收藏 isCollect:false, &#125;,// 点击收藏图标 handleCollect()&#123; let isCollect=false; // 1 获取缓存中的收藏数组 let collect=wx.getStorageSync(&quot;collect&quot;)||[]; // 2 判断文章是否被收藏过 let index=collect.findIndex(v=&gt;v.dessay_id===this.EssaysInfo.dessay_id) // 3 当index!=-1 表示已经收藏过了 if(index!==-1)&#123; // 已经收藏过了 在数组中删除 collect.splice(index,1); isCollect=false; // 弹窗提示 wx.showToast(&#123; title: &#x27;取消成功&#x27;, icon: &#x27;success&#x27;, mask: true &#125;); &#125;else&#123; // 没有收藏过 添加 collect.push(this.EssaysInfo); isCollect=true; // 弹窗提示 wx.showToast(&#123; title: &#x27;收藏成功&#x27;, icon: &#x27;success&#x27;, mask: true &#125;); &#125; // 4 把数组存入到缓存中 wx.setStorageSync(&quot;collect&quot;,collect); // 5 修改data中的属性 isCollect this.setData(&#123; isCollect &#125;) &#125;, 然后在收藏夹界面： wxml12345678910111213141516&lt;view&gt; &lt;navigator class=&quot;essays_item&quot; wx:for=&quot;&#123;&#123;collect&#125;&#125;&quot; wx:key=&quot;essay_id&quot; url=&quot;/pages/essays_detail/index?essay_id=&#123;&#123;item.dessay_id&#125;&#125;&quot;&gt; &lt;!-- 左侧图片 --&gt; &lt;view class=&quot;essays_img_wrap&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;item.dessay_img&#125;&#125;&quot;/&gt; &lt;/view&gt; &lt;!-- 右侧标题 --&gt; &lt;view class=&quot;essays_info_wrap&quot;&gt; &lt;view class=&quot;essays_title&quot;&gt;&#123;&#123;item.dessay_title&#125;&#125;&lt;/view&gt; &lt;view class=&quot;essays_src&quot;&gt;&#123;&#123;item.dessay_src&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; wxss1234567891011121314151617181920212223242526272829303132333435/* pages/like/index.wxss */page &#123; background-color: #f3f4f6;&#125;.essays_item &#123; display: flex; border-bottom: 1px solid #ccc;&#125;.essays_item .essays_img_wrap &#123; width: 70%; flex: 2; display: flex; justify-content: center; align-items: center; height: 300rpx;&#125;.essays_item .essays_img_wrap image &#123; width: 70%;&#125;.essays_item .essays_info_wrap &#123; flex: 3; display: flex; flex-direction: column; justify-content: space-around;&#125;.essays_item .essays_info_wrap .essays_title &#123; font-family: cursive; font-size: 45rpx; font-weight: bold; color: #000;&#125;.essays_item .essays_info_wrap .essays_src &#123; color: #dedede;&#125; js1234567891011121314151617// pages/like/index.jsPage(&#123; /** * 页面的初始数据 */ data: &#123; collect:[] &#125;, onShow()&#123; const collect= wx.getStorageSync(&quot;collect&quot;)||[]; this.setData(&#123; collect &#125;); &#125; &#125;) 图标还需要引入一下 app.wxss1@import &quot;./styles/iconfont.wxss&quot;; iconfont.wxss1234567891011121314151617181920212223@font-face &#123; font-family: &quot;iconfont&quot;; /* Project id 3280754 */ src: url(&#x27;//at.alicdn.com/t/font_3280754_152au8amv0n.woff2?t=1650717301641&#x27;) format(&#x27;woff2&#x27;), url(&#x27;//at.alicdn.com/t/font_3280754_152au8amv0n.woff?t=1650717301641&#x27;) format(&#x27;woff&#x27;), url(&#x27;//at.alicdn.com/t/font_3280754_152au8amv0n.ttf?t=1650717301641&#x27;) format(&#x27;truetype&#x27;);&#125;.iconfont &#123; font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;.icon-shoucang:before &#123; content: &quot;\\e8b9&quot;;&#125;.icon-shoucang1:before &#123; content: &quot;\\e8c6&quot;;&#125; 11.循环渲染板块image.png 12345678910&lt;view class=&quot;box1&quot; wx:for=&quot;&#123;&#123;achievement&#125;&#125;&quot; wx:key=&quot;item&quot;&gt; &lt;view class=&quot;success_img_wrap&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;&#123;&#123;item.img&#125;&#125;&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;success_info_wrap&quot; &gt; &lt;view class=&quot;success_title&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 12345678910111213141516171819202122232425262728293031.box1 &#123; display: flex; border-bottom: 1px solid #ccc;&#125;.success_img_wrap &#123; width: 60%; flex: 2; display: flex; justify-content: center; align-items: center; height: 250rpx;&#125;.success_img_wrap image &#123; width: 50%;&#125;.success_info_wrap &#123; flex: 3; display: flex; flex-direction: column; justify-content: space-around;&#125;.success_title &#123; font-family: cursive; font-size: 40rpx; font-weight: bold; color: #000;&#125; 地图相关获取中心点坐标12345678910111213141516//监听拖动地图，拖动结束根据中心点更新页面 mapChange: function (e) &#123; let self = this; if (e.type == &#x27;end&#x27; &amp;&amp; (e.causedBy == &#x27;scale&#x27; || e.causedBy == &#x27;drag&#x27;))&#123;\tself.mapCtx.getCenterLocation(&#123;\tsuccess: function (res) &#123;\tself.setData(&#123;\tnearList:[]， latitude: res.latitude,\tlongitude: res.longitude,\t&#125;)\tself.nearby_search();\t&#125; &#125;) &#125; 微信小程序——打开地图 选择位置 完整功能实现代码(定位，检索周边，可移动选点，可搜索，腾讯地图API)源码： CSDN: 微信小程序——打开地图选择位置信息完整功能实现代码(定位，可移动选点，可搜索，腾讯地图API)_微信小程序打开地图标点收藏-HTML5代码类资源-CSDN下载 github: https://github.com/mcky1928/map 效果： wxml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!--pages/shopMap/shopMap.wxml--&gt;&lt;!--绑定点击事件--&gt;&lt;!--绑定输入事件--&gt;&lt;view wx:if=&quot;&#123;&#123;addListShow&#125;&#125;&quot;&gt;&lt;view class=&quot;top&quot;&gt; &lt;view class=&quot;back iconfont icon-fanhui&quot; bindtap=&quot;back1&quot;&gt;&lt;/view&gt; &lt;view class=&quot;search-box &#123;&#123;addListShow?&#x27;search-box1&#x27;:&#x27;&#x27;&#125;&#125;&quot;&gt; &lt;view class=&quot;region&quot; bindtap=&quot;chooseCity&quot;&gt;&#123;&#123;currentRegion.district&#125;&#125;&lt;/view&gt; &lt;view class=&quot;shu&quot;&gt;&lt;/view&gt; &lt;input bindinput=&quot;getsuggest&quot; placeholder=&quot;请输入您的店铺地址&quot;&gt;&lt;/input&gt; &lt;/view&gt;&lt;/view&gt;&lt;!--关键词输入提示列表渲染--&gt;&lt;view class=&quot;add-list-box&quot;&gt;&lt;scroll-view class=&quot;add-list&quot; scroll-y&gt; &lt;view class=&quot;add-item&quot; wx:for=&quot;&#123;&#123;suggestion&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;!--绑定回填事件--&gt; &lt;view bindtap=&quot;backfill&quot; id=&quot;&#123;&#123;index&#125;&#125;&quot; data-name=&quot;&#123;&#123;item.title&#125;&#125;&quot;&gt; &lt;!--根据需求渲染相应数据--&gt; &lt;!--渲染地址title--&gt; &lt;view class=&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;!--渲染详细地址--&gt; &lt;view class=&quot;add&quot;&gt;&#123;&#123;item.addr&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt;&lt;/view&gt;&lt;/view&gt; &lt;view wx:if=&quot;&#123;&#123;!addListShow &amp;&amp; !chooseCity&#125;&#125;&quot;&gt;&lt;!--地图容器--&gt;&lt;map id=&quot;myMap&quot; style=&quot;width:100%;height:300px;&quot; longitude=&quot;&#123;&#123;longitude&#125;&#125;&quot; latitude=&quot;&#123;&#123;latitude&#125;&#125;&quot; scale=&quot;17&quot; bindregionchange=&quot;mapChange&quot;&gt; &lt;cover-view class=&quot;top&quot;&gt; &lt;cover-view class=&quot;back&quot; bindtap=&quot;back1&quot;&gt; &lt;cover-image src=&quot;../../images/back.png&quot;&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;cover-view class=&quot;search-box&quot;&gt; &lt;cover-view class=&quot;region&quot; bindtap=&quot;chooseCity&quot;&gt;&#123;&#123;currentRegion.district&#125;&#125;&lt;/cover-view&gt; &lt;cover-view class=&quot;shu&quot;&gt;&lt;/cover-view&gt; &lt;cover-view class=&quot;placeholder&quot; bindtap=&quot;showAddList&quot;&gt;请输入您的店铺地址&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class=&quot;map-prompt&quot;&gt;您可拖动地图, 标记店铺准确位置&lt;/cover-view&gt; &lt;cover-image class=&quot;current-site-icon&quot; src=&quot;../../images/my_marker.png&quot;&gt;&lt;/cover-image&gt; &lt;cover-view class=&quot;reload&quot; bindtap=&quot;reload&quot;&gt; &lt;cover-view class=&quot;center1&quot;&gt; &lt;cover-view class=&quot;center2&quot;&gt;&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt;&lt;/map&gt; &lt;scroll-view class=&quot;near-list&quot; scroll-y&gt; &lt;!--绑定回填事件--&gt; &lt;view class=&quot;near-item&quot; wx:for=&quot;&#123;&#123;nearList&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;view class=&quot;current-site iconfont icon-location&quot; wx:if=&quot;&#123;&#123;index == selectedId &#125;&#125;&quot;&gt;&lt;/view&gt; &lt;!--根据需求渲染相应数据--&gt; &lt;view bindtap=&quot;chooseCenter&quot; id=&quot;&#123;&#123;index&#125;&#125;&quot; data-name=&quot;&#123;&#123;item.title&#125;&#125;&quot;&gt; &lt;!--渲染地址title--&gt; &lt;view class=&quot;title &#123;&#123; index == selectedId?&#x27;title1&#x27;:&#x27;&#x27; &#125;&#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/view&gt; &lt;!--渲染详细地址--&gt; &lt;view class=&quot;add &#123;&#123; index == selectedId?&#x27;add1&#x27;:&#x27;&#x27; &#125;&#125;&quot;&gt;&#123;&#123;item.addr&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt;&lt;view class=&quot;bottom-box&quot;&gt; &lt;button bindtap=&quot;selectedOk&quot;&gt;确认地址&lt;/button&gt;&lt;/view&gt;&lt;/view&gt; &lt;view class=&quot;region-box&quot; wx:if=&quot;&#123;&#123;chooseCity&#125;&#125;&quot;&gt; &lt;view class=&quot;region-top&quot;&gt; &lt;view class=&quot;region-back iconfont icon-fanhui&quot; bindtap=&quot;back2&quot;&gt;&lt;/view&gt; &lt;view class=&quot;title&quot;&gt;选择城市&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-tabs&quot;&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showProvince&quot;&gt;&#123;&#123;currentProvince&#125;&#125;&lt;/text&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showCity&quot; wx:if=&quot;&#123;&#123;!regionShow.province&#125;&#125;&quot; bindtap=&quot;showCity&quot;&gt;&#123;&#123;currentCity&#125;&#125;&lt;/text&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showDistrict&quot; wx:if=&quot;&#123;&#123;regionShow.district&#125;&#125;&quot; bindtap=&quot;showDistrict&quot;&gt;&#123;&#123;currentDistrict&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;scroll-view scroll-y style=&quot;height:1050rpx;&quot;&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;&#123;&#123;regionShow.province&#125;&#125;&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;&#123;&#123;regionData.province&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot; data-name=&quot;&#123;&#123;item.fullname&#125;&#125;&quot; bindtap=&quot;selectProvince&quot;&gt; &lt;text&gt;&#123;&#123;item.fullname&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;&#123;&#123;regionShow.city&#125;&#125;&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;&#123;&#123;regionData.city&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot; data-name=&quot;&#123;&#123;item.fullname&#125;&#125;&quot; bindtap=&quot;selectCity&quot;&gt; &lt;text&gt;&#123;&#123;item.fullname&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;&#123;&#123;regionShow.district&#125;&#125;&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;&#123;&#123;regionData.district&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;&#123;&#123;item.id&#125;&#125;&quot; data-name=&quot;&#123;&#123;item.fullname&#125;&#125;&quot; data-latitude=&quot;&#123;&#123;item.location.lat&#125;&#125;&quot; data-longitude=&quot;&#123;&#123;item.location.lng&#125;&#125;&quot; bindtap=&quot;selectDistrict&quot;&gt; &lt;text&gt;&#123;&#123;item.fullname&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/* pages/shopMap/shopMap.wxss */@import &quot;../../lib/css/iconfont.wxss&quot;; .top &#123; width: 100%; height: 80rpx; line-height: 80rpx; position: fixed; top: 0; left: 0; padding: 30rpx 20rpx; z-index: 999; overflow: hidden;&#125;.back &#123; width: 80rpx; height: 80rpx; line-height: 80rpx; color: #666; text-align: center; background: rgb(255,255,255); font-size: 50rpx; border-radius: 50%; float: left;&#125;.back cover-image&#123; width: 50rpx; height: 50rpx; display: inline-block; margin-top: 15rpx;&#125;.search-box &#123; width: 610rpx; height: 80rpx; line-height: 80rpx; border-radius: 40rpx; background: rgb(255,255,255); margin-left: 20rpx; float: left; overflow: hidden;&#125;.search-box1 &#123; border: 1px solid #ccc; border-radius: 10rpx; background: #eee;&#125;.search-box .region &#123; width: 199rpx; line-height: 80rpx; font-size: 30rpx; color: #282828; text-align: center; float: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.search-box .shu &#123; width: 1rpx; height: 80rpx; background:#ccc; float: left;&#125;.search-box input &#123; width: 380rpx; height: 80rpx; line-height: 80rpx; font-size: 30rpx; color: #282828; padding: 10rpx 20rpx; box-sizing: border-box; float: left;&#125;.search-box .placeholder&#123; width: 380rpx; height: 80rpx; line-height: 80rpx; font-size: 30rpx; color: #ccc; padding: 0 20rpx; box-sizing: border-box; float: left;&#125;.add-list-box &#123; position: absolute; width: 100%; height: 100%; top: 0; z-index: 998; padding-top: 150rpx; background: #fff; box-sizing: border-box; overflow: hidden;&#125;.add-list &#123; width: 100%; height: 1000rpx;&#125;.add-item &#123; line-height: 40rpx; padding: 30rpx 50rpx; text-align: left; border-top: 1px solid #eee;&#125;.add-item .title &#123; color: #282828; font-size: 32rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.add-item .add &#123; color: #707070; font-size: 24rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.current-site-icon &#123; width: 50rpx; height: 50rpx; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125;.near-list &#123; height: 650rpx; padding-bottom: 100rpx; box-sizing: border-box;&#125;.near-item &#123; line-height: 40rpx; padding: 30rpx 50rpx 30rpx 90rpx; text-align: left; border-bottom: 1px solid #eee; position: relative;&#125;.current-site &#123; font-size: 40rpx; color: #3095F9; position: absolute; top: 40rpx; left: 30rpx;&#125;.near-item .title &#123; color: #282828; font-size: 32rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.near-item .add &#123; color: #707070; font-size: 24rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.near-item .title1 &#123; color: #3095F9;&#125;.near-item .add1 &#123; color: #3095F9;&#125;.bottom-box &#123; width: 100%; padding: 20rpx; background: #fff; box-sizing: border-box; position: fixed; left: 0; bottom: 0; z-index: 88; overflow: hidden;&#125;.bottom-box button&#123; width: 100%; height: 80rpx; line-height: 80rpx; border: none; background: #3095F9; color: #fff; font-size: 36rpx;&#125; .region-box &#123; width: 100%; height: 100%; background: #FFF; position: fixed; top: 0; left: 0; z-index: 1001;&#125;.region-box .region-top &#123; position: relative; font-size: 40rpx; color: #282828; font-weight: bold; line-height: 100rpx; text-align: center;&#125;.region-box .region-back &#123; width: 80rpx; height: 80rpx; font-size: 50rpx; text-align: center; position: absolute; top: 0; left: 0;&#125;.region-box .region-tabs&#123; line-height: 60rpx; font-size: 20rpx;&#125;.region-tabs .tab &#123; min-width: 100rpx; max-width: 200rpx; line-height: 40rpx; font-size: 20rpx; color: #3095F9; text-align: center; border: 1rpx solid #3095F9; border-radius: 20rpx; display: inline-block; margin: 20rpx 0 20rpx 20rpx; padding: 3rpx 20rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;&#125;.region-list .region-item&#123; font-size: 30rpx; color: #282828; line-height: 80rpx; padding: 10rpx 30rpx; border-top: 1rpx solid #eee;&#125; .map-prompt &#123; width: 420rpx; height: 60rpx; line-height: 60rpx; font-size: 24rpx; color: #707070; text-align: center; background: #fff; border-radius: 10rpx; box-shadow: 0 0 10rpx rgba(0,0,0,0.1); position: absolute; bottom: 40rpx; left: 50%; transform: translate(-50%,0);&#125;.reload &#123; width: 80rpx; height: 80rpx; background: #fff; border-radius: 50%; box-shadow: 0 0 10rpx rgba(0,0,0,0.1); position: absolute; bottom: 30rpx; right: 30rpx;&#125;.reload .center1 &#123; width: 30rpx; height: 30rpx; border: 1rpx solid #3095F9; border-radius: 50%; margin: 24rpx auto;&#125;.reload .center2 &#123; width: 25rpx; height: 25rpx; background: #3095F9; border-radius: 50%; margin: 3rpx auto;&#125; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528var QQMapWX = require(&#x27;../../utils/qqmap-wx-jssdk1.2/qqmap-wx-jssdk.min.js&#x27;);var qqmapsdk;Page(&#123; data: &#123; addListShow: false, chooseCity: false, regionShow: &#123; province: false, city: false, district: true &#125;, regionData: &#123;&#125;, currentRegion: &#123; province: &#x27;选择城市&#x27;, city: &#x27;选择城市&#x27;, district: &#x27;选择城市&#x27;, &#125;, currentProvince: &#x27;选择城市&#x27;, currentCity: &#x27;选择城市&#x27;, currentDistrict: &#x27;选择城市&#x27;, latitude: &#x27;&#x27;, longitude: &#x27;&#x27;, centerData: &#123;&#125;, nearList: [], suggestion: [], selectedId: 0, defaultKeyword: &#x27;房产小区&#x27;, keyword: &#x27;&#x27; &#125;, onLoad: function () &#123; let self =this; self.mapCtx = wx.createMapContext(&#x27;myMap&#x27;) // 实例化API核心类 qqmapsdk = new QQMapWX(&#123; key: &#x27;W57BZ-JDB6X-XPA4H-Z76MI-73FF2-24BT4&#x27; &#125;); wx.showLoading(&#123; title: &#x27;加载中&#x27; &#125;); //定位 wx.getLocation(&#123; type: &#x27;wgs84&#x27;, success(res) &#123; //console.log(res) const latitude = res.latitude const longitude = res.longitude const speed = res.speed const accuracy = res.accuracy //你地址解析 qqmapsdk.reverseGeocoder(&#123; location: &#123; latitude: latitude, longitude: longitude &#125;, success: function (res) &#123; //console.log(res) self.setData(&#123; latitude: latitude, longitude: longitude, currentRegion: res.result.address_component, keyword: self.data.defaultKeyword &#125;) // 调用接口 self.nearby_search(); &#125;, &#125;); &#125;, fail(err) &#123; //console.log(err) wx.hideLoading(&#123;&#125;); wx.showToast(&#123; title: &#x27;定位失败&#x27;, icon: &#x27;none&#x27;, duration: 1500 &#125;) setTimeout(function () &#123; wx.navigateBack(&#123; delta: 1 &#125;) &#125;, 1500) &#125; &#125;) &#125;, onReady: function () &#123; &#125;, //监听拖动地图，拖动结束根据中心点更新页面 mapChange: function (e) &#123; let self = this; if (e.type == &#x27;end&#x27; &amp;&amp; (e.causedBy == &#x27;scale&#x27; || e.causedBy == &#x27;drag&#x27;))&#123; self.mapCtx.getCenterLocation(&#123; success: function (res) &#123; //console.log(res) self.setData(&#123; nearList:[], latitude: res.latitude, longitude: res.longitude, &#125;) self.nearby_search(); &#125; &#125;) &#125; &#125;, //重新定位 reload: function () &#123; this.onLoad(); &#125;, //整理目前选择省市区的省市区列表 getRegionData: function () &#123; let self = this; //调用获取城市列表接口 qqmapsdk.getCityList(&#123; success: function (res) &#123;//成功后的回调 //console.log(res) let provinceArr = res.result[0]; let cityArr = []; let districtArr = []; for (var i = 0; i &lt; provinceArr.length; i++) &#123; var name = provinceArr[i].fullname; if (self.data.currentRegion.province == name) &#123; if (name == &#x27;北京市&#x27; || name == &#x27;天津市&#x27; || name == &#x27;上海市&#x27; || name == &#x27;重庆市&#x27;) &#123; cityArr.push(provinceArr[i]) &#125; else &#123; qqmapsdk.getDistrictByCityId(&#123; // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: provinceArr[i].id, success: function (res) &#123;//成功后的回调 //console.log(res); cityArr = res.result[0]; self.setData(&#123; regionData: &#123; province: provinceArr, city: cityArr, district: districtArr &#125; &#125;) &#125;, fail: function (error) &#123; //console.error(error); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125; &#125; &#125; for (var i = 0; i &lt; res.result[1].length; i++) &#123; var name = res.result[1][i].fullname; if (self.data.currentRegion.city == name) &#123; qqmapsdk.getDistrictByCityId(&#123; // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: res.result[1][i].id, success: function (res) &#123;//成功后的回调 //console.log(res); districtArr = res.result[0]; self.setData(&#123; regionData: &#123; province: provinceArr, city: cityArr, district: districtArr &#125; &#125;) &#125;, fail: function (error) &#123; //console.error(error); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125; &#125; &#125;, fail: function (error) &#123; //console.error(error); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125;, onShow: function () &#123; let self = this; &#125;, //地图标记点 addMarker: function (data) &#123; //console.log(data) //console.log(data.title) var mks = []; mks.push(&#123; // 获取返回结果，放到mks数组中 title: data.title, id: data.id, addr: data.addr, province: data.province, city: data.city, district: data.district, latitude: data.latitude, longitude: data.longitude, iconPath: &quot;/images/my_marker.png&quot;, //图标路径 width: 25, height: 25 &#125;) this.setData(&#123; //设置markers属性，将搜索结果显示在地图中 markers: mks, currentRegion: &#123; province: data.province, city: data.city, district: data.district, &#125; &#125;) wx.hideLoading(&#123;&#125;); &#125;, //点击选择搜索结果 backfill: function (e) &#123; var id = e.currentTarget.id; let name = e.currentTarget.dataset.name; for (var i = 0; i &lt; this.data.suggestion.length; i++) &#123; if (i == id) &#123; //console.log(this.data.suggestion[i]) this.setData(&#123; centerData: this.data.suggestion[i], addListShow: false, latitude: this.data.suggestion[i].latitude, longitude: this.data.suggestion[i].longitude &#125;); this.nearby_search(); return; //console.log(this.data.centerData) &#125; &#125; &#125;, //点击选择地图下方列表某项 chooseCenter: function (e) &#123; var id = e.currentTarget.id; let name = e.currentTarget.dataset.name; for (var i = 0; i &lt; this.data.nearList.length; i++) &#123; if (i == id) &#123; this.setData(&#123; selectedId: id, centerData: this.data.nearList[i], latitude: this.data.nearList[i].latitude, longitude: this.data.nearList[i].longitude, &#125;); this.addMarker(this.data.nearList[id]); return; //console.log(this.data.centerData) &#125; &#125; &#125;, //显示搜索列表 showAddList: function () &#123; this.setData(&#123; addListShow: true &#125;) &#125;, // 根据关键词搜索附近位置 nearby_search: function () &#123; var self = this; wx.hideLoading(); wx.showLoading(&#123; title: &#x27;加载中&#x27; &#125;); // 调用接口 qqmapsdk.search(&#123; keyword: self.data.keyword, //搜索关键词 //boundary: &#x27;nearby(&#x27; + self.data.latitude + &#x27;, &#x27; + self.data.longitude + &#x27;, 1000, 16)&#x27;, location: self.data.latitude + &#x27;,&#x27; + self.data.longitude, page_size: 20, page_index: 1, success: function (res) &#123; //搜索成功后的回调 //console.log(res.data) var sug = []; for (var i = 0; i &lt; res.data.length; i++) &#123; sug.push(&#123; // 获取返回结果，放到sug数组中 title: res.data[i].title, id: res.data[i].id, addr: res.data[i].address, province: res.data[i].ad_info.province, city: res.data[i].ad_info.city, district: res.data[i].ad_info.district, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng &#125;); &#125; self.setData(&#123; selectedId: 0, centerData: sug[0], nearList: sug, suggestion: sug &#125;) self.addMarker(sug[0]); &#125;, fail: function (res) &#123; //console.log(res); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125;, //根据关键词搜索匹配位置 getsuggest: function (e) &#123; var _this = this; var keyword = e.detail.value; _this.setData(&#123; addListShow: true &#125;) //调用关键词提示接口 qqmapsdk.getSuggestion(&#123; //获取输入框值并设置keyword参数 keyword: keyword, //用户输入的关键词，可设置固定值,如keyword:&#x27;KFC&#x27; location: _this.data.latitude + &#x27;,&#x27; + _this.data.longitude, page_size: 20, page_index: 1, //region:&#x27;北京&#x27;, //设置城市名，限制关键词所示的地域范围，非必填参数 success: function (res) &#123;//搜索成功后的回调 //console.log(res); var sug = []; for (var i = 0; i &lt; res.data.length; i++) &#123; sug.push(&#123; // 获取返回结果，放到sug数组中 title: res.data[i].title, id: res.data[i].id, addr: res.data[i].address, province: res.data[i].province, city: res.data[i].city, district: res.data[i].district, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng &#125;); &#125; _this.setData(&#123; //设置suggestion属性，将关键词搜索结果以列表形式展示 suggestion: sug, nearList: sug, keyword: keyword &#125;); &#125;, fail: function (error) &#123; //console.error(error); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125;, //打开选择省市区页面 chooseCity: function () &#123; let self = this; self.getRegionData(); self.setData(&#123; chooseCity: true, regionShow: &#123; province: false, city: false, district: true &#125;, currentProvince: self.data.currentRegion.province, currentCity: self.data.currentRegion.city, currentDistrict: self.data.currentRegion.district, &#125;) &#125;, //选择省 showProvince: function () &#123; this.setData(&#123; regionShow: &#123; province: true, city: false, district: false &#125; &#125;) &#125;, //选择城市 showCity: function () &#123; this.setData(&#123; regionShow: &#123; province: false, city: true, district: false &#125; &#125;) &#125;, //选择地区 showDistrict: function () &#123; this.setData(&#123; regionShow: &#123; province: false, city: false, district: true &#125; &#125;) &#125;, //选择省之后操作 selectProvince: function (e) &#123; //console.log(e) let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; self.setData(&#123; currentProvince: name, currentCity: &#x27;请选择城市&#x27;, &#125;) if (name == &#x27;北京市&#x27; || name == &#x27;天津市&#x27; || name == &#x27;上海市&#x27; || name == &#x27;重庆市&#x27;)&#123; var provinceArr = self.data.regionData.province; var cityArr = []; for (var i = 0; i &lt; provinceArr.length;i++)&#123; if(provinceArr[i].fullname == name)&#123; cityArr.push(provinceArr[i]) self.setData(&#123; regionData: &#123; province: self.data.regionData.province, city: cityArr, district: self.data.regionData.district &#125; &#125;) self.showCity(); return; &#125; &#125; &#125;else&#123; let bj = self.data.regionShow; self.getById(id, name, bj) &#125; &#125;, //选择城市之后操作 selectCity: function (e) &#123; let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; self.setData(&#123; currentCity: name, currentDistrict: &#x27;请选择城市&#x27;, &#125;) let bj = self.data.regionShow; self.getById(id, name, bj) &#125;, //选择区县之后操作 selectDistrict: function (e) &#123; let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; let latitude = e.currentTarget.dataset.latitude; let longitude = e.currentTarget.dataset.longitude; self.setData(&#123; currentDistrict: name, latitude: latitude, longitude: longitude, currentRegion: &#123; province: self.data.currentProvince, city: self.data.currentCity, district: name &#125;, chooseCity: false, keyword: self.data.defaultKeyword &#125;) self.nearby_search(); &#125;, //根据选择省市加载市区列表 getById: function (id,name,bj) &#123; let self = this; qqmapsdk.getDistrictByCityId(&#123; // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: id, //对应接口getCityList返回数据的Id，如：北京是&#x27;110000&#x27; success: function (res) &#123;//成功后的回调 //console.log(res); if(bj.province)&#123; self.setData(&#123; regionData: &#123; province: self.data.regionData.province, city: res.result[0], district: self.data.regionData.district &#125; &#125;) self.showCity(); &#125; else if (bj.city) &#123; self.setData(&#123; regionData: &#123; province: self.data.regionData.province, city: self.data.regionData.city, district: res.result[0] &#125; &#125;) self.showDistrict(); &#125; else &#123; self.setData(&#123; chooseCity: false, &#125;) &#125; &#125;, fail: function (error) &#123; //console.error(error); &#125;, complete: function (res) &#123; //console.log(res); &#125; &#125;); &#125;, //返回上一页或关闭搜索页面 back1: function () &#123; if (this.data.addListShow) &#123; this.setData(&#123; addListShow: false &#125;) &#125;else &#123; wx.navigateBack(&#123; delta: 1 &#125;) &#125; &#125;, //关闭选择省市区页面 back2: function () &#123; this.setData(&#123; chooseCity: false &#125;) &#125;, //确认选择地址 selectedOk: function () &#123; let pages = getCurrentPages(); //获取当前页面js里面的pages里的所有信息。 let prevPage = pages[pages.length - 2]; //console.log(this.data.centerData) prevPage.setData(&#123; storeAddress: this.data.centerData.title &#125;) wx.navigateBack(&#123; delta: 1 &#125;) &#125;&#125;) 引用的阿里图标 iconfont.wxss 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@font-face &#123;font-family: &quot;iconfont&quot;; src: url(&#x27;//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999&#x27;); /* IE9 */ src: url(&#x27;//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999#iefix&#x27;) format(&#x27;embedded-opentype&#x27;), /* IE6-IE8 */ url(&#x27;data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAgQAAsAAAAADnAAAAfAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCEIAqOMIwEATYCJAMoCxYABCAFhG0HgRsbZQxRlG9SkOzjMG74SoiyxOJKUQ6m+GaJv3j4fr//rb3Puf7FEE2iUTWqZhKe6QwJGo1EowRIJKYTkmfym3/ctJ8wScURvVFxQm2q0AnUsDdqSBIoEnSiYcrKRJQyE0dmdpyI9Ofv92oXzfKu7buc91//yqZV86fheECRDT6QAB0gzH3LdJLMDLxi+q3XExhtJwJdlIxTAERFeQEpT8yEDiA+uZrSGnpRG3NsFe9Bo8+38D0AvDM/H/9AZSCkpqAHXXs8ygiG/hRvpFGdFFUCiPq0uG5EwQFAvQo/xUo+AuDHu51mzK5eAdakI1vxN0iJp8Wz4py4MD4mfjf+qLOTmNFp8bDG9EAZ67+8Kg06rYZoIX8OKl8HBn4CMULhZ8oIPT/TRgh+Zo1Q+ckZIfkpxOsQjAGpDgRqkGpB0Aj4vtAzqmPWAPuBPAqUbajwksmvUtgK2i/nCnlmmenJyRnJKXwkgcNBUhGELiVJqQ6cXSlIMsI/LqELKyMlRRfk4geiUCymjkSUVFhkXItj0KoAi4hB0agqHFZQOkMkHRQOj78WFm6LjLoZy90etVyxCO+qXYEO1u/e0ajmRjRnR0x6PZK9NWwg8PUXe2GrKLrxxIGp26OVXCJVJeb2ssOUklNECiXdrbyjMdxlFfGMRub71Mq1FEcL5dES+gZsFa9sDYs1gDVWSaUKrOWxKG4rBHR6lgcnrT9TAF2PoAqIy1ULOAI2n61i8ZT7wiOhjrM8pbLFKOhmbATEo1gydithAOr5Cn7DBxyISlQgb2ReNX0cXUQfptfoi5Upu4jFslivLqRmoMWy/PzRjFEQYEpWM5ljBjOVTqxm0LJ8a2l7YkGQ5tzq1y1m5DMYvPYzR3ZcvGnH7NpP7TulmWKsKwepVbweuT24OWKuOkLZVc141Ud8CubgC1hK+j4KZYwPRlXp9oUTQf7o1kQoKRArS9GFw6pAlmpfuBkEIuiM+5TMA9HENH9EydBfD35B5a7HazFjHUEs25M69vr2tIeo3cqkLokTV7fTjarVQTp95VqGchVjtbVrfMRiRYXamfhqn29AYDdFN6wsUUn3BjI0UCPZPcXOsZLqHOz4CJnnczRi2qKr51fQGCiw7yFmq+fDbR+FyyETyEVyIXOppB6efqBjFoyAgBn1PZ0yiCAg2SojcAZC3M0gZJLHtXV8gRjw6FJdnYCfATo7rblkCXxaRzvxW8X6aYs/WzxNg2OBtbA1KtI6rba6umtXIaw17wEGjyrvLx21fWyR3UIwCLNlayoYCFHdudbDSwfqr5BuGp2DBseytA/2Ablhl8MNg8v5DnOtxz7YaKfb+jfJRah0SYMSfnzS1uRJNp7+zAPGYGWwKR1UVOb7pyV++93DQzJ061b//AkP69eu2LZMte0enJH38yulMbh6Zf3OHUdc1CztT78iX+1pP/cptEybqSjf3dcC99HL0MdkRtmylTJRc0W/lt2K8kztstCnlt4ytHj4fHkNrNU395oJddSPKOaVVOlDclHf4E0zPydz1PvkRzXwfHnxcBn6prmXPuu2tvzlhHOV0zqjveWi/k2n2yqDvTn45o+maGwQQIc2c/CtnoF8yrwv/QzEsqP8D1JLEdtWzFp/acT8BW98cnTKxTf/rhnZrNVVw2i0HMesIzt21q9cHTQqR/z0USZSga+6/3J5heAH5ck1k/e6GwOVgVDaOK0SXtKASls89/8v5KIfvp3TPXFXj+VytEoXNUZbe5eM23eCU8YVl+SralR+BLaodg7THLQe1LTRJvKBctEy6zLf04u6/gPJ8WCFunQ0d1/i7MQ+Tb0fSh1Ds69ep6m1a4d6oaG55EBd/4utvUtHr1Br49KHTb37vLXadZp6pYJh8yV6M3kbgWvT1qVnrsvIzMgwmeD3kulwqAOewbSh0HQNZ9yN63gaTJ+Yd3r/gXuUe5Xgj/K1XCX4abQb7VPmBdODJguxPzMHrOOuy85ewAGLZ6amfc9Zm3MXRc/lnJPsXdznHri6wc/yv3s3kQ1Yb/SWk1jIJLZ/82Y/K4NFLgBmfgWYXS5NtCEA5ZTFrDNf0boZyaUCeFxHfoPvbk2V3EIBlMwTRP8Zfu43PoFtx5HtfNhPZbSkDfzfJ/23rPhxp/+3xj6jKiiv72WSIThqEDmn1Q9F2fG7YAIv1TPGS8CXphvGlnGsMK94U7dwXW7i8CRc56LU2YaK3o7SWnkANSYHUat3Bo32k548WeVCE3XAPnMJCksOorTgCyqW3AcAqHyNGut9h1pLQUOjO5F1zsmuMCeOcGE6D2YU6icLzQbSjnOVJ9FKrccIr1Xn8lKmU4W53GaXsEJcHgxJMTvmquMA9wSi0uPBhbiLtAkl5GaY1UoKHS6yDTN4xCaPx9G/rAyPO1BsIG0g0QUuGB2PGmwkpDeZ08yAZIcX90gMfX89DMHLSseVMuqbUwXj4mZeu1AFsfIcpVK+Pdeofcl2m4BQyYNanFB4XUg2Wyg5aTFW5icJOeK3aoMx8BAzlfA69FeGs+F5+eL2hbatTf0TjUFvO0ZGiRpNtNFFH0OMMdm4ButMMZmneEm9WUfat/XaK3ojVtKg85hJe3ejbrLXpCOT2hKNHi8SVlZ0Px+LTDFhdsLpxbrhOrvJa94ErOuiQwEAAAAA&#x27;) format(&#x27;woff2&#x27;), url(&#x27;//at.alicdn.com/t/font_1120834_hvoztl864h6.woff?t=1554258412999&#x27;) format(&#x27;woff&#x27;), url(&#x27;//at.alicdn.com/t/font_1120834_hvoztl864h6.ttf?t=1554258412999&#x27;) format(&#x27;truetype&#x27;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url(&#x27;//at.alicdn.com/t/font_1120834_hvoztl864h6.svg?t=1554258412999#iconfont&#x27;) format(&#x27;svg&#x27;); /* iOS 4.1- */&#125; .iconfont &#123; font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125; .icon-iconfontzhizuobiaozhun16:before &#123; content: &quot;\\e60f&quot;;&#125; .icon-location:before &#123; content: &quot;\\e619&quot;;&#125; .icon-dayuhao:before &#123; content: &quot;\\e600&quot;;&#125; .icon-jizuobiaotu:before &#123; content: &quot;\\e613&quot;;&#125; .icon-dayuhao1:before &#123; content: &quot;\\e65c&quot;;&#125; .icon-zuobiao:before &#123; content: &quot;\\e657&quot;;&#125; .icon-zhengque:before &#123; content: &quot;\\e64a&quot;;&#125; .icon-fanhui:before &#123; content: &quot;\\e60d&quot;;&#125; .icon-iconfront-:before &#123; content: &quot;\\e620&quot;;&#125; 用到的图片 back.png(wxml39行)和my_marker.png(wxml48行) img img 可参考 WebService API | 腾讯位置服务","tags":["编程语言","小程序"],"categories":["编程"]},{"title":"中华文化酷！小程序","path":"/2022/07/01/中华文化酷！小程序/","content":"自从报名了icode比赛之后的几个月就再也没有理过这个东西了（事情多得有点忙乱，中途还要弄团委项目，当然我这个组长肯定要负主要责任）。还有半个月才和@Fire_egg急忙开工，当时也没想那么多就想着既然参加了就起码得完成吧，意外的是最后还获得三等奖（五月份的事了）。这次的经历出现了一些问题也让我获得除了开发小程序以外的收获。 策略方面首先就是一定要提前准备，确定好主题，做好长期的规划安排。其次是多和组员交流开会，带动一下整个团队。队长就是整个团队的核心和关键，需要有较强的内驱力和领导力。最后就是要做好调研调查，进度估计。了解好项目的大致框架和可能涉及到的技术栈。 技术方面这个小程序也是相当简易的，涉及到的都是一些简单的程序指令，没有高端的算法之类的，这也是我们不愿在答辩时过多呈现技术方面的原因呵呵（因为师兄师姐的技术都太过硬核了）。 总结这次作品主要有两点亮点吧，一是主题，二是UI界面。自从发现时间紧迫，在技术上不会有太大的造诣。于是每晚下工后躺在床上我都在想怎么包装这个作品。页面是参考的某学习app。而主题我们本打算就以传统文化为内容，但是后来我突然想起高中语文写的那么多作文都提到创新的中华文化。于是我就想以此为内容会不会更好，并定下了一个具有双关意味的名字。 当然也存在很多缺陷。一是前端基础不牢，运行时存在很多bug，不进行改进是绝对不能上线的。二是选题问题。答辩时师兄提了很好的问题，他说为什么不能用抖音这些平台来宣传呢？意思就是让我们思考这个软件凭什么让别人来使用你，如果只是单纯传播一些帖子，网上有很多流量更大的平台可以利用。师兄还建议我们可以增加一些相关活动信息的发布，来提升实用性。三当然就是技术的硬核程度了，要多注重技术方面才能拿得出手，这也是我在接下来要重点加强学习的。 最后附上我深夜爆肝的花里胡哨说明文档以及答辩ppt。 中华文化酷！说明文档2022/4/24 中华文化酷！答辩ppt2022/5/15 中华文化酷！演示视频2022/5/15 腾讯视频 (qq.com) 鸣谢：Fire_egg szlx560223 (github.com) 源码：JJuprising&#x2F;Cool-Chinese-Culture: 一款传播创新型中华文化的知识类小程序 (github.com)","tags":["编程语言","项目"],"categories":["编程","项目","小程序"]},{"title":"2022web大作业","path":"/2022/07/01/2022web大作业/","content":"最初想法是copy spsspro 可惜临近期末时间太赶了，而且发现还有好多前端知识还没学懂弄会，比如变量生存期、请求的顺序、解析后数据的存储形式等。 源代码已经放到仓库了：https://github.com/JJuprising/Web_FinalHomework 大作业要求： 大作业要求 说明文档","tags":["编程语言","项目"],"categories":["编程","本科课程"]},{"title":"线性代数","path":"/2022/07/01/线性代数/","content":"线性代数题型归纳","tags":["数学"],"categories":["本科课程"]},{"title":"Cpp语言程序设计","path":"/2022/07/01/Cpp语言程序设计/","content":"第一章 绪论 机器语言与汇编语言 由计算机硬件系统可以识别的二进制指令组成的语言称为机器语言。 汇编语言将机器指令映射为一些可以被人读懂的助记符，如ADD、SUB等。 高级语言 高级语言屏蔽了机器的细节，提高了语言的抽象层次，程序中可以采用具有一定含义的数据命名和容易理解的执行语句。这使得在书写程序时可以联系到程序所描述的具体事物。 面向对象的语言 出发点：更直接地描述客观世界中存在的事物(对象)以及它们之间的关系。 特点： 是高级语言。 将客观事物看作具有属性和行为的对象 通过抽象找出同一类对象的共同属性和行为，形成类。 通过类的继承与多态实现代码重用 优点：使程序能够比较直接地反映问题域的本来面目，软件开发人员能够利用人类认识事物所采用的一般思维方法来进行软件开发。 面向对象的方法 将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体——对象。 对同类型对象抽象出其共性，形成类。 类通过一个简单的外部接口，与外界发生关系。 对象与对象之间通过消息进行通信。 计算机中的信息 数据信息——计算机程序加工的对象 控制信息——指挥计算机操作 image-20220530234340268.png 信息的存储单位 位(bit，b)：度量数据的最小单位，表示一位二进制信息。 字节(byte，B)：由八位二进制数字组成(1 byte &#x3D; 8 bit)。 千字节 1 KB &#x3D; 1024 B 兆字节 1 MB &#x3D; 1024 K 吉字节 1 GB &#x3D; 1024 M 进制转换 第二章 C++简单程序设计I&#x2F;O流 在C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被建立，使用后要被删除。 从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。 数据的输入与输出是通过I&#x2F;O流来实现的，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。 第三章 函数static_cast是一个强制类型转换操作符 12double a = 1.999;int b = static_cast&lt;double&gt;(a); //相当于a = b ; 函数的声明的实现123void func(int);//函数的声明，可以没有形参名，没有大括号void func(int)&#123;&#125;//函数的实现必须要有&#123;&#125;，类构造函数用初始化列表容易忘加&#123;&#125; 函数的参数传递 在函数被调用时才分配形参的存储单元 实参可以是常量、变量或表达式 实参类型必须与形参相符或可隐式转换为形参类型 值传递传递参数值，即单向传递 引用传递可以实现双向传递 常引用作参数可以保障实参数据的安全 内联函数 声明时用关键字 inline 规模小、功能简单使用频繁的函数。编译时在调用处嵌入函数体，节省了参数传递、控制转移等开销 注意 内联函数体内不能有循环语句和switch语句 内联函数的定义必须出现在内联函数第一次被调用之前 对内联函数不能进行异常接口声明 函数高级1.默认参数 默认参数，如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值。 注意事项： 有默认参数的要放在最后面。int fun(int a,int b,int d=1)&#123;&#125;; 如果函数声明有默认参数，函数实现就不能有默认参数。因为声明时已经定义过了，两个有就冲突了。声明和实现只能有一个有默认参数 2.占位参数返回值参数 函数名(数据类型){} void func(int a, int);后面的int就是占位参数，只有传两个才能正常执行。 占位参数也能有默认默认参数，这时候就可以不传这个占位参数了。 3.函数重载作用：函数名可以相同，提高复用性 满足条件 同一作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或a 顺序不同 对返回值没有规定 123456int sumOfSquare(int a,int b)&#123; return a*a+b*b;&#125;double sumOfSquare(double a,double b)&#123; return a*a+b*b;&#125; 注意： 函数的返回值和形参名不可以作为函数重载的条件 函数重载碰到默认参数会出现二义性，尽量避免这种情况。 引用 引用相当于给变量取别名。语法：数据类型 &amp;别名=原名; 引用声明时就必须初始化，int &amp;c;是错误的 在声明一个饮用后，不能再使之作为另一变量的引用（指向不可修改） 引用作为重载的条件。 通过引用参数产生的效果同按地址传递是一样的，引用的语法更加清楚简单，简化指针修改实参。 123456789101112131415161718//指针作参数void swap1(int *a,int *b)&#123; int temp=*a; *a=*b; *b=temp;&#125;//引用作参数void swap2(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125;int main()&#123; int a=10; int b=20; swap1(&amp;a,&amp;b);//指针参数函数的调用，地址传递 swap2(a,b);//引用传递&#125; void func(int &amp; a);void func(const int &amp; a);当func(a)时走第一个，当func(10)走第二个。const是只读状态，相当于创建块区域，然后引用的指向它。注意int &amp;a=10;是不合法的，10是一个常量，故不会走第一个。 1234567891011121314151617181920212223// 声明简单的变量 int i; double d; // 声明引用变量 int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s &lt;&lt; endl; return 0; 结果： 1234Value of i : 5Value of i reference :5Value of d : 11.7Value of d reference :11.7 引用做函数的返回值 不要返回局部变量的引用 函数的调用可以作为左值存在 12345678910int &amp; test02()&#123; static int a=10;//一定要加static关键字，表示静态变量，存放在全局区，全局区上的数据在程序结束后系统释放。 //如果是int a;那就是返回局部变量的引用了 return a;&#125;int main()&#123; int &amp;ref=test02();//ref结果为10，ref是a的别名 test02=1000;//函数的调用作为左值做赋值操作，看成是a的别名，此时ref的结果变为1000 return 0;&#125; 第四章 类和对象类和对象C++面向对象的三大特性为：封装、继承、多态。万事万物都皆为对象，对象上有其属性和行为 具有相同性质的对象，我们可以抽象为类。 封装 class代表设计一个类，类后面紧跟着的是类的名称 1234567891011121314151617181920class Circle&#123;//访问权限public: //属性：半径int m_r;//行为：获取圆的周长\tdouble caculate()&#123;//这里的行为是个函数 double c=PI*m_r*2; return c;\t&#125;&#125; 实例化：通过类创建一个具体对象。通过”.”来访问，可以给属性赋值 12345Circle p1;//和结构体类似p1.m_r=3;//赋值半径cout&lt;&lt;p1.caculate();//输出周长 类中的属性和行为统称为 成员。属性： 成员属性&#x2F;成员变量。行为： 成员函数&#x2F;成员方法。 访问权限: 公共权限 public 成员 类内(class大括号内)可以访问 类外也可以访问 保护权限 protected 成员 类内可以访问 类外不可以访问 儿子可以访问父亲的保护内容 私有权限 private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲的私有内容 struct和class区别 唯一区别：默认的访问权限不同。struct 默认是公共public，class默认是私有private 建议成员属性设置为私有。 原因：1.可以自己控制读写权限 2.对于写可以检测数据的有效性 可以通过public里的行为对private里的属性进行修改，实现只读、可读可写、只写。 读 12345string getlover()&#123;return m_lover;&#125; 写： 12345void setlover(string lover)&#123;m_lover=lover&#125; 检测有效性: 123456789101112131415//经过检测才能修改到，不至于直接修改private的属性造成麻烦void setAge(int age)&#123;if(age&gt;=150||age&lt;=0)&#123;m_age=0;cout&lt;&lt;&quot;年龄有问题&quot;;return;&#125; 在类中可以让另一个类作为 本类中的成员 作用域::成员函数 类的声明.h,需要#pragma once 和#include&lt;iostream&gt;和using namepace,如果这个类中还用到另一个类，需要引用另一类的头文件然后加作用域 。 类的实现.cpp需要#include &quot;_.h&quot;以及在函数名前加作用域，不需要外部的class和public和private的属性。 对象特性 构造函数(对象初始化)和析构函数(对象清理) 构造函数和析构函数构造函数语法：类名()&#123;&#125; 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次 析构函数语法：~类名()&#123;&#125; 析构函数，没有返回值也不写void 函数名称与类名相同，在名称前加符号~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次 以上两个都是必须有的实现，如果不提供，编译器会提供，不过是空实现。 构造函数的分类及调用 两种分类方法 按照参数分类 无参构造（默认构造，编译器提供的）和有参构造 按照类型分类 普通构造和复制构造函数 复制构造函数写法 123Person(const Person &amp;p)&#123;//将传入的人身上的属性复制到我身上；&#125; 三种调用方法​ 1.括号法 Person p1; //默认构造函数调用 Person p2(10); // 有参构造函数 Person p3(p2); //拷贝构造函数 注意事项1：默认构造函数调用时不要加(),编译器会误认为函数的声明 ​ 2.显示法 Person p1;//不需要加括号写成Person p1() Person p2 = Person(10); //有参构造 Person p3 = Person(p2); //拷贝构造 person(10); &#x2F;&#x2F;是匿名对象 特点:当前行执行结束后，系统会立即回收匿名对象 注意事项2：不要利用拷贝构造函数 初始化匿名对象，如person(p3);编译器会识别出person p3; ​ 3.隐式转换法，直接写 123Person p4 = 10; //相当于写了 Person p4 = Person(10); Person p5 = p4; //拷贝构造 拷贝构造函数的调用时机1.使用一个已经创建完毕的对象来初始化一个新对象 123Person p1;Person p2(p1); ​ 2.值传递的方式给函数传值 1void fun1(Person p)&#123;&#125; 3.以值方式返回局部对象 1234567Person doword()&#123;Person p1;return p1;&#125; 构造函数的调用规则默认情况下，编译器至少给一个类添加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性进行值拷贝 如果写了有参构造函数，编译器就不提供默认构造，但仍提供拷贝构造 如果写了拷贝构造函数，编译器就不提供其他函数 归纳1234567891011121314151617181920212223242526//构造函数 可分为无参构造（默认构造）和有参构造;或者分成普通构造和拷贝构造Class Clock&#123;public: Clock();//默认构造函数的声明，不用加&#123;&#125; Clock(int newH,int newM,int newS);//构造函数的声明 Clock(Clock &amp;c1);//复制构造函数的声明 ~Clock()&#123;&#125;//析构函数private: int hour,minute,second; &#125;;Clock::Clock():hour(0),minutes(0),second(0)&#123;&#125;//默认构造函数的实现Clock::Clock(int newH,int newM,int newS):hour(newH),minute(newM),second(newS)&#123;&#125;//构造函数的声明Clock::Clock(Clock &amp;c1)&#123;//复制构造函数的实现 hour=c1.hour; minute=c1.minute; second=c1.second;&#125;int main()&#123; Clock c;//调用无参数的构造函数即默认构造，且设置初始化为(0,0,0) Clock c1(21,10,10);//调用有参数的构造函数 Clock c2(c1);//调用复制构造函数 //程序结束前会执行析构函数 return 0;&#125; 构造与析构顺序123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class A&#123;public: A()&#123; cout&lt;&lt;&quot;A类的构造函数调用&quot;&lt;&lt;endl; &#125;; ~A()&#123; cout&lt;&lt;&quot;A类的析构函数调用&quot;&lt;&lt;endl; &#125;&#125;;class B&#123;public: B()&#123; cout&lt;&lt;&quot;B类的构造函数调用&quot;&lt;&lt;endl; &#125; A a;//B类的成员是另一个类的对象，称为对象成员 ~B()&#123; cout&lt;&lt;&quot;B类的析构函数调用&quot;&lt;&lt;endl; &#125;&#125;;int main()&#123; B b;&#125;//结果/*A类的构造函数调用B类的构造函数调用B类的析构函数调用A类的析构函数调用*/ B类中有对象A作为成员，A为对象成员 当创建B对象是，会先调用对象成员A的构造函数，再调用B的构造函数 而析构顺序相反，先析构B再析构A，所谓先构造后析构，后构造先析构 深拷贝与浅拷贝浅拷贝：编译器的默认的简单的复制拷贝操作 深拷贝：在堆区重新申请空间(new)，进行拷贝操作 浅拷贝的问题（类中有指针，释放的时候同一块地方被两个类释放两次，非法）要用深拷贝解决 1234567891011//拷贝函数Person(const Person &amp;p)&#123;\tm_Age=age;\tm_Height=new int(*p.m_Height)&#125; 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 初始化列表 作用：初始化属性 语法：构造函数():属性1(值1),…{ } 类对象作为类成员 暂时用列表传参 C++运算符的重载 运算符重载的概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加法运算符的重载 第五章 数据的共享与保护作用域局部作用域image-20220626232121527 对象生存期静态生存期 这种生存期与程序的运行期相同 在文件作用域中声明的对象具有这种生存期 在函数内部声明静态生存期对象，要冠以关键字static 动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也被称为局部生存期对象 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时 常对象常对象必须进行初始化，且不能被更新 语法：const 类型说明符 对象名; 1234567class A&#123;\t...&#125;const A a(3,4);//a是常对象，不能被更新const int n=10;//正确，用10对常量n进行初始化n=20;//错误，不能对常量赋值 用const修饰的类成员常成员函数声明格式：类型说明符 函数名(参数表)const; 注意： 函数定义的时候也要加上const 常成员函数调用期间不能更新(修改)对象的数据成员，也不能常成员函数中调用没有用const修饰的成员函数 常数据成员使用const说明的数据成员为常数据成员，初始化后不能修改。构造函数对该数据成员进行初始化就只能通过初始化列表 1234567891011class A&#123;public: A(int i);private: const int a;//常数据成员\tstatic const int b;//静态常数据成员 &#125;const int A::b=10;//静态常数据成员在类外说明和初始化//常数据成员只能通过初始化列表来获得初值A::A(int i):a(i)&#123;&#125; 常引用12int &amp;a=b;//相当于int*const a=b，指向不可改变，指针常量const int &amp;a=b;//常引用，相当于const int * const a=b,指向的空间不可修改 使得引用的对象只读，不能通过a来改变b的值 静态变量与静态函数（存在于全局，并不属于特定的哪个对象）静态数据成员静态数据成员：使得一个类的所有对象具有相同的属性，对于任何对象实例，它的属性值相同，不属于任何一个对象。(具体看例子) 注意： 由于静态数据成员不属于任何一个对象，因此可以通过类名对他访问，一般用法：类名::标识符 静态数据成员需要在类定义之外再加以定义。原因：以此来专门为它们分配空间。非静态数据成员无须，因为他们的空间是与他们所属对象的空间同时分配的 12345678910111213141516171819202122class Point&#123;public: Point(int x=0,int y=0):x(x),y(y)&#123;//构造函数 //在构造函数中对count累加，所有对象共同维护同一个count &#125; Point(Point &amp;p)&#123; x=p.x; y=p.y; count++; &#125; ~Point()&#123;count--;&#125; int getX()&#123;return x;&#125; int getY()&#123;return y;&#125; void showCount()&#123;//输出静态数据成员 cout&lt;&lt;&quot; Object count=&quot;&lt;&lt;count&lt;&lt;endl; &#125;private: int x,y; static int count;//静态数据成员声明，用于记录点的个数&#125;int Point::count=0;//静态数据成员定义和初始化，使用类名限定 创建不同Point类对象a和b可以分别调用showCount函数输出同一个count在不同时刻的数值，实现了a,b之间直接的数据共享。 静态函数成员 静态成员函数可以访问静态成员变量 静态成员函数不可以访问非静态成员变量 ，无法区分到底是哪个对象的 访问可以通过成员也可以通过类名Person::func();这样就不需要创建一个对象然后通过对象的成员函数来访问成员了。 在静态成员函数中没有this指针，因为它属于整个类而不是具体的哪个对象，this指向的是具体的对象 12345678910111213//上面的例子做些修改class Point&#123;public: ... static void showCount()&#123;//金泰成员函数 ... &#125;&#125;int main()&#123; Point a(1,3); Point b(a); Point::showCount();//这是想要输出count直接类名访问，因为当为非静态时，a.showCount()和b.showCount()是一个意思&#125; 成员变量 和 成员函数 是分开存储的 空对象占用的内存空间为1字节，为了区分不同的空对象占用的空间 非静态成员变量 属于类的对象上，而静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上。 123456789101112131415161718192021class Person&#123;&#125;;class Phone&#123;int price;//void func();//static int p;&#125;;Person p1;Phone pp1;sizeof(p1);----1sizeof(pp1);---4 //就算里面有func和static，sizeof(pp1)都是int的4 this指针 this指针概念 成员函数和成员变量分开存储，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分是哪个对象调用自己呢？ this指针指向被调用的成员函数所属的对象不需要定义，直接用 解决名称冲突 1234567Person(int age)&#123;//age=age;编译器不知道哪个是哪个this-&gt;age=age;&#125; 返回对象本身用return *this 空指针调用成员函数.如果要用的话，成员函数里面不能有属性，否则报错，因为传入空指针，this是NULL，或者是成员函数里前面加个 12if(this==NULL) return; const修饰成员函数this指针本质是一个指针常量，不能修改指向 ： 12Person * const this;//指向不能改。const Person * const this;//指向不能改，指向的内容也不能改。 常函数 12345void showp() const&#123;&#125; 成员函数后加const称为常函数 常函数内不可修改成员属性 在成员函数后面加const修饰的是this指针，让指针指向的值也不能改，相当于这个函数加了const就是承诺不修改this指向的属性。 mutable int m_B;加上关键字mutable就是特殊变量，在常函数中可以修改 常对象 1const Person p;//在对象前加const，变为常对象，一般的成员变量不能改 同理加了mutable就可以改 常对象只能调用常函数,防止你用常对象调用普通函数来修改里面的属性 常数据成员 常数据成员只能通过初始化列表来获得初值 1234567891011class A&#123; public:\tA(int i);private:\tconst a;&#125;A::A(int i):a(i)&#123;&#125; 常引用：即只读状态 1void dist(const Point &amp;a); const型数据小结 形式 含义 Point const t1 t1是常对象，其值在任何情况下都不能改变 void Point::func() const func()是Point类中的常成员函数，可以引用，但不能修改成员 Point * const p p是指向Point类对象的常指针，p的值不能改变，即指向不能变 const Point *p p是指向Point类常对象的指针，其指向的类对象的值不能通过指针来改变 Point &amp;t1=t; t1是Point类对象t的引用，二者指向同一段内存空间 友元让一个函数或者类访问另一个类中私有成员和保护成员 注意: 友元的关系是单向的而不是双向的 友元的关系不能传递 全局函数作右元 12345678910class Room&#123;friend void visit(Room &amp;room);//相当于把函数声明放到类里头开头加上friend，结尾加&quot;;&quot;&#125;void visti(Room &amp;room)&#123;//全局函数的实现&#125; 类做友元 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Building;class goodgay &#123;//做友元public:\tgoodGay();\tvoid visit;private:\tBuilding *building;&#125;;class Building &#123;//告诉编译器 goodgay类是Building类的好朋友，可以访问到Building类中私有内容friend class goodGay;public:\tBuilding();public:\tstring m_SittingRoom;//客厅private:\tstring m_BedRoom;&#125;;Building::Building() &#123;\tthis-&gt;m_SittingRoom = &quot;客厅&quot;;\tthis-&gt;m_BedRoom = &quot;卧室&quot;;&#125;goodGay::goodGay() &#123;\tbuilding = new Building;&#125;void goodGay::visit() &#123;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;&#125;void test01() &#123;&#125; 另一个类的成员函数做友元 实操经验：如果是一个A类的成员变量想做B类的友元，那么B类里要声明友元，格式 :friend 函数类型 A::函数名(); 同时，B类的声明要放在A类之后，否则编译器找不到A::函数名()这个东西 friend声明友元函数，友元函数却依旧无法访问该类的私有属性”的解决一次C++作业题, 搞了很久弄明白了, 虽然成功了, 但VS2015依旧有红线提示错误, 不过不影响编译、运行, 这似乎是VS自身的一个BUG。解决：友元类方法小结： 包含声明”friend”的类，必须在((包含其声明的友元函数)的那个类)之前事先声明下————因为在Employer类中用到”Employee&amp;”,不然无法访问该引用的私有成员。 被声明为友元的函数，必须在类内声明，然后在将其声明为友元函数的类的后面定义。 还有一个我个人犯的低级错误——在声明友元函数时，忘记加该函数的作用域了。。。 作业代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940 #include &lt; iostream &gt; #include &lt; string &gt;using namespace std;class Employee;//先声明，因为在Employer中会用到，否则不给友元函数访问Employer的私有class Employer&#123;public: Employer(string a) &#123; Name = a; &#125;; void editEmployee(Employee &amp; person, double salary, string post);private: string Name;&#125;;class Employee &#123;public:Employee(int a, string b, double c, string d) &#123; ID = a; Name = b; Salary = c; Post = d;&#125; friend void Employer::editEmployee(Employee &amp; person, double salary, string post); void printInf() &#123; cout &lt;&lt; &quot;ID:&quot; &lt;&lt; ID &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; Name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Salary:&quot; &lt;&lt; Salary &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Post:&quot; &lt;&lt; Post &lt;&lt; endl; &#125;protected:private: int ID; string Name; double Salary; string Post;&#125;;void Employer::editEmployee(Employee &amp; person, double salary, string post) &#123; person.Salary = salary; person.Post = post;&#125;; 第六章 数组 指针与字符串数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素。 数组二维数组初始化 将所有初值写在一个{}内，按顺序初始化 例如：static int a[3][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;; 分行列出二维数组元素的初值 例如：static int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; 可以只对部分元素初始化 例如：static int a[3][4]=&#123;&#123;1&#125;,&#123;0,6&#125;,&#123;0,0,11&#125;&#125;; 列出全部初始值时，第1维下标个数可以省略 例如：static int a[][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;或：static int a[][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;; 注： 如果不作任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0 如果只对部分元素初始化，剩下的未显式初始化的元素，将自动被初始化为零 对象数组初始化1Point a[2]=&#123;Point(1,2),Point(3,4)&#125;; 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象 元素所属的类不声明构造函数，则采用默认构造函数。 当数组中每一个对象被删除时，系统都要调用一次析构函数。 指针内存空间的访问方式 通过变量名访问 通过地址访问 指针的概念 指针：内存地址，用于间接访问内存单元 指针变量：用于存放地址的变量 指针名&#x3D;地址 C++11使用nullptr关键字，是表达更准确，类型安全的空指针 指向常量的指针和指针类型的常量指向常量的指针（常指针）声明时const在最前面。不能通过指针来改变指向对象的值，但是指针本身指向可以改变 123456int a;const int *p1 = &amp;a;\t//p1是指向常量的指针int b;p1 = &amp;b;\t//正确，p1本身的值可以改变*p1 = 1;\t//编译时出错，不能通过p1改变所指的对象 指针类型的常量（指针常量）const在*后，指向不可改变。 1234int a;int * const p2 = &amp;a; int b;p2 = &amp;b;\t//错误，p2是指针常量，值不能改变 指针类型的算术运算 指针p加上或减去n 其意义是指针当前指向位置的前方或后方第n个数据的起始位置。 指针的++、–运算 意义是指向下一个或前一个完整数据的起始。 运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置。 当指针指向连续存储的同类型数据时，指针与整数的加减和自增自减算才有意义。 指针与数组指针名加了整数再用*解引用得到所指对象的值。 定义指向数组元素的指针 定义与赋值 1234int a[10], *pa;pa=&amp;a[0]; //或 pa=a;数组名a地址也是数组第一个元素a[0]的地址*pa就是a[0]，*(pa+1)就是a[1]，... ，*(pa+i)就是a[i].a[i], *(pa+i), *(a+i), pa[i]都是等效的。 注意：不能写 a++，数组名不能自加自减，因为a是数组首地址、是常量。 字符串字符数组用于存放字符串的数组其元素个数应该不小于字符串的长度(即字符个数)加1，因为要在末尾放置一个’\\0’。 1234567char str[8]=&#123;&#x27;p&#x27;,&#x27;r&#x27;,&#x27;o&#x27;,&#x27;g&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;m&#x27;&#125;;char str[8]=&quot;program&quot;;char str[]=&quot;program&quot;;//这三种写法等价char s1[3]=&quot;xyz&quot;;//错误！char s2[2][3]=&#123;&quot;xyz&quot;,&quot;mnp&quot;&#125;;//错误！char s3[][3]=&#123;&#x27;a&#x27;,&#x27;x&#x27;,&#x27;y&#x27;&#125;;//正确 动态内存分配目的：保证程序在运行过程中按照实际需要申请适量的内存，使用结束后还可以释放。 在C++程序中建立和删除堆对象使用两个运算符，new和delete new new的功能是动态分配内存，语法：new 数据类型 (初始化参数列表) 创建一维数组：new 类型名 [数组长度]; 如果内存申请成功，new运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针对堆对象进行访问 new T和new T()效果相同，都会调用这个默认构造函数 12345678int *point;point=new int(2);//初值设置为int *point=new int;//不设置初值，直接去括号int *point=new ();//括号里不写，表示用0初始化int *p=new int[10]();//用0初始化数组 delete 释放指针所指向的内存空间，语法：delete 指针名; 删除数组要在指针名前面加”[]”：delete []指针名; 如果是对象，会调用对象的析构函数 对于用new建立的对象只能执行一次delete删除操作 12delete point;delete []p;//一定是指针名，根据指针，去找对应地址的内存空间 内存四区代码区 全局区 栈区 堆区 c++中在程序运行前分为全局区和代码区 代码区 特点是共享和只读。共享目的是对于频繁被执行的程序只需要保存一份代码即可 全局区 全局变量、静态变量、字符串常量、const修饰的全局变量存放在全局区 局部修饰的都不在全局区里 常量分为字符串常量和const修饰的变量，const修饰的变量有全局也有局部 栈区 有编译器自动分配释放，存放函数的参数值、局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 堆区 由程序员分配释放，程序结束时由操作系统回收 在c++中用关键字new将数据开辟到堆区，返回值是地址，如 new int(10),将10放到堆区里，可指针接。在程序运行时，10一直存在。 释放利用delete指向该区域的指针。 12int *p=new int(10);delete p; 常见一个数组用中括号:int *arr=new int[10]; 上面的()表示只有一个元素 释放 delete[] arr; 第七章 类的继承基类和派生类graph TD; 交通工具-->火车 交通工具-->汽车 交通工具-->飞机 交通工具-->轮船 汽车-->卡车 汽车-->旅行车 汽车-->小汽车 小汽车-->工具车 小汽车-->轿车 小汽车-->面包车 从已有类产生新类的过程就叫类的派生 派生类(子类)包含了基类(父类)特征，同时可以加入自己所特有的新特征 一个派生类同时有多个基类的情况称为多继承(有多个爹)，只有一个直接基类叫做单继承 在类族中，直接参与派生出某类的基类称为直接基类(爸爸辈)，跨层的基类称为间接基类(爷爷辈及以上)。如图中汽车是卡车、旅行车、小汽车的直接基类，而交通工具是旅行车的间接基类 派生类构造函数和析构函数构造函数例题 1234567891011121314151617181920212223242526272829//例7-4.cpp#include&lt;iostream&gt;using namespace std;class Base1 &#123;//基类Base1,构造函数有参数public:\tBase1(int i) &#123; cout &lt;&lt; &quot;Constructing Base1 &quot; &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Base2 &#123;//基类Base2,构造函数有参数public:\tBase2(int j) &#123; cout &lt;&lt; &quot;Constructing Base2 &quot; &lt;&lt; j &lt;&lt; endl; &#125;&#125;;class Base3 &#123;//基类Base3,构造函数有参数public:\tBase3() &#123; cout &lt;&lt; &quot;Constructing Base3 * &quot; &lt;&lt;endl; &#125;&#125;;class Derived :public Base2, public Base1, public Base3 &#123;//派生新类Derived，注意基类名的顺序public:\tDerived(int a,int b,int c,int d):Base1(a),member2(d),member1(c),Base2(b)&#123;&#125;//注意基类名的个体与顺序，注意成员对象名的个体与顺序private://派生类的私有成员对象\tBase1 member1;\tBase2 member2;\tBase3 member3;&#125;;int main() &#123;\tDerived obj(1, 2, 3, 4);\treturn 0;&#125; 输出结果 image-20220331165212833 构造函数的调用顺序：先调用基类的构造函数，然后调用内嵌对象的构造函数 ①基类构造函数的调用顺序是按照派生类定义时继承的顺序，如例题 123class Derived :public Base2, public Base1, public Base3&#123; ...&#125; 因此是先Base2,再Base1,最后Base3. ②而内嵌对象的构造函数调用顺序应该是按照成员在类中声明的顺序 1234private://派生类的私有成员对象\tBase1 member1;\tBase2 member2;\tBase3 member3; 应该是先Base1,再Base2,最后Base3. 因此结果顺序是2-1-3-1-2-3 析构函数语法：~类名()&#123;&#125; 析构函数不接受任何参数 如果不显式说明，系统会自动生成 上个例题的析构结果是： image-20220331181110050 析构函数顺序和构造函数是严格相反的，因此会先对派生类新增的类类型的成员对象进行清理，最后对所有从基类继承来的成员进行清理 三种继承方式 公有继承，基类的公有和保护成员的访问属性在派生类中不变，私有的在类外无法直接访问 私有继承，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问。经过多轮私有继承之后，所有的基类成员都成为派生类的私有成员或不可直接访问成员，基类的成员无法发挥作用，相当于终止了派生，使用较少 保护继承，基类中的公有成员和保护成员都以保护成员身份出现在派生类中，而基类的私有成员不可直接访问。派生类的其他成员就可以直接访问从基类继承来的公有和保护成员，但在类外部通过派生类无法直接访问它们。与私有继承差别就是基类的保护成员可能被它的派生类访问(不至于无法发挥作用)，同时保证其绝对不可能被其他外部使用者访问。(某些需要被保护起来的成员对子孙有用时可以被用到) 类型兼容规则 派生类的对象可以隐含转换为基类对象，即可以用派生类对象赋值给基类对象。 派生类的对象可以初始化基类的引用 派生类的指针可以隐含转换为基类的指针 以上称为向上转型。 不要重新定义同名的非虚函数，因为此时派生类调用重新定义的非虚函数时都只能访问到从基类继承来的那个最原始的成员。 不能被继承C++中，不能被派生类继承的是： 构造函数 私有继承调用基类123456789101112131415161718192021222324252627282930313233343536373839404142//7-8.cpp#include&lt;iostream&gt;using namespace std;class Base &#123;public:\tBase():x(0),y(0)&#123;&#125;\tvoid initBase(int x,int y)&#123; this-&gt;x = x; this-&gt;y = y;//需要加this不然分不清\t&#125;\tvoid fun1() &#123; cout &lt;&lt; x &lt;&lt; endl;\t&#125;\tvoid fun2() &#123; cout &lt;&lt; y &lt;&lt; endl;\t&#125;private:\tint x, y;&#125;;class Derived :private Base &#123;//私有继承public:\tDerived() &#123;&#125;\tvoid initDerived(int x, int y) &#123; initBase(x, y);//通过成员函数调用基类成员\t&#125;\tvoid getX() &#123; fun1();\t&#125;\tvoid getY() &#123; fun2();\t&#125;&#125;;int main() &#123;\tDerived son;\tson.initDerived(3, 4);\tcout &lt;&lt; &quot;调用基类的fun1()返回的到x值：&quot;;\tson.getX();\tcout &lt;&lt; &quot;调用基类的fun2()返回的到y值：&quot;;\tson.getY();\treturn 0;&#125; image-20220331184719981 派生类成员的标识与访问作用域分辨符当某派生类的多个基类拥有同名的成员时，调用同名成员必须通过基类名和作用域分辨符“:”来标识成员 123456789101112int main()&#123;\tDerived d; Derived *p=&amp;d; d.Base1::var=2;//作用域分辨符在同名成员前加 d.Base1::fun(); p-&gt;Base2::var=1;//作用域分辨符在同名成员前加 p-&gt;Base2::fun(); return 0;&#125; 虚基类 virtual同名的数据成员在内存中拥有多个副本，需要使用作用域分辨符来唯一标识并访问它们。将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个，同一个函数名也只有一个映射，避免冗余。 语法形式：class 派生类名：virtual 继承方式 基类名 上述语句声明基类为派生类的虚基类，一起维护同一个内存数据 image-20220407111402840 在类Derived中d.Base1::var0和d.Base2::var0是一个对象，造成冗余 虚继承： 123456class Base1: virtual public Base0&#123;//类Base1是类Base0的公有派生类，Base0是Base1的虚基类 &#125;;class Base2: virtual public Base0&#123; &#125;; 因此访问呢只需d.var0 最远派生类就是最年轻的那个子孙，后面没有再派生了 最远基类最老的那个基类 虚基类及其派生类构造函数 如果最远虚基类中没有默认构造但是有有参构造，那么它的每一个子孙都必须在构造函数的成员初始化列表中为最远虚基类的构造函数列出参数。如果未列出表示调用虚基类默认构造函数，又因为没定义，所以会报错 如果最远派生类构造函数调用虚基类的构造函数，那么其他类对虚基类构造函数的调用将被忽略 例： image-20220407113108138 image-20220407113305802 注意：如果不可预估此基类会派生多少子类，那没必要用虚继承。同时多继承非必要不使用，来避免冗余。 第八章 多态性多态：指同样的消息被不同类型的对象接收时导致不同的行为，即调用了不同的函数 多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数 多态分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 虚函数什么是虚函数？ 在基类用virtual声明成员函数为虚函数 虚函数的作用： 虚函数的作用是允许在派生类中重新定义与基类同名的函数(且能同时存在)，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。 而对于派生类的同名函数来说，它覆盖了继承来的基类的同名函数，发挥自己的功能，解决了在第七章类型兼容规则中的问题 使用方法： 基类声明成员函数前加关键字virtual，实现时不用加virtual 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体 C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都 自动成为虚函数，可以不加virtual image-20220407114950788 image-20220407114933014 image-20220407114904923 上面例题是想通过基类的指针指向派生类的对象，并访问某个与基类同名的成员，那么首先在虚类中将这个同名函数说明为虚函数。 多态满足的条件： 有继承关系 子类重写父类中的虚函数 初识虚函数 用virtual 关键字说明的函数 动态绑定的函数 不能是内联，要在类外实现，因为对内联函数的处理是静态的 虚表image-20220414085124122 在Derived中新定义了f(),会覆盖Base::f,其实就是重新开一个新函数；**没有定义g()来覆盖基类，故在虚表中查找g()会指向基类的g()**。 virtual关键字 如果基类函数是虚函数，派生类有同名的函数，默认为虚函数可以不用加virtual,自动覆盖基类同名函数。 想要覆盖基类同名函数，习惯添加virtual，增加可读性 哪些成员函数可以是虚函数 一般非静态成员函数可以是 构造函数不具有多态功能，不能是 析构函数可以是 纯虚函数纯虚函数是在声明虚函数是被“初始化”为0的函数，没有定义具体的操作内容，甚至没有函数体。要求各派生类根据实际需要定义自己的版本。声明格式 1virtual 函数类型 函数名(参数表) = 0; 纯虚函数没有函数体，不需要实现，即没有&#123;&#125; 最后面的=0并不表示函数返回值为0，它只是告诉编译器这是纯虚函数 用途是当基类不知道或者不需要这个函数有具体的意义无法实现但是派生类可以进行实现 抽象类带有纯虚函数的类是抽象类。有函数但是不实现。用于初步设计，信息抽象暂时不实现。 抽象类只能是基类 1234class 类名&#123; virtual 类型 函数名(参数表)=0; //其他成员...&#125; 凡是包含纯虚函数的类都是抽象类 一个基类如果包含一个或一个以上纯虚函数，就是抽象基类 抽象类不能实例化，即不能定义一个抽象类的对象 运算符重载c++中有以下五个运算符不能重载 成员访问运算符 成员指针访问运算符 域运算符 长度运算符 条件运算符 . .* :: sizeof ?： 重载运算符规则： 重载不能改变运算符运算对象(即操作数)的个数 重载不能改变运算符的优先级别 重载不能改变运算符的结合性 重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数，与1矛盾 重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质 运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非类的成员函数也不是友元函数的普通函数。 单目运算符image-20220414105129983 当使用重载运算符c1+c2就相当于是c1.operator+(c2),重载+左操作数就是本类。 双目目标：经过重载后，相当于oprd1.operator 运算符(oprd2),oprd1要是随意的一个类而不像单目那样是本类。 重载++，– 前置单目运算符，重载函数没有形参 后置运算符，重载函数需要一个int形参（为了区分，加一个形参） 编译器编译成oprd.operator ++ (0) image-20220414151336572 前置运算符重载函数类型是引用，返回的是*this 后置运算符重载函数类型是类，返回值是一个局部类变量。如果此时函数类型错写成引用，试想一下引用指向的是一个即将消亡的局部变量…… image-20220421084529945 第九章 模板与全体数据模板函数模板函数体是一样的，定义形式 1234template&lt;模板参数类型&gt;类型名 函数名(参数表)&#123; 函数体的定义&#125; template，声明创建模板 typename，表明其后面的符号是一种数据类型，可以用class代替 T，通用的数据类型，名称可以替换，通常为大写字母 编译器通过实参类型推导函数模板的类型参数，以模板生成一个函数，称为函数的实例化 注意： 一个函数模板并非自动可以处理所有类型的数据，只有能够进行函数模板中运算的类型，可以作为类型实参 函数模板只适用于函数体相同、函数的参数个数相同而类型不同的情况，如果参数的个数不同，则不能用函数模板 自定义的类需要为该类重载模板中的运算符，才能作为类型实参 image-20220421092713829 123456789101112131415//求绝对值template&lt;typename T&gt;T abs(T x)&#123; return x&lt;0?-x:x;&#125;int main()&#123; int n=-5; double d=-5.5; cout&lt;&lt;abs(n)&lt;&lt;endl; cout&lt;&lt;abs(d)&lt;&lt;endl;&#125;/*结果55.5*/ 类模板image-20220421094753875 image-20220421095132549 把T做替换成传入的参数 注意使用模板要加上尖括号和实参 类名&lt;&gt;看作整体类名来用 例： 1234567891011121314151617181920212223242526272829//9_2template &lt;class T&gt;class Store&#123;private: T item;//存放任意数据类型的数据 bool haveValue;//标记item是否被存入内容public: Store();//缺省形式的构造函数 T &amp;getElem();//提取数据函数 void putElem(const T &amp;x);//存入数据函数&#125;//成员函数的实现template &lt;class T&gt;//缺省构造函数的实现Store&lt;T&gt;::Store():haveValue(false)&#123;&#125;template &lt;class T&gt;//提取数据函数的实现T &amp;Store&lt;T&gt;::getElem()&#123;//&amp;看作是类型的一部分，放在前面 if(!haveValue)&#123; cout&lt;&lt;&quot;No item present!&quot;&lt;&lt;endl; exit(1);//异常退出 &#125; return item;&#125;template &lt;class T&gt;void Sotre&lt;T&gt;::putElem(const T &amp;x)&#123; haveValue=true;//表示item中已存入数值 item=x;//存入x&#125; 结构体成员快速初始化 大括号 image-20220421095911747 群体线性群体直接访问的线性群体——数组 动态数组如vector元素个数可以在程序运行时改变 顺序访问的线性群体——链表 image-20220421102517039 image-20220421104449075 image-20220421104801229 上图例子了两个版本的[]运算符重载，const的为了能修改常对象。返回的常引用对象(函数名前有const)只能读不能写。不能写参数和返回值 类内数组深层复制一般需要重载“&#x3D;”运算符 避免自身复制 if(&amp;rhs!=this) 比较数组大小是否相同，new（不相同则删除原有，重新分配 遍历数组一个一个复制 return *this 链表概念：链表是一种动态数据结构，可以用来表示顺序访问的线性群体。链表是由系列结点组成的，结点可以在运行时动态生成。每个结点包括数据域和指向链表中下一个结点的指针(即下一个结点的地址)。如果链表每一个结点中只有一个指向后继结点的指针，则该链表称为单链表。 如果每个结点中有两个用于连接其他结点的指针，一个指向前趋结点(称前趋指针)，另一个指向后继结点(称后继指针)，则构成双向链表。链表中的第一个结点称为头结点，最后一个结点称为尾结点，尾结点的后继指针为空。 image-20220428092308225 插入结点image-20220428092952786 data1的结点存放着data2节点的地址，要先把data2结点的地址给新节点然后再把新结点的地址给data1结点，顺序不能乱。 删除结点 要看是不是最后的结点 实现起来还要加一个前驱节点的地址，只有用前一个previous结点才能删除现在遍历到的current结点。 image-20220428093716001 栈概念：生活中的例子，假设餐厅里有一摞盘子，如果我们要从中拿取盘子，只能从上面一个开始拿，当我们要放上一个盘子是也只能放在最上面。栈的结构正是如此，每个盘子相当于栈中的一个数据，数据只能从栈的一端存入(“压入栈”)，并且只能从栈的同一端取出(“弹出栈”)，这一端叫栈顶，而栈的另一端叫作栈底。栈中的数据的添加和删除操作具有”后进先出“(LIFO)的特性，也就是说，栈中的所有数据，越早被压入的(接近栈底的)，就越晚被弹出。 表达式处理读取输入流，左边放数值，右边放运算符，运算符入栈的时候如果优先级低（如a-b加号优先级低于/ image-20220428100015878，那么不能入栈，这时弹出栈中运算符(如/)同时弹出对应操作数的数值进行运算，结果重新放回数值栈中，重复操作。 栈的基本操作 初始化 入栈 出栈 清空栈 把栈顶top置为-1 访问栈顶元素 检查栈的状态（满、空） 队列概念：柜台前、收款机前排队。队列是只能向一端添加元素，从另一端删除元素的线性群体，在队尾添加元素，在队头删除元素。在队头位置的标记成为队头指针，对队尾位置的标记称为队尾指针。向队尾添加元素称为”入队”，删除队头元素称为”出队”。”先进先出”(FIFO)，最早入队的最先出队。 image-20220428110937794 排序与查找插入排序(从后往前检索)比较的时候如果不满足停止条件，需要给key元素腾出空间，找到之后可以直接插入 image-20220505085145537 123456789101112131415161718192021//用直接插入排序法对数组A中的元素进行升序排列template &lt;class T&gt;void insertionSort(T a[], int n) &#123;\tint i, j;\tT temp;\t//将下标为1～n-1的元素逐个插入到已排序序列中适当的位置\tfor (int i = 1; i &lt; n; i++) &#123; //从a[i - 1]开始向a[0]方向扫描各元素,寻找适当位置插入a[i] int j = i; T temp = a[i]; while (j &gt; 0 &amp;&amp; temp &lt; a[j - 1]) &#123; //逐个比较，直到temp &gt;= a[j - 1]时，j便是应插入的位置。 //若达到j == 0，则0是应插入的位置。 a[j] = a[j - 1]; //将元素逐个后移，以便找到插入位置时可立即插入。 j--; &#125; //插入位置已找到，立即插入。 a[j] = temp;\t&#125;&#125; 选择排序image-20220505085639585 12345678910111213141516171819//辅助函数：交换x和y的值template &lt;class T&gt;void mySwap(T &amp;x, T &amp;y) &#123;\tT temp = x;\tx = y;\ty = temp;&#125;//用选择法对数组a的n个元素进行排序template &lt;class T&gt;void selectionSort(T a[], int n) &#123;\tfor (int i = 0; i &lt; n - 1; i++) &#123; int leastIndex = i;\t//最小元素之下标初值设为i for (int j = i + 1; j &lt; n; j++)\t//在元素a[i + 1]..a[n - 1]中逐个比较显出最小值 if (a[j] &lt; a[leastIndex])\t//smallIndex始终记录当前找到的最小值的下标 leastIndex = j; mySwap(a[i], a[leastIndex\t]);\t//将这一趟找到的最小元素与a[i]交换\t&#125;&#125; 交换排序每一轮沉底一个最大元素，n个元素最多排序n-1次，即沉底n-1个元素。 image-20220505090218593 一轮循环结束后lastExchangeIndex其实就是沉好底的元素最上面那个还没排的元素的索引 1234567891011121314151617181920212223242526272829//辅助函数：交换x和y的值template &lt;class T&gt;void mySwap(T &amp;x, T &amp;y) &#123;\tT temp = x;\tx = y;\ty = temp;&#125;//用起泡法对数组A的n个元素进行排序template &lt;class T&gt;void bubbleSort(T a[], int n) &#123;\tint i = n - 1;\t// i是下一趟需参与排序交换的元素之最大下标\twhile (i &gt; 0) &#123;\t//持续排序过程，直到最后一趟排序没有交换发生，或已达n - 1趟 int lastExchangeIndex = 0;\t//每一趟开始时，设置交换标志为0（未交换） for (int j = 0; j &lt; i; j++)\t//每一趟对元素a[0]..a[i]进行比较和交换 if (a[j + 1] &lt; a[j]) &#123;\t//如果元素a[j + 1] &lt; a[j]，交换之 mySwap(a[j], a[j + 1]); lastExchangeIndex = j;\t//记录被交换的一对元素中较小的下标，下一步j++ &#125; i = lastExchangeIndex;\t//将i设置为本趟被交换的最后一对元素中较小的下标\t&#125; //一般方法 for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-i-1;j++)&#123;//注意索引 if(a[j]&gt;a[j+1]) mySwap(a[j],a[j+1]); &#125;&#125; 二分查找当找不到数，注意结束的条件（左边界要是中间数加一，右边界是中间数减一） image-20220505095453135 12345678910111213141516/用折半查找方法，在元素呈升序排列的数组list中查找值为key的元素template &lt;class T&gt;int binSearch(const T list[], int n, const T &amp;key) &#123;\tint low = 0;\tint high = n - 1;\twhile (low &lt;= high) &#123;\t//low &lt;= high表示整个数组尚未查找完 int mid = (low + high) / 2;\t//求中间元素的下标 if (key == list[mid]) return mid; //若找到,返回下标 else if (key &lt; list[mid]) high = mid - 1;\t//若key &lt; midvalue将查找范围缩小到数组的前一半 else low = mid + 1;\t//否则将查找范围缩小到数组的后一半\t&#125;\treturn -1;\t//没有找到返回-1&#125; 第十章 泛型程序设计与C++语言标准模板库面向对象三个特性：封装、继承、多态 STL 标准模板库 六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器可以嵌套容器，里面的叫元素，分为序列式容器和关联式容器： ​ 序列式容器：强调值的顺序，有固定顺序 ​ 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 迭代器，用来遍历元素的指针。实际上迭代器是一个类，这个类封装了一个指针 image-20220512085602460 算法，通过有限的步骤，解决问题。 ​ 质变算法：运算过程中改变区间内元素内容，如拷贝替换查找。 ​ 非质变算法：不更改内容，如查找、计数、遍历 仿函数，行为类似函数，可作为算法的某种策略。 适配器，一种用来修饰容器或者仿函数活迭代器接口的东西 空间适配器，负责空间的配置与管理 迭代器是算法和容器的桥梁，使算法能够作用到容器。理解为提供给算法函数的指针参数。 容器算法迭代器初识vector容器存放内置数据类型创建： 1vector&lt;int&gt;v; 向容器尾部插入数据： 1v.push_back(10); 通过迭代器访问容器中的数据： 12vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置,所以*itEnd是错误的 第一种遍历方式： 1234while(itBegin!=itEnd)&#123; cout&lt;&lt; *itBegin&lt;&lt;endl; itBegin++;&#125; 第二种遍历方式（常用）： 123for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)&#123; cout&lt;&lt; *it&lt;&lt; endl;//*it解出来的类型对应vecotr&lt;&gt;尖括号里的类型&#125; 第三种用算法库： 123456//需要加#include&lt;algorithm&gt;void myPrint(int val)&#123; cout&lt;&lt;val&lt;&lt;&quot; &quot;;&#125;for_each(v.begin(),v.end(),myPrint);//在for_each(,,func())中需要调用到第三个参数，是一个函数，在内部会执行func(*first)传递迭代器的指向的值，这是只需拿到这个数执行回调函数输出即可。 vector存放自定义数据存放指针类型 123vector&lt;Person*&gt;v;//Person是一个类，存放Person类型的指针Person p1;v.push_back(&amp;p1);//注意是取地址，存放指针类型的 遍历 123for(vector&lt;Person*)::iterator it=v.begin();it!=v.end();it++)&#123; cout&lt;&lt;it-&gt;name;//或者是*it.name&#125; 存放容器类型，容器嵌套 1234vector&lt;int&gt;v;vector&lt; vector&lt;int&gt;&gt;V;v.push_back(10);V.push_back(v); 遍历，需要两层循环 123456for(vector&lt; vector&lt;int&gt;::iterator it=V.begin();it!=V.end();it++)&#123; //此时it类型指向vector&lt;int&gt;类型的指针 for(vector&lt;int&gt;::iterator vit=(*it).begin();vit!=(*it).end();vit++)&#123; cout&lt;&lt;*vit; &#125;&#125; string容器基本概念string是一个类，封装了一个char*来维护，是一个char*容器 1234string s1;string(const char* s);//使用字符串s初始化string(const string&amp; str);//使用一个string对象初始化另一个string对象string(int n,char c);//使用n个字符c初始化，如string s4(10,&#x27;c&#x27;)，则s4=&quot;ccccccccc&quot; vector容器单端数组，可动态扩展 动态拓展：并不是在原空间之后来连续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间 set容器概念set不允许插重复的，multiset可以。实现自动升序排序 1234567891011121314#include&lt;set&gt;set&lt;int&gt;s1;//构造函数set&lt;int&gt;s2(s1);//拷贝构造s1.insert();//插入数据只有insert方式，而没有push_backprintSet(s1);//遍历输出函数自己写//遍历输出void printSet(set&lt;int&gt;&amp;s)&#123; for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl;&#125; set大小和交换函数原型123size();//大小，set没有resize()重新设置大小的操作，因为当扩大时其余未设定的会补0导致重复s1.empty();//判断是非为空s1.swap(s2);//交换容器s1和s2 set插入和删除函数原型1234s1.insert();//插入s1.erase();//删除，可以放指针如s1.begin(),也可以放数值s1.clear();//清空s1.insert(st).second;//若插入重复则该返回值为false set查找和统计map容器map中所有元素都是pair pair中第一个元素为key（键值），第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质属于关联式容器，底层结构二叉树实现 优点：可以通过key快速找到value值 map容器构造和赋值1234567891011map&lt;int,int&gt;m;//创建需要两个参数，对组pair元素m.insert(pair&lt;int,int&gt;(1,10));//插入要对组pair//输出void printMap(map&lt;int,int&gt;&amp;m)&#123; for(map&lt;int,int&gt;::iterator it=s.begin();it!=begin();it!=m.end();it++)&#123; cout&lt;&lt;&quot;key=&quot;&lt;&lt;(*it).first&lt;&lt;&quot;value=&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; &#125; cout&lt;&lt;endl;&#125;map&lt;int,int&gt;m2(m1);//拷贝构造m2=m1;//赋值 总结：map中所有元素都是成对出现，输入数据时需要使用对组 map容器大小和交换123size();//大小empty();//判断为空swap(st);//交换 函数对象函数对象（仿函数）本质是个类，而不是一个函数 谓词仿函数 返回值类型是bool数据类型，称为谓词 一元谓词如果operator()接受一个参数，那么叫做一元谓词，两个参数叫二元谓词 12345678find_if(v.begin(),v.end(),查询条件);//返回值是v相同类型的迭代器，没找到返回的是v.end()class Mycompare&#123; public: bool operator()(int val1,int val2)&#123; return val1&gt;val2; &#125;&#125;//二元谓词的匿名函数find_if(v.begin(),v.end(),Mycompare());//类要加上括号 第十一章 流类库与输入输出输出流概述最重要的三个输出流ostream,ofstream,ostringstream 预先定义的ostream类对象用来完成向标准设备的输出： cout是标准输出流 cerr是标准错误输出流，没有缓冲，发送给它的内容立即被输出 clog类似cerr ofstream类支持磁盘文件输出 使用width控制输出宽度123456789101112131415161718#include &lt;iostream&gt;using namespace std; int main() &#123;\tdouble values[] = &#123; 1.23, 35.36, 653.7, 4358.24 &#125;;\tfor(int i = 0; i &lt; 4; i++) &#123; cout.width(10); cout &lt;&lt; values[i] &lt;&lt; endl;\t&#125;\treturn 0;&#125;输出结果: 1.23 35.36 653.7 4358.24//加上左边的空格正好十个宽度，右对齐 使用setw操纵符指定宽度1234567891011121314151617181920//11_2.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std; int main() &#123;\tdouble values[] = &#123; 1.23, 35.36, 653.7, 4358.24 &#125;;\tstring names[] = &#123; &quot;Zoot&quot;, &quot;Jimmy&quot;, &quot;Al&quot;, &quot;Stan&quot; &#125;;\tfor (int i = 0; i &lt; 4; i++) cout &lt;&lt; setw(6) &lt;&lt; names[i] &lt;&lt; setw(10) &lt;&lt; values[i] &lt;&lt; endl;\treturn 0;&#125;输出结果: Zoot 1.23 Jimmy 35.36 Al 653.7 Stan 4358.24//setw(n)指定了后面输出的内容宽度在n个宽度内，右对齐 设置对齐方式123456789101112131415161718192021//11_3.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std; int main() &#123;\tdouble values[] = &#123; 1.23, 35.36, 653.7, 4358.24 &#125;;\tstring names[] = &#123; &quot;Zoot&quot;, &quot;Jimmy&quot;, &quot;Al&quot;, &quot;Stan&quot; &#125;;\tfor (int i=0;i&lt;4;i++) cout&lt;&lt;setiosflags(ios_base::left)//左对齐 &lt;&lt;setw(6)&lt;&lt;names[i]&lt;&lt;resetiosflags(ios_base::left)&lt;&lt;setw(10)&lt;&lt;values[i]&lt;&lt;endl;\treturn 0;&#125;//这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。输出结果:Zoot 1.23Jimmy 35.36Al 653.7Stan 4358.24 向二进制文件输出1234567891011121314//11_5.cpp#include &lt;fstream&gt;using namespace std;struct Date &#123; int mon, day, year; &#125;;int main() &#123;\tDate dt = &#123; 6, 10, 92 &#125;;\tofstream file(&quot;date.dat&quot;, ios_base::binary);\tfile.write(reinterpret_cast&lt;char *&gt;(&amp;dt),sizeof(dt));//write函数是把内存中的一块内容写到一个文件输出流中\tfile.close();\treturn 0;&#125; 向字符串输出12345678910111213141516171819//11_6.cpp#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;inline string toString(const T &amp;v) &#123;\tostringstream os;\t//创建字符串输出流\tos &lt;&lt; v; //将变量v的值写入字符串流\treturn os.str();\t//返回输出流生成的字符串&#125; int main() &#123;\tstring str1 = toString(5);\tcout &lt;&lt; str1 &lt;&lt; endl;\tstring str2 = toString(1.2);\tcout &lt;&lt; str2 &lt;&lt; endl;\treturn 0;&#125; 输入流重要的输入流类： istream类最适合用于顺序文本模式输入。cin是其实例。 ifstream类支持磁盘文件输入。 istringstream 构造输入流对象 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。 1ifstream myFile(&quot;filename&quot;); 在调用默认构造函数之后使用open函数来打开文件 12ifstream myFile;//建立一个文件流对象myFile.open(&quot;filename&quot;);//打开文件“filename” 打开文件时可以指定模式 1ifstream myFile(&quot;filename&quot;,ios_base::in|ios_base::binary); 相关函数open函数把该流与一个特定磁盘文件相关联。get函数的功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包括空白字符。（第6章介绍过）getline的功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。（第6章介绍过）read成员函数从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。seekg函数用来设置文件输入流中读取数据位置的指针。tellg函数返回当前文件读指针的位置。close函数关闭与一个文件输入流关联的磁盘文件。 输入流举例应用为输入流指定一个终止字符利用getline函数 123456789101112//11_8.cpp#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string line; cout &lt;&lt; &quot;Type a line terminated by &#x27;\\t&#x27; &quot; &lt;&lt; endl; getline(cin, line, &#x27;\\t&#x27;); cout &lt;&lt; line &lt;&lt; endl;\treturn 0;&#125; istringstream将字符串转换为数值1234567891011121314151617181920//11_12.cpp, 头部分省略template &lt;class T&gt;inline T fromString(const string &amp;str) &#123;\tistringstream is(str);\t//创建字符串输入流\tT v;\tis &gt;&gt; v;\t//从字符串输入流中读取变量v\treturn v;\t//返回变量v&#125; int main() &#123;\tint v1 = fromString&lt;int&gt;(&quot;5&quot;);\tcout &lt;&lt; v1 &lt;&lt; endl;\tdouble v2 = fromString&lt;double&gt;(&quot;1.2&quot;);\tcout &lt;&lt; v2 &lt;&lt; endl;\treturn 0;&#125;输出结果：51.2 两个重要的输入&#x2F;输出流 一个iostream对象可以是数据的源或目的。 两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。 fstream类 fstream类支持磁盘文件输入和输出。 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象。 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出 stringstream类 stringstream类支持面向字符串的输入和输出 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成 第十二章 异常处理异常处理的语法 若有异常则通过throw创建一个异常对象并抛掷 将可能抛出异常的程序段嵌在try块之中。通过正常的顺序执行到达try语句，然后执行try块内的保护段 如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后的最后一个catch子句后面的语句继续执行 catch子句按其在try块后出现的顺序被检查。匹配的catch子句将捕获并处理异常（或继续抛掷异常）。 如果匹配的处理器未找到，则库函数terminate将被自动调用，其默认是调用abort终止程序。","tags":["编程语言","c++"],"categories":["编程","本科课程"]},{"title":"离散数学","path":"/2022/07/01/离散数学/","content":"第一章 命题逻辑的基本概念1.1 命题与连接词 非真即假的陈述句称作命题 作为命题，是否知道它的真值并不重要，重要的是它有唯一的真值。如2050年的元旦下大雪 用小写英文(p,q,r,s…至少从p开始往后数)表示命题 否定式“非p”﹁p是复合命题；∧合取 ∨析取 相容或和排斥或 相容或，即它联结的两个命题可以同时为真。如小明爱打球或跑步这两个命题可以同时为真，相容或 排斥或，只有当一个为真，另一个为假时，才为真。但是这个形式化有两种情况。 ①”只能“，小芳只能挑选跳舞课或羽毛球课 这里p:小芳挑选跳舞课 q:小芳挑选羽毛球课,结果并不能单纯用p∨q表示，因为当p，q同真时结果也是真，即小芳既选了跳舞可，又选了羽毛球课，不满足”只能“。此复合命题为真应该时当且仅当p、q其中一个为真，另一个为假时才成立。（这里我们容易联想到”异或“关系）如何用形式化表达呢？不如我们表示得详细一点：小芳挑选跳舞课但不挑选羽毛球课或小芳挑选羽毛球课但不挑选跳舞课。于是用符号化表示：**(p∧﹁q)∨(﹁p∧q)** ②不能同时为真的。小芳是江西人或安徽人 这里既可以用**(p∧﹁q)∨(﹁p∧q)** 表示，又可以用p∧q表示，因为小芳不可能既是江西人又是安徽人，即p、q不能同时成立。 p→q称为p蕴涵q;规定p→q为假当且仅当p为真q为假。当p为假时无论q真假p→q都是真。 p q p→q 0 0 1 0 1 1 1 0 0 1 1 1 除非和否则。除非小王穿毛衣，否则天不冷 将”否“和”则“断开，否掉除非后的命题，改成如果小王不穿毛衣，则天不冷 这样就好判断蕴涵关系了。 只有天冷，小王才穿毛衣 是q→p，只有……才……后面推前面。小王穿了毛衣说明天冷了。 (p→q)∧(q→p)与p↔q的逻辑关系完全一样，都表示p与q互为充分必要条件。 优先顺序：”( )” &gt; “﹁” &gt; “∧” &#x3D; “→” &#x3D; “↔” 命题的中文说法与符号化 ﹁p “非p” p∧q “p并且q” p∨q “p或q” p→q “如果p，则q” p↔q ”p当且仅当q“ 1.2 命题公式及其赋值 真值可以变化的陈述句叫命题变项，命题变项不是命题。命题变项用符号联结起来的符号称为合式公式，简称公式。命题用符号联结起来就是复合命题。区分：如果题目只有符号p之类的，就是命题变项；如果是p:简单命题那就是命题常项 公式的层数。单个命题变项算0层，﹁算1层，其他的就是max(i,j) 解释或赋值：用命题常项代替公式中的命题变项然后各指定一个真值0或1（不关心命题内容，只关心真假） 三种命题公式（设A为任一命题公式） 重言式，A在它各种赋值下取值均为真，全为成真赋值。 矛盾式，A在它各种赋值中取值均为假，全为成假赋值。 非重言式的可满足式,A既有成真赋值又有成假赋值。（可满足式：不是矛盾时就是可满足式，至少有一个成真赋值。） 第二章 命题逻辑等值演算2.1等值式 等值：在所有扶植下，A和B的真值都相同，则称A与B是等值的，记作 等值式模式 image-20220304214907554 image-20220304214932944 比较重要的等值式模式：1双重否定律、6德摩根律、8零律、9同一律、10排中律、11矛盾律 等值演算法做题顺序： ​ 1.消→，↔ （蕴涵等值式、等价等值式） ​ 2.消﹁( ) （德摩根律） ​ 3.消双重否定（双重否定律） 2.2 析取范式与合取范式 命题变项及其否定统称作文字。仅由有限个文字构成的析取式（合取式）称作简单析取式（简单合取式）。 注意：p,﹁p,q,﹁q就即是简单析取式又是简单合取式。（单个文字析取0或者合取1，也是本身） 由有限个简单合取式的析取构成的命题公式称作析取范式，由有限个简单析取式做合取构成的命题公式称作**合取范式,**统称为范式。 注意有些命题公式名字不唯一：p∧q∧r 即是由三个简单析取式做合取构成的合取范式，又是由一个简单合取式构成的析取范式（理解成 (p∧q∧r)∨1) )。 析取范式容易求成真赋值，合取范式容易求成假赋值 （范式存在定理）任一命题公式都存在与之等值的析取范式与合取范式。这就意味着我们可将所有的命题公式运用等值演算法转化为析取范式或合取范式的形式，方便求得赋值。 在含有n个命题变项的简单合取式（简单析取式）中，若每个命题变项和它的否定式恰好出现一个且仅出现一次[全部齐全]，而且命题变项或它的否定式按照下标从小到大或按照字典序排列，称这样的简单合取式（简单析取式）为极小项（极大项） 简单合取出极小项，简单析取出极大项。 由于命题变项还有否定形式，所以n个命题变项可以组成2^n个不同的极小项（极大项同理2n个）。每个极小项都有且仅有一个成真赋值，每个极大项也只有一个成假赋值，且不同的极小项（极大项）有不同的成真（成假）赋值。说明一个极小项可以提供一个成真赋值，一个极大项可以提供一个成假赋值。 讲极小项的成真赋值对应的二进制数等于十进制i，将这个极小项记作mi.例如p∨q∨r这个极小项成真赋值为111，对应十进制7，那么这个极小项记作m7;极大项同理，记作Mi。 ﹁mi⇔Mi , ﹁Mi⇔mi 主析取范式（主合取范式）：全部由极小项（极大项）构成的析取范式（合取范式）。 主析取范式是简单合取式的极小项做析取，直接看出所有成真赋值；主合取范式是简单析取式的极大项做合取，直接看出所有成假赋值。 任何命题公式都存在与之等值的主析取范式和主合取范式，并且是唯一的。我将其称之为主范式存在定理，这条定理为我们转化范式提供依据。 简单合取式转化为极小项的步骤，如： 少了一个命题变项的 p∧q⇔(p∧q)∧1 (同一律) ⇔(p∧q)∧(r∨﹁r) (排中律，置换规则) ⇔(p∧q∧r)∨(p∧q∧﹁r) (分配律) ⇔m7∨m6 这样就变成了两个极小项做析取。 少了两个命题变项的 p⇔p∧1 (同一律) ⇔p∧(q∨﹁q) (排中律，置换规则) ⇔(p∧q)∨(p∧﹁q) (分配律) ⇔((p∧q)∨(p∧﹁q))∨1 (同一律) ⇔((p∧q)∨(p∧﹁q))∧(r∨﹁r) (排中律，置换规则) ⇔(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r) (分配律) 简单析取式转化为极大项的步骤，如： 少了一个命题变项的： p∨q⇔(p∨q)∨0 (同一律) ⇔(p∨q)∨(r∧﹁r) (矛盾律)&#x2F;&#x2F;这一步和简单合取式变极小项不一样，前后的步骤基本一致,结果符号调换 …… ⇔(p∨q∨r)∧(p∨q∨﹁r) (分配律) 少两个命题变项的 p⇔p∨0 …… ⇔(p∨q∨r)∧(p∨﹁q∨r)∧(p∨q∨﹁r)∧(p∨﹁q∨﹁r) (分配律) **总结简单合（析）取式转化为极大（小）项基本步骤**： 缺少哪个变项就添加同时添加那个变项的原形和否定式，缺少多个就做排列组合 如p∧q最后变成(p∧q∧r)∨(p∧q∧﹁r) ，p变成(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r)，原本是合取式加上后各部分做析取，原本析取的加上后各部分做合取 出现重复的命题变项或极小项或矛盾式应消去，如，p∧p⇔p，mi∨mi⇔mi，用0代替矛盾式 A是一个有3个命题变项的公式，假设主析取范式为 m2∨m5∨m7，说明它的成假赋值有三个，010,101,111，那么剩下的23-3&#x3D;5个就是它的成真赋值了，则它的主合取范式为M0∧M1∧M3∧M4∧M6，相当于把真值表分为成真和成假，成真赋值压缩到主合取范式，成假赋值压缩到主析取范式，一眼就可以看出来。 第三章 命题逻辑的推理理论3.2 自然推理系统常用的推理定理： 假言推理 (A→B)∧A⇒B 拒取式 (A→B)∧﹁B⇒﹁A 析取三段式 (A∨B)∧﹁B⇒A 假言三段式 (A→B)∧(B→C)⇒(A→C) 前提： 结论： 推理证明的两个技巧： 附加前提证明法。如结论是A→B，就可以把A作附加前提引入推出B。 归谬法，将结论的否定式作为附加前提引入并推出矛盾式。如结论是﹁q，就把q作结论的否定引入最终推出矛盾式。 第六章 集合代数6.1 集合的基本概念子集 ⊆空集 ∅空集的符号化表示为：∅&#x3D;{x|x≠x} n元集含有n个元素的集合简称n元集，它的含有m(m≤n)个元素的子集称作它的m元子集 对于A&#x3D;{1,2,3},0元子集：∅；1元子集：{1},{2},{3}；2元子集：{1,2},{2,3},{1,3}；3元子集：{1,2,3} 幂集 P(A)定义：把集合A的全体子集（包括空集）构成的集合称为A的幂集 其中，P(∅)&#x3D;{∅}（空集是任何集合的子集），P({∅})&#x3D;{∅,{∅} }（想不通就把{∅}换成一个具体的数如{1} 例：A&#x3D;{1,2,3} ​ P(A)&#x3D;{∅,{1},{2},{3},{1,2},{1,3},{2,3},{1,3},{1,2,3} }； ​ P(A)中有2n个元素，表示成|P(A)|&#x3D;2n 例题：设A&#x3D;{ {∅},{ {∅} } },计算 P(A) ​ ✔正确答案：P(A)&#x3D;{∅,{ {∅} },{ { {∅} } },{ {∅},{ {∅} } } } ​ ❌易错答案：P(A)&#x3D;{∅,{∅},{ {∅} },{ {∅},{ {∅} } } } ​ 自己是个集合，因此A中元素外边还要加一层{} 6.2 集合的运算并集 ∪交集 ∩相对补集 B-AB-A&#x3D;{x|x∈B∧x∉A}查看源图像 对称差集 ⊕A⊕B&#x3D;(A—B)∪(B—A) 或者A⊕B&#x3D;(A∪B)-(A∩B) 图1.对称差文氏图表示,红色区域表示对称差 绝对补集 ~给定了全集A，~A&#x3D;E-A&#x3D;{x|x∈E∧x∉A} 广义并∪ 广义交∩image-20220330210030656 广义运算可以转化为初级运算： image-20220330210109294 实例： image-20220330210143336 注意： ∪{ {a} }&#x3D;{a},∩{ {a} }&#x3D;{a} 集合的运算规则一类运算：广义运算、幂集和~运算， ​ 运算由右向左进行 二类运算：初级运算∪、∩、—、⊕ ​ 优先顺序由括号确定 混合运算：一类运算优先于二类运算 6.3有穷集的计数（21年不考）文氏图&#x2F;韦恩图包容排斥原理image-20220330210948987 |A1∪A2|&#x3D;|A1|+|A2|-|A1∩A2| 下面这一条不用记，等于|S|-|A1∪A2∪…∪An|，将上面公式代入即可 image-20220330210744599 6.4 集合的恒等式P101 image-20220330211956188 image-20220330212009534 image-20220330212024361 image-20220330212038788 第七章 二元关系7.1 有序对和笛卡尔积有序对 &lt;x,y&gt;&lt;x,y&gt; 笛卡尔积 AXB定义：A,B为集合，用A中元素为第一元素，B中元素为第二元素构成的所有有序对组成的集合称为A和B的笛卡尔积 AXB&#x3D;{&lt;x,y&gt;|x∈A∧y∈B} image-20220330212640447 特别强调： (4)空集中取不出元素 A&#x3D;B且C&#x3D;D的必要条件是AXC&#x3D;BXD，后不能推前。例如A&#x3D;{1},B&#x3D;{2},C&#x3D;∅,D&#x3D;∅ 7.2 二元关系二元关系定义：一个集合满足①集合非空，且它的元素都是有序对 或者②集合是空集 二元关系都可看作是某个笛卡尔集的子集 定义2A,B是集合，AXB的任何子集所定义的二元关系称作从A到B的二元关系(表示顺序)，特别当A&#x3D;B是称作A上的二元关系 对于任一集合A定义 空关系 ∅对于任何集合A，空集∅是AXA的子集，称作A上的空关系 全域关系EAEA&#x3D;{&lt;x,y&gt;|x∈A∧y∈A}&#x3D;AXA 恒等关系IAIA&#x3D;{&lt;x,x&gt;|x∈A} 单位阵（第一元素作行，第二元素作列） 小于等于关系LALA&#x3D;{&lt;x,y&gt;|x,y∈A,x≤y} 上三角矩阵 整除关系DADA&#x3D;{&lt;x,y&gt;|x,y∈A,x|y} x|y,即x是y的因子 包含关系R⊆R⊆&#x3D;{&lt;x,y&gt;|x,y∈A,x⊆y} 例如：A&#x3D;{∅,{a},{a,b} } R⊆&#x3D;{&lt;∅,∅&gt;,&lt;∅,{a}&gt;,&lt;∅, {a,b} &gt;,&lt;{a},{a}&gt;,&lt;{a},{a,b}&gt;,&lt;{a,b},{a,b}&gt;} 关系矩阵关系矩阵行表示第一元素，列表示第二元素，若xiRxj则是1，否则是0 关系图&lt;xi,xj&gt;，从xi到xj的有向边 7.3关系的运算定义域 domR第一元素的集合 值域 ranR第二元素的集合 域 fldR定义域和值域的并集，即第一元素和第二元素的集合 逆关系 R-1R-1&#x3D;{&lt;x,y&gt;|&lt;y,x&gt;∈R} 合成运算看作矩阵的乘法 image-20220330214148187 限制取第一元素在A中的有序对。 image-20220330214257948 xRy: 如果&lt;x,y&gt;∈R，记作xRy 像取限制的值域（第二元素的集合） image-20220330214319792 image-20220330214340462 定理合成满足结合律；第二条看作矩阵的逆 image-20220330214516993 IA看作单位阵 image-20220330214607904 定理 7.4image-20220406205316304 合成运算与并满足分配律，但是和交运算不满足分配律，用包含于连接 定理 7.5**限制与交、并满足分配律；像与并满足分配律，与交不满足分配律** #### n次幂Rn的定义 ##### 定义 设R为A上的关系，n为自然数，则R的n次幂Rn定义为 1）R0={|x∈A}=IA} 2）Rn+1=Rn∘R **注意**：由定义1 image-20220406205448393我们可知∅0结果也是IA 关系矩阵有： 1）MR1∘R2&#x3D;MR1MR2 2）MRn&#x3D;MRn 注意：这里M带角标R表示的是R的关系矩阵 Rn重复性定理定理： 设A为n元集，R是A上的关系，则存在自然数s和t，使得Rs&#x3D;Rt 理解 因为R是A上的关系，对于任何自然数k，Rk都是AXA的子集（二元关系都可以看作是某个笛卡尔积的子集）.又|AXA|&#x3D;n2（A是n元集），所以其子集总数为2n2个。因此可知，Rk的取值情况是有限的，最多也就2n2个不同的值，然而R的幂是无穷多的，因此必有重复的 Rn关系图的规律image-20220406211644948 由定义可知R2&#x3D;R∘R,这里假设等号右边取&lt;a,b&gt;,&lt;b,c&gt;,结果是&lt;a,c&gt;。此时在R和R2的关系图中我们可以看到R这边从第一个元素a走到b走了一步，b到c又走了一步一共走了两步对应到了R2中的a→c。而R上所有第一元素能走三步到另外一个元素的情况就构成了**R3**的关系图。 7.4 关系的性质自反与反自反image-20220406212613972 例题： image-20220406212640736 image-20220406212651743 这里注意R2既不是自反，也不是反自反。因为定义中要求是对于任意的x而当x取1、2的时候在R2中都有对应的&lt;x,x&gt;。两个条件都不满足，故既不是自反，也不是反自反。 一个关系不可以既是自反又是反自反。 image-20220406212952970 对称与反对称image-20220406213117022 例题： image-20220406213134339 这里R3是反对称因为前件为假，蕴含式结果为真而空集即是对称也是反对称也是前件为假的原因。 对称也就是说如果我R里面的有序对的元素是A的元素那么这些有序对的一二元素交换也得是我R里的元素 判断反对称只需要找x≠y的关系，如果有&lt;x,y&gt;那么&lt;y,x&gt;必不能在，对于所有的都满足那么就有是反对称的 传递image-20220406214546687 也就是说若R中有能合成的有序对，那么其结果也在R内。 关系性质的充分必要条件设R为A上的关系，则 image-20220406214736110 五种性质：自反性、反自反性、对称性、反对称性、传递性 注意： 自反性是对于任意的x而言的，也就是说所有的&lt;x,x&gt;都应该在R里！反自反同理，即不能够出现&lt;x,x&gt;！ 一个关系不能既是自反的又是反自反的 一个关系可以既是对称的也是反对称的 例: A&#x3D;{1,2,3},R是A上的关系，R1&#x3D;{&lt;1,1&gt;,&lt;2,2&gt;}，R2&#x3D;{&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;1,2&gt;}，R3&#x3D;{&lt;1,3&gt;} 答：R1具有对称性、反对称性，既不是自反也不是反自反；R2具有自反性；R3是反自反的。 用关系矩阵记忆：自反性则主对角线全是1，反自反性则主对角线上全是0，对称性矩阵是对称矩阵，反对称性若rij为1则rij为0，传递性，M2中1所在的位置对应M上也是1. 7.5 关系的闭包闭包就是最少的添加 闭包的关系图设关系R, r(R), s(R), t(R)的关系图分别记为 G ，Gr ， Gs ，Gt ,，则 Gr ，Gs ，Gt 的顶点集与 G 的顶点集相等. 除了 G 的边以外, 以下述方法添加新的边： (1) 考察G 的每个顶点, 若没环就加一个环，得到 Gr (2) 考察 G 的每条边, 若有一条xi 到 xj 的单向边, i≠j, 则在 G 中加一条xj 到 xi 的反向边, 得到 Gs (3) 考察 G 的每个顶点 xi , 找 xi 可达的所有顶点 xj (允许i&#x3D;j )， 如果没有从 xi 到 xj 的边, 就加上这条边, 得到图 Gt tsr(R)&#x3D;t(s(r(R)))，表示R的自反、对称、传递闭包，从里到外。 7.6 等价关系与划分等价关系设R为非空集合A上的关系。如果R是自反的、对称的和传递的，则称R为A上的等价关系。（对角线全为1，且是对称矩阵，M2的1对应M也是1） 等价类x的等价类 [x]R&#x3D;{y|y∈A∧xRy} 通俗来说就是R中哪些第一元素是x就把第二元素拿出来 商集设R为非空集合A上的等价关系，以R的所有等价类作为元素（不同块的集合）的集合成为A关于R的商集，记作A&#x2F;R，即 A&#x2F;R&#x3D;{[x]R|x∈A} 例如： image-20220618193029669 其中的等价类有：[1]&#x3D;[4]&#x3D;[7]&#x3D;{1,4,7}，[2]&#x3D;[5]&#x3D;[8]&#x3D;{2,5,8}，[2]&#x3D;[6]&#x3D;{3，6} 商集为：{ {1,4,7}，{2,5,8}，{3,6} } 划分满足条件： 是A子集的构成的集合 空集不存在里面 子集的交集是空集 这个子集族π(A的子集构成的集合，π⊆P(A))的并集就是A 则称π是A的一个划分，称π中的元素为A的划分块。 例：A&#x3D;{a,b,c,d}，给定π1&#x3D;{ {a}，{a,b,c,d} }，π2&#x3D;{∅，{a,b}，{c,d} }，π3&#x3D;{ {a,b}，{c}，{d} }，则*π1和π2都不是A的划分，π3*是A的划分（可以不止一个划分）。 在等价关系中，划分就是商集，划分块就是等价类。 7.7 偏序关系小于等于设R为非空集合A上的关系。如果R是自反的、反对称的和传递的，则称R为A上的偏序关系，记为≼。设≼为偏序关系，如果&lt;x,y&gt;∈≼，则记作x≼y，读作x”小于等于“y。 注意：这里的”小于等于“（也可理解为大于等于）不是指数的大小，而是指在偏序关系中的顺序性。依照不同定义的序，x排在y的前边或者x就是y。 三种符号： xRy：&lt;x,y&gt;∈R x~y：&lt;x,y&gt;∈R且R是等价关系 x≼y：&lt;x,y&gt;∈R且R是偏序关系 例如，恒等关系IA，小于等于关系LA、整除关系DA和包含关系R⊆都是相应集合上的偏序关系。一般全域关系EA不是A上的偏序关系 定义： 若x≼y ∧ x ≠ y , 则记作x≺y,读作x小于y。 （x≺y说明&lt;x,y&gt;∈R∧x≠y） x与y可比有三种情况：x&#x3D;y，x≺y，y≺x 例如，A&#x3D;{1,2,3}，≼是A上的整除关系，则有1≺2，1≺3；1&#x3D;1，2&#x3D;2，3&#x3D;3；2和3不可比（不满足整除） 全序关系设R为非空集合A上的偏序关系，如果∀x,y∈A，x与y都是可比的，则称R为A上的全序关系 偏序集集合A和A上的偏序关系一起叫做偏序集≼，记作&lt;A,≼&gt;。 覆盖x≺y且 x，y 之间没别的元素，则称 y 覆盖 x。 哈斯图只连覆盖关系，y覆盖x则把y画在x上方 例：偏序集&lt;{1,2,3,4,5,6,7,8,9}，整除关系&gt;和&lt;P({a,b,c},R⊆)的哈斯图 image-20220619085448843 最小元、最大元、极小元、极大元&lt;A,≼&gt;为偏序集，B⊆A，y∈B 最小(大)元：y小于(大于)等于B中的任何一个元素 极小(大)元：B中没有其他元素小于(大于)我 例：A&#x3D;{1,2,…,36}上的整除关系，B&#x3D;{2,3,4,12} 最小元：无（不会是2，因为2没办法整除3，不满足y小于等于B中的任何一个元素） 最大元：12（12可以大于等于2,3,4） 极小元：2，3（没有再可以整除2和3的了，有两个） 极大元：12（没有12能整除的数了） 上界、下界&lt;A,≼&gt;为偏序集，B⊆A，y∈A（y不同于上面的定义，这个范围更大） 上界和下界定义和最大元和最小元相同，不同的是y的范围。 C&#x3D;{y|y为B的上界}，则称C的最小元为B的最小上界或上确界。（上界中的最小） D&#x3D;{y|y为B的下界}，则称D的最大元为B的最大下界或下确界。（下界中的最大） 注意： B的上界、下界、最小上界、最大下界都可能不存在 如果存在，最小上界与最大下界是唯一的，而上下界不一定唯一 集合中如果存在最小元，那么这个最小元就是其最大下确界；最大元是上确界 画出哈斯图一般会有利于判断 例：A&#x3D;{1,2,…,36}整除关系，B&#x3D;{6,12,18}，C&#x3D;{4,6,12} B的最小元是6，下界是1,2,3,6。下确界即为最小元6 B的最大元没有，上界是36，上确界为36 C的最小元没有，下界是1,2，下确界为2 C的最大元为12，上界为12,24,36，上确界为最大元12 第十四章 图的基本概念14.1 图无序积：{ {a,b}|a∈A∧b∈B}，记作A&amp;B 无序积中的无序对记作(a,b) 二元组一个无向图G是一个有序的二元组&lt;V,E&gt;，其中 V是一个非空有穷集，称作顶点集，其元素称作顶点或结点 E是一个无序积V&amp;V的有穷多重子集(可重复)，称为边集，其元素称作无向边，简称为边 而有向图的二元组中的E的元素为有向边 图 图，有向图和无向图的统称 阶，顶点数称作图的阶，n个顶点的图称作n阶图 零图，一条边也没有的图；平凡图，1阶零图称作平凡图，只有一个顶点，没有边 定义中V要是非空的，但是运算中可能会出现顶点集为空集的情况，规定顶点集为空集的图为空图，记作∅ 如果给每一个顶点和每一条边指定一个符号，称这样的图为标定图，否则非标定图 相邻对于无向图，若两个顶点 vi 与 vj 之间有一条边连接，则称这两个顶点相邻。若两条边至少有一个公共端点，则称这两条边相邻 对于有向图，顶点之间有一条有向边则相邻，两条边一条的终点是另一条的起点，则两条边相邻 没有边关联的顶点称作孤立点 无向图G&#x3D;&lt;V,E&gt;中， 邻域是所有与我相邻的点，不包括我自己 闭领域是邻域并上子集 关联集是所有与我关联的无向边(环那条也算) 有向图D&#x3D;&lt;V,E&gt;中， 有向图的先驱元集和后继元集的定义中&lt;u,v&gt;,u不等于v，即不能是自己(环的情况) 邻域是先驱元集和后继元集的并 闭邻域即邻域加上自己 平行边无向图中，关联一对顶点的两条或以上的边为平行边 有向图中，关联一对顶点的有向边多于1条，称为平行边 简单图含平行边的图称作多重图(存在相同的无序对) 既不含平行边也不含环的图称作简单图 度数无向图中，v作为边的端点的次数称为度数，记为d(v) 有向图中，v作为边的始点的次数为v的出度，记为d+(v)；作为边的终点的次数为v的入度，记为d-(v) 度数列就是把各个顶点的度数列出来d(v1)&#x3D; ,d(v2)&#x3D;,… 最大度Δ(G)最小度img(G)握手定理在任何无向图中，所有顶点的度数之和等于边数的2倍 可图化 给定的非负整数列d&#x3D;(d1,d2,..,dn)，若存在以V&#x3D;{v1,v2,…,vn}为顶点集的n阶无向图G，使得d(vi)&#x3D;di，则称d是可图化的（即每个顶点度数要够） 可简单图化：若得到的图是简单图，则d是可简单图化的 判断方法：非负整数列d&#x3D;(d1,d2,..,dn)是可图化的当且仅当奇数度顶点个数为偶数 例：(3,3,2,1)和(3,2,2,1,1)奇数度顶点个数为3，不是偶数，不是可图画的。而(3,3,2,2)和(3,2,2,2,1)画一下图发现满足，是可图化的 完全图 n阶完全图，G中每个顶点均与其余的n-1个顶点相邻称为n阶无向完全图，简称n阶完全图 n阶有向完全图，有向图D中每个顶点都邻接到其余的n-1个顶点 n阶竞赛图，基图为Kn的有向简单图 14.2 通路与回路G为无项标定图，，G中顶点与边交替的序列Г&#x3D;vi0ej1vi1ej2…ejlvil称为从起点vi0到终点vil的通路，Г中边的条数称为它的长度。 回路若起点和终点相同，则称Г为回路。 简单通路、简单回路若Г所有边各异，则称Г为简单通路；若简单回路的起点和终点相同，则称为简单回路。 初级通路、初级回路（圈）若所有顶点各异（除起点和终点可能相同外），所有边也各异，则称Г为初级通路；若又有起点和终点相同，则称为初级回路或圈 注意 初级包含于简单，简单回路包含于简单通路，但是初级回路和初级通路在应用中完全分开。 长为1的圈（初级回路）只能由环生成，长为2的圈只能由平行边生成；而在简单无向图中，圈的长度至少为3，因为简单无向图中没有环和平行边。 14.3 图的连通性距离d(u,v)无向图G中u,v之间长度最短的通路为u,v之间的短程线，短程线的长度成为u,v之间的距离，记作d(u,v)。 点割集、边割集全部拿掉后，连通分支数增加、只拿掉其中一部分不影响。 割点、桥点割集{v}，则v是割点，同理的边成为桥（割边）。 无向连通图不一定有点割集（如Kn），但一定有边割集（只要去掉足够多的边，一定会有点连不上） 点连通度k(G)、边连通度λ(G)想把我从连通图变为非连通图，则至少删去k个顶点&#x2F;边 短程线、距离d&lt;vi,vj&gt;image-20220531205953526 短程线，最短的通路；短程线的长度称为距离 连通图、单向连通图、强连通图定义若有向图D的基图是连通图，则称D为弱连通图，简称为连通图。（一眼看上去是一个整体） 若∀vi,vj∈V,vi→vj与vj→vi至少成立其一，则称D为单向连通图。 若∀vi,vj∈V,均有vi↔vj，则称D为强连通图。（任意两点相互可达） 连通图⇒单向连通图⇒强连通图，条件要求越来越高 判别定理定理 14.8 有向图D&#x3D;&lt;V,E&gt;是强连通图当且仅当D中存在经过每个顶点至少一次的回路。 定理 14.9 有向图D是单向连通图当且仅当D中存在经过每个顶点至少一次的通路。（只需证vi可达vj或vj可达vi） 二部图将无向图划分成两部分V1和V2，使得每条边的两个端点都是一个属于V1，一个属于V2，则称无向图G为二部图。（环一定不是） 若G是简单二部图且V1中的每个顶点与V2中所有顶点相邻（有一条边相连），则称G为完全二部图，记为Kr,s,其中r&#x3D;|V1|,s&#x3D;|V2|。 注意：n(n≥2)阶零图为二部图 将图按如下方式尝试分成两部分，判断(a)为二部图 （e image-20220531211814859为完全二部图，上面r个点，下面s个点，共有rxs条边，点连通度为min{r,s}，即拿掉少的部分的所有点；边连通度也为min{r,s}，即拿掉一个点的所有边。 image-20220531212002901 14.4 图的矩阵表示关联矩阵M(G)关联矩阵表示的是顶点和边的关系，行是各点，列是各边，记录关联次数（注意无向图中环的点边关联次数为2） 有向图中无环的关联矩阵中，用1表示这个点是这条边的始点，0表示不关联，-1表示这个点是这条边的终点 邻接矩阵A(D) (有向图)有向图，表示从顶点vi邻接到顶点vj有多少条边，行和列都是点。 vi指向vj才加1，环自身加1 邻接矩阵A和Al反应的几个信息： aij(l)为D中vi到vj长度为 l 的通路数 对角线上的aii(l)表示到自身长度为 l的回路数 矩阵所有元素之和表示D中长度为 l 的通路（含回路）总数 其中对角线元素之和表示长度为 l 的回路总数 可达矩阵P(D) (有向图)首先首先，对角线先全标上1，自己可达自己 vi可达vj则标上1，否则为0 注意：什么叫可达？不是说一步走到是可达，而是存在通路即可，走多少步没关系，只要能走到就是可达！ D为强连通当且仅当P(D)为全1矩阵 第十五章 欧拉图与哈密顿图15.1 欧拉图欧拉通路通过图（无向图或有向图）中所有边一次且仅一次行遍所有顶点的通路称作欧拉通路。 欧拉回路通过图中所有边一次且仅一次行遍所有顶点的回路称作欧拉回路。 欧拉图具有欧拉回路的图称作欧拉图。 半欧拉图具有欧拉通路而无欧拉回路的图称作半欧拉图。 注意1 规定平凡图是欧拉图。(平凡图是只有一个孤立点组成的图) 欧拉通(回)路是简单通(回)路，但不一定是初级通(回)路。因为欧拉可以走环，而走了环就不满足所有点各异的条件，也就不是初级。 无向欧拉图的判别方法定理15.1 无向图G是欧拉图当且仅当G是连通图且没有奇度顶点。 ​ 即顶点的度数为偶数。理解：因为经过一个点需要走进来再走出去，而度数是由边提供的，故顶点度数为偶数。 定理 15.2 无向图G是半欧拉图当且仅当G是连通的且恰有两个奇度顶点。 有向欧拉图的判别方法定理 15.3 有向图D是欧拉图当且仅当D是强连通的且每个顶点的入度等于出度（度数为偶）。 ​ 一个图要是欧拉图它得首先是个强连通图。 定理 15.4 有向图D是半欧拉图当且仅当D是单向连通的且恰有两个奇度顶点，其中一个顶点的入读比出度大1，另一个顶点的出度比入度大1，而其余顶点的入度等于出度。 ​ 一个图是半欧拉图它得首先是个单向连通图 定理15.5G是非平凡的欧拉图当且仅当G是连通的且是若干个边不重的圈（无向）的并。 很好理解，如果是若干个边不重的圈的并，那么每个点度数都为偶 15.2 哈密顿图 经过图（有向图或无向图）中所有顶点一次且仅一次的初级通路称为哈密顿通路。 经过图中所有顶点一次且仅一次的初级回路称为哈密顿回路。 具有哈密顿回路的图称为哈密顿图。 具有哈密顿通路但不具有哈密顿回路的图称为半哈密顿图。 首先哈密顿通路一定是初级通路。但是对于哈密顿回路，如果加是初级回路的前提，那么哈密顿回路可以不是初级回路，例如v1ev2ev1，出现了重复的边，不是初级回路，但它确实是经过所有顶点一次且仅一次的回路。 哈密顿图的必要条件定理15.6 无向图G&lt;V,E&gt;是哈密顿图，则对于任意V1⊂V,且 V1≠∅，均有**p(G-V1)≤|V1|**。 ​ p是连通分支数，理解:分两种情况，一种v1,v2不相邻，去掉三个点，连通分支数为3；一种v1,v2相邻，与v3不相邻，去掉后两部分；当然如果都相邻去掉后为1，都满足p≤3 image-20220601214204395 是半哈密顿图，则有p(G-V1)≤|V1|+1 作为必要条件，用来初步判断其不是哈密顿图&#x2F;半哈密顿图 看看完全二部图什么时候是哈密顿图，用必要条件初步判别 image-20220601215140909 哈密顿图的充分条件G为n阶无向简单图，若对于G中任意不相邻的顶点u,v,均有度数和d(u)+d(v)≥n-1，则G中存在哈密顿通路。 （存在哈密顿通路说明其可能是哈密顿图也可能是半哈密顿图 推论：设G为n(n≥3)阶无向简单图，若对于G中任意两个不相邻的顶点u*,v均有 d(u)+d(v)≥n*则 G 中存在哈密顿图 哈密顿图解决实际问题","tags":["数学"],"categories":["本科课程"]},{"title":"云服务器搭建mc服务器经验总结","path":"/2022/03/04/云服务器搭建mc服务器经验总结/","content":"首先​ 我的云服务器是轻量化服务器2核4G，ubuntu，指令不同就是yum要改成apt hhh 刚开始照这网上做就是因为这个导致一开始就失败哈啊哈哈哈。 温馨提示：以下只是很粗糙的总结，如果真要动手的话建议还是直接到文章最下面去看看一些大佬的教程 配置一下服务器叭1.密钥、密码设置好 2.添加一个端口25565（阿里云是没有开这个的） 3.重启 下几个软件连接服务器​ 我这边用的是Xshell 6和FlashFXP 5。通过服务器公网ip和账号密码连接上就可以了 安装JAVA 17.0.1这里千万注意！ 1.装的是linux的，不要把自己电脑windows的放上去啊 2.版本！Linux x64 Compressed Archive 否则：unable to access jarfile 3.我是在电脑下载好安装包，用flashxp放上去根目录然后在Xshell解压 ​ tar -zxvf [文件名加.gz] 直接把自己原来的整个服务端文件打包上传上去如果你用过自己的电脑开过服的就很方便了，因为启动脚本全部已经都写好了（ 比如start.sh ）！利用FlashFXP上传文件到服务器里。（但是要开放执行权限！！！）上传后–文件右键–属性 权限全部勾上简单粗暴 开搞！装screen,后台运行用 apt install screen 然后开窗口 screen -S [自定义窗口名] cd到start.sh的文件夹下 ./start.sh 这里有可能会遇到打不开的问题：bad interpreter 这就需要把start.sh的doc改成unix。怎么改网上都有 然后重新 ./start.sh 看到Done!就搞定了！ 在mc多人游戏里直接连接-输入ip就能成功连接了！ 这里screen还是有一些其他指令的，比如 screen -ls 可以查看现在在运行的指令。 连接screen 其他的上网查查看吧 【参考资料】 1.零基础！使用云服务器搭建Minecraft服务器 - 哔哩哔哩 (bilibili.com) 2.【MC开服教程】十分钟手把手教你怎么用白嫖来的阿里云ECS搭建一台mc服务器|Linux搭建mc服务器_哔哩哔哩_bilibili 3.我的世界百分百成功搭建 阿里云 百度云 腾讯云服务器教程，超简单！！！！_哔哩哔哩_bilibili 这里上几张和舍友联机的截图吧，取名就是我们的宿舍号G318。其中大部分建筑都是FireEgg搭建的，他是MC骨灰级玩家了。 image.png image.png image.png image.png","tags":["教程","服务器","云服务器","minecraft"],"categories":["教程","编程"]},{"title":"my-first-blog","path":"/2022/03/03/my-first-blog/","content":"这是我的第一个博客文章"},{"title":"Hello World","path":"/2022/03/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing 1234$ hexo clean //清除缓存$ hexo g //生成静态文件$ hexo s //启动本地服务$ hexo d //上传 Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]