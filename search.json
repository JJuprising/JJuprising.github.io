[{"title":"软件测试","url":"/2024/05/27/软件测试/","content":"\n# 白盒测试\n\n```mermaid\ngraph TD\nA(组合覆盖)-->B(判断/条件覆盖)\nB-->C(判断覆盖)\nC-->D(语句覆盖)\nB-->E(条件覆盖)\n```\n\n> 判断覆盖一定是语句覆盖！\n\n![image-20240527162901548](软件测试.assets/image-20240527162901548.png)\n\n![image-20240527162921705](软件测试.assets/image-20240527162921705.png)\n\n![image-20240527162932222](软件测试.assets/image-20240527162932222.png)\n","categories":["本科课程"]},{"title":"论文写作经验","url":"/2024/04/22/论文写作经验/","content":"\n目前由于老师习惯用word批注，因此最初都会通过word简历草稿，latex其实在不用大改的情况去成稿是更加方便规范的。Latex的记录在2023年10月就已形成了，可以翻看。而下面一些内容会涉及到word。\n\n关于文献引用，可以看[【论文写作】Zotero文献引用技巧 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/689808657)\n\n然而，这貌似并不是最完美的办法，因为我发现在正文插入文献后，序号的顺序会乱，本来前面是123好好的，插着插着前面就变成78之类的了。\n\n更新域看看引用是否都正确\n\n用比如Gammerly检查语法，有条件上AI，比如Curie。自己再要看一遍意思对不对，有没有偏差\n\n浏览图片有没有放错图\n\n# 如何写\n\n## 调研\n\n近几年最好的文章。谷歌学术搜索。\n\n入门先看大的综述，0基础就先看中文好的，然后看英文，粗略看。\n\n看技术，十年前是什么算法，十年-五年有什么改进，五年之内又是什么样了。\n\n以此构建自己对这个领域的梳理和认识。\n\n了解这个领域，最牛的团队。后续关注谁，谁有可能跟我的idea撞车。同时，不知道怎么写也知道参考谁的比较靠谱。此外，陶瓷的时候也可以更加有优势，知道人家在做着什么需要什么。\n\n## 第二阶段\n\n描述问题-》缩小问题(精深)/找到大部分用的方法然后泛化->设计试验>\n\n​    ^-------------------------------------------------------------------------------------------\n\n上面过程进行不断迭代，反思原因改方案改实验/改问题(doge/\n\n形成结果然后写稿\n\n对问题的描述应该尽量符号化/数学，严谨且说的清晰。\n\n不一定按照别人的方法做才能合适，可能人家运气好之类的，思路要打开，广泛得去探索去想解决问题的办法。\n\n## 如何写稿\n\n五个部分\n\nintro：背景、存在的问题，解决方法贡献总结\n\n相关工作(对intro存在的分门别类讲清楚diss一下，引出问题描述)，问题描述\n\n方案：数学定义，讲清楚流程，算法架构，setup之类的\n\n实验：细节，消融实验\n\n摘要Abstract对应这五个部分，”五句话“\n\n数学怎么来的？参考文章。核心参考文献浓缩到五篇\n","categories":["经验"]},{"title":"AlexNet","url":"/2024/03/18/论文精读-AlexNet/","content":"\n[9年后重读深度学习奠基作之一：AlexNet【论文精读·2】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ih411J7Kz/?spm_id_from=333.788&vd_source=8ecff66abb776707f111647a284db8d9)\n\n读论文\n\n* 第一遍：题目摘要讨论总结，一些图和公式\n\nBERT无监督\n\nAlexNet之前事无监督，AlexNet有监督\n\n\n\n把最后一层的输出向量拿出来对比，在语义空间表示很好\n\n写论文最好不要局限小领域小方向，其他的也要提提公平些。\n\n研究能够让别人往下做是比较好的，而不是纯堆技术做的非常强。\n\nend-to-end端到端，原始图片文本进去，神经网络直接做出来\n\n\n\n结构图，维度是输入输出数据大小，中间小块是卷积核\n\n维度长宽逐渐降低降低，一小块表征原始的一大块，而通道不断增加，语义上信息的理解，这个通道理解猫腿，这个理解一个边等\n\n不断压缩，增加语义理解   \n\ndrop out 正则的东西\n\nsgd机器学习应用广泛的优化算法。weight decay加在模型上，其实就是一个L2正则化\n\n利用均值为0，方差为0.01的高斯分布初始化权重，以后的工作全部初始化为0也不错。BERT是方差为0.02，和模型复杂度有关。\n\n现在用平滑曲线来下降学习率，比如一个cos函数，横坐标是epoch。AlexNet就是每次下降10倍，节点手动选择。\n","tags":["DL"],"categories":["深度学习"]},{"title":"大数据原理与实践","url":"/2024/03/07/大数据原理与实践/","content":"\n\n\n# Hadoop基础\n\nMapReduce并行计算架构\n\nYARN\n\nHDFS分布式文件系统\n\n## HDFS\n\n计算机集群\n\n* 将文件分布存储到多个计算机节点，节点构成计算机集群\n* 计算机集群都是由普通硬件构成，大大降低硬件开销\n* 通过“心跳”判断是否节点损坏，有多个副本，不怕损坏\n\n结构\n\n* 采用主从结构，有主节点和从节点\n* 一个主节点关联多个从节点，一个从节点关联多个主节点，因此数据在不同从节点中有多个副本\n\nBlock-块\n\n* windows块大小是4k，而HDFS默认默认一个块128MB，一个文件被分成多个快，以块为存储单位\n* 块大也可以最小化寻址开销\n* 抽象块概念好处\n  * 支持大规模数据存储\n  * 简化系统设计\n  * 适合数据备份\n\n\n\n# HBase\n\n## 和传统关系数据库的对比\n\nHBase行操作，处理大型数据会方便\n\n（1）数据类型：关系数据库采用关系模型，具有丰富的数据类型和存储方式；HBase采用简单的数据模型，把数据存储为未经解释的字符串\n\n（2）数据操作：关系数据库包含丰富的操作，涉及复杂的多表连接。HBase不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空；HBase在设计上避免复杂的表和表之间的关系\n\n（3）存储模式：关系数据库：基于行模式存储。\n\n（4）数据索引：关系数据库：可以针对不同列构建复杂的多个索引，以提高数据访问性能；\n\n HBase只有一个行键索引，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来\n\n（5）数据维护：关系数据库：更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后不会存在。\n\n HBase中执行更新操作时，不会删除旧版本，而是生成一个新的版本\n\n（6）可伸缩性：关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。\n\n HBase能轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩\n\n## 数据模型\n\n行：每个HBase表都由若干个行组成，每个行由行键标识\n\n列族：列族数据通过列限定符来定位\n\n单元格：行和列确定的\n\n![image-20240411142446840](大数据原理与实践.assets/image-20240411142446840.png)\n\n## 功能组件\n\n两个组件\n\n* 一个Master主服务器，负责管理\n* 多个Region服务器，负责维护和分配给自己的Region\n\n一个HBase表被划分成多个Region，一个Region会分类为多个新的Region\n\n![image-20240411142504300](大数据原理与实践.assets/image-20240411142504300.png)\n\n![image-20240411142509594](大数据原理与实践.assets/image-20240411142509594.png)\n\n## Region 的定位\n\n元数据表META表，存储REgion和Region服务器映射关系\n\n当HBase表很大，META表会分裂多个Region\n\n根数据表，又名-ROOT-表，记录所有元数据的具体位置\n\n-ROOT-表只有唯一一个Region\n\nZookeeper文件记录了-ROOT-表的位置\n\n![image-20240411142519563](大数据原理与实践.assets/image-20240411142519563.png)\n\n# 内存大数据计算架构Spark\n\n* 快速、通用的开源大数据处理引擎\n* 与Hadoop平台类似，兼容\n\n## Spark RDD\n\n特性：\n\n* 数据集合\n* 弹性分布\n* 可持久化\n* 分布式存储\n* 只读\n* 可重新计算\n\n\n\nRDD转换操作\n\n| **RDD****转换** | **含义**                                                     |\n| --------------- | ------------------------------------------------------------ |\n| map(func)       | 通过函数func对数据集中的每个成员进行转换                     |\n| filter(func)    | 通过函数func选择过滤数据集中的成员                           |\n| flatMap(func)   | 和map转换类似，但函数func可以把单个成员转换为多个成员。      |\n| union(other)    | 返回当前集合与otherDataset集合的union操作                    |\n| distinct        | 去掉集合中重复成员，使新的集合中成员各不相同                 |\n| groupByKey      | 对键-值（key-value）对集合按照键（key）进行groupBy操作       |\n| sortByKey       | 对键-值（key-value）对集合进行排序                           |\n| join(other)     | 对两个键-值（key-value）对集合：（K,V），（K,W）进行连接操作，形成新的键-值对集合：（K，（V,W）） |\n\nRDD依赖关系：RDD转换生成新的RDD, 新的RDD依赖于旧的形成依赖关系\n\n窄依赖：map rdd1一个只对一个rdd2\n\n宽依赖：一个对多个\n","categories":["本科课程"]},{"title":"数模notes","url":"/2023/11/19/数模notes/","content":"\nAuthor：[JJuprising](https://jjuprising.github.io/)\n\n# 基本流程\n\n1. 拿到题目每个题都看看，画出背景材料和题干的关键字\n2. 对题目进行题型分类，统计分析/相关性问题(是否有关系、正负相关)/评价类/分类问题/预测问题/优化类\n3. 确定选题之后，先找思路，可以通过仔细阅读题目、查阅相关国内外论文(国内知网、国外谷歌学术,没有梯子用熊猫学术)、百度网上的思路等，铺垫一下基本知识（本过程需要现学一些模型和算法）\n4. 有些题目很笼统、晦涩，一开始搞不清出很正常，这个时候不要仓促下笔，多找资料多了解，搞清楚题目在问什么，想让你怎么用数学方法解决什么问题；注意一下前后问题的关联\n5. 有数据的题目在spsspro预处理一下，根据题型选不同模型跑一下结果对比看看\n6. 没数据的题目如果需要的话是可以在官方网站收集数据集的，这里就考验大家的数据检索和收集能力\n7. 写完论文内容之后凝练摘要、关键字\n\n# 小tips\n\n* 不建议上来第一二天冲太猛(除非思路非常清晰)，前两天不要熬太多，否则最后疲软，后劲不足\n* 切忌中途换题，组内多沟通，不要脱离队伍，不要摆烂，坚持到完成论文\n* 发挥主观能动性，多收集信息\n* 不要浪费太多时间死磕模型的数学原理，本科生是搞不明白的，主张“拿来主义”\n* 数据可以动点小操作，灵活一点，不要太死板辣~\n* 尽力而为，运气成分挺大的，比完之后放平心态接受结果\n\n# 论文结构\n\n## 题目\n\n国赛题目一般是：基于XXX模型的XXX问题研究\n\n![image-20230904002112819](数模notes.assets/image-20230904002112819.png)\n\n## 摘要\n\n![image-20230904002419263](数模notes.assets/image-20230904002419263.png)\n\n### 开头段\n\n![image-20230904002429638](数模notes.assets/image-20230904002429638.png)\n\n### 中间段\n\n![image-20230904002445304](数模notes.assets/image-20230904002445304.png)\n\n### 关键词\n\n![image-20230904002708012](数模notes.assets/image-20230904002708012.png)\n\n关键点：\n\n* 一定要写出你们最终的结论\n* 模型合理且出彩\n* 概述简洁\n\n> 句式套模板，要问啥答啥，适当加粗结论和一些关键词\n\n\n\n\n\n## 问题重述\n\n这部分包括问题背景、问题叙述和问题分析，前两个不要直接照抄问题，可以概括一下问题换个语序啥的(可以交给gpt)\n\n问题分析其实就是你的解题思路，可以在那个题目做完之后梳理一下解题想法和过程\n\n## 假设和变量\n\n多看看优秀论文是怎么做的，有些假设还是比较必要的，虽然去年国赛我们这部分写得很随便\n\n## 模型的建立和求解\n\n下面这部分我就贴一些美赛(需要提交全英论文)的资料，方法其实都是相同的\n\n### 数据预处理\n\n* 缺失值异常值\n* 数据降维！！ 如果数据指标太多(比如有几十条)，用**主成分分析**进行数据降维\n\n### 模型建立\n\n不要想得太复杂\n\n不要太高级，脱离问题。要解释问题\n\n![image-20230212120651859](数模notes.assets/image-20230212120651859.png)\n\n### 模型求解\n\n![image-20230212121021388](数模notes.assets/image-20230212121021388.png)\n\n### 结果分析\n\n![image-20230212121040272](数模notes.assets/image-20230212121040272.png)\n\n### 灵敏度分析 最后做\n\n![image-20230212121154154](数模notes.assets/image-20230212121154154.png)\n\n**变化系数、参数 上下调整5%画个图**（我们去年国赛就是这样子画了一个饼图）\n\n![image-20230216185333653](数模notes.assets/image-20230216185333653.png)\n\n如果是问鲁棒性 把参数上下变化一下\n\nhttps://www.bioladder.cn/web/#/chart/64)\n\n# 题型和方法\n\n![数学建模方法汇总](数模notes.assets/数学建模方法汇总.png)\n\n> 大部分spsspro上都有\n>\n> 不用全部都了解，用到的时候再去深入了解\n\n\n\n# 工具\n\n* [SPSSPRO-免费专业的在线数据分析平台](https://www.spsspro.com/)\n\n* 公式：AxMath、mathpix\n\n# 作图\n\n* ppt\n\n* [draw.io (diagrams.net)](https://app.diagrams.net/)\n\n* [BioLadder-生物信息在线分析可视化云平台](https://www.bioladder.cn/web/#/chart/64)\n\n![image-20230212141354761](数模notes.assets/image-20230212141354761.png)\n\n![image-20230212141500880](数模notes.assets/image-20230212141500880.png)\n\n\n\n\n\n![image-20230212152810724](数模notes.assets/image-20230212152810724.png)\n\n\n\n![image-20230212152728240](数模notes.assets/image-20230212152728240.png)\n\n![image-20230212153036477](数模notes.assets/image-20230212153036477.png)\n"},{"title":"BCI-MindBrige使用手册","url":"/2023/10/30/BCI-MindBrige使用手册/","content":"\n\n\n本文是我对自己所学的脑电知识以及使用MindBridge设备一年来的简单汇总，主要目的是为了整合自己的知识，同时考虑到一直都是师兄和我们言传身教使用方法，想要做一份规范化、低门槛的使用手册，方便新人使用这套设备，提高学习效率。\n\n# 离线数据采集\n\n## 硬件部分\n\n### 佩戴设备\n\n两种方式\n\n* 导电膏：先戴后打\n* 凝聚：先塞后戴\n\n#### 注入导电膏\n\n1. 用针管撩开看到**头皮**，注射一点。\n2. 询问受试是否头皮有凉凉感觉。\n3. 有，则盖好盖子，从小孔中往里注射，可以边注射，针头边往外拉。\n4. 注意不要一下子注射太多，会漏到整个头皮都是，造成通道信号粘连。\n5. 直至**充满**整个盖子。\n\n> 这一步非常关键，一定要保证头皮—电极片是连通的\n\n#### 放置凝聚\n\n1. 打开盖子，塞一个，**盖紧**。\n2. 全部通道塞完。\n3. 给受试带上，适当**调紧**，保证接触到头皮。\n\n### 检查连接\n\n#### 局域网配置\n\n#### OpenBCI检查\n\n关掉所有代理，管理员启动软件\n\n##### 配置设置\n\n\n\n##### 检查实时脑电\n\n调至auto\n\n* 所有通道是否有数据，有没有红色(出现坏导)\n  * 如果出现红色：头皮—电极接触不良，考虑重新打胶\n* 看FFT图，是否所有线粘连\n  * 粘连，检查参考电极是否放置有误/没打胶；检查头发/脑电帽是否湿了(没干/导电膏漏到其他通道了)\n\n没问题就关掉\n\n\n\n确保硬件一切正常后，进入软件部分\n\n## 软件部分\n\n### HBCI软件\n\n#### 范式接入\n\n代码\n\n填写\n\n先运行代码，后开始实验\n\n### Python\n\n没有HCI软件，可以直接通过brainflow包实现和硬件的配合，\n\n\n\n# 进阶能力\n\n## 预处理\n\n## 分类算法\n\n### 传统算法\n\n### 机器学习\n\n### 深度学习\n\n## 数据可视化\n\n### 时域图\n\n### 频谱图\n\n\n\n## 实时系统\n\n\n\n# 常见问题\n\n\n\n\n\n"},{"title":"latex常用命令","url":"/2023/10/11/latex常用命令/","content":"\n基于我用[Overleaf](https://www.overleaf.com/)写的第一篇论文总结出来的，方便下次查找~\n\nu1s1，第一次学不太熟练，然而如果熟练掌握的话，写文章看排版就是一种享受了：）\n\n首先的首先当然是在模板库里边套好模板啦！！！试过一次真的好爽\n\n# 超链接\n\n```latex\n\\href[连接地址][文字说明]\n```\n\n# 文献引用\n\n准备一个bib文件，比如我这里test.bib\n\n在正文的合适位置引入：\n\n```latex\n\\bibliography{test}\n```\n\n在test.bib中，直接复制谷歌学术引用的BibTex，复制进去：\n\n```latex\n%test.bib\n@article{wang2022design, %文献的key，必须唯一\n author = {Wang Dongqing and Dong Yuyang},\n title = {Design of portable EEG acquisition system based on ADS1299(in Chinese)},\n journal = {Communications Technology},\n volume = {55},\n number = {08},\n year = {2022},\n pages={1090-1098},\n doi ={},\n }\n...%其他文献依次放入\n```\n\n然后在正文要应用的地方，放入文献的key即可\n\n```latex\nThese signals provide valuable information about brain function, cognition, emotions, and health status. EEG amplifiers hold significant value and importance in scientific research, clinical diagnosis, rehabilitation therapy, and brain information decoding\\citep{wang2022design}EEG amplifiers, as a critical component in the field of neuroscience, are currently undergoing significant expansion.\n```\n\n\n\nbty，如果是word要求引用文献是什么比如Chicago风格的，你会发现谷歌学术引用里边没有，这个时候只需将在设置中把语言换成英文，就会出现很多其他的风格。\n\n# 多级标题\n\n```latex\n\\section{一级标题}\n\\subsection{二级标题}\n\\subsubsection{三级标题}\n\\paragraph{四级标题}\n```\n\n# 插入图片\n\n这里建议将图片转为pdf格式而不是esp，esp占用空间太大，放进去后会导致overleaf编译超时，要加钱噜。\n\n将图片的pdf格式放到根目录命好名后，我按期刊要求在手稿的最后罗列了图片：\n\n```latex\n\\begin{figure}[h!]\n\\begin{center}\n\\includegraphics[width=9.7cm,height=8.2cm]{MindBridge-NaNo}\n\\end{center}\n\\caption{ MindBridge-NaNo EEG Amplifier}\\label{fig:Nano} %这个label就是来引用的\n\\end{figure}\n\n```\n\n在正文引用的地方插入图片label进行引用：\n\n```latex\n...as shown in Figure \\ref{fig:Nano}\n```\n\n# 插入表格\n\n在正文开头处引入宏\n\n```latex\n\\usepackage{booktabs}\n```\n\n推荐一个很好用的工具，excel直接转latex，然后复制代码进来就好啦，链接：[搞定LaTeX论文中的表格 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/108505177#:~:text=搞定LaTeX论文中的表格 1 1. 好看的三线表 画表格最常用的包自然是 booktabs了，好看的三线表的基本命令如下图。 比较麻烦的是左右两端缩小一点点的横线，这个 叫做,3 3. 表格大小可以整体调整 如果一张表过大，超过了行宽，如果超过得不多的话，下面这个命令非常好用： \\resizebox{width} {height} {tabular} )\n\n# 序列\n\n**有序**\n\n```latex\n\\begin{enumerate}\n\\item 放分点一\n\\item 放分点二\n\\end{enumerate}\n```\n\n**无序**\n\n```latex\n\\begin{itemize}\n\\item 放分点一\n\\item 放分点二\n\\end{itemize}\n```\n\n# 各种符号\n\n**换行符**\n\n```latex\n//  %换行符\n/par  %分段符\n```\n\n# 字体\n\n加粗\n\n```latex\n\\textbf{}：文本环境加粗。在数学环境使用的话，会使斜体效果消失。并且无法输出加粗的希腊字母。\n\\mathbf{}：会变为粗体，但同样会导致数学字母斜体形式的丢失。\n\\boldmath{}：数学环境里可以加粗且不会使斜体消失。需要添加amsmath宏包。\n\\boldsymbol{}：可以对希腊字母加粗。需要添加amsmath宏包。\n在数学环境中，比较推荐的方式是添加宏包\\usepackage{bm}, 使用\\bm{}命令加粗。\n\n但是在xelatex或Luatex引擎的unicode-math环境中中，\\bm{}会报错。此时，可以使用以下命令：\n\n\\symbfit{}：加粗，且有斜体效果\n\\symbf{}：加粗，没有斜体效果\n\\mathbfcal{}：加粗的\\mathcal字体\n\n```\n\n","tags":["笔记"]},{"title":"软件体系结构笔记","url":"/2023/09/20/软件体系结构笔记/","content":"\n[Joel Station (jjuprising.github.io)](https://jjuprising.github.io/)\n\n> ⭐表示提纲内容，❗为考过的内容\n\n# 错题\n\n* 4+1\n* C/S系统p54\n  * 三层C/S体系结构p56\n* B/S结构，二者对比\n\n![image-20231206104329320](软件体系结构笔记.assets/image-20231206104329320.png)\n\n![image-20231206104441435](软件体系结构笔记.assets/image-20231206104441435.png)\n\n\n\n# 1软件体系结构概论\n\n## ❗⭐软件危机\n\n### 概念\n\n软件危机是指在**计算机软件开发和维护过程中**所遇到的**一系列严重问题**\n\n### 表现\n\n* 软件成本日益增长 \n\n* 开发进度难以控制\n  * 逻辑体系庞大\n  * 用户需求变化\n  * 开发人员盲目增加\n* 软件质量差\n* 软件维护困难\n  * 没有记录文档\n  * 开发人员离开\n\n### 原因\n\n◎ 用户**需求不**明确 \n\n◎ 缺乏正确的**理论指导**\n\n◎ 软件**规模**越来越大\n\n◎ 软件**复杂度**越来越高\n\n### 软件工程如何解决软件危机\n\n软件工程解决软件危机三要素：**方法**、**工具**和**过程**，其中： \n\n* 软件工程**方法**为软件开发提供了**“如何做”的技术**，是完成软件工程项目的**技术手段**\n\n* 软件工具是开发过程中**智力和体力的扩展和延申**，提供半自动和自动的软件**支撑环境**\n* 软件工程过程是将软件工程的**方法和工具综合起来**达到及时进行软件开发的目的。\n\n## 构件与软件重用\n\n### ❗⭐软件重用\n\n软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相近软件元素的过程。软件元素<u>包括程序代码、测试用例、设计文档、设计过程、需求分析文档甚至领域(domain)知识</u>。通常，把这种可重用的元素称作软构件(software component),简称为构件。可重田的软件元素越大，就说重用的粒度(granularity)越大。\n\n### ⭐构件模型三个主要流派\n\n* **OMG**（Object Management Group，对象管理集团）的CORBA（Common Object Request Broker Architecture，通用对象请求代理结构）\n* **Sun的EJB**（Enterprise Java Bean）\n* **Microsoft的DCOM**（Distributed Component Object Model，分布式构件对象模型）\n\n### ⭐构建获取\n\n* 从现有构件中获得符合要求的构件，**直接使用或作适应性修改**，得到可重用的构件；\n* 通过**遗留工程**，将具有潜在重用价值的构件**提取出来**，得到可重用的构件；\n* 从市场上**购买现成**的商业构件，即COTS（Commercial Off-The-Shell）构件；\n* **开发新的**符合要求的构件。 \n\n### ⭐构件管理\n\n1.**构建描述**：构建模型是对构建本质的抽象描述\n\n**2.构建分类与组织**\n\n已有的三大类构建分类方法：\n\n* **关键字分类法**\n* **刻面分类法**\n  * 主要思想来源于图书馆学\n\n* **超文本组织方法**、\n  * 基于**全文索引技术**\n\n\n构成一个系统的构件可分为以下5类：\n\n* 独立而成熟的构建\n* 有限制的构件\n* 适应性构件\n* 装配的构件\n* 可修改的构件\n\n3.人员及权限管理\n\n### ⭐'构件重用\n\n构件开发的目的是重用，为了让构件在新的软件项目发挥作用，必须完成：\n\n1. 检索与提取构件\n\n2. 理解与评价构件\n\n3. 修改构件\n\n4. ⭐构件组装\n\n   构件组装是指将库中的构件经**适当修改后相互连接**，或者将它们与当前开发项目中的软件元素相连接，**最终构成新的目标软件**。构件组装技术大致可分为：\n\n   1. 基于**功能**的组装技术\n   2. 基于**数据**的组装技术\n   3. **面向对象**的组装技术\n\n## ⭐软件体系结构的兴起和发展\n\n### 软件体系结构的定义\n\n随着研究发展，定义不断完善\n\n软件体系结构为软件系统提供了一个结构、行为和属性的**高级抽象**\n\n由构成系统的元素的**描述**、这些元素的**相互作用**、指导元素集成的**模式**以及这些模式的**约束**组成。\n\n软件体系结构不仅指定了系统的**组织结构和拓扑结构**并且显示了系统需求和构成系统的元素之间的对应关系，提供了一些**设计决策**的基本原理。\n\n### 发展阶段\n\n* **无体系结构**设计阶段。以<u>汇编语言</u>进行小规模应用程序开发为特征。\n* **萌芽阶**段。出现了程序结构设计主题，以<u>控制流图</u>和<u>数据流图</u>构成软件结构为特征。\n* **初期**阶段。出现了从不同侧面描述系统的结构模型，如<u>UML</u>。\n* **高级**阶段。以描述系统的高层抽象结构为中心，不关心具体的建模细节，划分了体系结构模型与传统软件结构的界限。以**4+1模型**为标志\n\n# 2软件体系结构建模\n\n## ⭐种类\n\n### 结构模型\n\n* 最直观、最普遍\n* 以体系结构的**构件、连接件和其他概念来刻画结构**\n* 力图用**结构**反映系统重要**语义内容**\n\n> 研究结构模型的核心——**体系结构描述语言**\n\n### 框架模型\n\n* 与结构模型类似\n* 但更侧重**整体结构**\n* 主要以**特殊问题**为目标，建立只针对和适应问题的结构\n\n### 动态模型\n\n* 是对结构或框架模型的补充，研究系统**“大颗粒”**行为性质\n* 例如描述系统的**重新配置或演化**\n\n> 动态可以指系统总体结构的**配置、建立或拆除通信通道或计算的过程**\n\n### 过程模型\n\n* 研究内容：构造系统的**步骤和过程**\n* 结构是遵循某些过程脚本的结果\n\n### 功能模型\n\n* 功能模型认为体系结构是**由一组功能构件按层次组成，下层为上层提供服务**\n* 可以看作一种特殊的**框架模型**\n\n## ⭐4+1模型\n\nKruchten 1995年提出\n\n* 4+1模型从5个不同的视角，来描述软件体系结构\n  * 逻辑视图\n  \n  * 进程视图\n  \n  * 物理视图\n  \n  * 开发视图\n  \n  * 场景视图\n  \n* 每个视图只关系系统的**一个侧面**，结合才一起能反映**系统软件体系结构**的全部内容\n\n![image-20230927090653322](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927090653322.png)\n\n![image-20230927094351154](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927094351154.png)\n\n### 逻辑视图\n\n* 逻辑架构主要支持**功能性需求**——即在为用户提供服务方面系统所应该提供的功能\n* 在面向对象技术中，通过**抽象、封装和继承**，可以用**对象模型来代表逻辑视图**，用<mark>**类图**</mark>来**描述逻辑视图**\n\n表示方法：Booch标记法\n\n![image-20230927095041358](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927095041358.png)\n\n类图用来显示一个类的集合和它们的逻辑关系：**关联、使用、组合、继承**等等\n\n例子：\n\n![image-20230927095238536](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927095238536.png)\n\n![image-20230927095304341](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927095304341.png)\n\n### 开发视图\n\n* 也称模块视图，关注软件开发环境下实际模块的组织。主要侧重于软件模块的组织和管理\n* 大部分情况考虑的内部需求与以下几项有关：\n  * **开发难度**\n  * **软件管理**\n  * **重用性**\n  * **通用性**\n  * **工具集、编程语言所带来的限制**\n* 关注程序包，可以直接使用**第三方SDK**和**现成框架**、**类库**，以及**开发的系统将运行于其上的系统软件**或**中间件**\n* 开发模型通过系统输入输出关系的**模型图和子系统图**来描述\n\n表示方法：Booch方法的变形\n\n![image-20230927095943041](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20230927095943041.png)\n\n#### 开发视图的分割\n\n**推荐使用分层(layered)的风格，定义4到6个子系统层**\n\n![image-20240107101449039](软件体系结构笔记.assets/image-20240107101449039.png)\n\n### 进程视图\n\n又称处理视图、过程视图、并发视图\n\n* 侧重系统的运行特性，关注一些**非功能性需求**\n  * 强调并发性、分步性、系统集成性和容错能力\n  * 关注对象、进程、线程等运行时的概念，以及相关的并发、同步、通信等问题\n* 可以描述为多层抽象，每个级别关注不同的方面。在最高层抽象中，进程结构可以看作是构成一个执行单元的一组任务。\n\n![image-20240107102502125](软件体系结构笔记.assets/image-20240107102502125.png)\n\n![image-20240107102509193](软件体系结构笔记.assets/image-20240107102509193.png)\n\n### 物理视图(软件到硬件的映射)\n\n主要考虑如何把**软件映射到硬件**上，最终如何安装或部署到物理机器\n\n它通常要考虑到**系统性能、规模、可靠性**等。解决系统**拓扑结构、系统安装、通讯**等问题\n\n软件到节点的映射要有较高的灵活性，**环境改变**时，对系统其他视图的影响最小\n\n![image-20240107102417301](软件体系结构笔记.assets/image-20240107102417301.png)\n\n![image-20240107102449950](软件体系结构笔记.assets/image-20240107102449950.png)\n\n### 各视图之间的关系\n\n#### 开发视图和进程视图的关系\n\n* 开发视图一般偏重程序包在编译时期的静态依赖关系，而这些程序运行起来之后会表现为对象、线程、进程\n* 进程视图比较关注的正是这些**运行时单元的交互问题**\n\n#### 物理视图和进程视图的关系\n\n* 进程视图特别关注目标程序的**动态执行**情况\n* 物理视图重视目标程序的**静态位置**问题；物理视图是综合考虑软件系统和整个IT系统相互影响的架构视图。\n\n### 场景\n\n* 是重要**系统活动的抽象**，它使四个视图有机联系起来，从某种意义上是说场景是最重要的**需求抽象**。\n* 在开发体系结构时，它可以帮助设计者找到体系结构的**构件和它们之间的作用关系**。同时，也可以用场景来分析一个特定的视图，或描述不同**视图构件间**是如何相互作用的\n* 场景可以用**文本表示**，也可以用**图形表示**。 \n\n> 融合所有的视图\n\n![image-20240107105944292](软件体系结构笔记.assets/image-20240107105944292.png)\n\n### 小结\n\n* 逻辑视图和开发视图描述系统的**静态结构**\n* 进程视图和物理视图描述系统的**动态结构**\n* 不同软件系统，侧重的角度有所不同。\n\n  * 对于信息管理系统来说，比较侧重于从**逻辑视图和开发视图**来描述系统\n  * 对于实时控制系统，比较注重于从**进程视图和物理视图**来描述系统\n* 并不是所有的软件架构都需要4+1视图，无用的视图可以省略\n\n  * 只有一个处理器可以省略物理视图\n  * 仅有一个进程/程序，可以省略过程视图\n  * 非常小型的系统，甚至可能逻辑视图与开发视图非常相似，而不需要分开描述\n\n* 场景对于所有的情况均适用\n\n\n\n![image-20231011090546301](D:\\Blog\\source\\_posts\\软件体系结构笔记.assets\\image-20231011090546301.png)\n\n### 实例\n\n* 某型号设备调试系统\n  * 设备调试员通过使用该系统，可以察看设备状态（设备的状态信息由专用的数据采集器实时采集)、发送调试命令\n\n![image-20240107110329891](软件体系结构笔记.assets/image-20240107110329891.png)\n\n#### 逻辑视图：设计满足功能需求的架构\n\n应用层负责什么，通讯层负责什么...\n\n* 应用层负责设备状态的显示，并提供模拟控制台供用户发送调试命令。\n* 应用层使用通讯层和嵌入层进行交互，但应用层不知道通讯的细节。\n* 通讯层负责在RS232协议之上实现一套专用的\"应用协议\"。\n* 当应用层发送来包含调试指令的协议包，由通讯层负责按RS232协议将之传递给嵌入层\n\n#### 开发视图：设计满足开发期质量属性的架构\n\n采用哪些现成框架、哪些第三方SDK、哪些中间件平台\n\n#### 进程视图：设计满足运行期质量属性的架构\n\n关注进程、线程、对象等运行时概念，以及相关的并发、同步、通信等问题\n\n设备调试系统采用多线程的设计\n\n#### 物理视图：和部署相关的架构决策\n\n关\n\n* 目标程序及其依赖的运行库和系统软件\n* 最终如何安装或部署到物理机器\n* 如何部署机器和网络来配合软件系统的可靠性、可伸缩性等要求\n\n## ⭐体系结构的核心模型\n\n核心模型的5种元素：\n\n* **构件**\n  * 具有某种功能的可重用软件模板单元\n  * 表示系统中主要的计算单元和数据存储\n  * 分类：**复合构件**(有其他复合和原子构件连接而成)、**原子构件**(不可再分的)\n* **连接件**\n  * 构件之间的交互\n  * 连接件接口由一组角色组成，每一个角色定义了该连接件表示的交互的参与者\n* **配置**\n  * 表示构件和连接件的拓扑逻辑和约束\n* 端口\n  * 表示构件和外部环节的交互点\n* 角色\n\n![image-20240107120344014](软件体系结构笔记.assets/image-20240107120344014.png)\n\n## ⭐体系结构的生命周期模型\n\n需求分析--**建立体系结构**--设计--实现--测试\n\n# 3软件体系结构风格\n\n**软件体系结构的组成：**\n\n* 构件，各种基本的软件构造模块（函数、对象、模式等)；\n* 连接件，将它们组合起来形成完整的软件系统\n* 物理分布\n* 约束\n* 性能\n\n> 体系结构=构件+连接件+约束\n\n## **软件体系结构风格的定义**\n\n* **惯用模式**\n  * 软件体系结构风格是描述某一特定应用领域中系统组织方式的惯用模式\n\n* **词汇表和约束，即构件连接件+约束**\n  * 体系结构风格定义了一个系统家族，即一个体系结构定义一个词汇表和一组约束。\n  * 词汇表中包含一些构件和连接件类型，而这组约束指出系统是如何将这些构件和连接件组合起来的。\n\n* **共同的结构和语义特征**\n  * 体系结构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统\n\n\n### 熟悉的软件体系结构\n\n* Client/Server结构\n* Browse/Server结构\n* Three-tier三层cs结构\n* Distributed分布式结构\n\n\n\n## 软件体系结构风格分类\n\n* 经典SA风格\n* 其他常用SA风格\n* 异构（复合）SA风格\n\n\n\n### 什么是数据流风格\n\n* 数据从一个处理单元流入到另一个处理单元，每经过一个单元就做一次转换\n\n> 注意：数据流风格不是某个过程的数据流图，它描述的是系统体系结构级别的设计\n\n\n\n###   ⭐管道过滤器风格\n\n是一种数据流风格，数据从一个处理单元流向另一个处理单元，每经过一个单元就做一次转换\n\n#### 基本组成\n\n```mermaid\ngraph LR\n过滤器1--管道1-->过滤器2--管道2-->过滤器3\n```\n\n每一个构件(过滤器)都有一组输入和输出，构件读输入的数据流，经过内部处理，然后产生数据流。\n\n连接件(管道)就像数据流传输的管道，将一个过滤器的输出传入到另一个过滤器的输入。\n\n> 过滤器必须是独立的实体\n>\n> * 不能与其他过滤器共享数据\n> * 且不知道自己的上下游标识\n\n* 构件：过滤器，处理数据流\n  * 一个过滤器封装了一个处理步骤\n  * 数据源点和数据终止点可以看作是特殊的过滤器\n    * 目标：将源数据流变成目标数据\n    * 五种变换类型：增加/丰富、删减/浓缩、转换、合并、分解\n* 连接件：管道，连接一个源和一个目的过滤器\n  * 作用：转发数据流\n    * 单向流\n    * 可能具有缓冲区\n  * 不同的管道中流动的数据流，具有不同的数据格式\n\n> 连接件定义了数据流图，形成拓扑结构\n\n**过滤器读取与处理数据流的方式：** 递增地读取和消费数据流，所以在输入被完全消费之前，输出便产生了。\n\n**应用：**DOS管道命令，Unix管道，编译器\n\n#### ❗优缺点\n\n**优点6个：**\n\n* 使得系统中的构件具有良好的**隐蔽性和高内聚、低耦合**的特点\n* 设计者可以将整个系统的输入、输出特性**简单的理解为各个过滤器功能的合成**\n* 支持功能模块的**复用**\n* 较强的**可维护性和可扩展性**\n* 支持一些特**定的分析**，如吞吐量计算和死锁检测等\n* 具有**并发性**\n\n**缺点4个：**\n\n* **交互式处理**能力弱\n* 设计者也许不得不花费精力**协调**两个相对独立，但又存在某种关系的**数据流之间的关系**\n* 过滤器具体实现**复杂**\n* 往往导致系统处理过程的**成批**操作\n\n### ⭐面向对象风格\n\n基础：**数据抽象和面向对象系统**\n\n数据的**表示方法**和它们的**相应操作封装在一个抽象数据类型或对象中**。\n\n![image-20240106160140532](软件体系结构笔记.assets/image-20240106160140532.png)\n\n特点：\n\n* 对象是构件\n* 对象之间也就是构件之间交互方式：函数调用和过程调用\n\n#### 优缺点\n\n**优点：**\n\n* 一个对象对外界**隐藏了自己的详细信息**，改变一个对象的表示，**不会影响系统**的其它部分\n* **继承和封装方法**为对象复用提供了技术支持\n* 对象将数据和操作封装在一起，提高了系统**内聚性**，**减小**了模块之间的**耦合**程度，使系统更容易分解为既相互作用又相互独立的对象集合\n\n**缺点：**\n\n* 如果一个对象要调用另一个对象，则**必须知道它的标识和名称**\n* 会产生连锁反应，如果一个对**象的标识发生改变**，那么必须修改所有**显式调用**它的其它对象，并消除由此**引发的副作用**\n\n### ⭐基于事件的系统/隐式调用\n\n* 构件不直接调用一个过程，而是**触发或广播一个或多个事件**。\n* 系统中的其它构件中的过程在一个或多个事件中**注册**，当一个**事件被触发**，系统**自动调用在这个事件中注册的所有过程**，这样，一个事件的触发就导致了另一模块中的过程的调用。因此这种风格也成为隐式调用\n\n> （1）显示调用\n>\n> ​       显示调用是指在程序中能找到相应的调用代码，或者说是手动调用的\n>\n> （2）隐式调用\n>\n> ​       隐式调用是指程序中找不到相应的调用代码，或者说是系统编译器根据条件自动调用的\n\n\n\n特点：\n\n* 构件：模块，可以是过程也可以是事件的集合\n* 连接件：往往是以过程之间的隐式调用来实现\n\n#### ❗优缺点\n\n**优点：**\n\n* 事件声明者不需要**知道哪些构件会响应事件**，因此，不能确定构件处理的先后顺序，甚至不能确定事件会引发哪些过程调用\n\n  > 这一条也是基于事件的隐式调用的主要特点\n\n* **提高了软件复用能力**，只要在系统事件中**注册构件**的过程，就可以将该构件**集成到系统中**\n\n* **便于系统升级**，只要构件名和事件中所**注册的过程名保持不变**，原有构件就可以**被新构件所替代**\n\n**缺点：**\n\n* **构件放弃了对系统计算的控制**。一个构件触发一个事件时，不能确定其它构件是否会响应它。而且即使它知道事件注册了哪些构件的构成，它也不能保证这些过程被调用的顺序。\n* **数据交换的问题**。有时数据可被一个事件传递，但另一些情况下，基于事件的系统必须依靠一个**共享的仓库**进行**交互**。在这些情况下，**全局性能和资源管理**便成了问题\n* 过程的语义必须依赖于**被触发事件的上下文约束**，关于**正确性的推理**存在问题。\n\n### 分层系统\n\n在层次系统中，系统被组织成若干个层次，每个层次由一系列构件组\n成：\n层次之间存在接口，通过接口形成call/return的关系\n\n* **下层构件向上层构件提供服务**\n* **上层构件被看作是下层构件的客户端**\n\n例如DBMS的“三级模式-两层映像”\n\n![image-20231101085309731](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231101085309731.png)\n\n#### 优缺点\n\n**优点3条**\n\n* 支持基于抽象程度递增的系统设计，使设计者可以把一个复杂系统按递增的步骤进行**分解**；\n* 支持**功能增强**，因为每一层至多和相邻的上下层交互，因此功能的改变**最多影响相邻的上下层**：\n* **支持重用**。只要提供的服务接口定义不变，**同一层的不同实现可以交换使用**。这样，就可以定义一组标准的接口，而允许各种不同的实现方法\n\n**缺点2条**、\n\n* 并不是每个系统都可以**很容易地划分为分层的模式**，甚至即使一个系统的逻辑结构是层次化的，出于对系统性能的考虑，系统设计师不得不把一些低级或高级的功能综合起来：\n* **很难找到**一个合适的、正确的**层次抽象方法**。\n\n### ⭐仓库系统及知识库\n\n应用：主要用在交换或共享大量数据的软件中\n\n**两种不同的构件：**\n\n(1)**中央数据结构构件**：代表系统当前状态；\n\n(2)一些相对**独立的构件的集合**：这些构件对中央数据存储进行操作。\n\n#### 黑板模式\n\n![image-20231101094120702](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231101094120702.png)\n\nDMZ是为了解决安装防火墙后外部网络不能问内部网络服务器的问题，而设立的缓冲区，这个缓冲区位于内部网络和外部网络之间的小网络区域内。\n\n##### ⭐组成\n\n* 知识源，提供领域专门知识\n* 黑板数据结构，提供数据存储和通信。\n* 控制，解决策略编码，知识源响应偶然事件。\n\n##### 优缺点\n\n**优点：**\n\n* 优点在于**可扩充性**比较强，模块间耦合比较松散，便于扩充。\n* 便于多客户**共享大量数据**，他们不关心数据何时有的、谁提供的、怎样提供的。\n* 既便于**添加新的作为知识源代理的应用程序**，也便于**扩展共享**的黑板数据结构。\n* **知识源可重用**以及支持**容错性和健壮性**\n\n**缺点：**\n\n**1.测试困难**：\n由于黑板模式的系统有中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试\n\n2不能保证有好的求解方案：\n一个黑板模式的系统所提供给我们的往往是解决问题的百分比，而不是最佳解决方案\n\n**3.效率低**：\n黑板模式的系统在拒绝错误假设的时候要承受多余的计算开销，所以导致效率比较低。\n\n**4.开发成本高**：\n绝大部分黑板模式的系统需要用几年的时间来进化，所以开发成本较高\n\n**5.缺少对并行机的支持**：\n黑板模式要求黑板上的中心数据同步并发访问，所以缺少对不并行机的支持\n\n### ⭐C2风格\n\n* 系统中的构件和连接件都有一个顶部和一个底部；\n* **构件的顶部应连接到某连接件的底部**，构件**的底部则应连接到某连接件的顶部**，而**构件与构件之间的直接**连接是不允许的；\n* 一个连接件可以和任意数目的其它构件和连接件连接；\n* 当两个连接件进行直接连接时，必须由其中一个的**底部到另一个的顶部。**\n\n> 核心，构件-连接件和连接件-连接件都要遵循顶部连底部(底部连顶部)的规则，其中构件之间不能直接相连\n\n**特点：**\n\n* 系统构件可实现应该用需求，并能将任意复杂度的功能封装在一起\n* 所有构件的通信以连接件为中介的异步信息交换机制实现\n* 构件独立、依赖少。\n\n### ⭐C/S风格——基本概念\n\nC/S软件体系结构是**基于资源不对等，且为实现共享而提出来的**\n\n三个组成部分：数据库服务器、客户应用程序和网络\n\n#### 任务分配-服务器\n\n服务器（饭堂）的任务：\n\n* 数据安全（保证食物质量）\n* 数据并发性控制（排队打饭）\n* 数据完整性(1块钱打1块钱的饭)\n* 数据的备份和恢复（做记录）\n\n客服端任务：\n\n* 提供用户与数据库的交互界面（一只碗）\n* 提交和接受来自数据库的信息（红烧肉）\n* 根据数据，执行逻辑任务（吃、消化）\n\n\n\n#### C/S处理流程\n\n![image-20231108093333306](软件体系结构笔记.assets/image-20231108093333306.png)\n\n#### 优点\n\n* 分离客户端、服务器端，**增加了系统灵活性**，易于对系统进行扩充和缩小\n* 客户端与服务端直接相连，**没有中间环节，响应速度快**\n* 操作界面漂亮、形式多样\n* 方便实现**复杂的业务流程**\n\n#### 缺点\n\n* 要专门**为客户安装程序**，分布功能弱\n* **兼容性差**\n* 成本高\n* 客户端压力大（胖客户端）\n* 软件移植、维护和升级困难\n* **新技术不能轻易应用**\n\n#### 三层C/S体系结构\n\n* 第一层：**用户界面**一表示层，图形化、事件驱动的\n* 第二层：**业务逻辑**一功能层，过程化的\n* 第三层：**数据库**一数据层，结构化和非过程化\n\n![image-20240106164332210](软件体系结构笔记.assets/image-20240106164332210.png)\n\n雇了保姆\n\n保姆的职责：跑腿、盛饭、打卡\n\n客户：饭来张口、衣来伸手\n\n服务器：提供所需饭菜\n\n**相比于两层结构的优势：**\n\n* 服务器**安全性**提高\n* 客户端成功减肥\n* 易于**维护**（若逻辑有问题，不需要重新安装客户端)\n* 易于**开发**，每层可用不同的语言。\n\n##### ❗优点\n\n1. 允许合**理地划分三层结构的功能**，使之在逻辑上保持相对独立性，使系统的逻辑结构更加清晰，提高系统的**可维护性和可扩展性**\n2. 允许合理选**择适用的相应平台和硬件系统**，使得在负荷和处理能力上分别适用于结构清晰的三层；并且各平台具有良好的**可升级性和开放性**\n3. 各层可以**并行开发**，且能各自选择最合适的开发语言\n4. 允许充分利用功能层有效隔离开表示层与数据层\n\n要注意的问题：\n\n* 三层C/S结构各层间的**通信效率若**不高，即使分配给各层的硬件能力很强，其作为整体来说也达不到所要求的性能。\n* 设计时必须慎重考虑三层间的**通信方法、通信频度及数据量**。这和**提高各层的独立性**一样是三层C/S结构的关键问题。\n\n### ⭐B/S风格P64\n\n浏览器/服务器(B/S)，具体结构为 **浏览器/Web服务器/数据库服务器**\n\n#### 三层B/S结构\n\n表示层：浏览器\n\n逻辑层：web服务器、应用服务器\n\n数据层：数据库服务器\n\n![image-20240106115712704](软件体系结构笔记.assets/image-20240106115712704.png)\n\n![image-20240106115929712](软件体系结构笔记.assets/image-20240106115929712.png)\n\n#### 优点\n\n* **安装、维护、修改**全在服务器端\n* 工作量减少\n* 降低成本\n* 开放性强，都可以来访问\n* 平台**无关性**，可以任意扩展\n* 信息发布和信息交流更加灵活\n\n#### 缺点\n\n* B/S体系结构缺乏对**动态页面**的支持能力，没有集成有效的**数据库处理功能**。\n* B/S体系结构的**系统扩展**能力差，**安全性**难以控制。\n* 采用B/S体系结构的应用系统，在数**据查询等响应速度上**，要远远地低于C/S体系结构。\n* B/S体系结构的数据提交一般以页面为单位，数据的**动态交互性**不强，不利于在线事务处理(OLTP)应用\n\n### ⭐B/S和C/S比较\n\n|      | 网络   | 安全控制 | 软件重用 | 维护开销 | 信息交流 | 数据     |\n| ---- | ------ | -------- | -------- | -------- | -------- | -------- |\n| C/S  | 局域网 | 能力高   | 不高     | 大       | 机械式   | 重在处理 |\n| B/S  | 广域网 | 能力低   | 较强     | 小       | 信息中心 | 重在共享 |\n\n### 异构风格(了解)\n\n结合C/S和B/S，发挥各自优点进行结合\n\n有两种模型：内外有别和查改有别\n\n### 批处理序列\n\n批处理风格的每一步处理都是独立的，并且每一步是顺序执行的。只有当前一步处理完，后一步处理才能开始。数据传送在步与步之间作为一个整体。\n\n组件为一系列固定顺序的计算单元，组件间只通过数据传递交互。每个处理步骤是一个独立的程序，每一步必须在前一步结束后才能开始，数据必须是完整的，以整体的方式传递。\n\n批处理的典型应用：\n\n（1）经典数据处理；\n （2）程序开发；\n （3）Windows 下的 BAT 程序就是这种应用的典型实例。\n\n## 调用/返回风格\n\n调用返回风格顾名思义，就是指在系统中采用了调用与返回机制。利用调用 - 返回实际上是一种分而治之的策略，其主要思想是将一个复杂的大系统分解为一些子系统，以便降低复杂度，并且增加可修改性。程序从其执行起点开始执行该构件的代码，程序执行结束，将控制返回给程序调用构件。\n\n调用 / 返回风格架构主要包括三种具体的架构风格：主程序 / 子程序；面向对象风格；层次结构。\n\n### 主程序/子程序\n\n主程序 / 子程序风格是结构化开发时期的经典架构风格。这种风格一般采用单线程控制，把问题划分为若干处理步骤，构件即为主程序和子程序。子程序通常可合成为模块。过程调用作为交互机制，即充当连接件。调用关系具有层次性，其语义逻辑表现为子程序的正确性，取决于它调用的子程序的正确性。\n\n## ⭐描述方式\n\n体系结构描述方式标准\n\n* **语义丰富性**\n* **语义精确性**\n* **形式化程度**\n\n#### ❗⭐种类\n\n* **图形表达工具**\n* **模块内连接语言 MIL**\n* **基于软构件的系统描述语言**\n* **软件体系结构描述语言 ADL Architecture Description Language**\n\n4.2考试不考\n\n# 4软件体系结构描述语言\n\n### ⭐ADL\n\nADL是这样一种**形式化语言**，它在**底层语义模型**的支持下，为软件系统的概念体系结构建模提供了**具体语法**和**概念框架**。基于底层语义的工具为体系结构的<u>表示、分析、演化、细化、设计</u>过程等提供支持\n\n三个基本元素是：\n\n* **构件**\n  * 计算或数据存储单元\n* **连接件**\n  * 用于构件之间交互建模的体系结构构造块及其支配这些**交互的规则** \n* **体系结构配置**\n  * 描述体系结构的构件与连接件的**连接图**。 \n\nADL与其他语言的比较:\n\n  **构造能力：**ADL能够使用**较小的独立体系结构元素**来建造**大型软件系统；**\n\n  **抽象能力：**ADL使得软件体系结构中的**构件和连接件描述**可以只关注它们的**抽象特性**，而不管其具体的**实现细节**；\n\n  **重用能力：**ADL使得**组成软件系统的构件**、**连接件甚至是软件体系结构**都成为软件系统开发和设计的**可重用部件**；\n\n  **组合能力：**ADL使得其描述的每一系统元素都有其自己的局部结构，这种描述局部结构的特点使得ADL支持软件系统的**动态变化组合**；\n\n  **异构能力**：ADL允许多个不同的体系结构描述**关联存在**；\n\n  分析和推理能力：ADL允许对其描述的体系结构进行多种不同的**性能和功能上的多种推理分析。**\n\n# 6可扩展标记语言\n\n## XML概述\n\n#### ❗⭐XML定义\n\n* XML是一套定义**语义标记的规则**，这些标记将文档分成了许多**部件**并对这些部件加以**标识**\n* XML是**元标记语言**，用于定义其他与特定领域**有关的、语义的、结构化**的标记语言的**句法语言**\n* 和HTML一样，来自**标准通用标记语言**(lStandard Generalized Markup Language,**SGML**)\n\n#### SGML的10个目标\n\n* 能够直接**应用在Internet上**\n* 能被各式**应用软件使用**\n* 能与SGML**兼容**\n* 能轻易发展**XML相关软件**\n* 能**简化**SGML\n* 能够直接**应用在**Internet上\n* 能被各式**应用软件使用**\n* 能与SGML**兼容**\n* 能轻易发展**XML**相关软件\n* 能简化SGML\n\n#### ⭐XML的特点\n\n* **简洁有效**\n  * 是精简的SGML，保留了可拓展性\n* **易学易用**\n* **开放的国际化标准**\n  * W3C正式批准\n* **高效且可扩充**\n\n## 解析XML \n\n### ⭐XML与HTML的区别\n\nHTML是一种**格式化的语言**，一个HTML文本可以看作一个**格式化的程序**\n\nXML是一种**元标记语言**\n\nXML定义了一套**元句法**，与特定领域有关的**标记语言**都必须遵守\n\n两者**同根**——SGML，均基于**文本**。\n\nHTML\n\n* HTML文档主要包含**显示格式**、主要是为了**浏览**，而不是为计算机所使用，是**显示格式描述语言**\n* HTML包含**预定义的标记**（Tag)集，易学易于访问，但难以数据重用，可扩展性差。\n\nXML\n\n* 以**数据可重用**为切入点，可**定义自己的标记集**，能让其他程序理解\n* 比HTML**易于扩展**，XML标记表示**数据的逻辑结构**，为不同应用以不同方式分析的同时，进行严格的**语法和语义检查**\n* XML文档将**数据与显示格式分离**。为**信息开放、共享和交互**提供基础\n\nXML优势\n\n* XML模式使用**XML语法**\n* XML模式支持**数据类型**\n* XML模式是**可扩展**的\n* XML模式有更强的**表达能力**\n\n### ⭐CSS与XSL的比较\n\n⭐**XSL**\n\n* XSL是专门用于XML文档的**样式语言**，当成把**XML转变成HTML的语言**。\n* 能够**筛选和排序XML文档中数据**的语言\n* 能够根据XML的数据**数值格式化XML数据的语言**\n* XSL文档本身就是**结构完整的XML语言**\n\n![image-20240107145815861](软件体系结构笔记.assets/image-20240107145815861.png)\n\n| CSS                                                  | XSL                                                          |\n| :--------------------------------------------------- | :----------------------------------------------------------- |\n| 只能改变**特定元素的格式**，也只能以**元素为基础**。 | 可以**重新排列元素**并对元素进行**重新排序**                 |\n| 具有**广泛的浏览器支持**                             | 更为**灵活和强大**，可更好地适用于XML文档。带XSL样式单的XML文档可以很容易地转换为带CSS样式单的HTML文档 |\n| 一些**固定数据进行排版**：“HTML＋CSS”                | 如果这些数据**独立于程序存在和使用**，“HTML＋XML＋XSL”       |\n\n## XML编程接口\n\n\n\n### API接口 – DOM\n\n* 解析器读入整个文档，然后构建一个驻留内存的树结构，然后代码就可以使用**DOM接口来操作这个树结构**。\n* 用户可以**遍历树**以了解原始文档包含了什么，可以删除树的几个部分，还可以重新**排列树和添加新的分支**，等等。\n* DOM可以用来解释和操作XML文档\n\n### API接口 – SAX（Simple API for XML，SAX）\n\nSAX是一个接口，也是一个软件包。\nSAX是事件驱动型XML解析的一个标准接口\n\n### API接口 – JDOM\n\nJDOM是基于Java技术的开放源码项目\n\n### API接口 – JAXP\n\n为了修正SAX和JDOM的一些问题，SUN发布了JAXP，该API为使用DOM、SAX和XSLT处理XML文档提供了公共接口。\n\n### ⭐xml编程接口有哪几种\n\nAPI接口有DOM、SAX、JDOM、JAXP\n\n### ❗⭐xml接口的选择 考虑什么因素 怎么选\n\n（1）**要用Java编写应用程序吗？**JAXP\n\nJAXP使用DOM、SAX和JDOM；如果用Java编写代码，那么应使用JAXP将代码与各种解析器实现的细节隔离。 \n\n（2）**一旦解析了XML文档，还需要多次访问那些数据吗？**DOM\n\n如果需要回过头来<u>访问 XML文件的已解析版本，DOM可能是正确的选择</u>。而<u>SAX事件被触发时</u>，如果以后需要它，则由（开发人员）自己决定以某种方式保存它。如果需要访问不曾保存的事件，则必须再次解析该文件；<u>而DOM自动保存所有的数据。</u> \n\n（3）**应用程序将如何部署？**SAX\n\n如果应用程序将要作为Java applet部署，那么会希望使要**下载的代码数量最小**，SAX解析器比DOM解析器小，而使用JDOM时，除了SAX或DOM解析器之外还要求编写少量的代码。\n\n（4）**只需要XML源文件的少量内容吗？**SAX\n\n如果只<u>需要XML源文件的少量内容，那么 SAX可能是正确的选择</u>。SAX不会为源文件中的每个东西创建对象。使用SAX，要检查每个事件以了解它是否与需要有关，然后相应地处理它。 \n\n（5）**正在一台内存很少的机器上工作吗？**SAX\n\n若是的话，不管可能考虑到的其它因素是什么，SAX都是最佳选择。 \n\n### XML开发工具\n\n#### DTD（Document Type Definition)\n\nDTD是关于XML文档中出现的**标记和元素结构的语法约束**，它可用来验证一个XML文档。\n\n#### XSL（eXtensible StyleSheet Language)\n\nXML把内容和显示格式分开\n\n#### XSLT （XSL Transformation）\n\nXSLT的基本原理是**模式和模板匹配**，是一个用来根据一个**XSL样式表将一个XML文档转换到另一个XML文档的语言**。\n\n#### XPath (XML Path Language，XML路径语言）\n\nXpath是一个用来指明XML文档中部件的地址的语言。\n\n#### Xpointer（XML Pointer)\n\nXPointer 是**指向文档片段的指针**。当文档片段发生变化时仍然可以发现。便于Server处理。\n\n#### Xlink(XML Link)\n\nXLink是一种用XML元素向XML文档中加入链接的机制。\n\n#### 命名空间\n\n命名空间用于区分具有相同名而又在相应的上下文中具有不同含义的元素和属性。\n\n#### XML Schema\n\nXML Schema 用于对XML文档的内容及其语义的约束机制进行有效的类型检验\n\n### XML的实现\n\n基本流程：\n\n* 用XML构造一个标记语言\n* 生成XML文档\n* 解释XML文档\n* 显示XML文档\n\n### XML的应用\n\n* 数据交换与信息共享\n* Web应用\n\n# 8Web服务体系结构\n\n**Web服务的核心技术**\n\n* 作为WEB服务基础的**XML**\n* 简单对象访问协议**SOAP**\n* WEB服务描述协议**WSDL**\n* 统一描述、发现和集成协议**UDDI**\n\n## SOA\n\n**面向服务的体系结构(Service-Oriented Architecture,SOA)。**\n\n### ⭐概念\n\nGartner定义：SOA是一种**客户端/服务器的软件设计方法**，应用由软件服务和软件服务使用者组成，SOA与大多数通用的客户端/服务器模型不同之处，在于它着重**强调软件构件的松散耦合，并使用独立的标准接口。** \n\n### ⭐特征\n\n**◎ 松散耦合** \n\n**◎ 粗粒度服务** \n\n**◎ 标准化接口**\n\n### ⭐关键技术\n\nSO的技术服务栈\n\nWeb服务要以一种可**互操作**的方式执行发布、发现和绑定操作，必须**有一个包含每一层标准的web服务栈**\n\n整个web服务的**技术系列**称为web服务栈\n\n* web服务有那几层，每一层有什么作用\n\n| 服务栈     | 主要技术             |\n| ---------- | -------------------- |\n| 发现服务层 | UDDI、DISCO          |\n| 描述服务层 | WSDL、XML、Schema    |\n| 消息格式层 | SOAP、REST           |\n| 编码格式层 | XML                  |\n| 传输协议层 | HTTP、TCP/IP、SMTP等 |\n\n* Web服务栈的发现服务层：帮助客户端**应用程序解析服务的位置**\n\n  * 通过UDDI实现: UDDI规范描述了WEB服务的概念，定义了一种**编程接口**\n\n  * 通过UDDI\n\n    * 企业可以**发布自己的WEB服务**供其他企业查询和调用\n\n    * 也可以查询特定的**描述信息**，动态**绑定到该服务商**\n\n* WEB服务栈的描述服务层\n  * 为客户端应用程序提供**与远程服务交互的描述信息**\n  * 通过**WSDL**实现：WSDL为服务提供者**提供以XML格式描述**WEB服务请求的标准格式\n  * 将网络服务描述为能将进行消息交互的通信端点集合，以表达一个**web服务的功能、位置和调用方法**\n* Web服务栈的消息格式层\n  * 保证客户端应用程序和服务器端在**格式设置上保持一致**\n  * 通过**soap协议**实现\n    * Soap定义了**服务请求者**和**服务提供者**之间的**消息传递规范**\n    * Soap用**xml来格式化信息**，用**HTTP承载消息**\n* Web服务栈的**编码格式层**\n  * 为客户端和服务器之间提供一个**标准的**、**独立于平台的**数据交换编码格式\n  * 一般通过xml实现\n* Web服务栈的传输协议层\n  * 为客户端和服务器提供**交互的网络通信协议**\n  * 一般通过**HTTP和SMTP**实现\n    * HTTP是广泛使用的协议，为WEB服务部件通过internet交互奠定了**协议基础**，并具有良好的穿透防火墙功能\n    * SMTP适用于**异步通信**，在服务中断时，SMTP可以自动进行重试\n\n## SOA的实现方法\n\n主流的方式有Web Service、企业服务总线和服务注册表\n\n### ⭐Web Service\n\n#### ❗概念\n\nWeb service 就是一个**应用程序**，它向外界暴露出一个能够通过**Web进行调用的API**。\n\nWeb服务是一个**应用逻辑单**元，它通过标准的**XML数据格式和通用的Web协议**（如HTTP、SOAP、WSDL、UDDI等）为其他应用程序**提供信息。**\n\n具体来说，Web服务**利用网络进行通**信，它**提供了一些操作集合的接口**，以实现特定的任务，其他应用程序通过调用这些接口实现信息的交换。 \n\n#### 目标\n\n为了让地理上分布在**不同区域**的**计算机和设备协同工作**，为用户提供**各种各样的服务**。\n\nl用户可以**控制**要获取**信息的内容、时间、方式**，而不必像目前这样，在无数个信息孤岛中**浏览**，去寻找自己**需要的信息**。\n\nWeb service平台三个技术\n\n* XML\n* SOAP\n* WSDL\n\nWeb服务逻辑层\n\n* **数据层**  保存web服务需要的所有**物理数据**\n* **数据访问层** 为业务层提供**数据服务**\n* **业务层** 提供业务**逻辑**\n* **业务面** 提供简单接口 直接映射到web服务提供的过程\n* **监听者** 接收带有**请求服务的输入消息**，解析这些消息，并把这些请求发送给业务面的相应方法\n\nWeb Service优势主要优势：\n\n* 跨越不同**软硬件平台**的分布式应用程序之间的**互操作性**\n* 通过使用 Web 协议的防火墙，轻松、广泛地**访问应用程序** \n* 跨平台、跨语言的数据模型 (XML) 方便了**异构分布式应用程序**的开发 \n\n❗特点：\n\n* 使用标准**协议**规范 \n* 使用**协议**的规范性 \n* 高度**集成**能力\n* 完好的**封装性**\n* **松散耦合** \n\n#### ⭐三种角色三种操作\n\n**三种工作角色(三种逻辑构件)**\n\n* 服务提供者。提供服务以使服务可用\n* 服务请求者。可在应用程序中通过服务代理请求服务，调用所需服务\n* 服务注册中心。中介作用，服务的注册构件\n\n**三种操作**\n\n* 发布。服务提供者需要发布用户描述，以便用户请求者查找使用\n* 查找。服务请求者直接检索服务描述或在服务注册中心查询所要求的服务类型。两个阶段\n  * 设计阶段，为了程序开发而查找服务的接口描述\n  * 运行阶段，为了调用而查找服务的位置描述\n* 绑定。服务的具体实现。服务请求者使用服务描述中的绑定细节来定位、联系并调用服务，从而在运行时与服务进行交互。可分为动态绑定和静态绑定。\n  * 动态绑定，服务请求者通过服务注册中心查找服务描述，并动态地与服务交互\n  * 静态绑定，服务请求者已经与服务提供者达成默契，通过本地文件或其他方式直接与服务进行绑定。\n\n## ⭐WSDL服务描述语言\n\n描述服务层的实现\n\n* 是对**服务进行描述**的语言，有一套基于XML的语法定义，用于将对包**含面向文档或面向过程信息的网络服务操作描述为一组端点。**\n* WSDL为客户端应用程序提供正确地与远程服务交互的**描述信息**。\n* 服务接口定义和服务实现定义结合在一起组成了完整的WSDL的定义\n* WSDL是可扩展的。\n\n## ⭐UDDI统一描述、发现和集成协议\n\n发现服务层的实现通过UDDI\n\n* UDDI规范描述了WEB服务的概念，定义了一种**编程接口**\n* 通过UDDI，企业可以**发布自己的WEB服务**供其他企业查询和调用，也可以查询特定的**描述信息**，动态**绑定到该服务商**\n\n## ❗⭐SOAP消息封装协议\n\nWeb服务栈的消息格式层通过**soap协议**实现\n\nSOAP以**XML形式**提供一个简单、轻量的用于在分散或分布环境中**交换结构化和类型信息**的机制。\n\n* Soap定义了服务请求者和服务提供者之间的消息**传递规范**\n* Soap用**xml来格式化信息**，用**HTTP承载消息**\n\n**四个部分：**\n\n* SOAP信封是SOAP消息在句法上的**最外层**，它构造和定义了一个**整体的表示框架**；\n* SOAP编码规则是一个定义传输**数据类型**的通用数据类型系统，这个简单类型系统包括了程序语言、数据库、和半结构数据中不同类型系统的公共特性；\n* SOAP RPC表示定义了**远程过程调用和应答的协议**；\n* SOAP绑定定义了一个使用**底层传输协议**来完成结点间**交换SOAP信封的约定**。\n\n**SOAP消息封装3个部分：**\n\n* 封装\n* SOAP头，header\n* SOAP体，body\n\n\n\n## Web服务体系结构的优势\n\n◎ 高度的**通用性**和**易用性** \n\n◎ 完全的平台、语言**独立性**  \n\n◎ 高度的**集成性**  \n\n◎ 容易**部署和发布** \n\nSOAP\n\n## **简单对象访问协议**\n\n概念，结构，组成部分\n\nSOAP是一个基于XML的、在松散分布式环境中**交换结构化信息**的**轻量级协议**\n\nSOAP包含4个部分，分别为SOAP信封、SOAP编码规则、SOAP RPC表示、SOAP绑定\n\n* SOAP信封是SOAP消息在句法上的最外层，它构造和定义了一个整体的表示框架；\n* SOAP编码规则是一个定义传输数据类型的通用数据类型系统，这个简单类型系统包括了程序语言、数据库、和半结构数据中不同类型系统的公共特性；\n* SOAP RPC表示定义了远程过程调用和应答的协议；\n* SOAP绑定定义了一个使用底层**传输协议**来完成结点间交换SOAP信封的约定。\n\n\n\n![image-20231206090953394](软件体系结构笔记.assets/image-20231206090953394.png)\n\n### 体系结构\n\n* SOAP客户机 是一台有**SOAP机制的机器**，它可以**产生**SOAP请求并通过HTTP发送到服务器\n\n* SOAP服务器 也是一台有**SOAP机制的机器**，能够**接收**来自SOAP客户机的**请求**，并对之做出适当的**响应**。\n\n  三个实体：服务管理器、被部署服务的列表、XML转换程序\n\n* 实际服务\n\n### 总结\n\n当 SOAP 客户机向 SOAP 服务器发送 SOAP 消息时，**用 HTTP 协议传输**。这就叫做 **SOAP 与 HTTP 绑定**\n\n当服务端根据用户请求返回请求结果时，又一次用 **HTTP** **绑定来传输** **SOAP** **响应**。\n\n# 9富互联网应用体系结构\n\n## ❗⭐RIA（富互联网应用）\n\n提出\n\nØ操作复杂性\n\nØ数据复杂性\n\nØ交互复杂性\n\nRIA是Web开发和部署模式的一种演变，“富”的含义有两种，分别是**丰富的数据模型**和**丰富的用户界面。**\n\n"},{"url":"/2023/09/19/计算机组成原理/","content":"title: 计算机组成原理\ndate: 2023-09-19 08:58:36\ntags:\n\n\n\n\n\n123\n\n# 错题\n\n缺漏：\n\n第一章：\n\n第三章：类型转换表示方法，乘除法 \t浮点数计算，CF,SF,OF意义和作用(作业T7)\n\n第四章：RR、RS之类\n\n第五章：选择t8指令执行、MIPS指令单周期多周期分析图8、16、19、微程序\n\n## 第一章\n\n* 从计算机的主要元器件来看，计算机发展所经历的过程为B\n  A.晶体管、电子管、SSI、MSI、LSI、ULSI、VLSI\n  B.电子管、晶体管、SSI、MSI、LSI、VLSI、ULSI\n  C.电子管、晶体管、LSI、MSI、SSI、VLSI、ULSI\n  D.晶体管、电子管、MSI、SSI、LSI、ULSI、VLSI\n\n  第一代：电子管；第二代，晶体管；第三代中、小规模集成电路(MSI、SSI)；第四代，大规模和超大规模集成电路(LSI和VLSI)，超超大规模(ULSI)\n\n* 软件分为：系统软件和应用软件\n\n* 以下给出的软件中，属于**应用软件**的是D。\n  A.汇编程序\n  B.编译程序\n  C.操作系统\n  D.文字处理程序\n\n* 下面有关指令集体系结构的说法中，错误的是(C)。\n  A.指令集体系结构位于计算机软件和硬件的交界面上\n  B.指令集体系结构是指低级语言程序员所看到的概念结构和功能特性\n  C.程序员**可见寄存器的长度、功能与编号**不属于指令集体系结构的内容\n  D.指令集体系结构的英文缩写是ISA\n\n* 冯·诺依曼计算机中，CPU区分从存储器取出的是指令还是数据的依据是D\n  A.指令译码结果的不同\n  B.指令和数据的寻址方式的不同\n  C.指令和数据的访问阶段的不同\n  D.指令和数据所在的**存储单元的不同**\n\n* 以下是有关计算机中指令和数据存放位置的叙述，其中正确的是D\n  A.指令存放在内存，数据存放在外存\n  B.指令和数据任何时候都存放在内存\n  C.指令和数据任何时候都存放在外存\n  D.程序被启动后，其**指令和数据**被**装入内存**\n\n* 以下有关计算机各部件功能的叙述中，错误的是（A）。\n  A.运算器用来完成算术运算 ×  **运算器的主要功能是实现算术运算和逻辑运算** \n  B.存储器用来存放指令和数据 \n  C.控制器通过执行指令来控制整个机器的运行\n  D.输入输出设备用来完成用户和计算机之间的信息交换\n\n### 冯诺依曼\n\n* 基本工作方式：控制流驱动方式;\n\n* 最根本的特征：采用“存储程序”原理，即**按地址访问并顺序执行指令**;\n* 指令和数据均以二进制形式存放在存储器中;\n* CPU区分依据是：指令周期的不同阶段。\n* 冯·诺依曼计算机：以**运算器**为中心\n* 现代的计算器：以存储器为中心\n* **5大部件：存储器、运算器、控制器、输入设备、输出设备(适配器)**\n*  三大部分：CPU(运算器、控制器)、I/O设备(输入设备、输出设备)、主存储器\n\n### 时钟频率问题\n\n* 己知计算机A的时钟频率为800MHz,假定某程序在计算机A上运行需要12s。现在硬件设计人员想设计计算机B,希望该程序在B上的运行时间能缩短为8s,使用新技术后可使B的时钟频率大幅度提高，但在B上运行该程序所需的时钟周期数为在A上的1.5倍。那么，机器B的时钟频率至少应为多少才能达到所希望的要求？ **1.8GHZ**\n\n  首先需要知道：周期=1/频率，时钟周期×时钟周期数(CPI)=总时间。\n\n  本题，用T表示周期，f表示频率，N表示周期数，由A的信息可得：\n\n  Ta*Na=Na/fa=12s，得Na=12s\\*fa=12\\*800\n\n  则，B机，Nb/fb=8s，又有Nb=1.5Na，代入Na，得fb=1800，即1.8GHZ\n\n* 假设同一套指令集用不同的方法设计了两种计算机A和B。机器A的**时钟周期**为1.2ns,机器B的**时钟周期**为2ns。某个程序在机器A上运行时的**CPI**为2，在B上的**CPI**为1。则对于该程序来说，机器A和机器B之间的速度关系为(D)。\n  A.机器A比机器B快1.2倍\n  B.机器B比机器A快1.2倍\n  C.机器A的速度是机器B的1.2倍\n  D.机器B的速度是机器A的1.2倍\n\n  和上题同理。时间=T*CPI，A是2.4，B是2，所以B比A快1.2倍\n\n![image-20231105153026386](计算机组成原理.assets/image-20231105153026386.png)\n\n主频为2.4GHZ，表示电脑一秒钟可以完成(经历)2.4×10<sup>9</sup>个时钟周期\n\n### MIPS计算\n\n![image-20231101203012899](计算机组成原理.assets/image-20231101203012899.png)\n\nMIPS：每秒执行百万条指令数（意思就是每秒cpu能算多几个百万的指令）\n\nMIPS=指令数/(执行时间*1\\*10<sup>6</sup>)=主频/(CPI×1×10<sup>6</sup>)\n\n> 关键即找执行时间或者找到CPI\n\n注意CPI，是平均执行时间周期数哦！\n\nCPI=一段程序中所有指令的时钟周期数之和/指令条数 (统计角度)\n=程序中各类指令的CPI×程序中该类指令的比例 (加权角度)\n\n\n\n![image-20231101210442600](计算机组成原理.assets/image-20231101210442600.png)\n\n首先，MIP=指令数/执行时间*10<sup>6</sup>=主频/CPI10<sup>6</sup>，我们首先不知道执行时间，那就先找CPI\n\nCPI=一段程序中所有指令的时钟周期数之和/指令条数 (统计角度)\n=程序中各类指令的CPI×程序中该类指令的比例 (加权角度)\n\n主频=1/时钟周期=1/2ns=5*10^8\n\n这里，我们用加权角度。\n\n对于序列1，总指令数为(5+1+1)*10<sup>9</sup>=9\\*10<sup>9</sup>，因此，CPI=1×5/7+2\\*1/7+3\\*1/7=10/7\n\nMIPS=5*10^8/10/710<sup>6</sup>得250，序列二为300\n\n对于运行速度，=时钟周期*CPI\n\n序列一为2*(5+1x2+1x3)=20s，序列二为2\\*(10+1x2+1x3)=30s\n\n故选B\n\n\n\n异或门就是进制\n\n同余\n\n* 假定有两个数a和b，若用某一个整数m去除，所得的余数相同，就称a,b两个数对m同余,记作：\n\na≡b (mod m)   模为m \n\n* 假设X,Y,Z三个数，满足下列关系：Z=nX+Y (n为整数),则称Z和Y对模X是同余的，记作： \n\nZ≡Y (mod X)    Y≡Z (mod X)  \n\n* 例子：以12为模    9 ≡ 12+9 ≡ 24+9 ≡ 36+9\n\n9 ≡ 21 ≡ 33 ≡ 45 ≡ -3 ≡ 12-3 ≡ 9\n\n\n\n7+(-3)\n\n​     =7+(**12**-3)\n\n​     =7+9\n\n​     =16  再对12取余\n\n​     =4\n\n>  表示负数的时候如利用模的性质转换成正数，即可将原码运算中的减法变成加法运算\n\n## 第二章\n\n负数转补码：写出原码，符号位为1，从右到左找第一个1，除了符号位都取反\n\n* ```c\n  short si=-8196;\n  unsigned short usi=si;\n  ```\n\n  usi的值。直接补码赋值就好\n\n  -8196原码 1010 0000 0000 0100\n\n  补码 1101 1111 1111 1100\n\n  直接换成十六进制计算真值，DFFC，无符号对应的就是二进制的真值，也就是57340\n\n* 在( )表示中,数值0是唯一表示的 A.原码 B.反码 C.补码 D.原码或反码\n\n  以8位为例，\n  原码0可以是：00000000或者10000000\n  反码0可以是：00000000或者11111111\n  只有补码的0是唯一表示的：00000000\n\n* 用于表示浮点数阶码的编码通常是(移码)。\n\n* 在一般的计算机系统中，西文字符编码普遍采用(B)。\n  A.BCD码\n  B.ASCII码\n  C.格雷码\n  D.CRC码\n\n* 16位补码整数所能表示的范围是(A)。\n  A.-2^15+(2^15-1)\n  B.-(2^15-1)~+(2^15-1)\n  C.-2^16~+(2^16-1)\n  D.-(2^16-1)~+(2^16-1)\n\n  原码的反码都有符号位，8位的范围都是-127-127;\n\n  而补码只有一个0，0000 0000，因此1000 0000可以用来表示-128，所以补码范围-128-128\n\n* 设**[X]补**=1.X1X2X3X4,当X1X2X3X4满足什么条件时，X<一1/2成立？\n  【分析解答】\n  补码的编码规则是：“正数的补码，其符号位为0，数值位不变；负数的补码，其符号位为1,数值位各位取反，末位加1。”从形式上来看，[X]补的符号位为1，故X一定是负数。因此，绝对值越大，数值越小，因而要满足X<一1/2，则X的绝对值必须大于1/2。因此，X]必须为0，X2X3X4至少有一个为1，这样，各位取反末尾加1后，X1一定为1，X2X3X4中至少有一个为1，使得X的绝对值保证大1/2。因此，X0必须为0，X2X3X4至少有一个为1。\n\n* [X]补=1000 0000，因为补码只有一个0即0000 0000，所以，这个1000 0000就是-128，不要觉得是没有符号位的！\n\n* U表示该常数用**无符号整型**方式存储，相当于 **unsigned int**  \n\n  L表示该常数用**长整型**方式存储，相当于 **long**  \n\n  F表示该常数用**浮点**方式存储，相当于 **float三、自动类型转换**\n\n<mark>千万注意整数的原反补都是一致的！！！</mark>\n\n* 作业2.6,t8\n\n  ![image-20231108200139163](计算机组成原理.assets/image-20231108200139163.png)\n\n### 模\n\n**“模”实质上是计量器产生“溢出”的量**，它的值在计量器上表示不出来，计量器上只能表示出模的\n余数。任何有模的计量器，均可化减法为加法运算。\n\n例如：\n时钟的计量范围是0～11，模=12。\n\n### BCD码\n\n每一位十进制数都用二进制表示(4位二进制)\n\n（10 1001）bcd =(29)十进制\n\n### 四种机器码表示零\n\n原码：小数：x=+0.0000 [x]原=0.0000\nx=-0.0000 [x]原=1.0000\n整数：x=+0 [x]原=0,0000\nX=-0 [x]原=1,0000\n\n反码：x=+0 [x]反=0,0000\nX=-0 [x]反=1，1111\nx=+0.0000 [x]反=0.0000\nx=-0.0000 [x]反=1.1111\n\n补码：x=+0 [x]补=0,0000\nX=-0 [x]补=0,0000\nx=+0.0000 [x]补=0.0000\nx=-0.0000 [x]补=0.0000\n\n移码：x=+0 [x]移=1,0000\nX=-0 [x]移=1,0000\nx=+0.0000 [x]移=1.0000\nx=-0.0000 [x]移=1.0000\n\n> 补码和移码的零唯一，但是不同！\n\n### 小数转二进制\n\n![image-20231107213549340](计算机组成原理.assets/image-20231107213549340.png)\n\n④：故加上符号为最后结果为：1101.0011（第一个1是符号位表示负数）\n\n### 浮点数\n\n![image-20231107222410362](计算机组成原理.assets/image-20231107222410362.png)\n\n\n\n1.化为二进制\n2.最高符号位\n3.取8位阶段码，通过偏置位127得真值\n4。写出隐藏1，加上尾数得到真值\n\n#### 规格化\n\n* 浮点数尾数用**原码**表示：有效位**最高位必须为1**\n* 浮点数尾数用**补码**表示：\n* \n\n![image-20231108164220032](计算机组成原理.assets/image-20231108164220032.png)\n\n### IEEE754\n\n![image-20231108202859956](计算机组成原理.assets/image-20231108202859956.png)\n\n![image-20231108202917490](计算机组成原理.assets/image-20231108202917490.png)\n\n## 第三章\n\n减一个数等于加他的补码\n\n无符号，空位补0；有符号，空位补符号位\n\n![image-20240104004236231](计算机组成原理.assets/image-20240104004236231.png)\n\n* 8位补码定点整数10010101左移一位后的值为(D)。\n  A.10101010\n  B.00101010\n  C.00101011\n  D.溢出\n\n  **移出的符号位与最高位不同，发生溢出**\n\n  ***\\*左移还是右移都先转换成补码形式\\****\n  \n     ***\\*左移：高位丢弃，低位补零\\****\n  \n    右移：低位丢弃，高位不变\\****\n  \n* 2.整数和小数 扩展位数的规则：\n\n  （1）正数/原码负数：有符号或无符号数的原码，反码，补码，一律整数在**高位补0**来补充少的位数，小数在**低位补0**来补充少的位数；\n\n  （2）原码负数：整数高位补0，小数低位补0；\n\n  （3）反码负数：整数高位补1，小数低位补1；\n\n  （4）**补码负数**：整数高位补1，小数低位补0；（非常重要，在硬件编程中经常用到！！！）\n\n* ALU是由组合逻辑电路构成的，最基本的部件是并行加法器。由于单纯的ALU不能够存储运算结果和中间变量，往往将ALU和寄存器或暂存器相连；ALU既能进行算术运算又能进行逻辑运算。\n\n\n\n注意加法器放入的要取决于sub，都是补码形式(正数都一样)\n\n* x正，y正，x+y，都是二进制，sub为0\n* x正，y正，x-y，y放反码，sub为1，相当于把y+1成为补码\n* x负、y负，x+y，都放补码，sub为0\n* x负，y负，x-y，x放补码，y放-y的二进制-1，sub为1，相当于输入的y+1就是y正\n\n![image-20240104011252218](计算机组成原理.assets/image-20240104011252218.png)\n\n### 标志寄存器\n\nCF——进/错位标志，OF——溢出标志，SF——符号标志，ZF——零标志\n\n溢出标志OF采用两个规则判断结果\n\n* 若两个加数的符号位相同，但与结果的符号位相异，则溢出\n* 若最高位上的进位和此高位上的进位不同，则溢出\n\nSF，1表示整数；ZF，0表示不为0\n\n\n\n\n\n### C语言类型转换\n\n**32位编译器**\n\nchar ：1个字节\n\nchar*（即指针变量）: 4个字节\n\n short int : 2个字节\n\nint： 4个字节\n\nunsigned int : 4个字节\n\nfloat: 4个字节\n\ndouble: 8个字节 \n\nlong: 4个字节\n\n long long: 8个字节\n\nunsigned long: 4个字节\n\n**64位编译器**\n\n char ：1个字节\n\nchar*(即指针变量): 8个字节\n\nshort int : 2个字节\n\nint： 4个字节\n\nunsigned int : 4个字节\n\nfloat: 4个字节\n\ndouble: 8个字节\n\nlong: 8个字节 （定义是long至少不小于int）\n\nlong long: 8个字节 （long long至少不小于long）\n\nunsigned long: 8个字节\n\n## 第四章\n\n4.6 5，10-3,11,16,19\n\n5.下列有关标志寄存器的叙述中，错误的是(B)。\nA.可用它来存放执行指令得到的各种标志信息\nB.可通过指令直接访问标志寄存器并修改其值\nC.条件转移指令根据其中的标志位确定PC的值\nD.不需像通用寄存器那样对标志寄存器进行编号\n\n5.标志寄存器用来存放执行指令得到的各种标志等信息，因此，标志寄存器中的内容\n通常是在执行指令过程中由CPU根据指令执行结果自动生成的，用户不能通过指令直接\n指定标志寄存器编号来修改其内容。标志寄存器一般是专用寄存器，而不是通用寄存器，因此，它也没有编号，不能在指令中直接指定其编号来访问它，也即不是用户可见寄存器。标志寄存器中的标志位主要用于条件转移或条件设置类指令中的条件判断。\n\n7.假定指令地址码给出的是**操作数的存储地址**，则该操作数采用的是(B)寻址\n方式。\nA.立即\nB.直接\nC.基址\nD.相对\n\n如果给出的是操作数则是立即寻址\n\n9.假定指令地址码给出的是操作数所在的寄存器的编号，则该操作数采用的是(C)\n寻址方式。\nA.直接\nB.间接\nC.寄存器直接\nD.寄存器间接\n\n10.寄存器间接寻址方式的操作数存放在(B)中。\nA.通用寄存器\nB.存储单元\nC.程序计数器\nD.堆栈\n\n12.若变址寄存器编号为X,形式地址为D,则变址寻址方式的有效地址为(\nA.R[X]+D\nB.R[X]+R[D]\nC.M[R[X]+D]\nD.M[R[X]+M[D]]\n\n12.变址寻址方式下，有效地址为形式地址加上变址值，变址值存放在变址寄存器中，\n因此，变址寻址方式的有效地址为R[X]十D。答案为选项A。\n\n* CISC(Complex Instruction Set Computer)\n  * 复杂指令集计算机。早期的计算机为了增加功能和更好地支持高级语言而不断地增加新的指令类型，使CPU可以直接实现复杂的指令操作。\n  * 这种指令系统中的**指令功能复杂**，**寻址方式多**，**指令长度可变**，指令格式多样。\n  * 因而采用这种指令系统的计算机被称为复杂指令集计算机。\n\n* RISC(Reduced Instruction Set Computer)\n  * 精简指令集计算机。\n  * 这种计算机采用简化的指令系统，指令集中只包含程序中常用的指令，只有Load和Store指令才能访存\n  * 运算类指令只能是R-R型\n  * 提供**大****量通用寄存器**以减少访存次数\n  * 采用流水线方式执行指令\n  * 控制器用**硬连阵列逻辑实现**，并采用优化的编译技术。\n\n21.通常将在部件之间进行数据传送的指令称为传送指令。以下有关各类传送指令功能的叙述中，错误的是(D)。\nA.出/入栈指令(push/pop)完成CPU和栈顶之间的数据传送\nB.访存指令(load/store)完成CPU和存储单元之间的数据传送\nC.I/O指令(in/out)完成CPU和I/O端口之间的数据传送\nD.寄存器传送指令(move)完成CPU和寄存器之间的数据传送   **寄存器和存储单元**\n\n13.假定采用相对寻址方式的转移指令占两个字节，第一字节是操作码，第二字节是相对位移量（用补码表示）。取指令时，每次CPU从存储器取出一个字节，并自动完成PC+1→PC。假设执行到某转移指令时（取指令前）PC的内容为200CH,该指令的转移目标地址为1FB0H,则该转移指令第二字节的内容应为(D**C**\nA.5CH\nB.5EH\nC.A2H\nD.A4H\n\n取出操作数和偏移量就要+2了，要剪掉2\n\n3某计算机为定长指令字结构，采用扩展操作码编码方式，指令长度为16位，每个地\n址码占4位三地址指令15条，二地址指令8条，一地址指令127条，则剩下的零地址指令\n最多有(B)条。\nA.15\nB.16\nC.31\nD.32\n\n3.指令长度为16位，每个地址码占4位，对于三地址指令，地址码占12位，操作码占\n4位，最多16种编码，15条指令用掉15种编码0000~1110，还剩一种编码1111；对于二地\n址指令，高4位操作码一定是1111，低位的地址码占8位，剩下的中间操作码还有4位，最\n多可以有16种编码，8条指令用掉8种编码11110000~11110111；对于一地址指令，高5位操作码一定为11111，低4位为地址码，剩下的中间操作码还有7位，最多可以有128种\n编码，127条指令用掉127种编码111110000000~111111111110，还剩一种编码11111\n1111111未用：对于零地址指令，其高12位操作码一定为111111111111，因此，还有4位未编码，故剩下的零地址指令最多有16条。答案为选项B。\n\n\n\n栈顶的地址存放在一个特定的栈指针寄存器中，可以使用专门的入栈和出栈指令来访问栈顶数据，也可以通过**普通的访存指令来读写栈帧中某个位置的内容**。\n\n**分析应用**\n\n1\n\n### 寻址\n\n| 寻址     | 偏移量             | 基准地址         |\n| -------- | ------------------ | ---------------- |\n| 相对寻址 | 指令的形式地址给出 | 程序计数器PC给出 |\n| 变址寻址 | 变址寄存器给出     | 指令的形式地址   |\n| 基址寻址 | 指令的形式地址     | 基址寄存器       |\n\n可以看到，相对寻址和变/基址寻址的区别就是对象是程序计数器还是通用寄存器(变址寄存器/基址寄存器)，也就是找当前指令前D个单元处的信息\n\n而变址指令形式地址给出的是基准地址，偏移量有变址寄存器给出\n基址由基址寄存器给出基准地址，偏移量由指令形式地址给出。\n\n- **在R型指令中：**\n\n- - OP：操作码\n  - rs：第一个源操作数寄存器\n  - rt：第二个源操作数寄存器（单目源数据）\n  - rd：结果寄存器\n  - Ms: 源操作数的寻址方式(mode)\n  - Md: 目的操作数的寻址方式(mode)\n  - shamt：移位操作时的位移量，非移位操作时为0\n  - func：功能码\n  - 例：R[rd] ← R[rs] + R[rt]\n\n- **在I型指令（立即数型指令）中：**\n\n- - rs：源操作数寄存器\n  - rt：结果寄存器\n  - 例：R[rt] ← R[rs]\n\n字长是指CPU指令集中的单指令的**最大处理长度**->通用寄存器位数\n\n16.假设某条指令的一个操作数采用一次间接寻址方式)指令中给出的地址码为\n1200H,地址1200H中的内容为12FCH,地址12FCH中的内容为38B8H,地址38B8H中\n的内容为88F9H,则该操作数的有效地址为(B)\nA.1200H\nB.12FCH\nC.38B8H\nD.88F9H\n\n16.一次间接寻址方式下，指令中给出的地址码为操作数的有效地址的地址，所以，操作数的有效地址是指令中地址码所指出的存储单元中的内容，即12FCH。答案为选项B。\n\n17.假设某条指令的一个操作数采用寄存器间接寻址方式，假定指令中给出的寄存器编号为8,8号寄存器的内容为1200H,地址1200H中的内容为12FCH,地址12FCH中的内容为38B8H,地址38B8H中的内容为88F9H,则该操作数的有效地址为(A)。\nA.1200H\nB.12FCH\nC.38B8H\nD.88F9H\n\n17.寄存器间接寻址方式下，操作数的有效地址在指令中给出的寄存器中，因此，8号寄存器中的内容为操作数的有效地址，即1200H。答案为选项A。\n\n14.假设某指令的一个操作数采用变址寻址方式，变址寄存器中的值为124，指令中给\n出的**形式地址为B000H**,地址B000H中的内容为C000H,则该操作数的有效地址为\nD错 C对\nA.B124H\nB.C124H\nC.B07CH\nD.C07CH\n\n14.变址寻址方式下，有效地址为变址寄存器中的值加上形式**地址**，变址值124=111\n1100B=7CH,有效地址为B000H+007CH=B07CH。答案为选项C。\n\n#### 目标地址范围\n\n\n\n### 大小端存储\n\nMSB，most，最高有效位\n\nLSB，least，最低有效位\n\n大端：高位存低地址，低位存高地址\n\n小端：低位存低地址，高位存高地址\n\n[数据存储：小端模式和大端模式——终于搞明白了！！！_小端存放_风兔子喵的博客-CSDN博客](https://blog.csdn.net/weixin_45633061/article/details/117421452)\n\n![image-20231116234740547](计算机组成原理.assets/image-20231116234740547.png)\n\n15.假设某计算机采用小端方式存储，按字节编址。一维数组a有100个元素，其类型\n为**float**,存放在地址C0001000H开始的连续区域中，则最后一个数组元素的MSB所在的\n地址应为(D}。\nA.C0001396H\nB.C0001399H\nC.C000118CH\nD.C000118FH\n\n15.数组元素的访问通常使用变址寻址方式，数组起始地址通常是指令中直接给出的\n形式地址，下标变量存放在变址寄存器中，本题中，数组元素类型为float,故每个数组元素\n占**4个字节**，最后一个元素的下标为99，其首地址为**C0001000H+99×4=C0001000H+**\n**110001100B=C000118CH**。因为采用小端方式并按字节编址，所以MSB所在的地址应\n为C000118FH。答案为选项D。\n\n18.某计算机按字节编址，采用大端方式在储信息。其中，某指令的一个操作数的机器\n数为ABCD 00FFH,该操作数采用基址寻址方式，指令中形式地址（用补码表示）为\nFF00H,当前基址寄存器的内容为C000O000H,则该操作数的LSB(即FFH)存放的地址是\n(D）。\nA.C00O FFOOH\nB.C000 FFO3II\nC.BFFF FFOOH\nD.BFFF FFO3H\n\n18.基址寻址方式下，操作数的有效地址为基址寄存器内容加上形式地址，因此，操作\n数ABCD 00FFH存放在C0000000H+FFO0H-C0000000+**FFFF FF00**=BFFF FFO0H\n因为是大端方式并按字节编址，所以LSB(FFH)存放的地址为BFFF FF03H。答案为选D\n\n## 第五章\n\n立即数都是存放在指令中的操作数单元，仅仅跟随着操作码。而对于这个值来说你可以解释为数字，也可以解释为地址，就好比数字4816511，你可以解释为人民币数值，也可是电话号码。\n\n立即数具体是什么含义那得看操作码了\n\n、3.冯·诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU依据(C)来区分它们。\nA.指令和数据的表示形式不同\nB.指令和数据的寻址方式不同\nC.指令和数据的访问时点不同\nD.指令和数据的地址形式不同\n\n取指令或数据时所处的机器周期不同：**取指周期取出的是指令**；**分析、取数或执行周期取出的是数据**。\n\n对汇编语言程序员不透明的是 (  D    ) 。\n\nA指令寄存器(IR)\nB存储器地址寄存器(MAR)\nC存储器数据寄存器(MDR)\nD程序计数器(PC)\n\n5.下列有关CPU中部分部件的功能的描述中，错误的是D)。\nA.控制单元用于对指令操作码译码并生成控制信号\nB.PC称为程序计数器，用于存放将要执行的指令的地址\nC.通过将PC按当前指令长度增量，可实现指令的按序执行\nD.IR称为指令寄存器，用来存放当前指令的操作码 **（正在执行的一条完整的指令而不是操作码）**\n\n8.下列有关程序计数器P℃的叙述中，错误的是(B\nA.每条指令执行后，PC的值都会被改变\nB.指令顺序执行时，**PC的值总是自动加1** X 是加上当前执行指令的长度，1指一条指令的长度\nC.调用指令执行后，PC的值一定是被调用过程的入口地址\nD.无条件转移指令执行后，PC的值一定是转移目标地址\n\n![image-20240102205112791](计算机组成原理.assets/image-20240102205112791.png)\n\n![image-20240102205130374](计算机组成原理.assets/image-20240102205130374.png)\n\n![image-20240102205145727](计算机组成原理.assets/image-20240102205145727.png)\n\n![image-20240102205156332](计算机组成原理.assets/image-20240102205156332.png)\n\n![image-20240102205220128](计算机组成原理.assets/image-20240102205220128.png)\n\n![image-20240102205243020](计算机组成原理.assets/image-20240102205243020-17041999635931.png)\n\n![image-20240102205304741](计算机组成原理.assets/image-20240102205304741.png)\n\n## 第六章\n\n超标量（superscalar）是指在CPU中有一条以上的流水线，**并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术**。\n\n下面两个题要区分，同样是三条，采用转发技术，一个要加nop一个不用加。原因就是lw是load，它应该不适用于ALU直接转发，因为这里的是地址，要从主存中load才能把操作数取来放到Mem阶段的DM，所以应该是在Mem的DM进行转发到第三条的ALU，因此要加一个气泡把第三条的ALU移到load的DM之后。\n\n转发能够解决大部分 RAW 数据冒险，那么 lw 指令随后跟 R型指令或I型运算类指令的相关问题能否通过转发来解决呢？不可以！！！\n\n![image-20240103103249420](计算机组成原理.assets/image-20240103103249420.png)\n\n![image-20240103103334332](计算机组成原理.assets/image-20240103103334332.png)\n\n![image-20240103104229216](计算机组成原理.assets/image-20240103104229216.png)\n\n链接：https://www.nowcoder.com/questionTerminal/4fccb91e532746d095565476efa9732a\n来源：牛客网\n\n\n\n对于经典五段流水线的数据相关问题，一般需要考察前后指令之间是否有寄存器写后读（顺序执行下，不会发生写后写或读后写的相关冲突，在乱序执行下才有可能发生）的问题。 \n\n  关于数据相关的流水线问题，具体延迟几个周期与下列两个因素相关： \n\n  \\1. 是否能在同一周期内完成寄存器的读和写 \n\n  \\2. 是否采用“转发/定向”（forward）技术 \n\n  具体的讨论如下： \n\n- ​    如果两者都为否定，那么应当至少延迟3个时钟周期。（下一条指令必须等到上一条指令完成写回后所需操作数才准备就绪）      \n- ​    如果能够在同一周期内完成寄存器的读和写，则上一条指令的“WB”段（写回）与下一条数据相关指令的“ID”（取操作数）可以安排在同一周期，此时至少延迟2个时钟周期。      \n- ​    如果更进一步，采用了“转发技术”，那么需要根据上一条指令的类型来进行区分：      \n  - ​     若上一条指令为算术逻辑运算类指令，例如sub、add等等，结果操作数能够在“EX段获得的话，那么上一条指令在“EX”段（运算）运算的结果，可以直接转发到本条指令运算时的一端，从而时钟周期延迟为0。        \n  - ​     若上一条指令为取数指令（ld），结果操作数必须等到访存阶段结束才能获得，那么至少需要延迟1个时钟周期。\n\n## 第七章\n\n**按字节编址**：存储器被划分成**若干个单元**，**每个单元容量为1个字节**，从0开始编号（地址）。\n\n5.某计算机字长16位，主存地址空间大小是64KB,按**字节编址**，则寻址范围是A\nA.0~(64K-1) B.0~(32K-1)\nC.0~(64KB-1) D.0~(32KB-1)\n\n注意 存储空间64B，这里按字节编址，所以应该是那么寻址范围就是64KB/1B=64K(个单元)，而一般从0开始，就是0-(64K-1)\n如果是按字长的话，1字=16bit=2B，那么64KB/2B=32K，寻址范围就应该是0-(32K-1)\n\n6.EPROM是指()。\nA.读写存储器  B.掩膜只读存储器\nC.可编程的只读存储器 D.可擦除可编程的只读存储器\n\n几个英文缩写：\n\n* ROM Read Only Memory只读存储器；RAM Random Access Memory随机访问存储器\n* DRAM，动态随机访问存储器，由电容组成，破坏性读出，要刷新\n* SRAM，静态随机访问存储器，双稳态的正负反馈电路，非破坏性，元器件多->集成度小，适合做高速缓冲存储器(cache)\n* PROM 可编程只读存储器\n* EPROM，Erasable PROM，可擦除可编程只读存储器\n* EEPROM，Electrically EPROM，电可擦除可编程只读存储器\n* Flash Memory，闪存，非易失，某种低电压是可读不可写；某种高电压可更改或删除\n\n7.下列几种存储器中，(A)是易失性存储器。\nA.cache B.EPROM\nC.Flash Memory D.CD-ROM\n\n9.需要定时刷新的半导体存储器芯片是(B)。\nA.SRAM B.DRAM(电容，破坏性)\nC.EPROM D.Flash Memory\n\n10.通常采用**行、列地址引脚复用**的半导体存储器芯片是()。\nA.SRAM **B.DRAM**\nC.EPROM D.Flash Memory\n\n11.具有**RAS(行地址选通)和CAS(列地址选通)信号**引脚的半导体存储器芯片是(B)。\nA.SRAM **B.DRAM**\nC.EPROM D.Flash Memory\n\n![image-20240104205726506](计算机组成原理.assets/image-20240104205726506.png)\n\n12.下面有关ROM和RAM的叙述中，错误的是()\nA.RAM是可读可写存储器，ROM是只读存储器√\nB.ROM和RAM都采用**随机访问方式**进行读写√\nC.系统的主存**由RAM和ROM**组成√\nD.系统的主存都用DRAM芯片实现× RAM区一般用DRAM，ROM区用相应的ROM存储元件\n\n13.下面有关半导体存储器的叙述中，错误的是(A)。\nA.半导体存储器都采用随机存取方式进行读写 不一定 全相联就是根据内容即cache行号进行读写\nB.ROM芯片属于半导体随机存储器芯片\nC.SRAM是半导体静态随机访问存储器，可用作cache\nD.DRAM是半导体动态随机访问存储器，可用作主存\n\n**计算题**：\n\n14.假定DDR3 SDRAM芯片内部核心频率为133.25MHz,与之相连的存储器总线每次传输8B,则下面有关叙述中，错误的是(C)。\nA.芯片内部I/O缓冲采用8位预取技术\nB.存储器总线每秒传1066M次数据\nC.存储器总线的时钟频率为1066MHz\nD.存储器总线的带宽大约为8.5GB/s\n\nDDR3 SDRAM就是8位预取\n一秒133.25次，每次8B，则每秒传133.25×8B≈1066M\n时钟频率：前置知识——存储器每个时钟频率传两次数据，因此每秒传1066M次，是两次的，时钟频率应为1066M次/2=533MHZ\n**带宽**：1066M×8B≈8.5GB/s。 **带宽为一个信号在频带上的宽度**\n\n\n\n\n\n### 芯片内编址最小地址\n\n15.假定用若干个16K×1位的存储器芯片组成一个64K×8位的存储器，芯片内各单元连续编址，则地址BFF0H所在的芯片的最小地址为()。\nA.4000H B.6000H\nC.8000H D.A000H\n\n16.假定用若干个16K×8位的存储器芯片组成一个64K×8位的存储器，芯片内各单元交叉编址，则地址BFFFH所在的芯片的最小地址为()。\nA.0000H B.0001H\nC.0002H D.0003H\n\n连续编址在单元内编(竖着)，交叉是各单元跳着(横着)，因此有\n\n* 连续编址：**模块位|块内地址**，模块在高位\n* 交叉编址：**块内地址|模块位**，模块位在低位\n\n> 求出总地址位和其中一个位，得到地址范围\n\n15题存储器64K=2^16，则地址位有16位(表示所有地址)，有4块芯片，则模块位占2位块内地址14位，于是列出所有模块的地址范围\n\n1: 0000<u>...0000-</u>0011<u>...1111</u> 后14位，十六进制就是0000H-3FFFH\n\n2: 0100<u>...0000-</u>0111<u>...1111</u>，十六进制就是4000H-7FFFH\n\n3: 同理十六进制就是8000H-BFFFH\n\n4: 十六进制就是C000H-FFFFH\n\n则BFF0H应该在8000H-BFFFH，即第三块\n\n16题交叉编址，地址位数16位，四个芯片，模块为为低2位\n\nBFFFH，低两位都为1，则是第四个模块，最小地址位0003H\n\n\n\n33.以下是有关虚拟存储管理机制中地址转换的叙述，其中错误的是(B)。\nA.地址转换是指把逻辑地址转换为物理地址\nB.通常逻辑地址的位数比物理地址的位数少\nC.地址转换过程中会发现是否“缺页”\nD.MMU在地址转换过程中要访问页表项\n\n\n\n35以下是有关虚拟存储管理机制中页表的叙述，其中错误的是D\nA.系统中每个进程有一个页表\nB.页表中每个表项与一个虚页对应\nC.每个页表项中都包含装入位（有效位）\nD.所有进程都可以访问页表\n\n\n\n37.以下是有关页式存储管理的叙述，其中错误的是(D)。\nA.进程被划分成等长的页，内存被划分成同样大小的页框\nB.采用全相联映射，每个页可以映射到任何一个空闲的页框中\nC.当从磁盘装人的信息不足一页时会产生页内碎片\nD.相对于段式存储管理，分页式更利于存储保护\n\n38.以下是有关段式存储管理的叙述，其中错误的是(D)。\nA.段是逻辑结构上相对独立的程序块，因此段是可变长的\nB.按程序中实际的段来分配主存，所以分配后的存储块是可变长的\nC.每个段表项必须记录对应段在主存的起始位置和段的长度\nD.分段方式对低级语言程序员和编译器来说是透明的\n\n\n\n39.以下是有关快表的叙述，其中错误的是()。\nA.快表的英文缩写是TLB,称为转换后援缓冲器\nB.快表中存放的是当前进程的常用页表项\nC.在快表中命中时，在L1 cache中一定命中。不一定在L1\nD.快表是一种高速缓存，一定在CPU中\n\n### cache总容量\n\ncache块大小=主存块大小\n\n然而cache还要放其他位和标记位\n\n由此看来 Cache 总容量 = 行数×行长 = 行数×(其他位+标记部分位数+数据部分位数)，其他为包括：可能存在的脏位位数+有效位位数+替换算法位(比如LRU就是2位)\n\n![image-20231222115358139](计算机组成原理.assets/image-20231222115358139.png)\n\n选择T25-29，分析题T9、T11   看书本，区分好各种映射方式的结构、其他位（直写回写替换位）\n\n![image-20240104234714860](计算机组成原理.assets/image-20240104234714860-17043832354871.png)\n\n理解题意，区分主存地址位数和主存块大小，主存块大小存的是数据，cache块大小等于主存块大小，是因为要存放入的主存块数据\n\n而主存地址位数是来表示主存地址编码的，它不是存在主存块内的！\n\n本题主存地址位数32位，字节编址，那就有32/8=4个单元，一个主存块4个单元，块内地址就是2位，还得有cache行号，一共32K行，那就是15位，那么32-2-15=15位就是标记位，其实就是主存块的编号。\n\n而cache总容量就是其他位+标记位+数据，标记为就是来标识放进来的是哪个主存块的\n\ncache 32K字，块大小1个字，那就有32K行，直写有效位1，总容量(1+15+32)×32K\n\n### cache缺失损失时钟周期\n\n30.假定CPU通过存储器总线读取数据的过程为：发送地址和读命令需1个时钟周期，存储器准备一个数据需8个时钟周期，总线上每传送1个数据需1个时钟周期。若主存和cache之间交换的主存块大小为64B,存取宽度和总线宽度都为**4B**,则cache的一次缺失损失至少为()个时钟周期。\nA.64\nB.72\nC.80\nD.160\n\n31.假定CPU通过存储器总线读取数据的过程为：发送地址和读命令需1个时钟周期，存储器准备一个数据需8个时钟周期，总线上每传送1个数据需1个时钟周期。若主存和cache之间交换的主存块大小为64B,存取宽度和总线宽度都为**8B**,则cache的一次缺失损失至少为()个时钟周期。\nA.64\nB.72\nC.80\nD.160\n\n方法：算出一个总线事务，然后再乘。\n\n30题，主存块大小为64B，**每个总线事务读取4B**，则有64B/4B=16个总线事务，每个总线事务用=发送地址和读命令+准备一个数据+传送1个数据=1+8+1=10个时钟周期，则一共需要160个时钟周期\n\n31题，总线事务8个，则一共80个时钟周期\n\n32.假定采用多**模块交叉存储器**组织方式，存储器芯片和总线支持突发传送，CPU通过存储器总线读取数据的过程为：发送首地址和读命令需1个时钟周期，存储器准备第一个数据需8个时钟周期（即CAS潜伏期=8），随后每个时钟周期总线上传送1个数据，可连续传送8个数据（即突发长度=8）。若主存和cache之间交换的主存块大小为64B,存取宽度和总线宽度都为8B,则cache的一次缺失损失至少为()个时钟周期。\nA.17 B.20\nC.33 D.65\n\n一次缺失读取64B，每个突发都能读取8B×8=64B，因此只需要一个总线事务，所用时间1+8+8=17.连续传8个那就是8个时钟周期\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200608201210112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3NjMx,size_16,color_FFFFFF,t_70)\n\n![img](https://img-blog.csdnimg.cn/20200608201858142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjI3NjMx,size_16,color_FFFFFF,t_70)\n\n### TLB和Page，Cache和主存\n\n四种结构\nTLB：快表，是一种虚拟地址到物理地址的地址映射结构，当CPU传出一个地址时，首先到达的就是TLB，如果TLB命中，那么隐藏的含义就是，这个虚拟地址可以直接转换为物理地址（因为快表的表项中装的就是他的实页号，而页内地址则在虚拟地址中可以找到，因此拼接起来就是物理地址）。\n\nPage：页表，是一种虚拟地址到物理地址的地址映射结构，当CPU传出一个地址时，如果Page命中，那么隐藏的含义就是，这个虚拟地址可以直接转换为物理地址（因为页表的表项中装的就是他的实页号，而页内地址则在虚拟地址中可以找到，因此拼接起来就是物理地址）。\n\nCache：高速缓存，是一种储存数据信息的结构，当物理地址传出时，首先到达的就是Cache，如果Cache命中，那么隐藏的含义就是，这个块我可以直接拿走（因为Cache中保存的就是主存的副本）。\n\n主存：主存，是一种储存数据信息的结构，当物理地址传出时，如果Cache未命中，主存命中，那么隐藏的含义就是，这个块我可以从主存中拿走（因为主存中保存的就是我要的信息，不过速度肯定是没有Cache快，有的时候会差好几个数量级）。\n\n**联系**\n可以看到，\n\nTLB和Page在形式上是高度相似的（他们都是地址映射的结构），Cache和主存在形式上是高度相似的（他们都是保存数据信息的结构）。\n\nTLB和Cache在存取速度和优先级上是高度相似的（他们都是优先访问的，因为他们存取速度比较快），Page和主存在存取速度和优先级上是高度相似的（他们都是后访问的，因为他们都在主存中）\n\n我们知道，**Cache是主存的高速缓存**。实际上，**TLB就是页表的高速缓存。**\n\n**而Cache用来加速数据存取，TLB用来加速地址转换。**\n\n对他们的访问均不算访问内存（因为他们的速度比访问主存快好几个数量级）。（这部分的知识对后面的访存部分有很大作用）\n\n6.假定执行最复杂的指令需要完成6个子功能，分别由对应的功能部件A~F来完成，每个功能部件所花的时间分别为80ps、40ps、50ps、70ps、20ps、30ps,流水段寄存器延时为20ps,现把最后两个功能部件E和F合并，以产生一个5段流水线。该5段流水线的时\n钟周期至少是(100)ps。 最长的＋寄存器延迟\n\n\n\n## **2.2** **数值数据表示方法**\n\n### 数的机器码\n\n#### 原反补\n\n补码十因为正负数有符号位(0正1负)，加减不能直接算，而补码可以直接运算\n\n正数都一致\n\n**负数：**\n\n* 机算：原码--符号位不变，数值位取反->反码--末尾加1-->补码\n* 快速算：补码--从右往左找到第一个1，这个1左边的所有“**数值位**”(不包括符号)按位取反->原码\n\n\n\n##### 补码的加法\n\n从最低为开始，按位相加(符号位参与运算)，并往更高位进位，丢弃超出的部分，比如8bit寄存器超出8位去掉。\n\n> 负数的补码各位不能解读为位权信息！！！转为原码才能解读\n\n\n\n##### 补码的减法\n\n减一个数等于加这个数的相反数\n\n那么已知“减数”的补码，如何求其负值的补码表示？\n\n机算方法：B补<---全部位按位取反，末位+1--->-B补\n\n**手算方法**：从右往左找到第一个1，左边**所有位(包括符号)**全部取反\n\n> 注意和补码-原码的区别！一个数值位，一个所有位\n\n#### 总结\n\n![image-20230919094524121](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230919094524121.png)\n\n#### 移码\n\n![image-20230919170130942](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230919170130942.png)\n\n* **定点表示** (小数点位置固定的数)\n  * 定点整数\n  * 定点小数\n  * 仅能表示纯小数及纯整数\n\n* **浮点表示**（解决小数点问题）\n\n* **机器数** （解决符号问题）\n\n![image-20230919170553322](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230919170553322.png)\n\n![image-20230919170603587](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230919170603587.png)\n\n![image-20230919170831705](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230919170831705.png)\n\n\n\n\n\n\n\n## 无符号整数\n\nunsigned int 无符号int型\n\n机器字长限制了 **通用寄存器长度**(因此表示的位数有上限)和ALU的输入端(n位运算)\n\n比如8位，真值为0，高位补0，0000 0000\n\n* 没有符号位，i位位权时2^i-1\n* nbit无符号整数表示范围：0-2^n-1，表示全0到最大全1\n\n## 数据校验\n\n### 奇偶校验\n\n![image-20230926084436366](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230926084436366.png)\n\n右边是改进的，三个bit可以表示8种状态，只取4个，其他是非法状态。\n\n奇偶校验码：在首位加一个校验位\n\n![image-20230926084723091](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230926084723091.png)\n\n> 当有偶数个位发生错误就发现不了，因为1和0数目没有变\n\n\n\n计算机求奇偶校验码就是把位数进行异或\n\n![image-20230926085304860](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20230926085304860.png)\n\n## 运算\n\n优先级：与>或\n\n与、或、非\n\n与非、或非、异或、同或（异或取反）\n\n\n\n## 算数逻辑单元\n\n![image-20231010084939783](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010084939783.png)\n\n## 并行进位加法器\n\n串行进位，依赖于前一个的信息\n\n如何更快的产生进位？其实就是把所有的加数和被加数再结合最开始输入的C0就可以直接得出最终的结果\n\n**并行进位的并行加法器**：各级进位信息同时形成，又称为先行进位、同时进位。\n\n然而无休止的套娃会让电路越来越复杂，因此一般只用4位加法器，由4个FA和一些新的线路、运算逻辑组成\n\n## 补码加减运算器\n\n## 加减运算和溢出判断\n\n### 原码的加减法\n\n被加数和加数，组合有4中\n\n**原码的加法运算：**\n\n正+正--绝对值做加法，结果为正\n\n负+负--绝对值加法，结果为负\n\n正+负--绝对值大的减绝对值小的，符号同绝对值大的数\n\n负+正--绝对值大的减绝对值小的，符号同绝对值大的数\n\n**原码的减法运算：**<u>“减数”符号取反</u>，转变为加法\n\n正-正-->正+正\n\n负-正-->负+负\n\n正-正-->正+负\n\n负+正-->负-负\n\n### 补码的加减法\n\n原码的逻辑在电路实现中太难了\n\n补码取负值：所有位按位取反再末位+1\n\n对于补码，最终都转变为加法，符号位也参与运算\n\n8位补码最高位是符号位，表示范围为-128-127,超出会溢出\n\n### 溢出判断\n\n下溢-负数区-0-正数区-上溢\n\n* 只有正数+正数才会上溢---结果是负\n* 只有负数+负数才会下溢---结果是正\n\n方法\n\n**一位符号位**\n\n![image-20231010094609942](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010094609942.png)\n\n“+”或运算\n\n溢出情况：As,Bs=0,Ss=1或As,Bs=1,Ss=0\n\n**采用一位符号位，证据数据位进位情况判断溢出**\n\n![image-20231010095631809](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010095631809.png)\n\n**双符号位**\n\n扩展符号位，正数符号位为00，负数符号位为11\n\n实际存储1个，运算时会复制一个符号位\n\n### 符号扩展\n\n为了解决溢出问题\n\n小数为了不影响位权，在末尾拓展\n\n![image-20231010100324855](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010100324855.png)\n\n![image-20231010100537593](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010100537593.png)\n\n## 标志位的生成\n\n## 定点数的移位运算\n\n## 原码的乘法\n\n### 乘法运算的实现思想\n\n \n\n### 原码的一位乘法\n\nX存被乘数，MQ存乘数原码的绝对值\n\nACC存乘积高位\n\nACC MQ用完后逻辑右移，MQ可以存放乘积地位，MQ右移出去的位舍弃(乘数低位乘完之后本来就舍弃了没用了)\n\n数值：绝对值相乘，用n轮加法，移位实现，看图步骤\n\n符号为：异或运算\n\n![image-20231010113633834](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231010113633834.png)\n\n## 补码的一位乘法\n\n和原码一位乘法类似，采用Booth算法\n\n![image-20231017092733316](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017092733316.png)\n\n![image-20231017090457843](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017090457843.png)\n\n|            | 原码                                                         | 补码                                                         |\n| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n|            | 进行n轮加法、移位                                            | 进行n轮加法、移位，最后再多来一次加法                        |\n| 每次的加法 | 可能是+0，+[\\|x\\|]<sub>原</sub>                              | 可能是+0，+[x]<sub>补</sub>，+[-x]<sub>补</sub>              |\n| 每次的移位 | **逻辑右移**，符号位也移动，高位补0                          | 补码的算数右移，符号位固定补位，正数补0，负数补1             |\n| 符号位     | 符号位不参与运算                                             | 符号位参与运算                                               |\n| 加法怎么加 | 根据当前MQ中的最低位来确定加什么：<br />MQ中最低为=1时，(ACC)+[\\|x\\|]<sub>原</sub><br />MQ中最低为=0时，(ACC)+0 | 根据当前MQ中的最低位辅助位来确定加什么(初始为0)<br />**辅助位**-MQ中最低位=1时，(ACC)+[x]<sub>补</sub><br />辅助位-MQ中最低位=0时,(ACC)+0<br />辅助位-MQ中最低位=-1时(ACC)+[-x]<sub>补</sub> |\n\n> MQ中拓展多一位为辅助位，而所说的最低为是辅助位前一位，为了和原码方法对应\n\n由于所有寄存器长度统一，因此ACC和X都会多加一位，可以表示**双符号位**\n\n**乘数单符号**位补码(有一位被辅助位占了)，被乘数双符号位补码\n\n## 原码的除法\n\n![image-20231017094703807](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017094703807.png)\n\n恢复余数法，逻辑**左**移\n\n![image-20231017102516997](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017102516997.png) \n\n\n\n加减交替法，\n\n![image-20231017103734867](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017103734867.png)\n\n如果第一位商是1，说明被除数比除数大，定点小数没法表示1，检测出来停止运算，因为定点小数没法表示这种情况\n\n\n\n## 补码的除法\n\n![image-20231017105414064](D:\\Blog\\source\\_posts\\计算机组成原理.assets\\image-20231017105414064.png)\n\n\n| 除法类型       | 符号位参与运算 | 加减次数 | 移位方向 | 移位次数 | 上商、加减原则     | 说明                       |\n| -------------- | -------------- | -------- | -------- | -------- | ------------------ | -------------------------- |\n| 原码加减交替法 | 否             | N+1或N+2 | 左       | N        | 余数的正负         | 若最终余数为负，需恢复余数 |\n| 补码加减交替法 | 是             | N+1      | 左       | N        | 余数和除数是否同号 | 商末位恒置1                |\n\n## C语言的类型转换\n\n无符号数与有符号数：不改变数据内容，改变解释方式\n\n长整数变短整数：高位截断，保留地位\n\n## 页式存储\n\n![image-20240105002808381](计算机组成原理.assets/image-20240105002808381.png)\n\n分页逻辑层面，分块物理层面\n\n进程被分页，页大小就是块大小，分页放进主存块中\n\n![image-20240105003403913](计算机组成原理.assets/image-20240105003403913.png)\n\n关键是逻辑页号——主存块号，通过页表，登记\n\n查到主存块号，拼接上页内地址就是物理地址\n\n逻辑页号|页内地址\n\n![image-20240105003247013](计算机组成原理.assets/image-20240105003247013.png)\n\n### 快表\n\n快表逻辑上的cache，采用SRAM，主存采用DRAM\n\n页表是逻辑上的主存\n\nchache是主存数据的副本——加快物理地址的访问\n\n而快表是页表页表项的副本——加快地址变换的速度\n\n![image-20240105003823746](计算机组成原理.assets/image-20240105003823746.png)\n\n# 指令系统\n\n* 操作码——指明了“做什么”\n* 地址码——指明了“对谁动手”\n\n一台计算机的所有指令的集合构成该机的指令系统，也称为**指令集**。\n\n注：一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令\nEg: X86架构(Inter的)、ARM架构(手机)\n\n一条指令：操作码字段+地址码字段(操作数字段)\n\n* 无符号数与有符号数转换方式：把补码**完全赋值**，然后按无符号整数解析\n* 长整数变短整数：高位截断，保留低位\n* 短整数变长整数，进行符号扩展\n\n![image-20240104155754297](计算机组成原理.assets/image-20240104155754297.png)\n\n## **指令格式：**\n\n一个指令\n\n![image-20231024104055949](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024104055949.png)\n\n\n\n### 零地址指令\n\n操作符就是一个零地址指令\n\n![image-20231024104316071](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024104316071.png)\n\n### 一地址指令\n\n![image-20231024104552021](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024104552021.png)\n\n### 二、三地址指令\n\n![ ](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024104730193.png)\n\n### 四地址指令\n\n![image-20231024104844533](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024104844533.png)\n\n![image-20231024105004386](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024105004386.png)\n\n### 指令-按指令长度分类\n\n* **指令字长**：一条指令的总长度（可能会变）\n* **机器字长**：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）\n* **存储字长**：一个存储单元中的二进制代码位数（通常和MDR位数相同）\n\n### 指令-按操作码长度分类\n\n* 定长操作码：指令系统中所有指令的操作码长度都相同\n  n位→2n条指令\n  控制器的译码电路设计简单，但灵活性较低\n* 可变长操作码：指令系统中各指令的操作码长度可变\n  控制器的译码电路设计复杂，但灵活性较高\n\n定长指令字结构+可变长操作码->扩展操作码指令格式\n\n### 指令-按操作类型分类\n\n* 数据传送类：CPU、主存之间的数据传输\n* 运算类：算数逻辑操作、移位操作\n* 程序控制类：改变程序执行流\n* 输入输出类：CPU、IO设备之间的数据传送\n\n## 扩展操作码\n\n为什么要扩展？因为除了表示四地址指令(16为)，可能还需要表示一、二、三地址指令，但是又因为固定是16位，所以短的地址指令相比大的要退一格，把上一格用全1来填充，因此上一个码只有15种(去掉全1)。\n\ncpu一次读入16位，根据是否全1判断是三地址指令还是二地址指令\n\n![image-20231024161232495](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024161232495.png)\n\n·在设计扩展操作码指令格式时，必须注意以下两点：\n\n1)不允许短码是长码的前缀，即短操作码不能与长操作码的前\n面部分的代码相同。\n\n2)各指令的操作码一定不能重复。\n通常情况下，对使用频率较高的指令，分配较短的操作码对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。\n\n![image-20231024164856526](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024164856526.png)\n\n## 指令寻址\n\n下一条 欲执行 指令 的 地址\n\n### 顺序寻址\n\n**定长指令字结构**\n\n \n\n### 跳跃寻址\n\n![image-20231024170857837](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231024170857837.png)\n\n执行指令：JMP，CALL会直接修改PC的值，JMP类似goto，CALL调用函数\n\n## 数据寻址\n\n确定**本条指令**的**地址码指明的真实地址**\n\n* 隐含寻址\n* 立即寻址\n* 直接寻址\n* 间接寻址\n* 寄存器寻址\n* 寄存器简介寻址\n* 相对寻址\n* 基址寻址\n* 变址寻址\n* 堆栈寻址\n\n### 偏移寻址\n\n#### 基址寻址\n\n{% note warning no-icon %}\n以程序的原始存放地址作为”起点“ \n{% endnote %}\n\n将CPU中基址寄存器的内容加上指令格式中的形式地址A，形成操作数的有效地址。EA=(BR)+A\n\n> OS课的”重定位寄存器“就是”基址寄存器“\n\n![image-20231031104220297](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231031104220297.png)\n\n有的寄存器不设置基址寄存器，指令编号指明哪个明通用寄存器作为基址，放入 ALU 再把偏移量放进去来寻址\n\n因此，指令编号 n 位可以指明通用寄存器 2<sup>n </sup>个，例如通用寄存器有 8 个，那就要 3 bit 编号\n\n{% note warning no-icon %}\n便于程序\"浮动\"，方便实现多道程序并发运行，扩大寻址范围\n{% endnote %}\n\n> 注：基址寄存器是面向操作系统的，其内容由**操作系统或管理程序确定**(程序员不能决定)。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。\n\n#### 变址寻址\n\nEA=(IX)+A，IX=index register\n\n{% note warning no-icon %}\n程序员自己决定从哪里作为”起点“\n{% endnote %}\n\n有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和\n\n\n\n和基址寻址很像，但有差别\n\n> 变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可**由用户改变**(IX作为偏移量)，形式地址A不变(作为基地址)\n>\n> 基址寻址中，BR保持不变作为基地址，A作为偏移量\n\n![image-20231107084734358](计算机组成原理.assets/image-20231107084734358.png)\n\n**复合寻址：**\n\n![image-20231107085123917](计算机组成原理.assets/image-20231107085123917.png)\n\n#### 相对寻址\n\nEA=(PC)+A\n\n{% note warning no-icon %}\n以程序计数器PC所指地址作为”起点“\n{% endnote %}\n\n**相对寻址**：EA=(PC)+A,其中A是相对于PC所指地址的位移量，可正可负，补码表示\n**优点**：\n\n* 操作数的地址不是固定的，它随着PC值的变化而变，并且与指令地址之间总是相差一个固定值，因此便于程序浮动(一段代码在程序内部的浮动)\n* 这段代码在程序内**浮动**(for循环在代码中的位置发生移动)时不用更改跳转指令的地址码\n\n\n相对寻址广泛应用于**转移指令**\n\n\n\n| 寻址方式           | 有效地址           | 访存次数（指令执行期间） |\n| ------------------ | ------------------ | ------------------------ |\n| 隐含寻址           | 程序指定           | 0                        |\n| 立即寻址           | A即是操作数        | 0                        |\n| 直接寻址           | EA=A               | 1                        |\n| 一次间接寻址       | EA=(A)             | 2                        |\n| 寄存器寻址         | EA=R<sub>1</sub>   | 0                        |\n| 寄存器间接一次寻址 | EA=(R<sub>1</sub>) | 1                        |\n| 转移指令 相对寻址  | EA=(PC)+A          | 1                        |\n| 多道程序 基址寻址  | EA=(BR)+A          | 1                        |\n| 循环程序变址寻址   | EA=(IX)+A          | 1                        |\n\n后面三种即偏移寻址\n\n> 注意：取出当前指令后，PC会指向下一条指令，相对寻址是相对于下一条指令的偏移\n\n\n\n# CPU\n\n\n\n## CPU的功能和基本结构\n\n### CPU的功能\n\nCPU：运算器+控制器\n\n* 指令控制：完成指令、分析指令和执行指令的操作，即程序的顺序控制\n* 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。\n* 时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号\n* 数据加工。对数据进行算术和逻辑运算\n* 中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。\n  \n* 运算器：对数据进行加工\n* 控制器：取指令，分析指令，执行指令——控制各个部件\n  * 取指令：自动形成指令地址，发出取指令命令\n  * 操作数译码产生操作数的有效地址\n  * 执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及I/O设备完成相应的操作\n  * 中断处理\n\n### 运算器的基本结构\n\n算术逻辑单元：主要功能是进行算术/逻辑运算\n\n通用寄存器组：如**AX、BX、CX、DX、SP**等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是**堆栈指针**，用于指示栈顶的地址。\n\n暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。(内部总线用到)\n\n程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OP)、符号标志(SF)、零标志(ZF)、进位标志\n(CF)等PSW中的这些位参与并决定微操作的形成。\n\n移位器对运算结果进行移位运算。\n\n计数器：控制乘除运算的操作步数。\n\n![image-20231107100039150](计算机组成原理.assets/image-20231107100039150.png)\n\n![image-20231107100309247](计算机组成原理.assets/image-20231107100309247.png)\n\n\n\n#### 专用数据通路\n\n> 专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路。\n\n如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据\n**解决方法**1.使用多路选择器根据控制信号选择一路输出\n\n![image-20231107100424547](计算机组成原理.assets/image-20231107100424547.png)\n\n解决方法2.使用三态门可以控制每一路是否输出.如：R0out为1时R0中的数据输出到A端，ROout;为O时R,中的数据无法输出到B端\n\n![image-20231107100533676](计算机组成原理.assets/image-20231107100533676.png)\n\n> 性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。\n\n#### CPU内部单总线\n\nCPU内部单总线方式：将所有寄存器的输入端和输出端都连接到一条公共的通路上。\n\n![image-20231107103753426](计算机组成原理.assets/image-20231107103753426.png)\n\n由ALU和一系列寄存器组成\n\n如：两个操作数分别来自主存和R。,最后结果存回R0,那么从主存中取来的操作数直接放入暂存器，就不会破坏运算前R,的内容。\n\n>  结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。\n\n### 控制器的基本结构\n\n取指令，分析指令，执行指令\n\n![image-20231227000511014](计算机组成原理.assets/image-20231227000511014.png)\n\n由PC得到下一条指令的地址，接着指令寄存器OP操作数输入到指令译码器进行译码提供操作信号，而地址信号输出到CPU内部总线存放到地址寄存器MAR。数据总线获取到的主存数据会存放在数据寄存器MDR \n\n**一系列寄存器+控制单元组成**\n\n\n\n两个结合\n\n![image-20231107105047616](计算机组成原理.assets/image-20231107105047616.png)\n\n### CPU内部透明\n\n用户课件:程序员通过汇编语言进行改变\n\n红色是可见的，灰色不可见辅助CPU工作\n\n![image-20231107105253535](计算机组成原理.assets/image-20231107105253535.png)\n\nPC：用条件转移指令来改变\n\nPSW：条件转移指令本身就要读取PSW的数据，也可以通过比较指令影响PSW\n\nACC：用户执行加法乘法\n\n通用寄存器：汇编读和写\n\nCU控制单元\n\n### 总结\n\n简化来说CPU就是由ALU+寄存器+CU控制单元+中断系统组成\n\n![image-20231227001225813](计算机组成原理.assets/image-20231227001225813.png)\n\n\n\n![image-20231107105314400](计算机组成原理.assets/image-20231107105314400.png)\n\n**n个总线说明支持n组部件的数据交换**\n\n![image-20231107105416712](计算机组成原理.assets/image-20231107105416712.png)\n\n## 指令周期\n\n时钟周期 = 节拍脉冲 = 震荡周期       能完成一次微操作\n\n机器周期 = CPU周期   从主存读出一条指令的**最短时间**    可完成    复杂操作 完成一个小工作\n\n指令周期：**从主存取一条指令并执行指令的全部时间**\n\n指令周期——若干个机器周期(CPU时间)组成——一个时钟周期又包含若干个时钟周期\n\n\n\n```mermaid\ngraph TD\nB(指令周期)-->A(机器周期)\nB-->C(机器周期)\nA-->D(时钟周期)\nA-->E(时钟周期)\n```\n\n注意事项：\n\n* 每个指令周期内机器周期数可以不等\n* 每个机器周期内的节拍数也可以不等\n\n![image-20231121094141477](计算机组成原理.assets/image-20231121094141477.png)\n\n上图中不同指令的执行周期不可以不等长，乘法需要执行多个加法自然会长。\n\n从上到下各需要1、2、2、3、4个机器周期\n\n![image-20231121094320066](计算机组成原理.assets/image-20231121094320066.png)\n\n最后进入下一个指令的执行阶段\n\nCPU如何知道执行到哪个阶段？——触发器(设置四个触发器判断处于哪个周期)\n\n### 数据流\n\n#### 取指周期\n\n结合下面的图：PC指明了接下来要执行的指令在主存的存放地址，因此要把地址信息送到MAR(PC)->MAR，然后CU向控制总线发出读信号1->R，MAR的地址信息通过**地址总线**送给主存，读出数据后内容通过**数据总线**送入MDR(M(MAR)->MDR)，将MDR的内容(指令)送入IR(MDR)->IR，CU发出控制信号形成下一条指令地址((PC)+1->PC)\n\nMAR存储器地址寄存器\n\nMDR存储器数据寄存器\n\nPC程序计数器\n\nIR指令寄存器\n\nM(MAR)→R表示将MAR所指主存中的内容经总线送到MDR。M是memory\n\n1→R主存读信号\n\n1→W主存去操作\n\n![image-20231121095949026](计算机组成原理.assets/image-20231121095949026.png)\n\n#### 间址周期\n\n> 之前已经经过了取值周期(回顾上面的内容)，由于IR的内容是从MDR复制的，因此IR和MDR此时都是指令\n\n再走一遍，取一个有效地址\n\n1.将指令的地址码送入MAR,\n记做：AdIR)→MAR，Ad(MDR)→MAR\n2.CU发出控制信号，启动主存做**读**操作\n记做：1→R\n3.将MAR所指主存中的内容经数据总线\n送入MDR,记做：M(MAR)→MDR\n4.将**有效地**址送至指令的地址码字段，\n记做：(MDR)→Ad(IR)\n\n![image-20231121095755152](计算机组成原理.assets/image-20231121095755152.png)\n\n#### 执行周期\n\n 执行周期的任务是根据R中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。\n\n#### 中断周期\n\n数据要写到主存一定要先放入MDR\n\n先保存现场---去执行中断处理程序--恢复现场\n\n所以要先将断点的存入到MDR放入主存保存，然后执行完再去找原来的\n\nSP要-1是因为有进的进入栈，要-1指回断点位置\n\n保存现场\n\n\n\n1.CU控制将SP减1，修改后的地址送入MAR(有些SP是放在CU中)\n记做：(SP)-1→SP,(SP)→MAR\n本质上是将断点存入某个存储单元，假设其地址为a,故可记做：a→MAR\n2.CU发出控制信号，启动主存做**写**操作，\n记做：1→W\n3.将断点(PC内容)送入MDR,\n记做：(PC)→MDR\n\n执行中断程序\n\n4.CU控制将中断服务程序的入口地址\n(由向量地址形成部件产生)送入PC,\n记做：向量地址→PC\n\n![image-20231228121002349](计算机组成原理.assets/image-20231228121002349.png)\n\n### 指令执行方案\n\n#### 单指令周期\n\n对所有指令都选用**相同的执行时间**来完成(最长的那一个)\n\n* 指令之间**串行执行**：\n* 指令周期取决于**执行时间最长的指令**的执行时间。\n* 对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，**会降低整个系统的 运行速度。**\n\n> 只需要根据节拍数来确定指令是否结束就好，设计更方便\n\n![image-20240104193755331](计算机组成原理.assets/image-20240104193755331.png)\n\n#### 多指令周期\n\n对不同类型的指令选用**不同的执行步骤来完成**\n\n* 指令之间串行执行；\n* 可选用**不同个数的时钟周期**来完成不同指令的执行过程。\n  缺点：需要更复杂的硬件设计。\n\n#### 流水线方案\n\n在每一个时钟周期启动一条指令，尽量让多条指令**同时运行**，但各自处在不同的执行步骤中。\n\n* 指令之间**并行执行**。\n\n> 某个部件执行完不用后，下一个指令直接使用该部件。如计算和I/0,A计算完进入I/O，B直接进行计算，并行执行\n\n\n\n![image-20231121103949441](计算机组成原理.assets/image-20231121103949441.png)\n\n### 指令周期同步\n\n* 不同指令功能不同，复杂度不同，如何进行时间控制？\n  * **定长指令周期：    早期三级时序系统**\n    * 机器周期数固定，节拍数固定，按机器周期同步，mips单周期\n  * **变长指令周期：    现代时序系统**\n    * 机器周期数可变，节拍数可变，按时钟周期同步，mips多周期\n    * 定长指令周期只是一种特例\n\n## 数据通路及指令操作流程\n\n### 数据通路\n\n**数据通路——执行部件间传送信息的路径   (数据流)**\n\n* 通路的建立由**控制信号**控制，受**时钟驱动   （控制流）**\n* **不同指令、同一指令在执行的不同阶段的数据通路不同**\n* 分类：**共享通路**（总线）、**专用通路**\n  * 指令执行流程、执行效率\n  * 微操作控制信号的时序安排\n\n**数据流动一般三种情况**\n\n* 寄存器与寄存器\n* 寄存器与主存\n* 寄存器与ALU\n\n### CPU内部单总线结构\n\n优点：设计成本更低\n\n一个微操作要用一个时钟周期，CU发出控制指令完成微操作\n\n1. 寄存器之间的数据传送\n\n   (PC)->Bus PCout有效，PC内容送总线\n\n   Bus->MAR MARin有效，总线内容送MAR\n\n   重要的是描述清楚数据流向\n\n2. 主存与CPU之间的数据传送\n\n   比如CPU从主存读取指令：\n\n   (PC)->Bus->MAR PCout和MARin有效，现行指令地址->MAR\n\n   **1->R**                      CU发读命令(通过控制总线发出) **不要漏**\n\n   MEM(MAR)->MDR MDRinE有效\n\n   MDR->Bus->IO     MDRout和IRin有效，现行指令->IR\n\n   关键：指明操作的主存地址放到MAR中，同时要通过CU给主存读/写信号\n\n3. **执行算术或逻辑运算**\n\n   参与加法指令的一个操作数已经存放在ACC里乐，另一个由加法指令指明存在在主存的哪个位置\n\n   比如一条加法指令\n\n   Ad(IR)->Bus->MAR MDRout和MARin有效(和间址周期一样，取指先从**MDR赋值到IR的，所以可以直接从MDR取**，送到MAR)或AdIRout和MARin有效\n\n   1->R                          CU发读命令\n\n   MEM(MAR)->数据线->MDR MDRin有效\n\n   MDR->BUS->Y 加数 **ALU的两个输入信号必须同时有效，而内部总线同一时刻只能传输一个信号，要先存在暂存寄存器Y，与ALU有专用数据通路不用占用内部总线，实现了同时有效 **\n\n   (ACC)+(Y)->Z  ACC放到被加数、Y为被加数进行运算\n\n   Z->ACC 加法结果存回ACC累加寄存器\n\n> 单总线，需要把一个操作数放到暂存寄存器中\n>\n> 每一个时钟周期，CU发出控制信号实现一个微操作 \n\n![image-20231202113136852](计算机组成原理.assets/image-20231202113136852.png)\n\n#### MIPS CPU典型指令\n\n| **#** | **指令**       | **指令功能** **(RTL描述)**                |\n| ----- | -------------- | ----------------------------------------- |\n| **1** | lw rt,imm(rs)  | **R[rt] ← M[R[rs] +SignExt(imm)]**        |\n| **2** | sw rt,imm(rs)  | **M[R[rs]  + SignExt(imm)]← R[rt]**       |\n| **3** | beq rs,rt,imm  | if(R[rs]==R[rt]) PC←PC+4+SignExt(imm)<< 2 |\n| **4** | addi rt,rs,imm | R[rt] ← R[rs] + SignExt(imm)              |\n| **5** | add rd,rs,rt   | R[rd] ← R[rs] + R[rt]                     |\n\n![image-20231212102821524](计算机组成原理.assets/image-20231212102821524.png)\n\n![image-20231114094517550](计算机组成原理.assets/image-20231114094517550.png)\n\n写入，表示一个节拍。四个节拍。  红色圆圈表示一个脉冲\n\n![image-20231114100713948](计算机组成原理.assets/image-20231114100713948.png)\n\n\n\n\n\n\n\n### 习题\n\nADD(R0)，打了括号表示目的操作数，即存放的是R0在主存中的地址，需要进行一次间接寻址，而R1没打括号就是R1放的就是R1操作数\n\n功能：指令打括号表示取出内容。((R0)+(R1)->(R0)，意思就是首先(R0)在主存中取到R0的地址所指的内容放回R0，然后取出R0和R1的内容相加，结果放回R0\n\n按取指周期、间址周期、执行周期来分析 \n\n![image-20231202115449260](计算机组成原理.assets/image-20231202115449260.png)\n\n> 每取出一个值，PC都要加一，题目没有给出控制信号不写\n\n![image-20231228154031811](计算机组成原理.assets/image-20231228154031811.png)\n\n间址周期和之前的有不同，这里直接放到MDR中了  \n\n![image-20231202115740980](计算机组成原理.assets/image-20231202115740980.png)\n\n上一步间址周期后，一个操作数已经放在Y了，加完的结果放回Z\n\n结果写回主存所以要放到MDR\n\nMemW写控制信号 \n\n这里注意M(MAR)什么意思，上一步中MAR的内容为(R0)也就是最终想要写回的主存地址，没有变，所以这里直接M(MAR)\n\n ![image-20231205085400269](计算机组成原理.assets/image-20231205085400269.png)\n\n![image-20231205085425019](计算机组成原理.assets/image-20231205085425019.png)\n\n![image-20231205085447411](计算机组成原理.assets/image-20231205085447411.png)\n\n![image-20231205085610873](计算机组成原理.assets/image-20231205085610873.png)\n\n![image-20231205085725782](计算机组成原理.assets/image-20231205085725782.png)\n\n### 控制器的设计\n\n* 一个节拍内可以并行完成多个“相容的”微操作\n* 同一个操作可能在不同指令的不同阶段被使用\n* 根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍下应该发出哪些“微命令”\n\n![image-20231205090919375](计算机组成原理.assets/image-20231205090919375.png)\n\n#### 硬布线控制器\n\n![image-20231205092947245](计算机组成原理.assets/image-20231205092947245.png)\n\n设计步骤：\n\n1. 分析每个阶段的微操作序列(取值、间址、执行、中断 四个阶段) 确定哪些指令在什么阶段，在什么条件下会用到的微操作\n2. 选择CPU的控制方式 定长机器周期还是不定长，定长每个机器周期安排几个节拍 选定3个\n3. 安排微操作时序 如何用3个节拍完成整个机器周期内的所有微操作？\n4. 电路设计 确定每个微操作命令的逻辑表达式，并用电路实现\n\n![image-20231205094658285](计算机组成原理.assets/image-20231205094658285.png)\n\n安排微操作时许的原则\n\n一：微操作的 **先后顺序不得** 随意 **更改**\n\n二：**被控对象不同** 的微操作 尽量安排在 **一个节拍** 内完成\n\n三：占用 **时间较短** 的微操作 尽量安排在 **一个节拍** 内完成 **并允许有先后顺序**\n\n组合逻辑设计：\n\n1. 列出操作时间表\n2. 写出微操作命令的最简表达式\n3. 画出逻辑图\n\n\n\n![image-20231205100221132](计算机组成原理.assets/image-20231205100221132.png)\n\n>  非访存指令不需进入间址阶段，直接进入执行阶段\n\n1->EX 进入执行周期\n\n\n\n![image-20231205100400359](计算机组成原理.assets/image-20231205100400359.png)\n\n![image-20231205102430188](计算机组成原理.assets/image-20231205102430188.png)\n\n硬布线控制器的设计步骤\n\n1. 分析每个阶段的微操作序列\n2. 选择CPU的控制方式\n3. 安排微操作时序\n4. 电路设计\n   1. 列出操作时间表\n   2. 写出微操作命令的最简表达式\n   3. 画出逻辑图\n\n\n\n#### 微程序控制器\n\n微程序设计概念:将一条机器指令编写成一个微程序，每个微程序包含若干个微指令，每个微指令又对应一个或几个微操作命令\n\n然后把这些微程序存到控制存储器中，用寻找用户程序的方法来寻找每个微程序中的微指令。\n\n所以逐条执行每一条微指令，也就相应地完成了一条机器指令地全部操作。\n\n链接：https://www.nowcoder.com/questionTerminal/307284997f254e14b235544811e36c25\n来源：牛客网\n\n\n\n先简单介绍下基本知识： \n\n   1） 微操作类型  \n\n​       相容性微操作：同时或同一个CPU周期内可以并行执行的微操作。    \n\n​       相斥性微操作：不能同时或在同一个CPU周期内并行执行的微操作 。  \n\n   2） 微命令编码  \n\n​        直接控制法：微指令控制字段的一种编码方法，每个微命令占一位。  \n\n​        直接编码法：相斥的n个微命令可以采用编码法表示，占log2（n+1）位。  \n\n​        混合编码法：相斥微命令采用直接编码法，相容微命令采用直接控制法。  \n\n   3） 7个互斥的微命令采用直接编码法至少需要log27+1位，即3位。  \n\n​       3个互斥的微命令采用直接编码法至少需要log23+1位，即2位。  \n\n​      12个互斥的微命令采用直接编码法至少需要log212+1位，即4位。  \n\n​       5个互斥的微命令采用直接编码法至少需要log25+1位，即3位。  \n\n​       6个互斥的微命令采用直接编码法至少需要log26+1位，即3位。  \n\n​    至少需要3+2+4+3+3=15位。答案为C\n\n#### 对比\n\n![image-20240102203753069](计算机组成原理.assets/image-20240102203753069.png)\n\n# 指令流水线 \n\n## 指令流水的定义\n\n指令执行过程划分为不同阶段，占用不同的资源，就能使多条指令同时执行\n\n表示方法：指令流程图、时空图\n\n![image-20231202154730864](计算机组成原理.assets/image-20231202154730864.png)\n\n> 每个流水阶段的执行时间一样，都等于一个时钟周期\n\n## 流水线性能指标\n\n* 吞吐率，单位时间内流水线所完成的任务数量，或是输出结果的数量\n* 加速比\n* 效率\n* \n\n## 影响因素和分类\n\n### 机器周期的设置\n\n五段式指令流水线 MIPS架构\n\n* IF Fetch 取值\n* ID Decode 指令译码\n* EX EXecute 执行\n* M Memory 存储器访问\n* WB Writerback 写回周期\n\n> 五个阶段耗时不完全一样但是为了方便流水线设计，取成一样的，以最长耗时为准\n\n**IF**\n\n默认从Cache命中取值，放到锁存器中\n\n**ID——读**\n\n大部分都是从Cache命中数据，分为两个模块，分别存指令和数据\n\nInstruction Cache,Data Cache\n\nRISC精简指令下，ID阶段取数直接来自寄存器而不是主存了(在主存也得先取到寄存器)\n\nID的锁存器有一个Imm表示立即数。有的指令食用立即寻址，直接从指令取出所需的立即数放到Imm\n\n**EX**\n\nALU运算结果直接写到M的锁存器，接着有可能需要写回前面的某个寄存器中\n\n**WB——写**\n\n![image-20240103010612938](计算机组成原理.assets/image-20240103010612938.png)\n\nID和WB涉及到对寄存器的读和写，会造成一些问题\n\n### 三种因素\n\n* 结构相关(资源冲突) 互斥\n  * 后一相关指令暂停一周期\n  * 资源重新配置：数据存储器+指令存储器。规定取值和访存在不同的cache体就好了\n\n![image-20240103091537521](计算机组成原理.assets/image-20240103091537521.png)\n\n* 数据相关(数据冲突) 同步 前一条执行后一条才能执行\n  * 等待，硬件阻塞(stall)和软件插入\"NOP\"两种方法(发现前后数据冲突则在之间插几条空指令)\n  * 数据旁路技术，结果直接输入到后面，不共用同一个了\n  * 编译优化，通过编译器调整指令顺序来解决数据相关\n\n在读出r1之前，需要保证之前已经把r1写回了！读出是在ID，写回是在WB\n\n![image-20240103092055373](计算机组成原理.assets/image-20240103092055373.png)\n\n硬件阻塞等待(气泡)，将ID延迟到W之后；软件空指令也是完整的指令，插入到前面\n\n![气泡](计算机组成原理.assets/image-20240103092346111.png)\n\n![空指令](计算机组成原理.assets/image-20240103092416734.png)\n\n数据旁路：写回太久了，不等寄存器取了，直接在上一条的ALU中取，送回ALU的输入端，作为下一条指令ALU的输入\n\n![image-20240103092700568](计算机组成原理.assets/image-20240103092700568.png)\n\n编译优化：把后面不冲突的先移上来执行，冲突的后移\n\n* 控制相关(控制冲突) 流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关\n  * 转移指令分支预测：简单预测、动态预测\n  * 预取转移成功和不成功两个控制流方向的目标指令\n  * 加快和提前形成条件码\n  * 提高转移方向的猜准率\n\n转移指令条件不满足，顺序执行，当满足时，发生跳转，PC的指发生跨越(本来是加1一指令长度，如指令长度为4B，每次加4B，有可能一下跳转到100B)。那么跨越中间的指令是不应该执行的\n\n\n\n### 分类 *了解\n\n1 部件功能级、处理机级和处理机间流水线\n\n2 单功能流水线和多功能流水线\n\n3 动态流水线和静态流水线\n\n4 线性流水线和非线性流水线\n\n## 流水线的多发技术\n\n1. 超标量技术 在一个时钟周期内可以并发多条独立指令，要配置多个功能配件\n\n   ![image-20231202164955938](计算机组成原理.assets/image-20231202164955938.png)\n\n   不能调整 指令的执行顺序\n\n   通过编译优化技术，把可并发执行的指令搭配起来\n\n   空分复用\n\n2. 超流水技术 在**一个时钟周期** 内 **再分段**\n\n   一个时钟周期内 **一个功能部件使用多次**\n\n   \n\n   ![image-20231202165235054](计算机组成原理.assets/image-20231202165235054.png)\n\n   不能调整 指令的执行顺序\n\n   靠编译程序解决优化问题\n\n3. 超长指令字\n\n   由编译程序挖掘出指令间潜在的并行性\n\n   将**多条**能**并发操作**的指令组合成一条\n\n   具有多个操作码字段的超长指令字(可达几百位)\n\n   采用多个处理部件\n\n   ![image-20231202165510524](计算机组成原理.assets/image-20231202165510524.png)\n\n   \n\n## 五段指令\n\n![image-20231212091136347](计算机组成原理.assets/image-20231212091136347.png)\n\n![image-20231212091237504](计算机组成原理.assets/image-20231212091237504.png)\n\n# 存储系统\n\n## 主存储器的基本组成\n\n\n\n\n\n## DRAM与SRAM\n\n双稳态触发器vs栅极电容\n\n![image-20231219094655865](计算机组成原理.assets/image-20231219094655865.png)\n\n刷新是指电容的电荷维持时间有限，不充电信息会消失，要定时刷新(充电)\n\n存储矩阵，用行地址和列地址选中一个存储单元(减少选通线的数量，电路更简单)\n\n![image-20231219095241115](计算机组成原理.assets/image-20231219095241115.png)\n\nDRAM分两次送是因为它本身容量大，将行地址和列地址送，可以再减少选通线的数量到n/2(实现从2<sup>n</sup>->n->n/2  )\n\n## ROM\n\nRAM断电丢失，主存，ROM辅存\n\n![image-20231219103244870](计算机组成原理.assets/image-20231219103244870.png)\n\n## 提升主存速度\n\n### 存取周期\n\n可以连续读/写的最短周期\n\n![image-20231219104453473](计算机组成原理.assets/image-20231219104453473.png)\n\n### 双口RAM\n\n多核CPU如何访存？\n\n![image-20231219104402105](计算机组成原理.assets/image-20231219104402105.png)\n\n### 多体并行存储器\n\n体号+体内地址\n\n低位高位不同，高位竖着编、地位横着编 \n\n![image-20231220151935231](计算机组成原理.assets/image-20231220151935231.png)\n\n### 多模块存取器\n\n![image-20231220152103620](计算机组成原理.assets/image-20231220152103620.png)\n\n![image-20231220152124844](计算机组成原理.assets/image-20231220152124844.png)\n\n多体并行存储器灵活性更高\n\n## 主存和CPU连接\n\n![image-20231226100226657](计算机组成原理.assets/image-20231226100226657.png)\n\n> 现代的MARMDR集成在CPU中\n\n![image-20231226100309438](计算机组成原理.assets/image-20231226100309438.png)\n\nA表示地址，D表示数据\n\n片选信号CS或CE，有横线说明低电平有效\n\n读写控制线WE或WR，有横线说明低电平表示写\n\n![image-20231226100546520](计算机组成原理.assets/image-20231226100546520.png)\n\n### 位扩展\n\n8Kx1位 \n\n* 8K为2^13有13根地址线，A13根\n* 1位说明一次数据总线只能传输一位数据\n\n如果只装这一个芯片，那么主存的存储字长只有1bit，数据总线8位并没有被充分利用\n\n加多一块，一样的，则存储字长拓展为两位，即可以同时读同时写两位数信息![image-20231226101206072](计算机组成原理.assets/image-20231226101206072.png)\n\n接着继续扩展6个芯片\n\n![image-20231226101331477](计算机组成原理.assets/image-20231226101331477.png)\n\n### 字扩展\n\n两种方法\n\n* **线选法**，两根线来控制CS，但是只能一个1一个0，不能同时位1或0\n\n* **译码器片选法**，一根线控制，连两个，但是连第一个的中途加一个非门，这样当为1另外一个就是0，这就是1-2译码器，1条线有2个片选信号。\n\n  * n条线可以对应2^n个片选信号(组合)\n\n    ![image-20231226102330788](计算机组成原理.assets/image-20231226102330788.png) \n\n![image-20231226103531117](计算机组成原理.assets/image-20231226103531117.png)\n\n那么如果增加A15进来，则为3-8译码器，能够拓展多4块芯片\n\n| 线选法            | 译码片选法                    |\n| ----------------- | ----------------------------- |\n| n条线→n个选片信号 | n条线→2<sup>n</sup>个选片信号 |\n| 电路简单          | 电路复杂                      |\n| 地址空间不连续    | 地址空间可连续                |\n\n\n\n\n\n\n\n\n\n## 高速缓存\n\n### 映射方式\n\ncache和主存块大小相等,本身放的是数据\n\ncache的标记位其实就是主存的块号(编号)\n\ncache和主存块数不相同\n\n![image-20231220213655854](计算机组成原理.assets/image-20231220213655854.png)\n\n![image-20231220214829155](计算机组成原理.assets/image-20231220214829155.png)\n\n![image-20231220214840792](计算机组成原理.assets/image-20231220214840792.png)\n\n\n\n![image-20231222103757308](计算机组成原理.assets/image-20231222103757308.png)\n\n#### 全相联\n\n![image-20231220224011669](计算机组成原理.assets/image-20231220224011669.png)\n\n![在这里插入图片描述](计算机组成原理.assets/15deb6eec8714768befb2bb87c700aa9.png)\n\n#### 直接相联\n\n![image-20231220223943017](计算机组成原理.assets/image-20231220223943017-17032165379622.png)\n\n![img](计算机组成原理.assets/a40c6cc26c1d4f69b76be36530fc2c9b.png)\n\n\n\n\n\n#### 组相联\n\n![image-20231220223915163](计算机组成原理.assets/image-20231220223915163.png)\n\n![img](计算机组成原理.assets/dffd330478524242a6d766ee6aa504ee.png)\n\n#### 总结\n\n![image-20231220224035725](计算机组成原理.assets/image-20231220224035725.png)\n\n## 写策略\n\n可以命中的情况：\n\n* 写回\n* 直(全)写，在cache和主存之间加写缓冲\n\n![image-20231222105143890](计算机组成原理.assets/image-20231222105143890.png)\n\n使用写缓冲，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞\n\n![image-20231222105416448](计算机组成原理.assets/image-20231222105416448.png)\n\n写不命中(写的地址不cache)：\n\n* 写分配法：先从主存调入cache再写，然后配合写回法使用\n* 非写分配：不调入cache，cpu直接写主存\n\n> 现代计算机常采用多级Cache\n\n\n\n"},{"title":"数字图像处理笔记","url":"/2023/09/18/数字图像处理笔记/","content":"\n13\n\n## 基于直方图的图像增强方式\n\n当一幅图像的像素占据了所有可能的灰度级并且呈均匀分布-->具有较高对比度&多变的灰度色调\n\n由上，图像增强的一种方法——**把不均匀的图像变均匀**\n\n1. 知道灰度概率密度函数\n2. 求积分，乘一个系数\n3. 得到的结果\n\n* 离散变换函数\n* 直方图均衡化\n\n# 频率域图像处理\n\n## 频率域图像处理的基本实现思路\n\n综上所述，频率域图像处理的步骤为：\n(1)用（一1）红+”乘以输入图像，进行中心变换。\n\n(2)对步骤(1)的计算结果图像（一1）<sup>(x+y)</sup>f(x,y)进行二维傅里叶变换，即求F(u,v)。\n\n(3)用**设计的转移函数H(u,v)**乘以F(u,),即按式(5.27)求G(u,v)。\n\n(4)求步骤(3)的计算结果的傅里叶反变换，即计算F-[G(u,)]。\n\n(5)取步骤(4)的计算结果的实部。\n\n(6)用（一1）<sup>(x+y)</sup>乘以步骤(5)的计算结果，就可得到通过频率域增强后的图像g(x,y)。\n\n以上过程可简要地描述为\n\n\n\n![image-20231016145528056](D:\\Blog\\source\\_posts\\数字图像处理笔记.assets\\image-20231016145528056.png)\n\n### 转移函数的设计\n\n> 频率域图像处理的关键是转移函数H(u,v)的设计\n\n关于转移函数的设计：\n\n* 比较笼统的说法是：频率域在很大程度上**凭直观**指定滤波器。\n* 比较具体的说法是：一般利用频率成分和图像外表之间的**对应关系**选择频率滤波器。\n* 更为一般的方法是利用**基于数学和统计准则**的近似设计二维数字滤波器、\n\n可以先通过滤波实验构造合适的频率滤波器，然后将其变换到空间域，在空间域进行实际的滤波运算。\n\n## 频率域低通滤波\n\n在频率域中，图像中的**噪声和边缘对应于傅里叶频谱的高频部分**，选择能让低频通过、高频衰减的转移函数达到滤除噪声的效果。\n\n### 理想低通滤波器\n\n最简单的思路就是设计一个分段函数，低频部分值为1，高频为0\n\n理想低通滤波器的含义为：\n\n* 在半径为D<sub>0</sub>的圆内的所有频率没有衰减地通过该滤波器；\n* 而在此半径的圆<u>之外的所有频率完全被衰减掉</u>。\n* 所以**D<sub>0</sub>称为截止频率。**\n\n截止频率如何设置？可以通过实验分析。\n\n![image-20231016150944266](D:\\Blog\\source\\_posts\\数字图像处理笔记.assets\\image-20231016150944266.png)\n\n### 巴特沃斯低通滤波器\n\n前面提到的0，1转移函数太简单粗暴了。\n\n图。巴特沃斯低通滤波器的转移函数H的透视图如图5.10(b)所示，该透视图的含义是：\n\n* 只有那些位于**该草帽形体内**的频率范围的信号才能通过，而位于草帽形体外的频率成分都将被滤除掉。\n* 由图可见，巴特沃斯低通滤波器在高低频率间的**过渡比较平滑**。\n\n![image-20231016151552763](D:\\Blog\\source\\_posts\\数字图像处理笔记.assets\\image-20231016151552763.png)\n\n### 高斯低通滤波器\n\n由于高斯函数的傅里叶变换和反变换均为**高斯函数**，并常常用来帮助寻找空间域与频率域之间的联系，所以基于高斯函数的滤波具有特殊的重要意义。\n\n![image-20231016151743835](D:\\Blog\\source\\_posts\\数字图像处理笔记.assets\\image-20231016151743835.png)\n\n与巴特沃斯低通滤波器相比，\n\n* 高斯低通滤波器**没有振铃现象**。\n* 另外在需要严格控制低频和高频之间截止频率的**过渡的情况**下，选择高斯低通滤波器更合适一些。\n\n>在频率域中，滤波器越窄，滤除掉的高频成分就越多，滤波后的图像就越模糊。\n>\n>这一特性正好对应于在空间域中，滤波器越宽（模板尺寸越大），平滑后的图像就越模糊的情况。\n\n## 频率域高通滤波\n\n高通滤波达到突出图像的**高频边缘成分**，实现**图像增强**效果\n\n* 理想高通滤波\n* 巴特沃斯高通滤波，在高低频率间的过渡比较平滑\n* 高斯高通滤波，随着截止频率D<sub>0</sub>值增大，增强效果更加明显，即时对于微小的物体和细线条，用高斯滤波器后也比较清晰\n\n类比低通这里不再过多赘述原理\n\n## 带阻滤波和带通滤波\n\n\n\n# 图像恢复\n\n## 图像的退化模型\n\n### 图像退化模型的表示\n\n![image-20231023142807969](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231023142807969.png)\n$$\ng(x,y)=H[f(x,y)]+n(x,y)\n$$\n图像退化的过程可以理解为作用于原图像f(x,y)的运算H，同时数字图像也常会因受一些随机误差也即噪声n(x,y)而退化。\n\n### 离散退化模型\n\n1.一位离散退化模型\n\n当利用卷积计算 g(x) 时，由 **A** 个样本表示的函数 f(x) 与由 **C** 个样本表示的另一个函数 h(x) 进行卷积将得到 **A+C一1** 个样本序列。\n\n2.二维离散退化模型\n\n用矩阵表示为：g=Hf+n\n\n> 卷积和泰勒级数、傅里叶奇数的内在逻辑是一脉相承的\n\n## 空间域图像的恢复\n\n### 无约束最小二乘方恢复\n\nn=g-Hf\n\n### 有约束最小二乘方恢复\n\n* 最小均方误差滤波(维纳滤波)恢复\n* 最大熵约束恢复\n\n恢复后的图像不具有唯一性，称为图像恢复的**病态性**\n\n由 n=g-Hf，不考虑噪声情况下要恢复图像需要对矩阵 H 求逆，即：\n\nf=H<sup>-1</sup>g\n\n在实际中，可能有逆矩阵 H<sup>-1 </sup>不存在的情况，但却存在有与 f 十分近似的解，称为图像恢复问题的奇异性。\n\n## 匀速直线运动模糊的恢复\n\n本节讨论其中最简单的**相机和目标的相对运动**可以看成是**匀速直线运动**而造成的**模糊图像的恢复问题**。\n\n如果用卷积的方法模拟出水平方向匀速运动产生的模糊图像，其过程可表示为：\n\n![image-20231030142917980](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231030142917980.png)\n\nh(x,y)为模糊算子或点扩散函数,*表示卷积，f(x,y)表示原始的清晰图像，g(x,y)表示观察到的退化图像\n\n### 图像噪声\n\n* 高斯噪声，也称正态噪声，左右对称，中间突出。**高斯噪声是一种源于电子电路噪声和由低照明度或高温带来的传感器噪声**。**高斯噪声是白噪声的一个特例**\n* 瑞利噪声\n* 均匀分布噪声\n* 脉冲噪声(椒盐噪声)\n* 其他\n\n> 为了在有噪声的情况下恢复图像，就需要了解噪声的统计性质\n\n### **被噪声污染图像的恢复** \n\n* **谐波均值滤波**\n* **逆谐波均值滤波**\n* **中点滤波**\n* **自适应中值滤波**\n\n## **几何失真的校正** \n\n# 小波图像处理\n\n小波是指小区域、长度有限、均值为0的振荡波形\n\n![image-20231030150826846](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231030150826846.png)\n\n* 小波变换是指基于小波的变换\n* 其基本思想是通过一个母函数在时间上的平移和在尺度上的伸缩得到一个函数族，然后**利用这族函数去表示或逼近信号或函数**，获得一种能自动适应各种频变成分的有效的信号分析手段。\n* 小波变换\n  * 弥补了傅里叶变换不能描述随时间变化的频率特性的不足，特别适合于那些在不同时间窗内具有不同频率特性\n  * 而且其应用目的是为了得到信号或图像的局部频谱信息而非整体信息的信号或图像处理问题。\n\n## 二维离散小波\n\n![image-20231106150322029](数字图像处理笔记.assets/image-20231106150322029.png)\n\n![image-20231106150359864](数字图像处理笔记.assets/image-20231106150359864.png)\n\n* *LL*(*x,y*) —原始图像的（粗）逼近子图\n* *HL*(*x,y*) —原始图像的水平方向细节子图\n* *LH*(*x,y*) —原始图像的垂直方向细节子图\n* *HH*(*x,y*) —原始图像的对角线方向细节子图\n\n![image-20231106150843981](数字图像处理笔记.assets/image-20231106150843981.png)\n\n![image-20231106150934667](数字图像处理笔记.assets/image-20231106150934667.png)\n\n关键：\n\n* 小波变换层数的选择\n* 小波基的选取\n\n**几种最基本的小波基**：\n\n* Haar小波\n  * 当0<=x<1，f=1；其它情况f=0\n* 墨西哥草帽（Mexico Hat）小波\n* Morlet 小波\n  * \n\n## 基于小波变换的图像去噪方法\n\n### 基本原理\n\n通过逼近，函数族最后让信号集中在少数小波系数上，其他无关的信号就会均匀分布在所有小波系数上。因此，可以通过选择合适的阈值，保留大于某个阈值的小波系数达到去除噪声保留有用信号的目的。\n\n### 阈值去噪算法步骤和思路\n\n（1）选择小波函数并确定分解层数N（一般取N=3）。\n\n（2）对图像信号进行小波分解，将图像信号分解为低频和高频信息。\n\n（3）对小波分解的高频系数进行阈值量化处理。\n\n（4）利用小波分解的第N层低频系数和经过阈值量化处理后的1～N层高频系数进行小波重构（小波反变换），即可得到去噪后的图像。\n\n\n\n# 图像分割\n\n图像分割的目的是将：\n\n* 图像划分成若干具有相近或相同特性的**子区域**\n* 以便继续在分割成的相关区域中**提取目标**\n* 并进而根据目标的特征或结构信息对其进行分类和识别，最后再给出对整幅图像分析结果的描述信息。\n"},{"title":"JJ的算法之旅","url":"/2023/09/17/JJ的算法之旅/","content":"\nkk=kk&(kk-1)，可以消除kk二进制的最后一个1\n\n\n\n\n```c++\n#include<bits/stdc++.h>\n```\n\n# 参考\n\nhttps://labuladong.gitee.io/algo/home/\n\n```python\n# 找到数组中的最大值及其索引 速度更快\n    max_num = max(nums)\n    max_idx = nums.index(max_num) \n```\n\n* Floyd\n* 背包问题 天平称0\n* 手写数据结构代码，链表、二叉树  P8744 [蓝桥杯 2021 省 A] 左孩子右兄弟\n* dfs,bfs\n* 前缀和、二分、差分\n* 刷动态规划\n* 时间复杂度控制在10^7\n\n![image-20240412104816902](JJ的算法之旅.assets/image-20240412104816902.png)\n\n# 基础知识\n\n## 模板\n\n### 输入输出\n\n```python\n# 输入样例\n# 3 2 1 6 0 5\nnums = list(map(int, input().split()))\n\n# 输入样例\n# 3\n# 1 2 4 \nLen = int(input())\nnums = list(map(int, input().split()))\n\n# 第一行输入两个整数，第一个代表数组的长度，第二个代表k，数字与数字之间用空格间开\n# 第二行输入一行数字代表数组arr。数字与数字之间用空格间开\n# 输入样例\n# 3 2\n# 3 2 1\nn, k = map(int, input().split())  # 注意这个输入是按行的，分割\nnums = list(map(int, input().split()))\n```\n\n### 构造\n\n**构建二维数组大坑！**\n\n```python\nnp.zeros((m, n)) √\ndp=[([0]*(n+1))]*(n+1) × 引用方式修改，每一列的第i都会跟着bian\n```\n\n### 字符串\n\n```python\n# 大小写转换\n## 函数法\nmsg='www.BAIDU.com.123'\nprint(msg.upper())  #upper()函数，将所有字母都转换成大写 WWW.BAIDU.COM.123\nprint(msg.lower())  #lower()函数，将所有字母都转换成小写 www.baidu.com.123\nprint(msg.capitalize())  #capitalize()函数，将首字母都转换成大写，其余小写 Www.baidu.com.123\nprint(msg.title())  #title()函数，将每个单词的首字母都转换成大写，其余小写 Www.Baidu.Com.123\n\n## Ascll码，用ord()转码，用chr转字符,注意python没有字符概念\n\nmsg = 'www.BAIDU.com.123'\nfor num in msg:\n    if 97 <= ord(num) <= 122: #小写字母\n        upper_num = ord(num)-32 #大小写字母之前差了32\n        #chr()函数可以将编码数值转为字符（python没有字符的概念）\n        print (chr(upper_num),end='')\n    else:\n        print(num,end='')  #不是小写字符，原样输出\n\n        \n# int转string\na=100\na_=str(a)\na*=int(a_)\n\n```\n\n### 二进制与位运算\n\n#### 基础运算\n\n- `//`：整数除法，返回商的整数部分，忽略余数。\n\n```python\nprint(10 // 3)    # 输出：3\n```\n\n- `%`：取模运算符，返回除法的余数。\n\n```python\nprint(10 % 3)    # 输出：1\n```\n\n- `**`：幂运算符，计算第一个操作数的第二个操作数次方。\n\n```python\nprint(2 ** 3)    # 输出：8\n```\n\n* **逻辑运算**\n\n逻辑运算符处理布尔值，包括：\n\n* `and`：逻辑与，只有两边的操作数都为True时结果才为True。\n* `or`：逻辑或，只要有一个操作数为True，结果就为True。\n* `not`：逻辑非，对一个布尔值进行否定。\n\n```python\nprint(True and False)    # 输出：False\nprint(True or False)    # 输出：True\nprint(not True)    # 输出：False\n```\n\n* **身份运算符**，比较两个对象是否为同一对象，而非仅看其值是否相等\n  - `is`：判断两个对象是否引用同一个内存地址，即它们是否是同一个实例。\n\n```python\na = [1, 2, 3]\nb = a\nprint(a is b)    # 输出：True，因为a和b指向同一列表对象\n\nc = [1, 2, 3]\nprint(a is c)    # 输出：False，尽管a和c的元素相同，但它们是不同的列表实例\n```\n\n- `is not`：与is相反，用于检查两个对象是否引用不同的内存地址。\n\n```python\na = \"hello\"\nb = \"hello\"\nprint(a is not b)    # 输出：False，Python对字符串采用intern机制，所以相同的字符串字面量会指向同一内存地址\n\nclass MyClass:\n    pass\n\nx = MyClass()\ny = MyClass()\nprint(x is not y)    # 输出：True，因为x和y是MyClass的不同实例\n```\n\n#### 位运算\n\n位运算符处理整数的二进制表示，包括：\n\n- `&`：按位与，对于两个对应位，如果都是1，则结果为1，否则为0。\n- `|`：按位或，只要有一个对应位为1，则结果为1，否则为0。\n- `^`：按位异或，当两个对应位不同时，结果为1，否则为0。\n- `~`：按位取反，对一个数的所有位进行翻转，即将1变为0，0变为1。\n- `<<`：左移运算符，将数字的所有二进制位向左移动指定的位数。\n- `>>`：右移运算符，将数字的所有二进制位向右移动指定的位数。\n\n例如：\n\n```python\nprint(5 & 3)    # 输出：1，二进制下 5（101）和 3（011）按位与的结果是 1（001）\nprint(5 | 3)    # 输出：7，二进制下 5（101）和 3（011）按位或的结果是 7（111）\n```\n\n### STL C++\n\n**stack**\n\n```c++\nstark<int> S;//初始化\nS.push(1);//入栈\nS.push(10);\nwhile(!S.empty()){//判空\n    cout<<S.top()<<endl;//栈顶元素\n    S.pop();//出栈\n}\n```\n\n**vector**\n\n```c++\nvector<int>demo{ 1,2,3,4,5 };\ndemo.pop_back();\ndemo.size();\ndemo.back();//最后一个元素\nauto iter = demo.erase(demo.begin() + 1);//删除元素 2\n//删除指定元素\nvector<int>demo{ 1,3,3,4,3,5 };\nauto iter = std::remove(demo.begin(), demo.end(), 3);//输出{1,4,5}\n```\n\n**string**\n\n```c++\n//构造\nstring str1;               //生成空字符串\nstring str2(\"123456789\");  //生成\"1234456789\"的复制品\nstring str3(\"12345\", 0, 3);//结果为\"123\" 从\"12345\"的第0开始复制3个\nstring str4(\"012345\", 5);  //结果为\"01234\" 以\"012345\"前5个作为粗值\nstring str5(5, '1');       //结果为\"11111\" 生成n个字符'1'\nstring str6(str2, 2);      //结果为\"3456789\" 将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值\n//读取\nstring s;\ncin>>s;\nchar s[100];\nscanf(\"%s\",s);//scanf读char数组\ngets(s);//整行读\n//插入\nstring s=\"Hahah\";\nstr.insert(1,s);//在原串下标为1的字符e前插入字符串s\nstr1.insert(4,5,s);//在原串下标为4的字符o前插入5个字符s\nstr2.insert(0,s,1,3);//将字符串s从下标为1的a开始数3个字符，分别是aha，插入原串的下标为0的字符h前\n```\n\n**set**\n\n```c++\nset<int> a;\nunordered_set<int> occ;\n//长度\nint b=0;\na.size();\na.insert(b);\na.erase(b);//移除\na.count(b);//查找返回值为1\n```\n\n**memset**\n\n```c++\n功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,\n块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作\n\n用 法: void *memset(void *s, char ch, unsigned n);\n\n对比：\nmemcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：char a[100],b[50]; memcpy(b, a, sizeof(b));注意如用sizeof(a)，会造成b的内存地址溢出。\n\nstrcpy就只能拷贝字符串了，它遇到'/0'就结束拷贝；例：char a[100],b[50];strcpy(a,b);如用strcpy(b,a)，要注意a中的字符串长度（第一个‘/0’之前）是否超过50位，如超过，则会造成b的内存地址溢出。\n```\n\n**map**\n\n```c++\nmap<string,int> maps;\n//插入\nmaps.insert(pair<int, string>(111, \"kk\"));\nmaps[111]=\"kk\";\n//maps.find(key) 查找一个元素 返回key的映射的迭代器\nmap<string,int>::iterator it;\nit=maps.find(\"123\");//在容器中寻找值为key为123的元素，返回该元素的迭代器。否则，返回map.end()。\n\n//取值\nmap->first;//对应key,111\nmap->second;//对应value,kk\n\n//清空\nmaps.clear();\n//删除一个元素\n//迭代器刪除\nit = maps.find(\"123\");\nmaps.erase(it);\n\n//关键字删除\nint n = maps.erase(\"123\"); //如果刪除了返回1，否则返回0\n\n//用迭代器范围刪除 : 把整个map清空\nmaps.erase(maps.begin(), maps.end());\n//等同于mapStudent.clear()\nmaps.begin();//返回指向map头部的迭代器\nmaps.end();//返回指向map末尾的迭代器\nmaps.size();\nmaps.empty();//判空\n```\n\n\n\n### 注意\n\n#### python\n\n```python\ncur=[]\nres.append(cur) # 这里是引用，cur变，res变\nres.append(cur.copy) # 或者cur[:]y\n```\n\n\n\n计时\n\n```python\nimport time\nstart = time.perf_counter()\n\n\nend = time.perf_counter()\nprint(f\"Running time: {end - start} Seconds\")\n```\n\n\n\n```python\nsort()\n\n```\n\n```python\nmax_value = sys.maxsize\nmin_value = -sys.maxsize - 1\n```\n\n\n\n#### c++\n\n* oj运行出错：数组开小了\n\n* oj和答案不对的一个重要原因：没有说明是eof的就得换一种方式读取！！，如果保持eof的方式就会错\n\n  ```c++\n  #include <stdio.h>\n  int main() {\n      int n;\n      while (scanf(\"%d\", &n) != EOF) {\n          printf(\"%d\\n\", (1 + n) * n / 2);\n      }\n  }\n  ```\n\n* 读取方式有可能会造成运行超时：\n\n  ```c++\n  //超时版\n  int len;\n  int v[100001]={0};\n  while (scanf(\"%c\", &n) != '\\n') {\n      if (n != ' ') {\n          v[len] = n - '0';\n          len++;\n      }\n  \n      if (n == '\\n') break;\n  }\n  //不超时版\n  vector<int> v;\n  int i;\n  while (cin >> i) {\n      v.push_back(i);\n      if (cin.get() == '\\n') break;\n  }\n  ```\n\n  \n\n## 数据结构及基本操作\n\n 数组遍历\n\n```python\ndef traverse(arr: List[int]):\n    for i in range(len(arr)):\n        # 迭代访问 arr[i]\n```\n\n链表，迭代递归\n\n```python\n# 基本的单链表节点\nclass ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ndef traverse(head: ListNode) -> None: # -> None 是类型注释的一部分，用于说明函数的返回类型。\n    p = head\n    while p is not None:\n        # 迭代访问 p.val\n        p = p.next\n\ndef traverse(head: ListNode) -> None:\n    # 递归访问 head.val\n```\n\n\n\n二叉树 递归\n\n```python\n# 基本的二叉树节点\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \ndef traverse(root: TreeNode):\n    traverse(root.left) # 递归遍历左子树\n    traverse(root.right) # 递归遍历右子树\n    \ndef traverse(root):\n    # 前序位置\n    traverse(root.left)\n    # 中序位置\n    traverse(root.right)\n    # 后序位置\n```\n\n### 括号匹配\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//括号匹配 栈 ([)]这种可不对 应该先配对好[才能再配对( \n//((([]))) \nint main(){\n\tstring s;\n\tcin>>s;\n\tint len=s.length();\n\tstack<char> st;\n\tfor(int i=0;i<len;i++){\n\t\tif(!st.empty()){\n\t\t\tchar now=st.top();\n\t\t\tif(s[i]==')'&&now=='('||(s[i]==']'&&now=='[')) st.pop();\n\t\t\telse st.push(s[i]);\n\t\t}else{\n\t\t\t//如果为空，入栈\n\t\t\tst.push(s[i]); \n\t\t}\n\t}\n\tif(!st.empty()) printf(\"NO\\n\");//栈空才成 \n\telse printf(\"YES\\n\");\n    return 0;\n}\n```\n\n### 哈夫曼树\n\n[1544 - 合并果子 _N诺计算机考研 (noobdream.com)](https://noobdream.com/DreamJudge/Issue/page/1544/)\n\n在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。\n\n> 误区：将从小到大排序后依次合并。错误的，例如 5,6,7,8。这里合完5,6为11，再合7,8为15，最后合11和15.因此应当每次挑最小的两个合并，用到优先队列\n\n注意这个运算符的重载为什么符号相反？升序则相反，降序则相同，\n\n在此处定义一个优先队列priority_queue<point> q;\n\n如果要按照以times进行从小到大排列，操作如上。\n\n进行重载<操作符。\n\n意思是如果a.times > b.times成立，那么结构体point a < point b成立。\n\n由于优先队列是按照从大到小排列，所以结构体b会排列到a之前，然而b.times是最小的，所以实现了按照times的从小到大排序,其实用一句话说就是要想b更大那么b.times.[C++优先队列(priority queue)及重载运算符_c++ 优先队列重载运算符-CSDN博客](https://blog.csdn.net/riba2534/article/details/53450085)\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n\tint x;\n\tnode(int a){x=a;}//构造方法 \n};\n//重载关系运算符定义优先队列比较关系\nbool operator <(const node& a,const node &b){\n\treturn a.x>b.x;\n} \nint main(){\n\tpriority_queue<node> q;\n\tint n,x;\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x;\n\t\tq.push(node(x));\n\t}\n\tint anx=0;\n\twhile(q.size()>1){\n\t\t//继续合并\n\t\tnode numa=q.top();//类型是Node \n\t\tq.pop();\n\t\tnode numb=q.top();\n\t\tq.pop();\n\t\tanx+=(numa.x+numb.x);\n\t\t//插入\n\t\tq.push(node{numa.x+numb.x});\n\t}\n\tcout<<anx;\n\treturn 0;\n} \n```\n\n\n\n## 链表\n\n快慢指针找中点\n\n```python\n\"\"\"\n链表排序\n\n思想 拆分完后 各自排序，再每部分合并从新排序\n\n快慢指针找中点\n\"\"\"\n\n# 链表节点\nclass ListNode:\n    def __init__(self,val):\n        self.val=val\n        self.next=None\n\ndef merge(l1,l2):\n    if l1 is None:\n        return l2\n    if l2 is None:\n        return l1\n    if l1.val<=l2.val:\n        # l1放最前 后面继续成链\n        l1.next=merge(l1.next,l2)\n        return l1\n    else:\n        l2.next=merge(l1,l2.next)\n        return l2\n# def merge_sort(node,len):\n#     # 找链表中间\n#     if node is None or node.next is None or len is 0:\n#         return node\n# \n#     slow=node\n#     mid_loc=len//2\n#     print(f\"mid_loc:{mid_loc}\")\n#     for i in range(mid_loc): # 中点\n#         slow=slow.next\n# \n#     mid=slow.next\n#     slow.next=None # 断开\n# \n#     # 左右子链归并排序\n#     left=merge_sort(node,mid_loc)\n#     right=merge_sort(mid,len-mid_loc)\n# \n#     return merge_sort(left,right)\ndef merge_sort(head):\n    if head is None or head.next is None:\n        return head\n\n    slow = head\n    fast = head.next\n\n    # 找到链表的中点\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n\n    mid = slow.next\n    slow.next = None\n\n    left = merge_sort(head)\n    right = merge_sort(mid)\n\n    return merge(left, right)\ndef print_list(node):\n    while node:\n        print(node.val,end=' ')\n        node=node.next\nif __name__==\"__main__\":\n    # 读取构造链表\n    nums=list(map(int,input().split()))\n    head=ListNode(int(nums[0])) # 记录头结点\n    curr=head # 工作指针\n    len=len(nums)\n    for num in nums[1:]: # 从1之后开始赋值，第0个已经在头结点了\n        curr.next=ListNode(int(num))\n        curr=curr.next\n    # print_list(head)\n    print()\n    new=merge_sort(head,len)\n\n    print_list(new)\n\n```\n\n### 合并k个有序链表\n\n小根堆，面试常考题，\n\n```python\n\"\"\"\n合并k个升序列表\n\n思想，因为每个链表都是有序的，因此对他们进行排序，每次取最小的放进去就好了\n建立小根堆\n\"\"\"\nimport heapq\nimport random\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        # 虚拟头结点\n        dummy = ListNode(-1)\n        p = dummy\n\n        # 优先级队列\n        pq = []\n        for head in lists:\n            if head:\n                heapq.heappush(pq, (head.val, head)) # 往pq内建立小根堆\n\n        while pq:\n            # 获取最小节点 接到结果链表中\n\n            node = heapq.heappop(pq)[1]  # heapq.heappop()是从堆中弹出并返回最小的值,取1指头节点\n            # far=heapq.heappop(pq)[0]\n            # print(node.val,far.val)\n            p.next = node\n            if node.next:\n                heapq.heappush(pq, (node.next.val, node.next))\n            # p前进\n            p = p.next\n            # print_priority_queue(pq)\n        return dummy.next\n```\n\n### 单链表的倒数第k个节点\n\n巧妙思想\n\n如何一次遍历链表就到倒数第k个节点呢\n\n用p1先走k，然后设置一个新的p2指向头节点，和p2一起走\n\n当p2走到末尾，p1也就到倒数第k个了\n\n```python\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        # 预防删除头结点的 虚拟节点的重要性\n        # 如果是直接从head开始，应对不了规模为1删除为1的，或者是删除的是头结点的情况\n        newnode=ListNode(-1)\n        newnode.next=head\n        p1=newnode\n        p2=newnode\n        for i in range(n):\n            p1=p1.next\n        \n        # p2开始遍历，直至p1到尾\n        # if p1==None:\n        #     return None\n        while p1.next :\n            p1=p1.next\n            p2=p2.next\n        \n        # 删除第n个，即下一个\n        p2.next=p2.next.next\n        return newnode.next\n```\n\n### 单链表的中点\n\n快慢指针法\n\n```python\ndef middleNode(head:ListNode):\n\t# 快慢指针初始化指向head\n    slow=head\n    fast=head\n    # 快指针走向末尾\n    while fast and fast.next:# fast判断下一轮直接走出界的情况\n        slow=slow.next # 走一步\n        fast=fast.next.next # 走两步\n    # 慢指针指向中点\n    return slow \n```\n\n### 链表是否有环\n\n力扣第 142 题「[环形链表 IIopen in new window](https://leetcode.cn/problems/linked-list-cycle-ii/)」\n\n![image-20240313162945782](JJ的算法之旅.assets/image-20240313162945782.png)\n\n###  两个链表是否相交\n\n太巧妙了！\na，b长度可能不同，但是让p1走完a然后走b，p2走完b走a，就能同时达到公共区域\n第一次相等的那一刻就是连接点\n\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p1,p2=headA,headB\n        while p1!=p2:\n            if p1==None:\n                p1=headB\n            else:\n                p1=p1.next\n            if p2==None:\n                p2=headA\n            else:\n                p2=p2.next\n        return p1\n```\n\n## 数组\n\n### 普通数组\n\n[56. 合并区间 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)\n\n以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。\n\n> 排序，时间复杂度简化(思路简化)\n\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        int arr_nums=intervals.size();\n        if (arr_nums==0){\n            return {};//返回一个空\n        }\n        sort(intervals.begin(),intervals.end()); //排序一下，根据第一个元素\n        vector<vector<int>> res;//最终结果\n        for(int i=0;i<arr_nums;i++){\n            //如何降低复杂度，就是排序后一个一个存到结果数组\n            //显然，结果数组最后一个一定是那个临近的合并元素，如果合不了就直接加入\n            int L=intervals[i][0],R=intervals[i][1];\n            if(!res.size()||res.back()[1]<L){\n                res.push_back({L,R});\n                //只有当为空，或者新元素左值大于最后一个右值(无法合并)，才添加\n            }else{\n                //直接合并取最大\n                res.back()[1]=max(res.back()[1],R);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 哈希表\n\n[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n从O(N)->O(1)\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> hashtable;\n        for(int i=0;i<nums.size();i++){\n            auto it=hashtable.find(target-nums[i]);\n            if(it!=hashtable.end()){\n                //找的到满足的\n                return {it->second,i};//value对应索引\n            }\n            hashtable[nums[i]]=i;\n        }\n        return {};\n    }\n};\n```\n\n\n\n### 快慢指针技巧\n\n删除重复项\n巧妙，利用快慢指针，fast扫到一个新的直接赋值给slow\nfast直是在最开始多1，速度是同步的\n\n### 二分法\n\n167 两数组之和 输入有序数组\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n```python\nclass Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        # 非递减排序就可以用类似二分法\n        lenth=len(numbers)\n        left,right=0,lenth-1\n        while left!=right:\n            sum=numbers[left]+numbers[right]\n            if sum==target:\n                return [left+1,right+1]\n            if sum<target:\n                left+=1\n            else:\n                right-=1\n        return [-1,-1]\n```\n\n5 最长回文子串\n核心：对每个字符向两边扩散，注意区分奇偶数情况\n\n```python\ndef longestPalindrome(s: str) -> str:\n    res = \"\"\n    for i in range(len(s)):\n        # 以 s[i] 为中心的最长回文子串\n        s1 = palindrome(s, i, i)\n        # 以 s[i] 和 s[i+1] 为中心的最长回文子串\n        s2 = palindrome(s, i, i + 1)\n        # res = longest(res, s1, s2)\n        res = res if len(res) > len(s1) else s1\n        res = res if len(res) > len(s2) else s2\n    return res\n\ndef palindrome(s, l, r):\n    while (l >= 0 and r < len(s) and s[l] == s[r]):\n        l -= 1\n        r += 1\n    return s[l+1:r]\n```\n\n调用内置函数\n\n`lower_bound( begin,end,num)`：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\n\n`upper_bound( begin,end,num)`：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\n\n例如，求最长上升子序列长度，可以利用升序特点把遍历查找dp改成二分查找\n\n```c++\nint LTS_nlgn(){\n    int len=1;\n    dp[1]=a[1];\n    for(int i=2;i<=n;i++){\n        if(a[i]>dp[len]){\n            dp[++len]=a[i];\n        }else{\n            int pos=lower_bound(dp,dp+len,a[i])-dp;\n            dp[pos]=a[i];\n        }\n    }\n    return len;\n}\n```\n\n\n\n### 双指针\n\n[15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked)\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n\n你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n这题不难，但是很值得思考，各种条件限制，逻辑\n\n```python\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        int length=nums.size();\n        //排序\n        sort(nums.begin(),nums.end());\n        vector<vector<int>> res;\n        for(int first=0;first<length;first++){\n            if(first>0&&nums[first]==nums[first-1]){\n                continue;\n            } // 和上一次不一样 这个很重要也难想，因为first和first-1相同，则二三都可能有两组满足\n            int third=length-1;//三指向最后一个来递减\n            int target=-nums[first];//达到这个目标\n            for(int second=first+1;second<length-1;second++){\n                if(second>first+1 && nums[second]==nums[second-1]){\n                    continue;\n                }\n                //为什么是大于，排完序之后，后面是大数\n                //third越减，值越小，大于就是为了提前结束后面的没必要再比了，而不至于造成second==thrid跳出后直接second的递增被break了\n                while(third>second&&nums[second]+nums[third]>target){\n                    third--;\n                }\n                cout<<second<<','<<third;\n                cout<<nums[second-1]<<','<<nums[second];\n                if (second==third){\n                    //重合\n                    break;\n                }\n                if(nums[second]+nums[third]==target){\n                    //满足条件\n                    res.push_back({nums[first],nums[second],nums[third]});\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 子串\n\n#### 前缀和\n\n[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。\n\n子数组是数组中元素的连续非空序列。\n\n```c++\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int count=0;\n        int sum=0;\n        map<int,int> map;\n        map.insert(pair<int,int>(0,1));//初始化前缀和为0\n        //遍历\n        for(int i=0;i<nums.size();i++){\n            sum+=nums[i];\n            if(map.find(sum-k)!=map.end()){//找不到返回map.end()\n                count+=map[sum-k];//有值对应满足个数 不会计重，因为在此时有多少个满足的就有多少个子数组了，都得算上\n            }\n            //记得插入\n            map[sum]++;\n        }\n        return count;\n    }\n};\n```\n\n\n\n## 二叉树\n\n动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：\n\n动态规划算法属于分解问题的思路，它的关注点在整棵「子树」。\n回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。\nDFS 算法属于遍历的思路，它的关注点在单个「节点」。\n\n层序遍历\n\n```python\ndef levelTraverse(root: TreeNode):\n    if not root:\n        return\n    \n    q = deque()\n    q.append(root)\n\n    # 从上到下遍历二叉树的每一层\n    while q:\n        sz = len(q)\n        # 从左到右遍历每一层的每个节点\n        for i in range(sz):\n            cur = q.popleft()\n            # 将下一层节点放入队列\n            if cur.left:\n                q.append(cur.left)\n            if cur.right:\n                q.append(cur.right)\n```\n\n### 前中序构造\n\n理解前中序数组的结构\n\n![img](https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/4.jpeg)\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# 存索引\n\nval2Index={}\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        for i in range(len(inorder)):#这里和leftSize对应\n            val2Index[inorder[i]]=i\n        return self.build(preorder,0,len(preorder)-1,inorder,0,len(inorder)-1)\n    def build(self,preorder,prestart,preend,inorder,instart,inend):\n        if prestart>preend:\n            return None\n        rootVal=preorder[prestart]\n        root=TreeNode(rootVal) # 构造头\n        index=val2Index.get(rootVal)\n        leftSize=index-instart\n        root.left=self.build(preorder,prestart+1,prestart+leftSize,inorder,instart,index-1)\n        root.right=self.build(preorder,prestart+leftSize+1,preend,inorder,index+1,inend)\n\n        return root\n        \n```\n\n### 中序后序\n\n![image-20240406013906501](JJ的算法之旅.assets/image-20240406013906501.png)\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nvar2Index={}\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        for i in range(len(inorder)): #这里和rightSize对应\n            var2Index[inorder[i]]=i\n        return self.build(postorder,len(postorder)-1,0,inorder,0,len(inorder)-1)\n    def build(self,postorder,poststart,postend,inorder,instart,inend):\n        if poststart<postend:\n            return None\n        # if instart > inend:\n        #     return None\n\n        rootVal=postorder[poststart]\n        root=TreeNode(rootVal)\n        index=var2Index.get(rootVal)\n        rightSize=inend-index\n\n        root.right=self.build(postorder,poststart-1,poststart-rightSize,inorder,index+1,inend)\n        root.left=self.build(postorder,poststart-rightSize-1,postend,inorder,instart,index-1)\n        return root\n\n```\n\n### 前序后序\n\n```python\nvar2Index={}\nclass Solution(object):\n    def constructFromPrePost(self, preorder, postorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        for i in range(len(postorder)):\n            var2Index[postorder[i]]=i\n        return self.build(preorder,0,len(preorder)-1,postorder,len(postorder)-1,0)\n    def build(self,preorder,prestart,preend,postorder,poststart,postend):\n        if prestart>preend:\n            return None\n        if prestart==preend:\n            return TreeNode(preorder[prestart])\n        rootVal=preorder[prestart]\n        root=TreeNode(rootVal)\n        leftrootVal=preorder[prestart+1]\n        #直接折半\n        index=var2Index.get(leftrootVal)\n        leftSize=index-postend+1\n        root.left=self.build(preorder,prestart+1,prestart+leftSize,postorder,index,postend)\n        root.right=self.build(preorder,prestart+leftSize+1,preend,postorder,poststart-1,index+1)\n        return root\n```\n\n\n\n## 搜索\n\n### 广度优先BFS\n\n[1563 - 迷宫 _N诺计算机考研 (noobdream.com)](https://noobdream.com/DreamJudge/Issue/page/1563/#)\n\n队列+访问记录\n\npop一个，push所有邻接的，并且要标记当前为访问的\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100+5;\nchar mpt[maxn][maxn];\nint vis[maxn][maxn];\n//代表上下左右四个动作对应的x，y变化，调用就行 \nint dir[4][2]={0,1,1,0,0,-1,-1,0};\nstruct node{\n\tint x,y;\n\tint step;\n};\n//迷宫 BFS \nint bfs(int sx,int sy){\n\t//记录访问\n\tmemset(vis,0,sizeof(vis));\n\tqueue<node> q;//使用队列来维护一层层发散的优先级\n\tq.push(node{sx,sy,0});\n\tvis[sx][sy]=1;//起点已访问\n\tint ans=-1;\n\twhile(!q.empty()){\n\t\tnode now=q.front();\n\t\tq.pop();//出队\n\t\tif(mpt[now.x][now.y]=='E'){\n\t\t\t//找到终点\n\t\t\tans=now.step;//记录步数 \n\t\t\tbreak; \n\t\t} \n\t\t//上下左右四个方向都试一遍 \n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=now.x+dir[i][0];\n\t\t\tint ny=now.y+dir[i][1];\n\t\t\t//判断可走同时未被访问\n\t\t\tif((mpt[nx][ny]=='*'||mpt[nx][ny]=='E')&&vis[nx][ny]==0){\n\t\t\t\tq.push(node{nx,ny,now.step+1});\n\t\t\t\tvis[nx][ny]=1;//标记访问 \n\t\t\t} \n\t\t}\n\t} \n\treturn ans; \n}\nint main(){\n\tint h,w;\n\twhile(scanf(\"%d%d\",&h,&w)!=EOF){\n\t\tif(h==0&&w==0)break;\n\t\tint sx=0,sy=0;\n\t\tmemset(mpt,0,sizeof(mpt));//填充0\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tscanf(\"%s\",mpt[i]+1);\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(mpt[i][j]=='S'){\n\t\t\t\t\tsx=i,sy=j;//记录起点 \n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\tint ans=bfs(sx,sy);\n\t\tprintf(\"%d\\n\",ans); \n\t}\n\t\n\t\n\treturn 0;\n}\n```\n\n### 递归\n\n#### Hanoi塔\n\n注意移动要借助才行\n\n```c++\nhanoi(n-1,p,h,m);//前n-1个 从第一个经过第三个移动到第二个 \nhanoi(1,p,m,h);//最后一个经过第二个移动到第三个 \nhanoi(n-1,m,p,h);//n-1从第二个经过第一个移动到第三个 \n```\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//汉诺塔 不是简单的一步移动，而是要借助其他的 \nint step;//移动步数\n \nvoid hanoi(int n,char p,char m,char h){//表示要将p经过m移动到h \n\tif(n==1){\n\t\tif((step+1)%5==0){\n\t\t\t//输出格式要求\n\t\t\tcout<<p<<\"-->\"<<h<<endl; //不能特指，而是通过变量的形式 \n\t\t}else cout<<p<<\"-->\"<<h<<\"   \";\n\t\tstep++;\n\t\treturn ;\n\t}\n\thanoi(n-1,p,h,m);//前n-1个 从第一个经过第三个移动到第二个 \n\thanoi(1,p,m,h);//最后一个经过第二个移动到第三个 \n\thanoi(n-1,m,p,h);//n-1从第二个经过第一个移动到第三个 \n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tstep=0; \n\t\thanoi(n,'A','B','C');\n\t\tcout<<endl;\n\t} \n\treturn 0;\n}\n```\n\n### DFS\n\n实现方式：递归。递归流程->递归树->多叉树\n\n简单来说，BFS和DFS到底有什么区别呢？\n对于一棵二义树，\n**BFS**就是二叉树的**层次遍历**，一层一层的扩展下去。\nDS就是二义树的中序遍历，一条路走到底，然后回溯走第二条，直到所有路都走完。\n\n需要注意的是，DFS一般情沉下效率不如BFS,比如求DFS中的迷宫的最短路径使用DFS就会超时。\n\n迷宫\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nchar mpt[105][105];\nchar vis[105][105];\nint H=0,W=0;\nint dir[4][2]={0,1,0,-1,-1,0,1,0};//上下左右 \nint minres=1000000;\n//要标记vis！不然就是死循环 \nint dfs(int sx,int sy,int res){\n\tif(res>=minres) return 0;\n\tif(mpt[sx][sy]=='E'){\n\t\tif (res<minres){\n\t\t\tminres=res;\n\t\t}\n\t\treturn res;\n\t} \n\tfor(int i=0;i<4;i++){\n\t\tint newx=sx+dir[i][0];\n\t\tint newy=sy+dir[i][1];\n\t\tif((mpt[newx][newy]=='*'||mpt[newx][newy]=='E')&&vis[newx][newy]==0){\n\t\t\t//可以走，递归\n\t\t\tvis[newx][newy]=1;//访问过 \n\t\t\tdfs(newx,newy,res+1);\n\t\t\tvis[newx][newy]=0;//记得回溯，你退出来要留给其他路径走 \n\t\t}\n\t} \n}\nint main(){\n\t\n\tint sx=0,sy=0;//记录出入口 \n\tint res=0;\n\twhile(scanf(\"%d%d\",&H,&W)!=EOF){\n\t\tif(H==0&&W==0) return 0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>mpt[i][j];\n\t\t\t\tif(mpt[i][j]=='S') {\n\t\t\t\t\tsx=i;\n\t\t\t\t\tsy=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tminres=1000000;//注意每轮都要重新设置 \n\t\tdfs(sx,sy,0);\n\t\tif(minres==1000000) cout<<\"-1\"<<'\\n';\n\t\telse cout<<minres<<'\\n';\n\t}\n\treturn 0;\n} \n```\n\n## 图论\n\n### 存储\n\n#### 邻接矩阵\n\n邻接矩阵是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(邻接矩阵)存储图中的边或弧的信息\n\narc\\[i][j]=1,若(v<sub>i</sub>,v<sub>j</sub>)∈E或(v<sub>j</sub>,v<sub>i</sub>)∈E：0,反之\n\n![image.png](https://s2.loli.net/2024/05/29/4dWl9R5qYFBySDZ.png)\n\n特点：\n\n* 要判断任意两顶点是否有边无边就很容易了；\n* 要知道某个顶点的度，其实就是这个顶点vi 在邻接矩阵中第i 行或（第i 列）的元素之和；\n* 求顶点vi 的所有邻接点就是将矩阵中第i 行元素扫描一遍，arc[i][j]为1 就是邻接点；而有向图讲究入度和出度，顶点vi 的**入度**为1，正好是第i **列**各数之和。顶点vi 的**出度**为2，即第i **行**的各数之和。\n\n#### 邻接表\n\n对于边数相对顶点较少的图，邻接矩阵对空间浪费。邻接表是数组和链表相结合的方法，更加适合，即顶点表(一位数组)和边表(链表)\n\n![image.png](https://s2.loli.net/2024/05/29/5iTjQse6bMByPR2.png)\n\n从图中可以看出，顶点表的各个结点由data 和firstedge 两个域表示，data 是数据域，存储顶点的信息，firstedge 是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex 和next 两个域组成。adjvex 是邻接点域，存储某顶点的邻接点在顶点表中的下标，next 则存储指向边表中下一个结点的指针。\n\n> 对于带权的网图，在边表结点定义下加一个weight的数据域，存储权值信息即可\n\n#### 区别\n\nn个顶点e条边的无向图-->邻接表表示有n个顶点表节点，2e个边表结点\n\nn个顶点e条边的有向图-->邻接表表示有n个顶点表节点，e个边表结点\n\n如果图中边的数目远远小于n<sup>2</sup>称作<u>稀疏图</u>，这时用邻接表表示比用邻接矩阵表示节省空间;\n\n如果图中边的数目接近于n<sup>2</sup>,对于无向图接近于n*(n-1)称作<u>稠密图</u>,考虑到邻接表中要附加链域，采用邻接矩阵表示法为宜。\n\n### 并查集(Disjoint Set Union)\n\nDisjoint Set Union：不相交集合并集\n\n解决集合类问题，核心是：树形结构+路径压缩思想，加快区分集合，效率远高于map\n\n并查集还有一个英文名字：[union](https://so.csdn.net/so/search?q=union&spm=1001.2101.3001.7020)-find sets，从这里可以看出，并查集就是合并(union)查找(find)的集合(set)\n\n代码实现\n\n1.初始化\n\n假设有编号1,2,3,...,n的n个元素，用数组fa[]**来存储每个元素的父节点**，初始化f[i]=i\n\n2.查询\n\nfind，查找i的祖先代表元素\n\n```c++\nint find(int i){\n    if(fa[i]==i) return i;//递归出口到达祖先\n    else return find(fa[i]);//不断往上查找祖先\n}\n```\n\n3.合并\n\n```c++\nvoid unionn(int i,int j){\n    int i_fa=find(i);//找到i的祖先 \n    int j_fa=find(j);//找到j的祖先\n    fa[i_fa]=j_fa;//i的祖先指向j的祖先\n}\n```\n\n然而，每次从根开始查都要查n个结点直至到最上面的祖先，大大增加时间开销，因此，出现**路径压缩方**法，也就是直接指向最大的祖先\n\n```mermaid\ngraph TD\n1-->1\n2-->1\n3-->2\n4-->3\n```\n\n变为\n\n```mermaid\ngraph TD\n1-->1\n2-->1\n3-->1\n4-->1\n```\n\n查询语句变成\n\n```c++\nint find(int i){\n    if(i==fa[i]) return i;\n    else fa[i]=find(fa[i]);//进行路径压缩 更新最\n    return fa[i];//返回父节点\n}\n```\n\n\n\n例题[1319 - 畅通工程2 _N诺计算机考研 (noobdream.com)](https://noobdream.com/DreamJudge/Issue/page/1319/#)\n\n每个城镇都要可达，最小添加多少。其实可以发现只要是有共同祖先的，都是可以连通的，那么如何判断需要加多少条呢？\n\n* 判断已经连通的城镇数。在查找合并的时候，如果发现祖先不同，合并的时候联通的城镇数就加1，最后N-sum-1\n* 在判定完后遍历fa，如果等于本身，sum++，最后输出sum-1。这里sum表示有多少个独立的集合，连接这sum个独立集合只需要sum-1条边\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint fa[1001];//记录祖先\nint find(int x){\n\tif(x==fa[x]) return x;//祖先\n\tfa[x]=find(fa[x]);//压缩 我要祖先的祖先 \n\treturn fa[x];//返回上一级祖先 \n} \nint main(){\n\tint N,M;\n\twhile(cin>>N){\n\t\tif(N==0) break;\n\t\tcin>>M;\n\t\tint sum=0;\n\t\t//初始化城市\n\t\tfor(int i=1;i<=N;i++) fa[i]=i;\n\t\t//读取道路\n\t\tfor(int i=1;i<=M;i++){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\tint fxa=find(a);\n\t\t\tint fxb=find(b);\n\t\t\tif(fxa!=fxb){\n\t\t\t\t//本身不连通，现在联通了\n\t\t\t\t fa[fxa]=fxb;\n\t\t\t\t sum++;//把对方看作一个单位，那就是多加一个连通的了 \n\t\t\t}\n\t\t} \n\t\tprintf(\"%d\\n\",N-sum-1);\n\t}\n\treturn 0;\n}\n```\n\n> 很奇怪的是上面代码在N诺如果用scanf反而超时...\n\n### 最小生成树\n\n[最小生成树详解(模板 + 例题)-CSDN博客](https://blog.csdn.net/qq_43619271/article/details/109091314)\n\n一个图中可能存在多条相连的边,我们**一定可以从一个图中挑出一些边生成一棵树。**这仅仅是生成一棵树,还未满足最小,**当图中每条边都存在权重时,这时候我们从图中生成一棵树(n - 1 条边)时,生成这棵树的总代价就是每条边的权重相加之和。**\n\n>  找最小带权图\n\n#### Kruskal 加边法\n\n**Kruskal（克鲁斯卡尔）算法是一种巧妙利用并查集来求最小生成树的算法。**\n\nKruskal算法将一个连通块当做一个集合。Kruskal首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个点都是孤立的，分属于n个独立的集合。然后按顺序枚举每一条边。如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点**属于同一集合，就跳过**。直到选取了n-1条边为止。\n\n\n#### Prim\n\n### 最短路径\n\n#### floyd\n\n邻接矩阵，最大初始化，三种全遍历循环，k在外头\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//邻接矩阵\nconst int maxn=101;\nint mpt[maxn][maxn]; \nint N,M;\nvoid floyd(){\n\t//k在i,j之间 \n\tfor(int k=1;k<=N;k++){\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tmpt[i][j]=min(mpt[i][k]+mpt[k][j],mpt[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\t\n\twhile(scanf(\"%d%d\",&N,&M)!=EOF){\n\t\tif(N+M==0) break;\n\t\t//初始化赋最大值\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tif(i==j) mpt[i][j]=0;\n\t\t\t\telse mpt[i][j]=100000000;\n\t\t\t}\n\t\t} \n\t\tfor(int i=1;i<=M;i++){\n\t\t\tint vi,vj,w;\n\t\t\tscanf(\"%d%d%d\",&vi,&vj,&w);\n\t\t\t//注意重边！\n\t\t\tif(w<mpt[vi][vj]){\n\t\t\t\tmpt[vi][vj]=w;\n\t\t\t\tmpt[vj][vi]=w;//对称 \n\t\t\t} \n\t\t\t\n\t\t}\n\t\tfloyd();\n\t\tprintf(\"%d\\n\",mpt[1][N]);//起点到终点的最短路径 \n\t}\n\t\n\treturn 0;\n}\n```\n\n### 拓扑排序\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=505;\nbool mpt[maxn][maxn];//记录图 \nint lev[maxn];//记录i个结点的入度\nvector<int> v[maxn];//表示被i进入的邻居 \n//priority_queue<int,vector<int>,greater<int> > q;//最小堆优先队列存放入度为0的优先队列 \npriority_queue<int, vector<int>,greater<int> >q;//最小堆优先队列\nvoid topo(int n){\n\tfor(int i=1;i<=n;i++){\n\t\tif(!lev[i]) q.push(i);//存放入度为1 \n\t}\n\tint flag=0;//统计出队元素个数\n\twhile(!q.empty()){\n\t\tint now=q.top();\n\t\tq.pop();//踢出 \n\t\tif(flag) printf(\" %d\",now);\n\t\telse printf(\"%d\",now);\n\t\tflag++;\n\t\tfor(int i=0;i<v[now].size();i++){//修改邻居的入度 \n\t\t\tint next=v[now][i];\n\t\t\tlev[next]--;\n\t\t\tif(!lev[next]) q.push(next);//入度变0了 \n\t\t}\n\t} \n\tif(flag!=n){\n\t\tprintf(\"这个图有环，并没有拓扑排序\\n\");\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tmemset(lev,0,sizeof(lev));\n\t\tfor(int i=0;i<=n;i++)v[i].clear();\n\t\twhile(m--){\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tv[a].push_back(b);\n\t\t\tlev[b]++;\n\t\t}\n\t\n\t\ttopo(n);\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n\n\n## 回溯算法\n\n递归和回溯相辅相成\n\n递归函数下面就是回溯内容\n\n回溯搜索：纯暴力搜索算法\n\n* 组合问题\n* 切割问题\n* 子集问题\n* 排列问题 \n* 棋盘问题，n王后，解数独\n\n抽象为n叉数问题，横向节点用for循环表示，纵向深度用递归\n\n```c++\nvoid backtracking(参数){\n    if(终止条件){\n        在叶子节点搜集结果;\n        return;\n    }\n    for(集合元素){\n        处理结点;\n        递归;\n        回溯;//撤销处理节点结果\n    }\n    return;\n}\n```\n\n\n\n回溯三部曲\n\n* 递归函数参数返回值\n* 确定终止条件\n* 单层递归逻辑(最后一步回溯pop)\n\n### 组合和排列\n\n回溯用递归模拟了嵌套n层for循环的方式。\n\n回溯：递归嵌套for循环\n\n组合不区分顺序，排列区分\n\n叶子结点收割结果：也就是数组大小等于数的个数\n\n## 排序算法\n\n### 堆排序\n\n堆是一个完全二叉树，只有最后一层不满，且只能没有右子节点\n\n**堆序性：**\n\n* 大根堆\n* 小根堆\n\n**存储：**\n\n用一位数组，从上到下从左到右给每个节点编号，这个就是在数组的存储序号\n\n这样存储有一个规律，设节点下标为i：\n\n* 左子节点下标为2i+1\n* 右子节点下标为2i+2\n\n**上滤和下滤：**O(logN)\n\n* 当根节点不满足堆序性，子树都满足时(以大根堆为例)，把该节点和最有子树最大值比较然后换位，直到没有小于或者到达最后一层，这就是下滤\n* 同理，上滤就是和根比较，小于就换，直到遇到比他小的或到根节点\n\n**建堆：**\n\n* 自顶向下建堆法 O(NlogN)\n  * 将新元素放到堆的**最后一位**，然后进行**上滤**操作\n* 自下而上建堆法 O(n)\n  * 首先将下面的调整成堆，然后对父节点进行下滤，直到根节点操作完毕\n\n**应用：**\n\n* 优先队列(小根堆)，是插入队列后弹出最小元素。直接弹出排好序的堆的根节点\n  * 弹出后，将最后一个元素放到根节点，重新进行下滤就有序了\n* 插入操作，插入到尾部，然后进行上滤\n\n**堆排序：**\n\n就是将优先队列的所有元素依次弹出即可！\n\n![image-20240511152631639](JJ的算法之旅.assets/image-20240511152631639.png)\n\n![image-20240511152655004](JJ的算法之旅.assets/image-20240511152655004.png)\n\n> 然而实际为了考虑空间复杂度会利用原来堆的空余位置建立有序区\n\n如何做：\n\n1. 先调整为最大堆(最大元素在顶上)\n2. 将根节点和最后一个元素(不一定最小)交换，此时最后一个位置就是有序区的开始\n3. 然后将新的根节点进行下滤，完成后根节点又是最大的，把它的倒数第二个交换(倒数第一个位置已经是有序区了)，这时有序区延伸到倒数第二个位置\n4. 重复扩大有序区，直到全部有序，这是会发现，大的在最后，小的在最前，也就是递增序列\n\n因此：形成递增则构造最大堆，递减则构造最小堆\n\n[【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=8ecff66abb776707f111647a284db8d9)\n\n## 动态规划\n\n**核心是：最优子结构**。不都是(如乘积最大子数组，根据题意适当变动\n\n* 动规基础\n* 背包问题\n* 打家劫舍\n* 股票问题\n* 子序列问题\n\n重要点：\n\n* dp数组以及下界的含义，dp[i]\\[j]、dp[i]\n* 递推公式\n* dp数组如何初始化,0?1?...\n* 遍历顺序\n* 打印dp数组，看看输出结果是否正确\n\n斐波那契，dp数组降到1维，动态变化三个值即可\n\n```python\nclass Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        dp_i=1\n        dp_ii=1\n        dp_iii=1\n        for i in range(2,n):\n            dp_iii=dp_i+dp_ii\n            dp_i=dp_ii\n            dp_ii=dp_iii\n        return dp_iii\n```\n\n### 跳楼梯\n\n照动态规划思想，我们可以先分析下问题，每次都有两种跳法，分别是一阶或者两阶，那么如果当前是第n 个台阶，那么跳法是不是是(n-1)台阶的跳法数加上(n-2)台阶的跳法数？如果划算成公式是F(n) = F(n-1)+F(n-2)。\n\n这里容易有误区，为什么不是F(n-1)加一步，然后F(n-1)加两步(跳一个和两个)。首先F(n-1)到F(n)此时只有唯一的一种操作，那么到F(n)的步数就是F(n-1)。而F(n-1)跳一步的情况已经被F(n-1)包括了，此时只有跳两步的操作，同上，只有F(n-2)的情况。因此F(n)=F(n-1)+F(n-2)\n\n如果测试样例一直过不了，考虑数据类型，要开`long long`\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tlong long tff=1,tf=2,fin=2;//开long long才够\n\t\tif(n<=2) {\n\t\t\tcout<<n;\n\t\t}\n\t\telse{\n\t\t\tfor(int i=3;i<=n;i++){\n\t\t\t\tfin=tff+tf;\n\t\t\t\ttff=tf;\n\t\t\t\ttf=fin;\t\n\t\t\t}\n\t\t\tcout<<fin;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n### 最大子段和\n\n#### 最大序列和\n\n>  可能自己就已经大于加上前面的了(前面时负数)!!!!\n>\n> 并且，子序列是连续的！\n\n对于dp输出，dp[i]表示到第i的最大序列和，可能是前一个加上自己或者仅是自己。\n\n然而，最长的不一定是最大的，如果前面已经达到最大的了呢？那么我们需要维护一个最大值，如果大于他，更新。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nlong long ans[1000001];\nint main(){\n\tint N;\n\twhile(scanf(\"%d\",&N)!=EOF){\n\t\t//维护一个最大值\n\t\tlong long maxn=-100000000; \n\t\tlong long fin=-100000000;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>ans[i];\n\t\t\tmaxn=max(maxn+ans[i],ans[i]);\n\t\t\tif(maxn>fin) fin=maxn;\n\t\t} \n\t\t//每个都要找子序列，然后跟新最大的\n\t\t \n\t\tcout<<fin<<\"\\n\";\n\t\t\n\t}\n\treturn 0;\n}\n```\n\n#### 字符串区间翻转 题意转换\n\n[1642 - 字符串区间翻转 _N诺计算机考研 (noobdream.com)](https://noobdream.com/DreamJudge/Issue/page/1642/#)\n\n我们把01字符串的0变成1,1变成-1，然后构成一个1和-1的字符串。\n对这样一个字符串去求它的最大子段和即可，最后再把1的个数加上就是最终的答案。\n\n为什么可以这样?\n\n* 本质是求0和1最大数量差的区间\n* 最大序列和就意味着反转后，这里会在01反转互相抵消之下又多出多少个1，因此和原本的1加上，就是翻转后1的个数\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint dp[10000005];\nchar s[10000005];\nint a[10000005];\nint _max(int x,int y){\n\treturn x>y?x:y;\n}\nint main(){\n\tint n;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tscanf(\"%s\",s);//读取字符串\n//\t\tcout<<s;\n\t\n\t\t//遍历构建构建新数组，0->1,1->-1 \n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(s[i]=='0') a[i]=1;\n\t\t\telse a[i]=-1;\n//\t\t\tcout<<a[i]<<\" \";\n\t\t}\n\t\tint maxn=0;\n\t\tdp[0]=a[0];\n\t\t\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[i]=_max(dp[i-1]+a[i],a[i]);//最大序列和\n\t\t\tif(dp[i]>maxn) maxn=dp[i]; \n//\t\t\tcout<<dp[i]<<\"\\n\";\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(s[i]=='1') maxn++;\n\t\tcout<<maxn<<\"\\n\"; \n\t}\n\treturn 0;\n}\n```\n\n\n\n### 最长递增子序列\n\n既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的**子序列长度加一**。\n\n```python\nfor (int j = 0; j < i; j++) {\n    if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n    }\n}\n```\n\n利用函数lower_bound\n\n```c++\nint LTS_nlgn(){\n    int len=1;\n    dp[1]=a[1];\n    for(int i=2;i<=n;i++){\n        if(a[i]>dp[len]){\n            dp[++len]=a[i];\n        }else{\n            int pos=lower_bound(dp,dp+len,a[i])-dp;//从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\n            dp[pos]=a[i];\n        }\n    }\n    return len;\n}\n```\n\n求和\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[1002];\nint dp[1002];\nint main(){\n\tint N;\n\twhile(scanf(\"%d\",&N)!=EOF){\n\t\tfor(int i=1;i<=N;i++) cin>>a[i];\n\t\tint maxn=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tdp[i]=1;//清空上一个样例\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tif(a[j]<a[i]){\n\t\t\t\t\t//满足升序\n\t\t\t\t\tdp[i]=max(dp[i],dp[j]+a[i]);\n\t\t\t\t\tif(dp[i]>maxn) maxn=dp[i];\n\t\t\t\t} \n\t\t\t} \n\t\t}\n\t\tcout<<maxn<<\"\\n\";\n\t}\n\t\n\treturn 0;\n}\n```\n\n### 最长公共子序列 二维dp\n\ndp[i, j]代表a 字符串前i 个字符组成的子串和b 字符串前j 个字符组成的子串的LCS。\n那么\ndp[i, j] = 0 if i = 0 or j = 0\ndp[i, j] = dp[i - 1, j - 1] + 1 if i, j > 0 and ai = bj\ndp[i, j] = max{dp[i, j - 1], dp[i - 1, j]} if i, j > 0 and ai != bj 至少一个满足\n\n> 注意，这里0留空了，dp数组从1开始，因此对比是要比较s1[i-1]和s2[j-1]，最后输出是输出dp\\[strlen(s1)][strlen(s2)]\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nchar s1[101];\nchar s2[101];\nint dp[101][101];\nint main(){\n\twhile(scanf(\"%s\",s1)!=EOF){\n\t\tscanf(\"%s\",s2);\n\t\tfor(int i=1;i<=strlen(s1);i++){\n\t\t\tfor(int j=1;j<=strlen(s2);j++){\n\t\t\t\tif(s1[i-1]==s2[j-1]) dp[i][j]=dp[i-1][j-1]+1;\n\t\t\t\telse dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n//\t\t\t\tmaxn=max(maxn,dp[i][j]);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[strlen(s1)][strlen(s2)];\n\t}\n\treturn 0;\n}\n```\n\n\n\n\n\n### 最少编辑长度\n\n字符串动规，递归超时\n\n[72. 编辑距离 - 力扣（LeetCode）](https://leetcode.cn/problems/edit-distance/)\n\n```python\nclass Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        m,n=len(word1),len(word2)\n        dp=[[0]*(n+1) for _ in range(m+1)]\n        for i in range(1,m+1):\n            dp[i][0]=i\n        for j in range(1,n+1):\n            dp[0][j]=j\n        for i in range(1,m+1):\n            for j in range(1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(\n                        dp[i-1][j]+1,\n                        dp[i][j-1]+1,\n                        dp[i-1][j-1]+1\n                    )\n        return dp[m][n]\n```\n\n### 乘积最大子数组\n\n[152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked)\n\n给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续\n\n子数组\n\n（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n测试用例的答案是一个 **32-位** 整数。\n\n关键：当前位置的最优解未必是由前一个位置的最优解转移得到的->**根据正负性进行分类讨论**\n\n```python\nclass Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        length=len(nums)\n        dpmax=[0]*length\n        dpmin=[0]*length\n        dpmax[0]=nums[0]\n        dpmin[0]=nums[0]\n        for i in range(1,length):\n            dpmax[i]=max(dpmax[i-1]*nums[i],dpmin[i-1]*nums[i],nums[i])\n            # 「负得更多」，即尽可能小\n            dpmin[i]=min(dpmax[i-1]*nums[i],dpmin[i-1]*nums[i],nums[i])\n            \n        print(dpmax)\n        return max(dpmax)\n```\n\n\n\n### 完全平方\n\n[279. 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)\n\n**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。\n\n数学拆分为jxj+i-jxj，i-jxj就是一个子问题，遍历枚举\n\n```python\nclass Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        dp=[0]*(n+1)\n        dp[0]=0\n        for i in range(1,n+1):\n            j=1\n            minn=sys.maxsize \n            while j*j<=i:\n                minn=min(dp[i-j*j],minn)\n                j+=1\n            dp[i]=minn+1 # 超分成i-j*j的子集+j的情况，这个1就是代表j\n        # print(dp)\n        return dp[n]\n\n```\n\n\n\n### 背包问题\n\n**第一步要明确两点，「状态」和「选择」**。只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。**所以状态有两个，就是「背包的容量」和「可选择的物品」**。\n\n对于每件物品，你能选择什么？**选择就是「装进背包」或者「不装进背包」嘛**。\n\n**第二步要明确 `dp` 数组的定义**。\n\n两个状态->一个二维dp数组\n\n`dp[i][w]` 的定义如下：对于前 `i` 个物品，当前背包的容量为 `w`，这种情况下可以装的最大价值是 `dp[i][w]`。 (前i个任取，放到w容量的背包)\n\n比如说，如果 `dp[3][5] = 6`，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。\n\n根据这个定义，我们想求的最终答案就是 `dp[N][W]`。base case 就是 `dp[0][..] = dp[..][0] = 0`，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。\n\n**第三步，根据「选择」，思考状态转移的逻辑**。\n\n**如果你没有把这第 `i` 个物品装入背包**，那么很显然，最大价值 `dp[i][w]` 应该等于 `dp[i-1][w]`，继承之前的结果。\n\n**如果你把这第 `i` 个物品装入了背包**，那么 `dp[i][w]` 应该等于 `val[i-1] + dp[i-1][w - wt[i-1]]`。(定义i从1开始，所以 `val[i-1]` 和 `wt[i-1]` 表示第 `i` 个物品的价值和重量)\n\n```python\n# 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。\n# 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 java 代码对比查看。\n\ndef knapsack(W: int, N: int, wt: List[int], val: List[int]) -> int:\n    assert N == len(wt)\n    # 初始化一个二维数组，用于存储状态\n    # dp[i][j] 表示将前 i 个物品装入容量为 j 的背包中所获得的最大价值\n    dp = [[0] * (W + 1) for _ in range(N + 1)]\n    # 开始进行递推\n    for i in range(1, N + 1):\n        for w in range(1, W + 1):\n            if w - wt[i - 1] < 0:\n                # 当前商品 i 的重量已经超过了 w，无法被放入当前容量为 w 的背包中，只能选择不装入背包\n                dp[i][w] = dp[i - 1][w]\n            else:\n                # 当前商品 i 的重量小于等于当前容量 w，可以尝试将其放入背包中\n                # 取最大值，考虑是将其放入之前的最优方案中还是选择不放\n                dp[i][w] = max(\n                    dp[i - 1][w - wt[i - 1]] + val[i - 1],# 放第i个物品，那么就要从i-1个物品中加上第i个，注意重要要从当前的减去第i个物品的开始加.同时，因为val从0开始放，所以第i个重量是val[i-1]\n                    dp[i - 1][w] # 啥都不放\n                )\n    # 返回最大价值\n    return dp[N][W]\n\n```\n\n#### 简化版背包\n\n**值得思考的简化版背包**\n\n设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。\n\n问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。\n\n如果有满足条件的选择，则此背包有解，否则此背包问题无解。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//int dp[1001][1001];//代表前i 个物品背包容量最大为j 最多能装的物品总重量\nint dp[1005][1005]={0}; \nint ths[1005];\nint main(){\n\tint s,n;\n\twhile(scanf(\"%d%d\",&s,&n)!=EOF){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&ths[i]);\n\t\t}\n\t\tmemset(dp, 0, sizeof(dp));//必要清空 \n\t\tdp[0][0]=1;//前i件物品凑成重量0可行性为1 \n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=s;j>=0;j--){\n\t\t\t\tif(dp[i-1][j]==1) dp[i][j]=1;//前i-1已经可以满足\n\t\t\t\tif(j>=ths[i-1]&&dp[i-1][j-ths[i-1]]==1) dp[i][j]=1;//能够凑成 \n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(dp[n][s]==1) printf(\"YES\\n\");\n\t\telse printf(\"NO\\n\");\n\t}\n\t\n\treturn 0;\n}\n```\n\n\n\n### 状态压缩\n\n\n\n## 数论\n\n### 质数\n\n**判断素数**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\t//注意1的情况\n\tif(n==1) {\n\t\tprintf(\"2\"); \n\t\treturn 0;\n\t}\n\tfor(int i=n;;i++){//它本身如果是，直接输出，否则它+1开始找！\n\t\t//输出大于整数的素数\n\t\t int flag=0;\n\t\t for(int j=2;j<sqrt(n);j++){//判断素数 \n\t\t \tif(i%j==0){\n\t\t \t\tflag=1;\n\t\t \t\tbreak;\n\t\t\t } \n\t\t }\n\t\t if(flag==0){//是素数，输出 \n\t\t \tprintf(\"%d\",i);\n\t\t \tbreak;\n\t\t }\n\t\t //不是的话就从+1开始找 \n\t}\n\t\n\treturn 0;\n}\n```\n\n**分解质因素**\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n//质因素个数 \nint main(){\n\tint N;\n\tint nums[1001];\n\twhile(scanf(\"%d\",&N)!=EOF){\n\t\tint cnt=0;\n\t\tint i=2;\n\t\twhile (i*i<=N){\n\t\t\tif(N%i==0){\n\t\t\t\tnums[cnt++]=i;\n\t\t\t\tN/=i;\n\t\t\t}else{\n\t\t\t\ti+=1;\n\t\t\t}\n\t\t}\n\t\t//最后跳出循环的N结果如果大于1就是一个素数 \n\t\tif(N>1){\n\t\t\tnums[cnt++]=N;\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t\tfor(int i=0;i<cnt;i++)\n\t\t\tprintf(\"%d \",nums[i]);\n\t}\n\treturn 0;\n}\n```\n\n\n\n```python\n# 分解质因素\ndef prime_factor(num):\n    factors = []\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            factors.append(i)\n            num = num // i\n        else:\n            i += 1\n    if num > 1:\n        factors.append(num)\n    return factors\n\n# 或者 用于统计质因数指数\nn=int(input())\ni=2\nwhile i*i<=n:\n    while not n%i:\n        n//=i\n        print(i,end=' ')\n\nif n!=1:\n    print(n)\n```\n\n\n\n### **背住最大公约数，最小公倍数，Floyd 算法！！！**\n\n最小公倍数* 最大公约数 = 两数乘积 ，即 `x*y=LCM(x, y)*GCD(x, y)`。而最大公约数可以使用[辗转相除法](https://zhuanlan.zhihu.com/p/31824895#:~:text=辗转相除法， 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。,它是已知最古老的算法， 其可追溯至公元前300年前。 这条算法基于一个定理： 两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。)求解。\n\n```python\n# 最大公倍数、最小公约数\n#最大公约数和最小公倍数\na = int(input('请输入第一个数: '))\nb = int(input('请输入第二个数: '))\nMin = min(a,b)\nGys = 1\nfor i in range(1,int(Min+1)):\n    if a%i == 0 and b%i == 0:\n        Gys = i\nprint('最大公约数为：%d' %Gys)\nGbs = a*b / Gys\nprint('最小公倍数为:%d' %Gbs)\n\n```\n\n辗转相除法基于原理“**两个整数的最大公约数等于其中较小值与两数相除余数的最大公约数**\n\nGCD(a,b)=GCD(b,a%b)\n\n```python\na = int(input('请输入第一个数: '))\nb = int(input('请输入第二个数: '))\nm,n=a,b\nif a<b:\n    m,n=b,a\nr=m%n\nwhile n!=0:\n    m=n\n    n=r\n    r=m%n\nprint(n)\n```\n\n```c++\n//如果结果为1，说明二者是最简真分数\nint gcd(int a,int b){\n\tif(b==0) return a;//结束\n\telse return gcd(b,a%b);//辗转相除 \n}\n```\n\nFloyd算法\n\n原理很简单：\n一个点 i 到另一个点 j 的最短路径无非有两种：\n\n1. 直接到达( i --> j )\n2. 通过走其他点(k1, k2 … kn)，一个或多个点到达（ i --> k1–>k2–> … --> j )\n\n```python\nfor k in range(n):\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tgraph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n```\n\n### 完全平方数\n\n数论问题，一个整数 �*a* 是一个完全平方数，是指它是某一个整数的平方，即存在一个 整数 �*b*，使得 �=�2*a*=*b*2 。\n\n给定一个正整数 �*n*，请找到最小的正整数 �*x*，使得它们的乘积是一个完全平方数。\n\n一个完全平方数，他的质因数的指数都是偶数\n\n所以要凑的话，就得分解质因数，不是偶数的补上，一直乘\n\n留意未分尽的情况\n\n```python\nn = int(input())\ni = 2\ncnt = 0\nres = 1\nwhile i * i <= n:\n    cnt = 0\n    while not n % i:\n        n //= i\n        cnt += 1\n    if cnt % 2:\n        res *= i\n    i+=1\n\nif n != 1:\n    res *= n\n\nprint(res)\n\n```\n\n## 高精度\n\nstring[0]输出反而代表数字的高位，\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring couculate(string a,string b){\n\tint carry=0;//计算进位\n\tif(a.length()<b.length()) a.swap(b);\n\tstring res(a.length(),0);//设置\n\tb.insert(0,a.length()-b.length(),'0');//较短的字符补0 \n\tfor(int i=a.length()-1;i>=0;i--){\n\t\tint sum=(a[i]-48)+(b[i]-48)+carry;\n\t\tcarry=sum/10;\n\t\tres[i]=sum%10+48;\n\t}\n\tif(carry!=0){\n\t\tres.insert(res.begin(),carry+48);\n\t}\n\treturn res;\n\t\n}\n\nint main(){\n\tstring a,b;\n\twhile(cin>>a>>b){\n\t\tcout<<couculate(a,b)<<endl;\n\t}\n\t\n\treturn 0;\n} \n```\n\n\n\n# SCNUOJ\n\n## P01 最大二叉树\n\n* 读取，构造二叉树\n* 构造最大二叉树\n  * 特殊情况--只有一个元素\n  * 找最大值\n  * 判左右是否空，左右递归\n  * 返回根节点\n* 前序遍历函数\n  * 终止情况：为空结点，返回\n  * 排除叶子结点情况\n  * 其他：输出结点，递归左右\n\n```c++\n// 最大二叉树\n#define _CRT_SECURE_NO_WARNINGS\n# include<iostream>\n# include<vector>\nusing namespace std;\n//定义二叉树\nstruct TreeNode\n{\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    //无参\n    TreeNode() :val(0), left(nullptr), right(nullptr) {}\n    //有参\n    TreeNode(int x) :val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) :val(x), left(left), right(right) {}\n};\n//前序遍历\nvoid PreOrder(TreeNode* tr) {\n    if (tr == NULL) {\n        cout << \"null\" << \" \";\n        return;\n    }\n    //叶子节点的两个子空节点要去掉不输出！否则会多输出一对null\n    else if (tr->left == NULL && tr->right == NULL) {\n        cout << tr->val<<\" \";\n        return;\n    }\n    else {\n        cout << tr->val << \" \";\n        PreOrder(tr->left); //递归左子树\n        PreOrder(tr->right); //递归右子树\n    }\n}\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        TreeNode* node = new TreeNode(0);\n        if (nums.size() == 1) {\n            //只有一个元素，直接返回\n            node->val = nums[0];\n            return node;\n        }\n        //中间找最大\n        int maxValue = 0;\n        int maxValueIndex = 0;//找最大值\n        for (int i = 0; i < nums.size(); i++)\n        {\n            if (nums[i] > maxValue) {\n                maxValue = nums[i];\n                maxValueIndex = i;\n            }\n        }\n        node->val = maxValue;\n        //左边还有元素\n        if (maxValueIndex > 0)\n        {\n            //newVec左闭右开\n            vector<int> newVec(nums.begin(), nums.begin() + maxValueIndex);\n            //左子树的构造就是对左边递归\n            node->left = constructMaximumBinaryTree(newVec);\n        }\n        if (maxValueIndex < (nums.size() - 1)) {\n            //右边递归\n            vector<int> newVec(nums.begin() + maxValueIndex + 1, nums.end());\n            node->right = constructMaximumBinaryTree(newVec);\n            \n        }\n        return node;\n\n    }\n};\n\nint main() {\n    int a ;\n    vector<int> nums;\n    //读取\n    while (scanf(\"%d\", &a) != EOF) {\n        nums.push_back(a);\n    }\n    Solution s1;\n    TreeNode *re;\n    re=s1.constructMaximumBinaryTree(nums);\n    PreOrder(re);\n    return 0;\n}\n```\n\n## ！P02. [算法课分治] 寻找多数\n\n```c++\n//寻找多数\n#include<iostream>\nusing namespace std;\n//返回特定元素在特定数组中出现的次数\nint traverse(int nums[], int pivot, int left, int right) {\n\tint num = 0;\n\tfor (int i = left; i <= right; i++) {\n\t\tif (nums[i] == pivot) num++;\n\t}\n\treturn num;\n}\nint findM(int nums[], int left, int right) {\n\t//规模为1直接求解\n\tif (left == right) return nums[left];\n\t//分解\n\tint mid = (left + right) / 2;\n\tint leftNum = findM(nums, left, mid);\n\tint rightNum = findM(nums, mid+1, right);\n\t//当前数组的解为两个数组解在当前数组出现次数较大的解\n\tif (leftNum == rightNum) return leftNum;\n\telse {\n\t\tint lcount = traverse(nums, leftNum, left, right);\n\t\tint rcount = traverse(nums, rightNum, left, right);\n\t\treturn lcount > rcount ? leftNum : rightNum;\n\t}\n}\n\nint main() {\n\t//读取\n\tint n;\n\tint nums[10001] = { 0 };\n\tcin >> n;\n\tint a;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a;\n\t\tnums[i] = a;\n\t}\n\tcout << findM(nums, 0, n - 1);\n\treturn 0;\n}\n```\n\n## P03. [算法课分治] 找到最大子序和\n\n```c++\n#include<iostream>\n#include<vector>\n#include <climits>\nusing namespace std;\n\nint getMaxNum(int a, int b, int c) {\n    if (a > b && a > c) {\n        return a;\n    }\n    if (b > a && b > c) {\n        return b;\n    }\n    return c;\n}\nint maxSumRec(int data[], int left, int right) {\n    if (right - left == 1) {\n        //如果当前序列只有一个元素\n        return data[left];\n    }\n    int center = (left + right) / 2;//计算当前序列的分裂点\n    int maxLeftSum = maxSumRec(data, left, center);\n    int maxRightSum = maxSumRec(data, center, right);\n    //计算左边界最大子序列和\n    int leftBonderSum = 0;\n    int maxLeftBonderSum = data[center - 1];\n    for (int i = center - 1; i >= left; i--) {\n        leftBonderSum += data[i];\n        if (maxLeftBonderSum < leftBonderSum) {\n            maxLeftBonderSum = leftBonderSum;\n        }\n    }\n    //计算右边界最大子序列和\n    int rightBonderSum = 0;\n    int maxRightBonderSum = data[center];\n    for (int i = center; i < right; i++) {\n        rightBonderSum += data[i];\n        if (maxRightBonderSum < rightBonderSum) {\n            maxRightBonderSum = rightBonderSum;\n        }\n    }\n    //返回当前序列最大子序列和\n    return getMaxNum(maxLeftBonderSum + maxRightBonderSum, maxLeftSum, maxRightSum);\n}\nint main() {\n\tint n;\n\tint v1[1000000];\n\tcin >> n;\n\tint t;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> t;\n\t\tv1[i]=t;//读入\n\t}\n\t\n    cout<<maxSumRec(v1, 0, n);\n}\n```\n\n## P04. [算法课分治] 找到 k 个最小数\n\n就是一个快速排序\n\n```c++\n#include<iostream>\nusing namespace std;\n\nint part(int* a, int low, int height) {\n\tint i = low, j = height, pviot = a[low]; //这里是low就要从j开始，要从i开始就得是height\n\twhile (i < j) {\n\t\t\n\t\twhile (a[j]>pviot&&i<j)\n\t\t{\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(a[i++], a[j]);//交换后i后移\n\t\t}\n\t\twhile (a[i] < pviot && i < j)\n\t\t{\n\t\t\ti++;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(a[i], a[j--]);//交换后，j前移\n\t\t}\n\t}\n\treturn i;//返回最终划分完成后基准元素所在的位置\n}\nvoid Quicksort(int* a, int low, int height) {\n\tint mid;\n\tif (low < height) {\n\t\tmid = part(a, low, height);\n\t\t//分治\n\t\tQuicksort(a, low, mid - 1);\n\t\tQuicksort(a, mid + 1, height);\n\t}\n}\nint main() {\n\tint n,a,k;\n\tint nums[10001] = { 0 };\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a;\n\t\tnums[i] = a;\n\t}\n\tQuicksort(nums, 0, n - 1);\n\tfor (int i = 0; i < k; i++) {\n\t\tcout << nums[i] << \" \";\n\t}\n\treturn 0;\n}\n```\n\n\n\n## P05. [算法课分治] 寻找第 k 个最大元素\n\n```c++\n#include<iostream>\n\nusing namespace std;\n\nint part(int* a, int low, int height) {\n\tint i = low, j = height, pviot = a[low];\n\twhile (i < j) {\n\t\twhile (a[j] > pviot && j > i) {\n\t\t\tj--;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(a[i++], a[j]);//交换后，i后移\n\t\t}\n\t\twhile (a[i] < pviot && i < j) {\n\t\t\ti++;\n\t\t}\n\t\tif (i < j) {\n\t\t\tswap(a[i], a[j--]);\n\t\t}\n\t\t\n\t}\n\treturn i;//返回最终划分完成后基准元素所在的位置\n}\n\nvoid Quicksort(int *a, int low,int height) {\n\tint mid;\n\tif (low < height) {\n\t\tmid = part(a, low, height);\n\t\tQuicksort(a, low, mid - 1);\n\t\tQuicksort(a, mid + 1, height);\n\t}\n}\nint main() {\n\t//数据读取\n\tint len, k;\n\tint a[1000];\n\tint t;\n\tcin >> len >> k;\n\tfor (int i = 0; i < len; i++) {\n\t\tcin >> t;\n\t\ta[i] = t;\n\t}\n\t//快速排序\n\tQuicksort(a, 0,len-1);\n\tcout << a[len-k];\n}\n```\n\n## P06. [算法课动态规划]走网格\n\n```c++\n//棋盘\n#include<iostream>\nusing namespace std;\n\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\tint dp[11][11] = { 0 };\n\tdp[1][1] = 1;\n\t//初始化\n\tfor (int i = 1; i <= m; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tif (i == 1 || j == 1) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout << dp[m][n];\n\treturn 0;\n}\n```\n\n## P07. [算法课动态规划]爬楼梯\n\n```c++\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\tint dp[21];\n\tdp[0] = 1;\n\tdp[1] = 1;//零一阶都是只有一种方法达到\n\tcin >> n;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t}\n\tcout << dp[n];\n\treturn 0;\n}\n```\n\n## P08. [算法课动态规划]背包问题\n\n- **不放物品i**：由dp\\[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp\\[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)\n- **放物品i**：由dp\\[i - 1][j - weight[i]]推出，dp\\[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp\\[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值\n\n```c++\n//背包问题\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n\tint weight[] = { 7,3,4,5 };\n\tint value[] = { 42,12,40,25 };\n\tint wetLen,cap;\n\tcin >> wetLen >> cap;\n\tint dp[11][11] = { 0 };\n\tfor (int i = weight[0]; i <= cap; i++) {\n\t\t//能放物品1的进行初始化\n\t\tdp[0][i] = value[0];\n\t}\n\t//遍历物品\n\tfor (int i = 1; i <= wetLen; i++) {\n\t\t//遍历背包容量\n\t\tfor (int j = 1; j <= cap; j++) {\n\t\t\tif (j < weight[i-1]) dp[i][j] = dp[i - 1][j];//放不进，就是不妨上一个物品\n\t\t\telse dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i-1]] + value[i-1]);//放的进就是比较上一个和放进这个的大小\n\n\t\t}\n\t}\n\tcout << dp[wetLen][cap];\n\n\treturn 0;\n}\n```\n\n## P09 最长回文子串\n\n```c++\n/Problem P09. [算法课动态规划]最长回文子串\n\n#include<iostream>\n#include<string>\nusing namespace std;\nint dp[1001][1001] = { 0 };\nint main() {\n\tstring s1;\n\tcin >> s1;\n\t\n\t//对角线为1\n\tfor (int i = 0; i < s1.size(); i++) {\n\t\tfor (int j = 0; j < s1.size(); j++) {\n\t\t\tif (i == j) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = s1.size()-1; i < s1.size(); i--) {\n\t\tfor (int j = i ; j < s1.size(); j++) {\n\t\t\t//少了一个判断是两个字符的情况\n\t\t\tif (s1[i] == s1[j]) {\n\t\t\t\t//两个字符\n\t\t\t\tif (j - i <= 1) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t\telse if (dp[i + 1][j - 1] == 1) {\n\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//找最长的，记录下来\n\tint maxI = 0, maxJ = 0, maxdis = 0;\n\tfor (int i = 0; i < s1.size(); i++) {\n\t\tfor (int j = i; j < s1.size(); j++) {\n\t\t\tif (j - i > maxdis&&dp[i][j]==1) {\n\t\t\t\tmaxI = i;\n\t\t\t\tmaxJ = j;\n\t\t\t\tmaxdis = j - i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int z = maxI; z <= maxJ; z++) {\n\t\tcout << s1[z];\n\t}\n\n\treturn 0;\n}\n```\n\n\n\n## P10 连续数组最大\n\n```c++\n//Problem P10.[算法课动态规划]连续数组最大和\n\n#include<iostream>\n\nusing namespace std;\nint main() {\n\tint n;\n\tint a[51] = { 0 };\n\tint dp[51][51] = { 0 };\n\tcin >> n;\n\tint p;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> p;\n\t\ta[i] = p;\n\t}\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int j = i; j < n; j++) {\n\t\t\tif (i == j) dp[i][j] = a[i];\n\t\t\telse dp[i][j] = dp[i + 1][j - 1] + a[i] + a[j];//加端点\n\t\t}\n\t}\n\tint max=0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (dp[i][j] > max) {\n\t\t\t\tmax = dp[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << max;\n\n\treturn 0;\n}\n```\n\n\n\n## ⭐P11 最长公共子序列\n\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint dp[1001][1001] = { 0 };\nint main() {\n\tstring s1, s2;\n\tcin >> s1>>s2;\n\t//空出一个外围，非则会越界\n\tfor (int i = 1; i <= s1.size(); i++) {\n\t\tfor (int j = 1; j <= s2.size(); j++) {\n            //注意i，i都要退一个\n            //如果当前字母想都，就是左上角加上1\n\t\t\tif (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n            //如果不同，找左边或者上边的最大值\n\t\t\telse {\n\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[s1.size()][s2.size()];\n\treturn 0;\n}\n```\n\n## P12 贪婪 6和9组成的最大数字\n\n简单跳过\n\n## P13 贪婪 三角形的最大周长\n\n给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。如果不能形成任何面积不为零的三角形，返回 0。\n\n- 3 <= A.length <= 1000\n- 1 <= A[i] <= 1000\n\n```c++\n//Problem P13. [算法课贪婪]三角形的最大周长\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint v;\n\tint a[1001] = { 0 };\n\tint count = 0;\n\twhile (scanf(\"%d\", &v) != EOF) {\n\t\ta[count] = v;\n\t\tcount++;\n\t}\n\t//对a进行排序 冒泡排序 降序\n\tfor (int i = 0; i < count; i++) {\n\t\tfor (int j = 0; j < count - 1 - i; j++) {\n\t\t\tif (a[j] < a[j + 1]) {\n\t\t\t\tint temp = a[j];\n\t\t\t\ta[j] = a[j + 1];\n\t\t\t\ta[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n\tint mark = 0;\n\tfor (int i = 0; i + 3 <= count; i ++) {\n\t\tif (a[i + 1] + a[i + 2] > a[i] && a[i] - a[i + 1] < a[i + 2]) {\n\t\t\tcout << a[i] + a[i + 1] + a[i + 2];\n\t\t\tmark = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mark == 0) {\n\t\tcout << 0;\n\t}\n\treturn 0;\n}\n```\n\n用sort\n\n```c++\n\n```\n\n\n\n## P14 蛮力 种花问题\n\n假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。\n\n给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。\n\n提示：\n\n- 1 <= flowerbed.length <= 2 * 10^4\n\n- flowerbed[i] 为 0 或 1\n\n- flowerbed 中不存在相邻的两朵花\n\n- 0 <= n <= flowerbed.length\n\n  \n\n```c++\n//Problem P14.[算法课蛮力法]种花问题\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\nint v[100001] = { 0 };\nint main() {\n\tchar a;\n\n\tint nums=0;\n\tint count = 0;\n\twhile (scanf(\"%c\", &a) != '\\n') {\n\t\tif (a != ' ') {\n\t\t\tv[count] = a-'0';\n\t\t\tcount++;\n\t\t}\n\t\tif (a == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\tcin >> nums;\n\t//nums=v[count-1];//最后一个就是插入总数\n\tcount--;//去掉最后一个总数的\n\t/*cout << \"nums:\" << nums<<'\\n';\n\tcout << \"count:\" << count << '\\n'; cout << \"v[count+1]:\" << v[count+1] << '\\n';*/\n\t//只有一个花坛\n\tif (nums <= 0) {\n\t\tcout << \"true\";\n\t\treturn 0;\n\t}\n\tif (count == 1) {\n\t\tif (v[0] == 0 && nums == 1) {\n\t\t\tcout << \"true\";\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\t\n\t}\n\t//第一个和最后一个特殊情况 先种最左和最右\n\tif (count >= 2) {\n\t\tif (v[0] == 0 && v[1] == 0) {\n\t\t\tnums--;\n\t\t\tv[0] = 1;\n\t\t}\n\t\tif ( v[count - 1] == 0 && v[count - 2] == 0) {\n\t\t\tnums--;\n\t\t\tv[count - 1] = 1;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i < count-1; i++) {\n\t\t\n\t\t//开始从左往右有位置就种\n\t\t\n\t\tif (v[i - 1] == 0 && v[i + 1] == 0&&v[i]==0) {\n\t\t\tv[i] = 1; //种上后要赋值\n\t\t\tnums--;\n\t\t}\n\t}\n\tif (nums<=0) {\n\t\tcout << \"true\";\n\t}\n\telse {\n\t\tcout << \"false\";\n\t}\n\t//cout << '\\n';\n\t/*for (int i = 0; i < count; i++)\n\t\tcout << v[i] << \" \";*/\n\t//cout << '\\n';\n\t//cout << \"最后一个数\" << v[count - 1] << '\\n';\n\t// 真的猪啊，nums在前面经历过--操作，你在这里调试输出肯定对应不上原始值啊！！\n\t//cout << \"转换到的最后一个\" << nums << '\\n';\n\t//cout << \"总数\" << count;\n\treturn 0;\n}\n```\n\n## ❗P15 贪婪 移掉K位数字(有一步没搞懂)\n\n给你一个以字符串表示的非负整数 **num** 和一个整数 **k** ，移除这个数中的 **k** 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。\n\n- 1 <= k <= num.length <= 1000\n- num 仅由若干位数字（0 - 9）组成\n- 除了 0 本身之外，num 不含任何前导零\n\n```c++\n//\n// Created by chan on 2023/12/13.\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nint main(){\n    int k=0;\n    int count;\n    string v;\n    cin>>v>>k;\n\n    //开始遍历\n    for(int i=0;i<v.size();i++){\n        while(k>0&&v.size()>0&&v[i]>v[i+1]){\n            //前一个大于后一个\n            v.erase(i,1);\n            if(i>0) i--;\n            k--;\n        }\n    }\n    if(k>0&&v.size()){\n        v.pop_back();\n        k--;\n    }\n    //去除前导0\n    int i=0;\n    while(v[i]=='0'&&v.size()>0){\n        v.erase(i,1);\n    }\n    if(v.size()==0){\n        cout<<\"0\";\n    }else{\n        cout<<v;\n    }\n\n    return 0;\n}\n```\n\n## P16 贪婪 盛最多的水\n\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器。\n\n```c++\n// Problem P16.[算法课贪婪]盛最多的水\n// 思路从最远两边往里收缩，不是同时收缩，是一边一边收缩，记录最大\n#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<vector>\nusing namespace std;\nint main() {\n\t//找第一长，和所有其他的算，再找第一二长和所有其他的算。。。\n\tchar n;\n\tint len = 0;\n\tvector<int> v;\n\tint i;\n\twhile (cin >> i) {\n\t\tv.push_back(i);\n\t\tif (cin.get() == '\\n') break;\n\t}\n\n\tint l = 0,r=v.size()-1;\n\tint ans = 0, area = 0;\n\twhile (l < r) {\n\t\tarea = min(v[l], v[r]) * (r - l);//面积\n\t\tans=max(ans,area);\n\t\t//小的一边收缩\n\t\tif (v[l] < v[r]) {\n\t\t\tl++;\n\t\t}\n\t\telse {\n\t\t\tr--;\n\t\t}\n\t}\n\tcout << ans;\n\treturn 0;\n}\n```\n\n\n\n## P17 回溯 括号生成 void backTracking(int left, int right, string curstr)\n\n```c++\n//Problem P17.[算法课回溯]括号生成\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint n;\nvector<string> strs;//放string的数组\nvoid backTracking(int left, int right, string curstr) {\n\t//递归结束条件\n\tif (right == 0 && left == 0) {\n\t\tstrs.push_back(curstr);\n\t\treturn;\n\t}\n\t//当剩余左边括号小于或等于右边时，才满足\n\tif (left <= right && left >= 0) {\n\t\tbackTracking(left - 1, right, curstr + \"(\");//放左\n\t\tbackTracking(left, right - 1, curstr + \")\");//放右\n\t}\n}\nint main() {\n\tcin >> n;\n\tbackTracking(n, n, \"\");\n\tcout << \"[\";\n\tfor (int i = 0; i < strs.size(); i++) {\n\t\tcout << strs[i];\n\t\tif (i != strs.size() - 1) {\n\t\t\tcout << \", \";\n\t\t}\n\t}\n\tcout << \"]\";\n\treturn 0;\n}\n```\n\n## P18 回溯 目标和 void check(int nums[], int tar, int n) \n\n给你一个整数数组 nums 和一个整数 target 。\n\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n\n例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n\n提示：\n\n- 1 <= nums.length <= 20\n- 0 <= nums[i] <= 1000\n- 0 <= sum(nums[i]) <= 1000\n- -1000 <= target <= 1000\n\n\n\n```c++\n//\n// Created by chan on 2023/12/13.\n//\n//Problem P18. [算法课回溯]目标和\n#include<iostream>\nusing namespace std;\n\n\nint count = 0;\nint tsize = 0;\n//数组 目标和 参与个数\nvoid check(int nums[], int tar, int n) {\n    if (tar == 0 && n == tsize) count++;\n    if (n == tsize) return;//不满足但是退出\n    check(nums, tar - nums[n], n + 1);\n    check(nums, tar + nums[n], n + 1);\n}\n\n\n\n\nint main() {\n    int nums[21];\n    int target = 0;\n    int a;\n    int size=0;\n    while (cin>>a)\n    {\n        nums[size] = a;\n        size++;\n        if (cin.get() == '\\n') break;\n    }\n    cin >> target;\n    tsize=size;\n    check(nums,target,0);\n    cout<<count;\n    return 0;\n}\n```\n\n\n\n## P19 回溯 电话号码的字母组合 void backtracking(const string& s,int index,string curStr) 输入序列 序列号 可能组合\n\n给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案按**字母顺序**返回。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n![img](https://oj.socoding.cn/uploads/20211104/16360198642759.png)\n\n```c++\n#include <iostream>\n#include<string>\n#include <vector>\nusing namespace std;\n//const char chara[][4]={{'a','b','c'},{'d','e','f'},{'g','h','i'},{'j','k','l'},{'m','n','o'},{'p','q','r','s'},{'t','u','v'},{'w','x','y','z'}};\nconst string chara[8] = {\n        \"abc\", // 2\n        \"def\", // 3\n        \"ghi\", // 4\n        \"jkl\", // 5\n        \"mno\", // 6\n        \"pqrs\", // 7\n        \"tuv\", // 8\n        \"wxyz\", // 9\n};\nvector<string> strs;\n//标记当前是遍历到第几个\n//_ _ x记录遍历到第几个，n记录第x个位置\nvoid backtracking(const string& s,int index,string curStr){\n    if(index==s.size()){//当这个满足时，说明前面的坑都填完了\n        //三个位置都放好了\n        strs.push_back(curStr);\n        return;\n    }\n    int num=s[index]-'0'-2;//转为数值 取序号\n    string letter=chara[num];\n    for(int i=0;i<letter.size();i++){\n        curStr.push_back(letter[i]);\n        backtracking(s,index+1,curStr);//递归\n        curStr.pop_back();//回溯\n    }\n}\n\nvector<string> printPar(string s){\n    if(s.size()==0){\n        return strs;\n    }\n    backtracking(s,0,\"\");\n    return strs;\n}\n\nint main() {\n    //7,9长度是4，其他都是3\n    string s1;\n    cin>>s1;\n    printPar(s1);\n    cout<<\"[\";\n    for(int i=0;i<strs.size();i++){\n        cout<<strs[i];\n        if(i<strs.size()-1) cout<<\", \";\n    }\n    cout<<\"]\";\n    return 0;\n}\n```\n\n\n\n## P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度\n\n假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：\n\n- perm[i] 能够被 i 整除\n- i 能够被 perm[i] 整除\n\n给你一个整数 n ，返回可以构造的 优美排列 的 数量 。\n\n提示：\n\n- 1 <= n <= 15\n\n```c++\n//Problem P20. [算法课回溯]优美的排列\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n//int number[]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\nvector<int> vis=vector<int>(20,0);//标记作用\nint res=0;\nvoid backtracking(int pos, int n){\n    if(pos>n) {\n        res++;\n    \treturn;\n    }\n    for(int i=1;i<=n;i++){\n        if(vis[i]) continue;\n        if(pos%i==0||i%pos==0){\n            vis[i]=1;//访问\n            backtracking(pos+1,n);\n            vis[i]=0;//回溯\n        }\n    }\n\n}\n\nusing namespace std;\nint main(){\n    //1-n所有排列的组合，边凑数，进行判断，如果不满足，置标记为false，直接排除当前情况\n    int n;\n    cin>>n;\n    backtracking(1,n);\n    cout<<res;\n    return 0;\n}\n```\n\n\n\n## P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置\n\n```c++\n//\n// Created by chan on 2023/11/8.\n//\n#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> path;\nvector<vector<int>> result;\nvoid backTracking(int n,int k,int startIndex){\n    //n是氛围，k是个数，startIndex记录遍历到那个数了\n    if(path.size()==k){//到叶子了，收割结果\n        result.push_back(path);\n        return;\n    }\n    for (int i = startIndex; i <=n ; ++i) {\n        path.push_back(i);\n        //递归\n        backTracking(n,k,i+1);\n        path.pop_back();//回溯\n    }\n}\nint main(){\n    int tar[21][21]={0};\n    int n,k;\n    cin>>n>>k;\n    backTracking(n,k,1);\n    for (int i = 0; i < result.size(); ++i) {\n        for (int j = 0; j < result[i].size(); ++j) {\n            cout<<result[i][j]<<\" \";\n        }\n        cout<<'\\n';\n    }\n    return 0;\n}\n```\n\n## P22 回溯 大礼包\n\n\n\n```c++\n//\n// Created by chan on 2023/11/8.\n//\n#include <iostream>\n#include <vector>\nusing namespace std;\nvector<int> goods;//商品即对应价格\nvector<vector<int>> special;//存放大礼包\nvector<int> need;//需要的各个商品数量\n\nint specialn=0;//礼包种类数\nint backTracking(vector<int> n){//n为need\n    int ans=0;//此层决策要花多少钱\n    for(int i=0;i<n.size();i++){\n        ans+=goods[i]*n[i];//先不考虑买礼包\n    }\n    for (int i = 0; i < specialn; ++i) {//遍历礼包\n        vector<int> tmp(n);//复制一遍需求，暂存\n        int size_1bag=special[i].size();//礼包的大小\n        int price=special[i][size_1bag-1];//存入礼包价格\n        bool is_valid= true;//是否能买当前礼包\n        for (int j = 0; j < size_1bag-1; ++j) {//遍历礼包的物品列表\n            if(special[i][j]>n[j]){\n                //有一个不满足\n                is_valid= false;\n                break;\n            }\n            tmp[j]-=special[i][j];//能买的话更新\n        }\n        if (is_valid){//能买礼包\n            price+= backTracking(tmp);//当前礼包加上剩下需求所需的钱\n            ans= min(ans,price);\n        }else{//不能买礼包，换下一个\n            continue;\n        }\n    }\n    return ans;\n}\nint main(){\n    //读取\n    //\n    // 假设有n个大礼包\n    // 最基本的：一个大礼包都不买\n    // 遍历所有大礼包包括自己（递归)\n    /*\n     * 终止条件：它加下一个礼包超出了数量\n     * 首先大礼包的物品数要都小于目标数据\n     * 不满足，则跳过，递归\n     * 满足，则加入，算出总价，递归\n     * 检查是否到最后一个大礼包\n     *  是，判断还剩多少，用则用基本物品价格去补充\n     * 问题:这里的k你不知道？即礼包的个数不定\n     */\n    vector<int> init;\n    int n;\n    while(cin>>n){\n        init.push_back(n);\n        if(cin.get()=='\\n') break;\n    }\n    //前size-1都是商品\n    for (int i = 0; i < init.size()-1; ++i) {\n        goods.push_back(init[i]);\n    }\n    int speciallen=init[init.size()-1];\n\n    for(int i=0;i<speciallen;i++){\n        vector<int> save;\n        for(int j=0;j<goods.size()+1;j++){\n            cin>>n;\n            save.push_back(n);\n        }\n        special.push_back(save);\n    }\n    for(int i=0;i<goods.size();i++){\n        cin>>n;\n        need.push_back(n);\n    }\n\n    specialn=special.size();\n\n    cout<< backTracking(need);\n    return 0;\n}\n```\n\n## P23 计数排序\n\n![image-20231212144444548](JJ的算法之旅.assets/image-20231212144444548.png)\n\n```c++\n//\n// Created by chan on 2023/11/15.\n// 计数排序\n#include <iostream>\nusing namespace std;\n#define N 10000000\nint a[N],b[N],c[N]={0};\nint n=0,m=0,bi=0;\nint mod=1e9+7;\nlong long ans;\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&a[i]);\n        ++c[a[i]]; //这里按序号赋值，本身就已经有序了，不用排序了\n    }\n    for(int i=1;i<=m;++i){\n        for(int j=1;j<=c[i];++j){\n            b[++bi]=i;//重复的a[i]进行排序 0的话自动跳过了巧妙\n        }\n    }\n    for(int i=1;i<=n;++i){\n        (ans+=1LL*i*b[i])%=mod;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n\n}\n```\n\n## P24 贪心 跳跃游戏\n\n给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度\n\n判断你是否能够到达最后一个下标。\n\n```c++\n#include <iostream>\nusing namespace std;\nint num[100001]={0};\nint main(){\n    int a;\n    int size=0;\n    while(cin>>a){\n        num[size]=a;\n        size++;\n        if(cin.get()=='\\n') break;\n    }\n    int latTar=0;//上一个0\n    int curTar=0;//标记当前出现0的位置\n    bool flag=true;//能到最后的标记\n    if (num[0]==0){\n        cout<<\"false\";\n        return 0;\n    }\n    for(int i=0;i<size;i++){\n        if(num[i]==0){\n            curTar=i;\n            bool canFly= false;\n            //查到0，判断前面有没有能够跳过0的\n            for(int j=i-1;j>=latTar;j--){\n                if(j+num[j]>curTar){\n                    canFly= true;\n                }\n            }\n            if(!canFly){\n                flag=false;\n                break;\n            }\n        }\n    }\n    if(flag) cout<<\"true\";\n    else cout<<\"false\";\n    return 0;\n}\n```\n\n法2\n\n维护一个可达到的最远位置maxPos，通过遍历当前可跳跃范围内的所有位置，计算每个位置能够达到的最远位置，并更新maxPos。如果maxPos超过数组长度的最后一个位置，则表示可以到达末尾，返回true；否则，根据当前位置调整下一次可跳跃范围的起点和终点，直到无法继续跳跃返回false。\n\n```c++\nint main(){\n    int a;\n    vector<int> v;\n    while(cin>>a){\n        v.push_back(a);\n        if(cin.get()=='\\n') break;\n    }\n    int maxPos=0,left=0,right=0,flag=0;\n    while(left<=right){\n        if(maxPos>=v.size()-1){\n            flag=1;\n            break;\n        }\n        for(int i=left;i<=right;i++){\n\n            maxPos=max(maxPos,i+v[i]);\n        }\n        left=right+1;\n        right=maxPos;\n    }\n    if (flag) cout<<\"true\";\n    else cout<<\"false\";\n\n    return 0;\n}\n```\n\n\n\n## P25 动规 整数拆分\n\n给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。\n\n我们用dp[i]来表示分拆数字i，可以得到的最大乘积，对于每个i来说，都可以通过前面已知的拆分结果来求，遍历i前面的每个数字j，假设拆分成两个数 j 和 i-j ，这是一种情况，另外，j 又可以继续拆分，j拆分的最大值就是dp[j]， 同理 i-j 也是一样的，我们在所有情况里取最大值就是dp[i]的结果。\n\n\n```c++\n//\n// Created by chan on 2023/11/26.\n//\n\n#include \"iostream\"\nusing namespace std;\n\nint main(){\n    int n;\n    int dp[60]={0};\n    cin>>n;\n    dp[1]=1;\n    dp[2]=1;\n    if(n<=2) {\n        cout<<dp[n];\n        return 0;\n    }\n    for(int i=3;i<=n;i++){\n        for(int j=1;j<i-1;j++){\n            dp[i]=max(dp[i], max(j*(i-j),dp[i-j]*j));\n        }\n    }\n    cout<<dp[n];\n\n    return 0;\n}\n```\n\n## P26 动态规划 打家劫舍\n\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n**提示：**\n\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400\n\n```c++\n//Problem P26. [算法课动态规划] 打家劫舍\n#include \"iostream\"\n#include \"vector\"\nusing namespace std;\nint main(){\n    vector<int> room;\n    room.push_back(0);//占着第0个\n    int n;\n    int dp[101]={0};\n    while(cin>>n){\n        room.push_back(n);\n        if(cin.get()=='\\n') break;\n    }\n    dp[1]=room[1];\n    //初始化dp\n    //遍历dp\n    for(int i=2;i<=room.size()-1;i++){\n        dp[i]=max(dp[i-1],dp[i-2]+room[i]);//不偷本间,偷本间加前面的第二间\n    }\n//    cout<<room.size()<<endl;\n    cout<<dp[room.size()-1];\n    return 0;\n}\n```\n\n## P27 动态规划 戳气球\n\n![image-20231212145315276](JJ的算法之旅.assets/image-20231212145315276.png)\n\n```c++\n// Problem P27. [算法课动态规划] 戳气球\n#include \"iostream\"\n#include <math.h>\n#include \"vector\"\n\nusing namespace std;\nint maxCoins(vector<int> nums){\n    int n = nums.size();\n    // 添加两侧的虚拟气球\n    vector<int> points(n+2) ;//= new int[n + 2]\n    points[0] = points[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        points[i] = nums[i - 1];//nums从0开始\n    }\n    // base case 已经都被初始化为 0\n    vector<vector<int>>dp(n+2,vector<int>(n+2));//    int[][] dp = new int[n + 2][n + 2];\n\n    // 开始状态转移\n    // i 应该从下往上\n    for (int i = n; i >= 0; i--) {\n        // j 应该从左往右\n        for (int j = i + 1; j < n + 2; j++) {\n            // 最后戳破的气球是哪个？\n            for (int k = i + 1; k < j; k++) {\n                // 择优做选择\n                dp[i][j] = max(\n                        dp[i][j],\n                        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]\n                );\n            }\n        }\n    }\n    return dp[0][n + 1];\n}\nint main(){\n    vector<int> nums;\n    int n;\n    while (cin>>n){\n        nums.push_back(n);\n        if(cin.get()=='\\n') break;\n    }\n    cout<<maxCoins(nums);\n\n\n    return 0;\n}\n```\n\n\n\n## P28 贪心 跳跃游戏\n\n有一个非负整数数组 nums，最初位于数组的第一个位置。\n\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\n\n假设你总是可以到达数组的最后一个位置, 你的目标是使用最少的跳跃次数到达数组的最后一个位置。\n\n输入\n\n```c++\n//\n// Created by chan on 2023/11/22.\n//\n#include \"iostream\"\n#include \"vector\"\nusing namespace std;\n\n\n/*\n * 基本思想\n * 每次在当前能跳跃范围内选择可以使得接下来能跳跃最远的位置\n */\nvector<int> nums;\n\nint findMaxStep(vector<int> vector1);\n\nint main(){\n    int n;\n    int a;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a;\n        nums.push_back(a);\n    }\n    cout<<findMaxStep(nums);\n}\n\nint findMaxStep(vector<int> vector1) {\n    int maxReach=0;//记录跳到最远的\n    int curReach=0;\n    int cnt=0;\n    int maxPos=0;\n    while (curReach<=maxReach&&maxPos<vector1.size()-1){\n        cnt++;\n//        curReach=maxReach;//当前的位置\n//        maxReach=vector1[curReach]+curReach;//首先初始化一个最远\n        for(int i=curReach;i<=maxReach;i++){\n            //跳得超越了之前的maxReach\n            maxPos= max(maxPos,i+nums[i]);\n        }\n        curReach=maxReach+1;\n        maxReach=maxPos;\n    }\n\n    return cnt;\n}\n```\n\n## P29 指针 颜色分类\n\n给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n输入\n\n第一行输入一个整数 n (1≤n≤300)*n* (1≤*n*≤300) 代表数组的长度。\n\n第二行输入一行数字代表数组 nums[i] 为0，1，2，数字与数字之间用空格间开。\n\n输出\n\n输出排序后的数组\n\n```c++\n//Problem P29. [算法课指针] 颜色分类\n\n#include <iostream>\nusing namespace std;\nint key[3]={0};//检查三种颜色\nvoid sortColor(int *head,int n){\n    if(n==1) return;\n    int *p= nullptr;//工作指针\n    int *edge= head;\n    int *hh=head;\n    int temp=-1;\n    for(int i=0;i<3;i++){\n        //检查head\n        head=edge;\n        p=head;\n\n        while (*p!=i&&*p!=-1) p++;//找到颜色头一个\n        if(*p==-1) continue;\n        temp=*p;\n        *p=*head;\n        *head=temp;\n        key[i]=1;//头部解决，建议记录头部索引\n        edge=head;//存储颜色族头\n        head++;\n        while(*head!= -1){\n            //进入一个聚类的循环\n\n            p=head;\n            while(*p!=i&&*p!=-1) {\n                p++;\n            }\n            //找到一个替换\n            if(*p==-1) {\n                edge=head;\n                break;\n            }\n            temp=*p;\n            *p=*head;\n            *head=temp;\n            //直到越界\n            head++;\n        }\n    }\n}\nint main(){\n    int n;\n    int nums[301]={0};\n    int a;\n    for(int i=0;i<301;i++) nums[i]=-1;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>a;\n        nums[i]=a;\n    }\n    sortColor(nums,n);\n    cout<<'[';\n    for(int i=0;i<n-1;i++) cout<<nums[i]<<\",\";\n    cout<<nums[n-1]<<']';\n    return 0;\n}\n```\n\n"},{"title":"大型数据库笔记","url":"/2023/09/14/大型数据库笔记/","content":"\n# 环境配置\n\n登录oracle(Oracle已经安装)：`sqlplus sys/orcl as sysdba` \n\nsqlplus scott/tiger \n\n(以超级管理员登录必须加as sysdba)\n\n```md\nsz [文件名]\n```\n\n* 切换用户：`su - oracle`  （-和oracle中间有空格）\n* 运行设置Oracle环境shell脚本：`. oraenv` （. 后面有空格）\n* 注释：. `= source`(执行 shell 文件)\n* 输入实例名：`orcl`  按回车\n\nsu -xxx，-xxx是运行脚本\n\n![image-20230915001830676](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230915001830676.png)\n\nsys用户 dba登录\n\n# 01体系结构\n\n## OracleDB体系结构\n\n![image-20230914150100943](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230914150100943.png)\n\n## 内存结构\n\n**Oracle DB** **内存结构**\n\nOracle DB 创建并使用内存结构来满足多种需要。例如，使用内存来存储正在运行的程序代码、在各用户之间共享的数据以及所连接的每个用户的专用数据区域。\n 一个实例有两个关联的基本内存结构： \n\n•**系统全局区 (SGA)：**一组共享的内存结构（称为 SGA 组件），其中包含一个 Oracle DB 实例的数据和控制信息。SGA 由所有服务器进程和后台进程共享。SGA 中存储的数据有高速缓存的数据块和共享 SQL 区域等。\n\n•**程序全局区 (PGA)：**包含某个服务器进程或后台进程的数据及控制信息的内存区域。PGA 是 Oracle DB 在服务器进程或后台进程启动时创建的非共享内存。服务器进程对 PGA 的访问是独占式的。每个服务器进程和后台进程都具有自己的 PGA。\n\n![image-20230914150838773](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230914150838773.png)\n\n\n\n### SGA\n\n**共享池**\n\n**数据缓冲区**\n\n**重做日志缓冲区**\n\n## 后台进程\n\n### **进程监视器进程 (PMON)**\n\n进程监视器进程 (PMON) 在用户进程失败时执行进程恢复。PMON 负责清除数据库缓冲区高速缓存和释放该用户进程占用的资源。例如，PMON 会重置活动事务处理表的状态，释放锁，并从活动进程列表中删除该进程 ID。\n\nPMON 定期检查分派程序和服务器进程的状态，并重新启动任何已停止运行（除了 Oracle DB 故意终止）的分派程序和服务器进程。PMON 还会在网络监听程序中注册有关实例和分派程序进程的信息。\n\n与 SMON 一样，PMON 定期检查以查看是否需要运行；如果其它进程检测到需要该进程，也可以调用它。\n\n![image-20230914161215340](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230914161215340.png)\n\n### **恢复器进程 (**RECO)\n\n恢复器进程 (RECO) 是一个用于分布式数据库配置的后台进程，它可以自动解决涉及分布式事务处理的故障。实例的 RECO 进程会自动连接到有问题的分布式事务处理中涉及的其它数据库。当 RECO 进程在涉及到的数据库服务器之间重新建立连接后，它会自动解决所有有问题的事务处理，并从每个数据库的暂挂事务处理表中删除所有对应于已解决的有问题事务处理的行。\n\n如果 RECO 进程无法与远程服务器连接，RECO 会在某个计时间隔之后自动尝试重新连接。但是，RECO 在再次尝试另一个连接之前，会等待一段时间，该时间会随尝试次数不断\n 增加（呈幂指数增长）。\n\n![image-20230914161228190](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230914161228190.png)\n\n### **归档进程 (ARCn)**\n\n发生日志切换之后，归档进程 (ARC*n*) 会将重做日志文件复制到指定的存储设备。仅当\n 数据库处于 ARCHIVELOG 模式且已启用自动归档时，才会存在 ARC*n* 进程。\n\n如果您预计归档的工作负荷很重（例如在成批加载数据期间），可以增加最大归档进程数。此外，也可以有多个归档日志目标位置。建议每个目标位置至少有一个归档进程。默认\n 设置是四个归档进程。\n\n![image-20230914161301300](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20230914161301300.png)\n\n### 归档模式\n\n默认为非归档模式。\n\n**查看数据库是否处于归档模式：**`archive log list`。\n\n```\nSQL> archive log list\n```\n\n**改变数据库的归档模式步骤：** \n\n(1)停止Oracle Server并装载数据库： \n\n```\nsql>shutdown immediate //停\n\nsql>startup mount  //启动到：装载数据库阶段\n```\n\n(2)修改数据库为归档模式： \n\n```\nalter database archivelog; \n```\n\n(3) 打开数据库：`alter database open;`\n\n**测试是否生成归档日志：**\n\n（1）update emp表（生成重做日志信息）:\n\n• update scott.emp set sal=sal + 500;\n\n• commit;\n\n（2）日志切换（生成归档日志）： alter system switch logfile;\n\n（3）检查是否生成归档日志:\n\n在文件夹/opt/oracle/flash_recovery_area下查看是否有归档文件生成。\n\n**改为非归档模式：**\n\nMount状态：\n\nalter database noarchivelog;\n\n**打开数据库：**alter database open;\n\n## 逻辑和物理数据库结构\n\n数据库具有逻辑结构和物理结构。\n\n**数据库、表空间和数据文件** \n\n本幻灯片对数据库、表空间和数据文件之间的关系进行了说明。每个数据库都在逻辑上分为两个或多个表空间。在每个表空间均显式创建一个或多个数据文件，以在物理上存储表空间中所有逻辑结构的数据。对于 TEMPORARY 表空间，不创建数据文件，而是创建临时文件。表空间的数据文件可以采用任何受支持的存储技术进行物理存储。\n\n**表空间** \n\n数据库分为多个逻辑存储单元，这些单元称为“表空间”，用于对相关逻辑结构或数据\n 文件进行分组。例如，表空间一般会将一个应用程序的所有段分成一组，以简化一些管理操作。\n\n**数据块** \n\nOracle DB 的数据存储在“数据块”中，数据块是粒度最低的一级。一个数据块对应于磁盘中特定字节数的物理空间。每个表空间的数据块大小是在表空间创建时指定的。数据库以 Oracle 数据块为单位使用和分配空闲数据库空间。\n\n\n\n自动存储管理不需要做，实验室磁盘太少\n\n# 04实例\n\nspfile：/opt/orcale/product\n\n**图形界面 管理 服务器**\n\n控制台地址可以在此文件中查看：$ORACLE_HOME\\install\\readme.txt\n\n控制台的操作：\n\n查看状态： **emctl status dbconsole**\n\n启动：**emctl start dbconsole**\n\n停止（不要执行停止这条命令）：**emctl stop dbconsole**\n\n\n\n改显示日期\n\n```shell\nalter session set nls_date_format='yyyy-mm-dd';\n```\n\n\n\n**V$PARAMETER** **显示当前会话中的当前参数值**\n\n```sql\nSQL> SELECT name , value FROM V$PARAMETER;\nNAME                   VALUE\n------------          ----------\nlock_name_space        2\nprocesses              150\nsessions               247\n…\n```\n\nMOUNT阶段\n\n* 执行以下任务必须装载数据库\n  * 重命名数据文件\n  * 启用和禁用联机重做日志文件归档选项\n  * 执行完整的数据库恢复\n\nOPEN阶段\n\n![image-20231007142725996](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20231007142725996.png)\n\n![image-20231007144423909](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20231007144423909.png)\n\n## 数据字典视图\n\n![image-20231007145236364](D:\\Blog\\source\\_posts\\大型数据库笔记.assets\\image-20231007145236364.png)\n\n**用法举例：**\n\n```sql\nSELECT table_name, tablespace_name \nFROM user_tables;\n\nSELECT sequence_name, min_value, max_value, increment_by \nFROM all_sequences \nWHERE sequence_owner IN ('MDSYS','XDB');\n\nSELECT USERNAME, ACCOUNT_STATUS \nFROM dba_users \nWHERE ACCOUNT_STATUS = 'OPEN';\n\nDESCRIBE dba_indexes\n\n```\n\n查找scott用户有哪些索引，以及这些索引所在的表空间名称:\n\n```sql\nselect table_name from dict where table_name like '%INDEX%’;\n\nDesc user_indexes select  INDEX_NAME, TABLESPACE_NAME from user_indexes;\n\n```\n\n# 06配置Oracle Network\n\nvim保存失败，修改文件权限可以用winscp\n\n# 07Storage\n\n\n\n# 08User\n\n## 权限\n\n* 系统权限：允许用户在数据库中执行特定的操作 \n* 对象权限：允许用户访问和操纵特定的对象 \n\ndba分配权限\n\n```sql\nsqlplus / as sysdba \n```\n\n查权限\n\n```sql\nselect * from user_role_privs;\n```\n\n\n\n### 系统权限\n\n所有系统权限：\n\n```sql\nselect * from system_privilege_map;\n```\n\n授予系统权限：\n\n```sql\nGRANT <system_privilege> TO <grantee clause> [WITH ADMIN OPTION] \n# Grant create table, unlimited tablespace to scott with admin option;\n\n```\n\nWITH ADMIN OPTION: 被授权用户可以转授权给其它用户，收回权限没有级联，慎用\n\n查询用户具有的系统权限： \n\n```sql\nselect * from user_sys_privs;\n```\n\n\n\n撤销系统权限的 SQL语句：\n\n```sql\nREVOKE <system_privilege> FROM <grantee clause>\n# REVOKE CREATE TABLE FROM joe;\n```\n\n\n\n### 对象权限\n\n授予对象权限\n\n```sql\nGRANT <object_privilege> ON <object> TO <grantee clause> [WITH GRANT OPTION]\n```\n\n查看用户对象权限：\n\n```sql\nselect * from user_tab_privs;\n```\n\n> 撤销对象权限时会级联撤销。\n\n•用户只能撤销授予他们的那些权限。例如，Bob 无法撤销 Joe 授予 Emily 的对象权限。\n\n•只有被授予者或者具有 GRANT ANY OBJECT PRIVILEGE 系统权限的用户可以撤销对象权限。\n\n# 09Locking\n\n## 锁\n\n* 防止多个会话同时更改同一数据 \n* 在指定语句的最低可能级别自动获取 \n\n### 机制\n\n* 插入、更新、删除：行级锁 \n* 修改对象（如表移动）：对象级锁\n* 查询不需要任何锁 \n\n> 事务处理结束（使用 COMMIT 或 ROLLBACK 操作）前一直保持锁定 \n\n# 10Undo\n\n## 还原数据\n\n还原数据是： \n\n* 原始的、修改之前的数据副本 \n\n* 针对更改数据的每个事务处理而捕获，保存旧值（还原数据） \n\n* 至少保留到事务处理结束 \n\n* 用于支持： \n\n  * 回滚操作 rollback \n  * 读取一致性查询 ：提供与查询开始时的数据一致的结果；“快照太旧” (ORA-01555)\n  * Oracle 闪回查询、闪回事务处理和闪回表\n  * 从失败的事务处理中进行恢复\n\n   \n\n> 还原信息：至少保留到事务处理结束\n\n![image-20231109142603647](大型数据库笔记.assets/image-20231109142603647.png)\n\n* 每个事务处理仅分配一个还原段。 \n* 还原段可根据需要自动增长和收缩\n* 一个还原段可以同时服务多个事务处理。 \n\n还原信息分为三类\n\n* **未提交**的还原信息（活动）\n* **提交的**还原信息（未过期）：\n* **过期的**还原信息（过期）：\n\n\n\n# 11Auditing\n\n**指定审计选项**,每次行使审计的系统权限时，都会生成一条记录\n\n![image-20231116143337623](大型数据库笔记.assets/image-20231116143337623.png)\n\n设计触发器\n\n```sql\nCREATE OR REPLACE TRIGGER system.hrsalary_audit \nAFTER UPDATE OF sal\nON scott.emp\nREFERENCING NEW AS NEW OLD AS OLD\nFOR EACH ROW\nBEGIN\nIF :old.sal != :new.sal THEN\nINSERT INTO system.audit_employees \nVALUES \n  (\n    sys_context('userenv', 'os_user'), \n    sysdate, \n    sys_context('userenv', 'ip_address'),\n    :new.empno || ' salary changed from '||:old.sal|| ' to ' ||:new.sal); END IF; END; /\n```\n\n```\nexec dbms_fga.add_policy(\n  object_schema =& gt; 'scott', \n  object_name =& gt; 'emp',  \n  audit_condition =& gt; 'MGR=7566', \n  audit_column =& gt; 'comm', \n  enable =& gt; TRUE, \n  statement_types =& gt; 'SELECT,UPDATE’);\n```\n\nUPDATE scott.emp\nSET comm = 1000\nWHERE ENAME = 'FORD';\n\n# 基础\n\n打开管理界面\n\n```bash\nsu - oracle\n. oraenv\norcl\nemctl start dbconsole\n```\n\n360极速浏览器打开\n\nhttps://192.168.126.151:5500/em\n\n# Gauss安装\n\n文件查找，非编辑状态：\"/查找内容\"\n"},{"title":"操作系统笔记","url":"/2023/09/14/操作系统笔记/","content":"\n# 错题\n\n进程虚存文件\n\n\n\n## 内存管理\n\n## 第二章进程\n\n进程的“同步”和“互斥”反映了进程间 直接制约 和 间接制约 的关系。\n\n### 信号量\n\n* 例5程序描述前驱关系\n\n![image-20231227192819842](操作系统笔记.assets/image-20231227192819842.png)\n\n```pseudocode\nsemaphore a-b-c=d-e-f-g-h-0;\nS1(){...;signal(a);signal(b);} //…表示原来S1内的语句序列\nS2(){wait(a);...;signal(c);signal(d);}//…表示原来S2内的语句序列\nS3(){wait(b);.;signal(e);}//…表示原来S3内的语句序列\nS4(){wait(c);…;signal(f);}//…表示原来S4内的语句序列\nS5(){wait(d);..;signal(g);}//…表示原来S5内的语句序列\nS6()wait(e);;signal(h);}//…表示原来S6内的语句序列\nS7(){wait(f);wait(g);wait(h);...;)//…表示原来S7内的语句序列\nmain(){\n\tcobegin //注意这个开头表示并发执行\n\t\tS1();S2(),S3():S4();S5();S6();S7();\t\n\tcoend //注意这个结尾\n}\n\n```\n\n### 进程同步\n\n**生产者消费者：**\n\n```pseudocode\n//最原型代码\nProducer(item){\n\twait(empty);\n\tWait(mutex);\n\tEnqueue(item);\n\tsignal(mutex)\n\tsignal(full);\n}\nConsumer(){\n\twait(full);\n\twait(mutex);\n\titem=Dequeue();\n\tsignal(mutex);\n\tsignal(empty);\n}\n//这个版本交换了wait会造成死锁，当生产者过了mutex，此时如果是满的状态，无法向下执行，而此时消费者无法进入mutex就不能执行signal(mutex)来唤醒生产者，发生死锁\nProducer(item){\n\tWait(mutex);\n\twait(empty);\n\tEnqueue(item);\n\tsignal(mutex)\n\tsignal(full);\n}\nConsumer(){\n\twait(mutex);\n\twait(full);\n\titem=Dequeue();\n\tsignal(mutex);\n\tsignal(empty);\n}\n//此版本交换signal不会造成死锁，只会改变临界资源的释放次序\nProducer(item){\n\twait(empty);\n\tWait(mutex);\n\tEnqueue(item);\n\tsignal(full);\n\tsignal(mutex)\n}\nConsumer(){\n\twait(full);\n\twait(mutex);\n\titem=Dequeue();\n\tsignal(empty);\n\tsignal(mutex);\n}\n```\n\n* 生产消费变体 例15 有三个进程PA、PB和PC协作解决文件打印问题。PA将文件记录从磁盘读入内存的缓冲区1，每执行一次读一个记录：PB将缓冲区1的内容复制到缓冲区2中，**每执行一次复制一个记录**，PC将缓冲区2的内容打印出来，每执行一次打印一个记录缓冲区的大小与记录大小一样。请用信号量来保证文件的正确打印。\n\n  ```mermaid\n  graph LR\n  磁盘--PA-->缓冲区1--PB-->缓冲区2--PC-->打印\n  ```\n\n  这里会发生冲突的只有缓冲区1和缓冲区2这两个临界资源。都只能存放一个记录——无需in,out指针，原来的生产消费者中的mutex信号量在这里可以省去\n\n  * 注意初始化empty=1，full=0\n  * 主函数cobegin,coend\n\n  ```pseudocode\n  semaphore empty1=1,full1=0,empty0=1,full2=0;\n  PA(){\n  \twhile(1){\n  \t\t从磁盘读入一个记录;\n  \t\twait(empty1);//缓冲区1没记录\n  \t\t将记录放入缓冲区1;\n  \t\tsignal(full1);//缓冲区1有记录\n  \t}\n  }\n  \n  PB(){\n  \twhile(1){\n  \t\twait(full1);//缓冲区1有记录\n  \t\t从缓冲区1取出一个记录;\n  \t\tsignale(empty1);\n  \t\twait(empty2);//等缓冲区2空\n  \t\t将记录复制到缓冲区2\n  \t\tsignal(full2);\n  \t}\n  }\n  PC(){\n  \twhile(1){\n  \t\twait(full2);//缓冲区2有记录\n  \t\t从缓冲区2取出一个记录;\n  \t\tsignal(empty2);\n  \t\t将取出的记录打印出来\n  \t}\n  }\n  main(){\n  \tconbegin\n  \tPA();PB();PC();\n  \tcoend\n  }\n  ```\n\n* 生产消费变体  桌上有个能盛得下**五个水果**的空盘子。爸爸不停地向盘中放苹果或桔子，儿子不停地从盘中取出桔子享用，女儿不停地从盘中取出苹果享用。规定**三人不能同时从盘子中取放水果**。试用信号量实现爸爸、儿子和女儿这三个循环进程之间的同步。\n\n  关键点：信号量的设置\n\n  * 判空盘子empty，而且还有初始值为5\n  * 保护碗 mutex，初始为1，这样爸爸才能取到碗\n  * 区分苹果还是桔子 orange apple，儿子女儿其他都是一样\n\n  ```pseudocode\n  semaphore empty=5,orange=0,apple=0,mutex=1;\n  Dad(){\n  \twhile(1){\n  \t\twait(empty);//能放东西\n  \t\twait(mutex);//保护碗\n  \t\t将水果放入碗;\n  \t\tsignal(mutex);//释放碗\n  \t\tif(放入的是桔子);signal(orange);\n  \t\telse signal(apple);\n  \t}\n  }\n  Son(){\n  \twhile(1){\n  \t\twait(orange);//有桔子\n  \t\twait(mutex);//保护碗\n  \t\t取出桔子;\n  \t\tsignal(mutex);//释放碗\n  \t\tsignal(empty);//减少水果\n  \t\t享用桔子；\n  \t}\n  }\n  Daughter(){\n  \twhile(1){\n  \t\twait(apple);\n  \t\twait(mutex);\n  \t\t从盘中取一个苹果;\n  \t\tsignal(mutex);\n  \t\tsignal(empty);\n  \t\t享用苹果;\n  \t}\n  }\n  ```\n\n* 生产消费变体 例18\n\n  关键点：\n\n  * A-B≤m，B-A≤n，各自设一个信号量，SAB表示当前允许A生产的产品数量，**初始值为m**；SBA表示允许B生产的产品数量，**初始值为n**；\n  * 千万理解搭配wait(SAB)--signal(SBA)，wait(SBA)--signal(SAB)\n  * 还需要设置一个初值为0的资源信号量S，对应于仓库中的产品量\n  * 看懂生产者有两个步骤1是生产、2是放入仓库，一个用SAB/SBA维护，一个用**mutex**(初值为1)维护\n  * 生产后要增加S,signal(S)，消费要先判断S,wait(S)\n\n  ```pseudocode\n  semaphore SAB=m,SBA=n,S=0,mutex=1;\n  PA(){\n  \twhile(1){\n  \t\twait(SAB);//满足条件\n          生产一个产品A;\n          signal(SBA);//意味着B允许生产的数量要同步增加\n          wait(mutex);//保护仓库\n          将产品A放入仓库;\n          signal(mutex);\n          siganl(S);//增加仓库产品量\n  \t}\n  \t\n  }\n  PB(){\n  \twhile(1){\n  \t\twait(SBA);\n  \t\t生产一个产品B;\n  \t\tsignal(SAB);//A允许数量增加\n          wait(mutex);\n          将产品B放入仓库\n          signal(mutex);\n          signal(S);\n  \t}\n  \t\n  }\n  PC(){\n  \twhile(1){\n  \t\twait(S);//有S\n  \t\twait(mutex);//记得保护仓库\n  \t\t取出一个产品\n  \t\tsignale(mutex);\n  \t\t售卖;\n  \t}\n  }\n  main(){\n  \tconbegin\n  \t\tPA();PB();PC();\n  \tcoend\n  }\n  ```\n\n  \n\n* ⭐**读者写者问题 过独木桥**\n\n  关键点：\n\n  * 保护过桥人数\n  * 保护桥\n\n  ```pseudocode\n  int countA=0,countB=0;//分别表示A、B两个方向过桥的行人数量\n  semaphore bridge=1;//实现不同方向行人对桥的互斥共享\n  semaphore mutexA=mutexB=1;//分别实现对countA、countB的互斥共享\n  PA(){\n  \t//进入桥\n  \twait(mutexA)\n  \t\tif(countA==0)wait(bridge);//等桥，此时过桥的A初始状态为0，保护桥，其他人别来\n  \t\tcountA++;//人数增加\n  \tsignal(mutexA);//人数定了，不用保护\n  \t过桥;\n  \t//离开桥\n  \twait(mutexA);\n  \t\tcountA--;\n  \t\tif(countA==0)signal(bridge);\n  \tsignal(mutexA);\n  }\n  PB(){\n  \t//进入桥\n  \twait(mutexB)\n  \t\tif(countB==0)wait(bridge);//等桥，此时过桥的A初始状态为0，保护桥，其他人别来\n  \t\tcountB++;//人数增加\n  \tsignal(mutexB);//人数定了，不用保护\n  \t过桥;\n  \t//离开桥\n  \twait(mutexB);\n  \t\tcountA--;\n  \t\tif(countA==0)signal(bridge);\n  \tsignal(mutexA);\n  }\n  \n  ```\n  \n\n## 第四章 存储管理\n\n3.设有16页的逻辑空间，每页有1024字节，它们被映射32块的物理存储区中，那么，逻辑地址的有效位是14位，物理地址至少是**15**位。\n\n页大小就是块大小，块大小1024字节，一共32块，那就是1024*32=2^15\n\n### 二级页表\n\n[某计算机系统按字节编址，采用二级页表的分页存储管理方式，虚拟__牛客网 (nowcoder.com)](https://www.nowcoder.com/questionTerminal/2ea7b55568c34aa2a80e0f7ec7392a19)\n\n\n\n## 第六章 I/O\n\n9.I/0软件的分层结构中，**I/0中断处理程序**负责将把用户提交的逻辑I/0请求\n转化为物理I/0操作的启动和执行。X 是设备驱动程序\n\n\n\n10.为了使多个进程能有效地同时处理输入和输出，最好使用<u>循环缓冲结构</u>的缓冲技术 × 应该是缓冲池\n\n## 第七章 文件管理\n\n文件系统的主要目的是实现对**文件的按名存取**。\n\n## 第八章 磁盘管理\n\n**一次磁盘读写操作需要的时间：**寻道时间、旋转延迟时间、传输时间\n\n* 寻道时间：把磁臂（磁头）移动到指定磁**道**上所经历的时间。\n* 旋转延迟时间：把指定**扇区**移动到磁头下所经历的时间。\n* 传输时间：把数据从磁盘读出或向磁盘写入数据所经历的时间\n\n# 第一章 操作系统引论\n\n## 操作系统的概念、功能\n\n操作系统\n\n* 是指控制和管理整个计算机系统的硬件和软件资源——**操作系统是系统资源的管理者**\n  * ⭐提供的功能：处理机管理、存储器管理、文件管理、设备管理\n  * 目标：安全高效\n* 以提供给用户和其他软件方便的接口环境——**向上层提供方便易用的服务**\n  * 硬件只接受二进制指令，在硬件之上安装操作系统，友好交互接口\n  * 把复杂的硬件功能封装成简单易用的服务\n* 是计算机系统中最基本的系统软件——**是最接近硬件的一层软件**\n  * 直接给用户使用：GUI 图形化用户接口、命令接口（**联机命令接口、脱机命令接口**，前者说一句计算机做一句，后者说一堆做一堆如txt配置文件)\n  * 给软件/程序员使用：程序接口\n\n没有任何软件支持的计算机称为裸机，操作系统实现了对硬件机器的拓展。\n\n通常把覆盖了软件的机器称为**扩充机器**，又称之为**虚拟机**\n\n\n\n<center>用户</br>——</br>应用程序</br>——</br>操作系统</br>——</br>裸机(纯硬件)</center>\n\n\n\n\n​    \n\n进程-虚存-文件\n\n## 操作系统的特征\n\n### 并发\n\n并发：指两个或多个时间在统一时间间隔发送，宏观上是同时发生，微观上是交替的。\n\n> 注意区分，并行指两个或多个同时发生，宏观微观都是同时\n\n操纵系统并发性：同时运行多个程序，微观上交替运行\n\n操作系统伴随着“多道程序技术”出现，操作系统和程序并发是一起诞生的\n\n**考点：**\n\n* 单核CPU同一时刻执行一个程序，各个程序并发执行\n* 多核执行多个，并行执行\n\n计算机系统中同时存在多个运行的程序，需要OS管理和调度\n\n### 共享\n\n资源共享，系统的资源可供内存中多个并发执行的程序共同使用\n\n两种方式\n\n* 互斥共享方式，一个时间段只允许一个进程访问该资源\n* 同时共享方式，一个时间段允许多个进程“同时”对它们进行访问\n  * 读取文件，微观上其实也是交替访问硬盘的；扬声器确实可以微观上同时使用\n\n\n\n#### 并发与共享的关系\n\n**并发性**指计算机系统中同时存在着**多个**运行着的程序。\n**共享性**是指系统中的资源可供内存中**多个并发执行**的进程共同使用。\n\n互为存在条件，失去并发性，系统只有一个程序，共享性没意义；失去共享性，无法实现同时访问资源，无法并发。\n\n### 虚拟\n\n指把物理上的实体变为逻辑上的对应物，物理实体存在，而逻辑上对应物是用户感受的。\n\n虚拟存储器，好像运行内存大于实际的内存\n\n虚拟技术：\n\n* 空分复用技术，如虚拟存储技术 \n* 时分复用技术，如虚拟处理器\n\n> 失去了并发性，一个时间段只运行一道程序，失去了实现虚拟性的意义。因此没有并发现就失去了虚拟性\n\n\n\n### 异步\n\n允许多个程序并发执行，但进程的执行不是一贯到底，而是走走停停\n\n并发的程序会争用资源\n\n由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进\n如果失去了**并发性**，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。\n\n![image-20230928110145877](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20230928110145877.png)\n\n## 操作系统的发展\n\n### 手工操作阶段\n\n### 批处理阶段\n\n#### 单道批处理系统(引入脱机输入输出技术)\n\n优：缓解人机速度矛盾\n\n缺：资源利用率依然很低\n\n#### 多道批处理系统(操作系统开始出现)\n\n优：多道程序并发执行，资源利用率高\n\n缺：不提供人机交互功能\n\n### 分时操作系统\n\n以时间片轮流为各个用户服务，用户请求可以被即时响应，解决了人机交互问题\n\n缺点：不能有限解决紧急任务\n\n### 实时操作系统\n\n优点：能优先响应一些**紧急任务**\n\n要在严格时限内处理完事件，**及时性和可靠性**\n\n* 硬实时系统：必须在绝对严格的规定时间内完成处理\n* 软实时系统：能接受偶尔违反时间规定\n\n\n\n## 操作系统的运行机制\n\n### 两种程序\n\n* 内核程序：负责实现操作系统，由很多内核程序组成**操作系统内核**，内核(Kernel)是操作系统最核心的部分，也是最接近硬件的部分\n* 应用程序，跑在操作系统之上\n\n### 两种指令\n\n指令：是指处理器(cpu)能识别、执行的最基本命令，二进制机器指令\n\n### 两种处理器状态\n\ncpu判断指令类型，如何区分此时正在运行的是内核程序还是应用程序？\n\n* **内核态**(目态)，此时正在运行内核程序，可以执行特权指令\n* **用户态**(管态)，运行应用程序，只能执行非特权指令\n\nCPU有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示内核态，0表示用户态。\n\n#### ⭐状态切换\n\n**内核态->用户态**：执行一条**特权指令--修改PSW**的标志位为”用户态”，操作系统主动让出CPU使用权\n\n**用户态->内核态**：由**中断**(非法使用特权指令等)引发，硬件**自动完成变态**过程，触发中断信号意味着操作系统强行夺回CPU使用权\n\n\n\n![image-20231007090904321](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231007090904321.png)\n\n## 中断和异常\n\n### 中断的作用\n\nCPU运行两种程序，**内核程序**和**应用程序**，内核程序是系统管理者\n\n一个应用程序上cpu运行后就会一直运行下去\n\n“中断”是让操作系统**内核夺回CPU使用权**的唯一途径，用户态->内核态\n\n\n\n### 中断的类型\n\n#### 内中断(也称异常)\n\n与当前执行的指令**有关**，中断信号来源于CPU**内部**\n\n例子：\n\n* 试图在用户态执行特权指令，**终止**\n* 执行除法指令发现除数为0，**终止**\n\n> 若当前执行的指令是非法的，则会引发一个中断信号\n\n* 应用程序请求内核服务，执行一条特殊的指令——陷入指令，会引发内部中断信号，**陷阱、陷入(trap)**\n\n> 陷入指令主动将控制权还给操作系统内核，“系统调用”就是通过陷入指令完成。陷入指令不是特权指令！\n\n#### 外中断(也称中断，狭义的中断)\n\n与当前执行的指令**无关**，中断信号来源于CPU**外部**\n\n例子：\n\n* **时钟中断**——由时钟部件发来的中断信号\n  * 如时钟部件每隔一个时间片发送时钟中断信号，用户态->内核态\n  * 执行内核程序，操作系统内核决定接下来让另一个程序上CPU运行，内核态->用户态\n\n* **I/O中断**——由输入/输出设备发来的中断信号\n  * 当输入输出任务完成后，向CPU发送中断信号\n\n> 每一条指令执行结束后，CPU都会例行检查是否有外中断信号\n\n![image-20231007100331373](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231007100331373.png)\n\n### 中断机制的基本原理\n\n**不同的中断信号，需要不同的中断处理程序来处理**\n\nCPU检测到中断信号后，根据中断信号的类型去查询”**中断向量表**“，找到相应的中断处理程序在内存中的存放位置\n\n\n\n## 系统调用\n\n系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来请求获取操作系统内核的服务**\n\n\n\n**操作系统向上的的接口**\n\n* 给用户用的\n  * GUI\n  * 命令接口\n    * 联机命令接口\n    * 脱机命令接口\n* 给应用程序用的\n  * 程序接口(系统调用)\n\n计算机本质四个字寻址执行\n\n### 系统调用和库函数的区别\n\n![image-20231012085435583](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012085435583.png)\n\n### 为什么系统调用是必须的\n\n生活场景：去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开\n始工作。\n你的论文打印到一半时，另一位同学按下了Wod的“打印”按钮，开始打印他\n自己的论文。\n思考：如果两个进程可以随意地、并发地共享打印机资源，会发生什么情况？\n两个进程并发运行，打印机设备交替地收到WPS和Word两个进程发来的打印请求，结果两篇论文的内容混杂在一起了…\n解决方法：由操作系统内核对共享资源进行统一的管理，并**向上提供“系统调用”**，用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。\n\n### 系统调用按功能分类\n\n* 设备管理，完成设备的 请求/释放/启动 等功能\n* 文件管理，完成文件的 读/写/创建/删除 等功能\n* 进程控制，完成进程的 创建/撤销/阻塞/唤醒 等功能\n* 进程通信，完成进程之间的 消息传递/信息传递 等功能\n* 内存管理，完成内存的 分配/回收 等功能\n\n\n\n由于\n\n①应用程序通过系统调用请求操作系统服务\n\n②而系统中的各种共享资源由操作系统内核统一掌管\n\n因此，凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等)，都必须**通过系统调用的方式向操作系统内核作出服务请求**，由操作系统内核代为完成。这样可以**保证系统的稳定性和安全性**，防止用户进行非法操作。\n\n\n\n### 系统调用的过程\n\n用户态应用程序要执行一列执行然后加一条**陷入指令**，引发一个内中断，使得能够转变为内核态运行系统调用入口程序，检查寄存器中的应用程序设置好的参数，判断是那种服务，调用处理程序上CPU运行，然后转回用户态\n\n![image-20231012092740165](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012092740165.png)\n\n![image-20231012092809273](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012092809273.png)\n\n## 操作系统的体系结构\n\n本节简要了解\n\n内核是操作系统**最基本**、**最核心**的部分\n\n实现操作系统内核功能的那些程序都是内核程序\n\n### 大内核和微内核√\n\n**大内核√又名宏内核/单内核和微内核√**\n\n![image-20231012093655556](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012093655556.png)\n\n\n\n![image-20231012093754573](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012093754573.png)\n\n分层结构\n\n模块化\n\n外核\n\n![image-20231012103814193](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012103814193.png)\n\n## 操作系统引导\n\n  BIOS：Basic Input/Output System\n\n![image-20231012105645065](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012105645065.png)\n\n\n\n## 虚拟机\n\n传统计算机，一台物理机器只能运行一个操作系统，容易造成性能浪费\n\n**虚拟机：**使用虚拟化技术，将一台物理机器虚拟化成为多台虚拟机器，每个虚拟机器都可以独立运行一个操作系统\n\n第一类VMM，直接运行在硬件上\n\n此种上层操作系统运行在虚拟内核空间不是真实的，因此一些特权指令需要通过虚拟机管理程序进行转化并反馈\n\n第二类VMM，运行在宿主操作系统上\n\n常用的虚拟机软件，VirtualBox、Vmware。\n\n虚拟机管理程序请求宿主操作系统再进行资源分配\n\n![image-20231012184011898](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012184011898.png)\n\n\n\n**两类虚拟机管理程序(VMM)的对比**\n\n|                    | 第一类VMM                                                    | 第二类VMM                                                    |\n| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 对物理资源的控制权 | 直接运行在硬件之上，能**直接**控制和分配物理资源             | 运行在Host OS之上，**依赖于Host OS**为其分配物理资源         |\n| 资源分配方式       | 在安装Guest OS时，VMM要在原本的硬盘上**自行分配**存储空间，类似于**“外核**\"的分配方式，分配未经抽象的物理硬件 | GuestOS拥有自己的**虚拟磁盘**，该盘实际上是Host OS文件系统中的一个**大文件**。GuestOS分配到的内存是虚拟内存 |\n| 性能               | 性能更好                                                     | 性能更差，需要HostOS作为\"中介”                               |\n| 可支持的虚拟机数量 | **更多**，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机 | **更少**，Host OS本身需要使用物理资源，HostOS上运行的其他进程也需要物理资源 |\n| 虚拟机的可迁移性   | 更差                                                         | 更好，只需导出虚拟机**镜像文件**即可迁移到另一台Ho5tO5上，商业化应用更广泛 |\n| 运行模式           | 第一类VMM运行**在最高特权级(Ring 0)**,可以执行最高特权的指令。 | 第二类VMM****。GuestOS发出的系统调用会被VMM截获，并转化为VMM对Ho5tOS的系统调用 |\n\n\n\n\n\n# 进程和线程\n\n## 进程的概念、组成和特征\n\n### 进程的概念\n\n程序：是**静态**的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。\n\n进程：是**动态**的，是程序的一次执行过程。(同一个程序多次执行会对应多个进程)\n\n### 进程的组成——PCB\n\n操作系统给每一个进程分配一个PID，相当于进程的身份证号\n\n* 还记录进程所属用户ID(UID)\n* 还记录进程的运行情况(CPU使用时间，磁盘使用情况..)\n\n这些信息都保存到PCB(Process Control Block)这个数据结构中，即进程控制块\n\n操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息都被放在PCB中。\n\n![image-20231012194155841](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012194155841.png)\n\n\n\n![image-20231012194722570](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012194722570.png)\n\n\n\n* PCB\n  * 进程描述信息\n  * 进程控制和管理信息\n  * 资源分配清单\n  * 处理机相关信息\n* 程序段\n  * 程序的代码(指令序列\n* 数据段\n  * 运行过程中产生的各种数据(程序中定义的变量)\n\n![image-20231012195222855](D:\\Blog\\source\\_posts\\操作系统笔记.assets\\image-20231012195222855.png)\n\n### 进程的特征\n\n程序是静态的，进程是动态的，相比于程序，进程有以下特征\n\n* **动态性**，是进程**最基本的特征**\n  * 进程是程序的一次执行过程，是动态地产生、变化和消亡\n* 并发性\n  * 内存中有多个进程实体，各进程可并发执行\n* **独立性**\n  * 进程是独立运行、**独立获得资源、独立接受调度的基本单位**\n* **异步性**，异步性会导致并发程序执行结果的不确定性。\n  * 各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题\n* 结构性\n  * 每个进程都会配置PCB，结构上看，进程是由程序段、数据段、PCB组成\n\n\n\n### 进程的状态与转换\n\n#### 进程的状态\n\n##### 运行态\n\n一个进程此时在CPU上运行，处于运行态。\n\n##### 就绪态\n\n\n\n##### 阻塞态\n\n等待态。在进程运行的过程中，可能会**请求等待某个时间的发生**(如等待某种系统资源的分配，或者等待其他进程的响应)\n\n##### 创建态\n\n正在被创建，尚未转到就绪态\n\n##### 结束态\n\n进程正在从系统中消失，正常结束或其他原因退出运行。进程需要结束则先置为结束态——>再进一步处理资源释放和回收等工作\n\n![image-20231026093952808](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231026093952808.png)\n\n\n\n![img](https://pic3.zhimg.com/v2-7c0aad9b5e7dd87bb36e39c58be02086_r.jpg)\n\n#### 进程的控制\n\n##### 进程的创建\n\n1)为新进程分配一个唯一的进程标识号，并申请一个空白PCB(PCB是有限的)。若PCB申请失败，则创建失败。\n\n2)为进程分配其运行所需的资源，如内存、文件、I/O设备和CPU时间等（在PCB中体现)。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。\n\n3)初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。\n\n4)若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。\n\n##### 进程的终止\n\n操作系统终止进程的过程如下（终止原语）：\n\n1)根据被终止进程的标识符，检索出该进程的PCB,从中读出该进程的状态。\n\n2)若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。\n\n3)若该进程还有子孙进程，则应将其所有子孙进程终止。\n\n4)将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。\n\n5)将该PCB从所在队列（链表）中删除。\n\n##### 进程的阻塞和唤醒\n\n阻塞：\n\n1)找到将要被阻塞进程的标识号对应的PCB。\n\n2)若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。\n\n3)把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。\n\n唤醒：\n\n1)在该事件的等待队列中找到相应进程的PCB。\n\n2)将其从等待队列中移出，并置其状态为就绪态。\n\n3)把该PCB插入就绪队列，等待调度程序调度。\n\n### 进程的通信\n\n#### 共享存储\n\n对共享空间进行读/写操作时，需要使用同步互斥工具(如P操作、V操作)，对共享空间的写/读进行控制。\n\n共享存储分两种：\n\n* 低级方式的共享是基于数据结构的共享\n* 高级方式则是基于存储区的共享\n\n#### 消息传递\n\n若通信进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方式实现进程通信。\n\n* 直接通信方式，发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息，如图23所示。\n* 间接通信方式。发送进程把消息发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体一般称为信箱。该通信方式广泛应用于计算机网络中。\n\n```mermaid\ngraph LR\n共享存储:\n进程1-->共享空间\n共享空间-->进程1\n共享空间-->进程2\n进程2-->共享空间\n```\n\n```mermaid\ngraph LR\n消息传递:\n进程3-->进程4\n进程4-->进程3\n```\n\n#### 管道通信\n\n向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道：而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。\n\n```mermaid\ngraph LR\n进程1--字符流-->缓冲区\n缓冲区--读取-->进程2\n进程2-->- \n- -->进程1\n\n```\n\n为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和\n确定对方的存在。\n\n> 管道可以理解为共享存储的优化和发展\n\n如果共享有进程在操作，会阻塞\n\n儿存储空间变回缓冲区，不用担心阻塞，可以一边写入一边读出\n\n## 线程和多线程\n\n引入进程——多道程序能并发执行——提高资源利用率和系统吞吐量\n\n引入进程——减小程序在并发执行时所付出的时空开销——提高操作系统的并发性能\n\n线程-轻量级进程\n\n一个进程内部有多个线程，线程切换发生在一个进程内部\n\n### 引入线程机制后带来的变化\n\n* 资源分配、调度\n  * 传统进程机制中，进程是资源分配和调度的基本单位\n  * 引入后，**进程是资源分配的基本单位，线程是调度的基本单位**\n* 并发性\n  * 传统进程机制，只能进程间并发\n  * 引入后，可**各线程也能并发**，提升了并发度\n* 系统开销\n  * 传统进程间开发，需要切换进程的运行环境，系统开销很大\n  * 线程间并发，如果是同一进程内的线程切换，不**需要切换进程环境**，系统开销小\n  * 引入线程后，并发所带来的系统开销很小\n\n### 线程的属性\n\n* 线程是处理机调度的单位\n* 多CPU计算机中，各个线程可占用不同的CPU\n* 每个线程都有一个线程ID、线程控制块 (TCB)\n* 线程也有就绪、阻塞、运行三种基本状态\n* 线程几乎不拥有系统资源\n* 同一进程的不同线程间共享进程的资源\n* 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预\n* 同一进程中的线程切换，不会引起进程切换\n* 不同进程中的线程切换，会引起进程切换\n* 切换同进程内的线程，系统开销很小\n*  切换进程，系统开销较大\n\n\n### 线程的实现方式\n\n\n\n#### **用户级线程**\n\n三段代码逻辑，可以看作三个“线程”\n\n```c++\nint main(){\n\tint i=0;\n\twhile (true){\n\t\tif(i==0)(处理视频聊天的代码：}\n\t\tif（i==1){处理文字聊天的代码：}\n\t\tif(i==2){处理文件传输的代码：)}\n\t\ti=（i+1)%3：//i的值为0,1,2,0,1,2...\n}\n```\n\n> 用户级线程的管理由应用程序完成，而不是操作系统\n>\n> 在用户态下就能换成切换\n>\n> 操作系统不能意识到用户级线程的存在，因为是在用户态进行的，不涉及内核态\n\n优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。\n\n#### **内核级线程**\n\n有操作系统支持的线程\n\n> 线程管理工作由操作系统完成\n>\n> 需要CPU变态切换为内核态\n>\n> 通过TCP(线程控制块进行管理)\n\n优点：分配到不同核心，可以并发执行，当一个线程被阻塞后，别的线程可以继续执行，并发能力强，多线程在多核处理机上并发执行\n\n缺点：一个用户进程会占多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大\n\n##### **多线程模型**\n\n* 一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有**与用户级线程同数量的内核级线程**。左图\n* 多对一模型：多个用户级线程映射到一个内核级线程。且**一个进程只被分配一个内核级线程**。右图\n  * 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高\n  * 缺点：**当一个用户级线程被阻塞后，整个进程都会被阻塞**，**并发度不高**。多个线程不可在多核处理机上并行运行\n  * 重点重点重点：操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。\n\n![image-20231102094718632](操作系统笔记.assets/image-20231102094718632.png)\n\n* 多对多模型，n用户级线程映射到m个内核级线程(n>=m)。每个用户进程对应m个内核级线程。\n  * 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。\n  * 只有所有内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞\n\n#### 线程的状态与转换\n\n```mermaid\ngraph LR\n就绪--3被调度程序选中-->运行\n运行--2时间用完-->就绪\n运行--1等待某事件-->阻塞\n阻塞--4等待的事件发生-->就绪\n```\n\n \n\n##### 线程的组织和管理\n\n按照需要把TCB分门别类组织起来\n\n## 处理调度\n\n资源有限，事情没法同时处理——需要确定某种规则决定处理任务的顺序\n\n### 调度的三个层次\n\n作业：一个具体的任务\n\n**高级调度（作业调度）**。按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。**每个作业只调入一次，调出一次。**作业调入时会建立PCB，调出时才撤销PCB。\n\n> 简化理解：好几个程序需要启动，到底先启动哪个\n\n**低级调度**（**进程调度**/处理机调度）一一按照某种策略从就绪队列中选取一个进程，将处理机分配给它。\n\n> 进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。进程调度的**频率很高**，一般几十毫秒一次。\n\n**中级调度（内存调度）**一一按照某种策略决定将哪个处于挂起状态的进程重新调入内存。\n\n> 当内存不足的时候，有些进程需要先挂起。组织成挂起队列。中级调度决定下一步的策略\n\n#### 七状态模型\n\n```mermaid\ngraph LR\n创建态-->就绪态\n创建态-->就绪挂起\n就绪态-->运行态\n就绪态--挂起-->就绪挂起\n就绪挂起--激活-->就绪态\n运行态-->就绪态\n运行态-->阻塞态\n运行态-->终止态\n阻塞态-->就绪态\n阻塞态--挂起-->阻塞挂起\n阻塞挂起--激活-->阻塞态\n阻塞挂起--事件出现-->就绪挂起\n```\n\n#### 三级调度的联系\n\n**作业调度**从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，\n\n**进程调度**从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。\n\n **中级调度**是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。\n\n特点：\n\n* 作业调度为进程活动做准备，进程调度使进程正常活动起来。\n* 中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间\n* 作业调度次数少，中级调度次数略多，进程调度频率最高。\n* 进程调度是最基本的，不可或缺。\n\n### 调度的目标\n\n调度算法性能评价指标：\n\n* CPU利用率\n  $$\n  \\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}\n  $$\n  \n* 系统吞吐量，表示单位时间CPU完成作业的数量\n\n$$\n\\frac{总共完成作业数}{总共花了多少时间}\n$$\n\n\n\n* 周转时间，周转时间=作业完成时间-作业提交时间\n\n  平均周转时间=(作业1的周转时间+...+作业n的周转时间)/n\n\n  带权周转时间=作业周转时间/作业实际运行时间=(作业完成时间-作业提交时间)/作业实际运行时间 越小用户满意度越高\n\n* 等待时间，进程处于等处理机的时间之和\n\n* 响应时间，指从用户提交请求到系统首次产生响应所用的时间\n\n### 调度的实现\n\n![image-20231102113343526](操作系统笔记.assets/image-20231102113343526.png)\n\n调度程序：用于调度和分派CPU的组件，由三部分组成\n\n* 排队器，故名思意，将系统中的所有**就绪进程**按照一定的策略**排成一个或多个队列**，以便于调度程序选择。每当有一个进程**转变为就绪态时**，排队器便将它**插入到相应的就绪队列**中。\n* 分派器。依据调度程序所选的进程，将其从就绪队列中**取出**，将**CPU分配给新进程**。\n* 上下文切换器。在对处理机进行切换时，会发生两对上下文的切换操作：\n  * 第一对，将当前进程的上下文保存到其P℃B中，再装入分派程序的上下文，以便分派程序运行；\n  * 第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。\n\n#### 调度的时机、切换与过程\n\n{% note warning no-icon %}\n调度程序是操作系统内核程序\n{% endnote %}\n\n* 不能进行进程的调度与切换的情况\n  * 在处理中断的过程中\n  * 进程在操作系统内核临界区中\n  * 其他需要完全屏蔽中断的原子操作过程中。如加锁，中断现场保护\n* 应该进行进程调度与切换的情况\n  * **发生引起调度条件且当前进程无法继续运行下去时**，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是非剥夺调度。\n  * **中断处理结束或自陷处理结束后**，返回被中断进程的**用户态**程序执行现场前，**若置上请求调度标志**，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了剥夺方式的调度。\n\n#### 进程调度方式\n\n* 非抢占调度方式，又称非剥夺方式。不打断\n  * A进程在处理机上执行，此时有进程B进入就绪队列，虽然B可能会比A更紧要，但是还是让A继续，直至运行完成或发生某种事件而进入阻塞态，才把处理机分配给其他进程。\n  * 优点：实现简单、系统开销小，适合大多数批处理系统\n  * 缺点：不能用于分时系统和大多数的实时系统\n* 抢占调度方式，又称剥夺方式。可以打断\n  * 与上述相同情况，当B进入就绪队列，则允许调度程序根据某种原则去暂停正在执行的进程A，将处理机分配给更为重要或紧迫的进程。\n  * 优点：对提高系统吞吐率和响应效率都有明显好处\n  * 注意：但“抢占”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等\n\n#### 闲逛进程\n\n在进程切换时，如果系统没有就绪进程，就会调度闲逛进程(idle)运行。优先级最低。\n\n#### 两种线程的调度\n\n1)用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的**调度程序决定哪个线程运行。**\n2)内核级线程调度。内核选择一个特定线程运行，**通常不用考虑该线程属于哪个进程**。对被选择的线程赋予一个时间片，如果超过了时间片，就会强制挂起该线程。\n用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；\n\n内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。\n\n### 典型的调度算法\n\n#### FCFS\n\n先来先服务(first-come first-served，FCFS)调度算法。\n\n系统将按照作业到达的先后次序来进行调度，非抢占调度方式\n\n可以分别用于作业调度和进程调度。\n\n先到先得：简单、直观\n\n\n问题：平均周转、响应时间过长\n\n#### SJF\n\n短作业优先(short job first，SJF)调度算法\n\nSJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。\n\n可以分别用于作业调度和进程调度。\n\n短任务优先：平均周转时间短\n问题：1）不公平，任务饿死  2）平均响应时间过长\n\n#### PR\n\n优先级调度算法PR\n\n* 每个进程都有一个优先数，优先数为整数。\n* 默认：小的优先数具有高优先级。\n* 目前主流的操作系统调度算法。\n\n#### RR\n\n轮转调度算法（时间片轮转(RR，Round-Robin)调度算法）\n\n> 分时操作系统的诞生而诞生\n\n在轮转(RR)法中，系统将所有的就绪进程按FCFS策略排成一个就绪队列。系统可设置**每隔一定时间(如30 ms)便产生一次中断，去激活进程调度程序进行调度，把CPU分配给队首进程，并令其执行一个时间片。**当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。\n\n优点：公平；响应快，适用于分时操作系统\n\n缺点：由于高频率进程切换有开销，不区分进程紧急程度\n\n* 如果时间片太大就变成了FCFS了\n* 如果时间片太小，进程切换过于频繁，大量时间都用在处理进程切换了\n\n\n\n\n\n> 注意实际做题遇到一种情况：\n>\n> * 当A执行完一个时间片下处理机时，B正好到达，此时默认新进程B先进入队列，下处理机的A后进入队列\n> * 时间片没用完就执行完了，那么也会发生调度， \n\n#### 优先级调度算法\n\n优先级一样的先到的先运行\n\n#### 多级反馈队列调度算法\n\n是对上面方法的折衷\n\n![image-20231229111344095](操作系统笔记.assets/image-20231229111344095.png)\n\n两个关键\n\n* 新进程FCFS先进入第一级\n* 执行完放到下一级队列队尾\n* 只有当k级队列为空，才会为k+1级队头的进程分配时间片\n* ((默认是抢占式的)被抢占处理机的进程重新放回原队列队尾\n* 在最后一级用完时间片回到原队列队尾(即采用时间片轮转调度)\n\n优点\n\n* 对各类型进程相对公平(FCFS的优点)\n* 每个新到达的进程都可以很快就得到响应(RR的优点)\n* 短进程只用较少的时间就可完成(SPF的优点)；\n* 不必实现估计进程的运行时间（避免用户作假）\n* 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（拓展：可以将因/O而阻塞的进程重新放回原队列，这样\n  /O型进程就可以保持较高优先级)\n\n#### 总结\n\n![image-20231229111427276](操作系统笔记.assets/image-20231229111427276.png)\n\n# 进程同步\n\n**忙等待：**指在单CPU情况下，一个进程进入临界区之后，其他进程因无法满足竞争条件而循环探测竞争条件。其缺点是，在单CPU情况下，等待进程循环探测竞争条件，浪费了时间片。\n\n## 概念定义\n\n并发相互合作\n\n### 两种形式的制约关系\n\n* 间接相互制约关系(互斥关系)\n\n  对资源互斥访问，提出申请\n\n* 直接相互制约关系(同步关系)\n\n  多个进程完成同一个任务\n\n### 进程同步机制\n\n* 软件同步机制\n* 硬件同步机制\n* **信号量机制**：一种有效的进程同步机制，已被广泛应用\n* 管程机制\n\n#### 软件同步机制\n\n**面包店算法**\n\nPeterson方案，主动谦让\n\n```c++\ndo {\n\tflag[i] = true; //表示希望占用\n\tturn = j; //如果另一进程希望进入，当前进程忙等\n\twhile (flag[j] && turn == j); //flag[j]表示另一进程在用，turn==j表示我进行谦让\n\t临界区;\n\tflag[i] = false;\n\t剩余区;\n} while (1);\n```\n\nturn=j保证了当我是最后一个被谦让的就能得到资源了\n\n#### 硬件同步机制\n\n##### 关中断\n\n最简单的实现互斥的方法。\n进入锁测试前，**关掉中断机制**，完成锁测试且上锁后，**开启中断测试**。则执行临界区期间，不响应中断，所以保证了原子性。\n缺点：①滥用关中断权限可能导致严重后果。②关中断太长影响系统效率，限制CPU交叉执行程序能力；③不适用于多CPU系统，一个CPU关中断不防其他CPU执行相同临界区代码\n\n**test-and-set**\n\n```c++\nbool ts(bool& lock) { //原语(原子性)\n\tbool old = lock;\n\tlock = true;//上锁\n\treturn old;\n}\n```\n\n```c++\ndo {\n\t//...\n\twhile (ts(lock));\n\t//临界区\n\tlock=false;//解锁\n\t//剩余区;\n} while(true);\n```\n\n如果测试返回结果为 true，证明被上锁了，则需要等待(再赋值一次lock为真也没用)。否则，证明还没被上锁，赋值一次代表进行上锁。\n\n**swap**\n\n\n\n> 然而以上都不适合由普通用户实现\n\n因此出现信号量机制\n\n## 信号量机制\n\n找到哪些地方要停，什么时候再走\n\n信号量为正表示多多少个资源可以被使用\n\n为负表示有多少个进程等待使用\n\n**信号量-软件解决方案：**\n\n* 保证两个或多个代码段不被并发调用\n* 在进入关键代码段前，进程必须获取一个信号量，否则不能运行\n* 执行完该关键代码段，必须释放信号量\n* 信号量有值，**为正说明它空闲，为负说明其忙碌**\n\n\n\n**类型：**\n\n整型信号量->**记录型信号量**->AND型信号量->信号量集\n\n\n\n**信号量vs锁**\n\n* 信号量是一个一般的锁\n  * 锁{0,1}，信号量：{-∞,...,-2,-1,0,1,2,...∞}\n  * 信号量即信号的数量，唤醒的就是发一个信号\n  * 开锁也是一个信号\n* 信号量作用\n  * 实现互斥\n  * 记录睡眠操作的次数\n  * 记录资源个数\n  * 记录等待进程个数\n  * 实现复杂的进程间同步关系\n\n基本知识\n\n* 用户进程->使用操作系统提供的一对原语->对信号量进行操作，从而很方便的实现了**进程互斥**、**进程同步**\n* 信号量其实就是一个变量，表示系统中某种资源的数量\n* 原语，其执行只能一气呵成，不可被中断\n* 一对原语：wait(S) 原语和 signal(S) 原语\n* wait、signal 原语常简称为 P、V操作，把wait(S)，signal(S) 两个操作分别写为 P(S)、V(S)\n\n### wait,signal操作定义\n\n```c\nwait(semaphores *S) {   \t//请求一个单位的资源\n  S->value --; \t\t\t//资源减少一个\n  if (S->value<0) {\n     block(S->list) ；}\t//进程自我阻塞，并将其挂到信号S的等待队列（阻塞队列）中\n}\n\nsignal(semaphores *S){ \t\t\t//释放一个单位资源\n  S->value++; \t\t\t//资源增加一个\n  if (S->value<=0) \n      wakeup(S->list); \t//唤醒等待队列中的一个进程\n}\t\t\n\n```\n\n![image-20231116093230645](操作系统笔记.assets/image-20231116093230645.png)\n\n### 信号量的应用\n\n​    **1.** **利用信号量实现进程互斥**\n\n为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。\n\n```c\nsemaphore mutex; \nmutex=1; // 初始化为 1\nwhile(1)\n{\twait(mutex);\n\t临界区；\n\tsignal(mutex);\n\t剩余区；}\n\n```\n\n​       2. 利用信号量实现同步（前趋后继关系）\u000b　　还可利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行S2。为实现这种前趋关系，只需使进程P1和P2共享一个公用信号量S，并赋予其初值为0，将signal(S)操作放在语句S1后面，而在S2语句前面插入wait(S)操作，保证了S2 一定是在S1之后执行。**技巧口诀：前V后P。**\n\n```c\nP1(){\n  S1;\n  signal(S);\n  ...\n}\n\nP2(){\n  wait(S);\n  S2;\n  ...\n}\n\n```\n\n利用前趋图\n\n![image-20231116093457693](操作系统笔记.assets/image-20231116093457693.png)\n\n![image-20231116093508052](操作系统笔记.assets/image-20231116093508052.png)\n\n### 解法分析——出现死锁\n\n![image-20231116093556001](操作系统笔记.assets/image-20231116093556001.png)\n\n## 管程机制\n\n​        Hansan为管程所辖的定义：一个管程定义了一个**数据结构**和能为并发进程所执行（在该数据结构上）的一组**操作**，这组操作能同步进程和改变管程中的数据。\u000b\n\n> 数据结构：信号量 操作：pv原语\n\n### 生产者消费者\n\n\n\n### 哲学家进食\n\n### 读者写者\n\n## 3.5死锁 上课插入的\n\n原因：\n\n**1.** **竞争不可抢占性资源引起死锁**\n\n**2.** **竞争可消耗资源引起死锁**\n\n**3.** **进程推进顺序不当引起死锁**\n\n目前处理死锁的方法可归结为四种：\n 　(1) 预防死锁。\n 　(2) 避免死锁。\n 　(3) 检测死锁。\n 　(4) 解除死锁。\n\n![image-20231116105804885](操作系统笔记.assets/image-20231116105804885.png)\n\n### 预防死锁\n\n满足两种协议\n\n* 第一种协议：该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。缺点：资源利用率低，可能出现饥饿。 特别是需要申请很多资源的时候更容易出问题。\n* 第二种协议：该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。 其后在运行过程中逐步释放已经分配的且用毕的全部资源，然后再请求新资源。缺点：对进程运行过程中的资源需求要有清晰的认识，实现难度很大。\n\n### 避免死锁\n\n银行家算法\n\n![image-20231116110403618](操作系统笔记.assets/image-20231116110403618.png)\n\n本题的安全序列为P2，P1，P3，可以先满足P2，P2释放后足够给P1，P1释放后足够给P3\n\n# 存储管理\n\n## 引入\n\n程序需要先放到内存中才能被CPU处理——用来缓和CPU与硬盘之间的速度矛盾 \n\n内存地址从0开始，每个地址对应一个存储单元。\n\n每个小房间就是一个存储单元\n\n两种说法：\n\n* 如果计算机”按字节编址“则每个存储单元大小为1字节，即1B，即8个二进制位\n* 如果字长为16位的计算机“按字编址”，则每个存储单元大小为1个字；每个字的大小为16个二进制位。\n\n内存使用：将**程序放到内存中**，PC指向开始地址\n\n### 程序的执行\n\n* 1编译--从C到汇编\n\n![image-20231123123859063](操作系统笔记.assets/image-20231123123859063.png)\n\n* 2链接--从汇编到可执行程序\n\n  ![image-20231123124143857](操作系统笔记.assets/image-20231123124143857.png)\n\n* 3然而还是程序，不是进程，要由装载器进行内存装入...\n\n  ![image-20231123124229654](操作系统笔记.assets/image-20231123124229654.png)\n\n* 同时，由于内存地址从0开始，为了防止内存中从0开始的一段内存有专门的用途怎么办? 要有：\n\n  **重定位**: 为执行程序而对其中出现的地址（相对地址）所做的修改\n\n重定位两个时机：\n\n* 1在编译链接时，绝对代码: 这样的代码只能放在事先确定的位置上。即编译时重定位的程序只能放在内存固定位置\n* 2载入时，一旦载入内存中就不能移动\n\n因此，移动也是必要的\n\n### 交换\n\n能让更多的进程并发\n\n## 存储器管理\n\n> 目标：容量大，速度快，成本低\n\n### 多层结构的存储器系统\n\n三级：\n\n* 最高层：CPU寄存器\n* 中间为主存（高速缓存、主存储器、磁盘缓存）\n* 最底层是辅存（固定磁盘，可移动介质）\n\n特点：\n\n＊层次越高－访问速度越快－价格越高－存储容量也最小\n\n＊**寄存器和主存**掉电后存储的信息不再存在\n\n＊辅存的信息长期保存\n\n![image-20231126151710613](操作系统笔记.assets/image-20231126151710613.png)\n\n## 程序的装入和链接\n\n用户的程序要在系统中运行，要先装入内存再转变为可执行的程序，步骤：\n\n(1) **编译**，由编译程序(Compiler)对用户源程序进行编译，形成若干个目标模块(Object Module)；\n (2) **链接**，由链接程序(Linker)将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的装入模块(Load Module)；\n (3) **装入**，由装入程序(Loader)将装入模块装入内存。\n\n![image-20231126152542178](操作系统笔记.assets/image-20231126152542178.png)\n\n### 物理地址和逻辑地址\n\n* 物理地址(绝对地址)\n  * 物理内存的地址，内存以**字节/字**为单位编址\n  * 物理地址空间：所有物理地址的集合\n* 逻辑地址(虚拟地址、相对地址)\n  * 由CPU产生的地址，即程序编译后使用的**相对于0字节的地址**\n  * 逻辑地址空间：由程序所生成的所有逻辑地址的集合\n\n![image-20231126152807165](操作系统笔记.assets/image-20231126152807165.png)\n\n### 程序的装入\n\n三种装入方式：\n\n1. 绝对装入方式-**编译连接时**。编译时产生的地址使用绝对地址\n\n2. 可**重定位**装入方式-**载入时**。编译后的目标模块使用相对地址，装入后的地址是绝对地址(物理地址)\n\n   在装入时，完成重定位（**静态重定位**）重定位，通常来说把在装入时对目标程序中指令和数据地址修改的过程称为**重定位**\n\n   重定位：逻辑地址转换为物理地址的过程，称为重定位，也成为地址变换。\n\n3. **动态运行**时的装入方式。编译后的目标模块使用相对地址。在运行后完成重定位(**动态重定位**)-**地址翻译**\n\n两种重定位方式比较\n\n* 静态重定位，地址变换是在进程装入时一次完成的以后不再改变\n\n  优点：是无需增加硬件地址转换机构，便于实现程序的静态连接。在早期计算机中大多采用这种方案\n\n  缺点：内存空间不能移动；各个用户进程很难共享同一程序的副本。\n\n* 动态重定位，并不立即把装入模块的逻辑地址进行转换，推迟到程序执行是才进行。需要寄存器的支持\n\n  优点：内存空间可以移动；各个用户进程可以共享内存中同一程序的副本。\n\n  缺点：增加了机器成本，而且实现存储管理的软件算法比较复杂。\n\n### 程序的连接\n\n三种\n\n* 静态链接方式\n* 装入时动态链接\n* 运行时动态链接\n\n### 对换和覆盖\n\n引入：某些进程由于某些事件未发生导致阻塞运行，有很多作业又因为内存不足一直驻留在外存，不能进入内存运行。\n\n> 严重浪费系统资源，吞吐量下降\n\n**对换：**不能运行/暂时不用的进程调出到外存，已具备条件的调入到内存\n\n### 多道程序环境下的对换技术\n\n对换的类型：\n\n* 整体对换\n* 页面对换\n\n### 对换空间的管理\n\n## 对换与覆盖\n\n## 分页存储管理方式\n\n### 单一连续分配\n\n存储器把内存分配系统区和用户区\n\n* 系统区给os用\n* 用户区内存仅装有且一道用户程序\n\n### 固定分区分配\n\n### 动态分区分配\n\n### 动态可重定位分区分配\n\n内存紧缩: 将空闲分区合并在一起，需要移动进程3(复制内容)\n\n![image-20231130091137018](操作系统笔记.assets/image-20231130091137018.png)\n\n## 分页存储管理方式\n\n把物理内存分成大小固定的块，称为**物理块**(frame，也称为页框)（大小为2的幂，通常为1KB~8KB）\n\n把逻辑内存也分成固定大小的块，称为**页**(page)\n\n### 分页存储管理的基本方法\n\n![image-20231130094741049](操作系统笔记.assets/image-20231130094741049.png)\n\n#### ⭐页表 要考几题的\n\n**地址结构**：\n\n以**32**位地址举例，\n\n页号P：\n\n* 12-32位：**20**位\n* 地址空间最多允许有1M(2<sup>20</sup>)页\n\n位移量W(页内地址)\n\n* 0-11：12位\n* 每页大小为4KB(2<sup>12</sup>)\n\n![image-20231130100319228](操作系统笔记.assets/image-20231130100319228.png)\n\n在分页系统中，**允许将进程的各个页离散地存储在内存的任一物理块中**，为保证进程仍然能够正确地运行，即能在内存中找到每个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n\n**页表的作用：实现从页号到块号的地址映射。**（类比路由表）\n\n![image-20231130094910566](操作系统笔记.assets/image-20231130094910566.png)\n\n**页表的实现**\n\n![image-20231130095405196](操作系统笔记.assets/image-20231130095405196.png)\n\n### 地址变换机构\n\n1. 基本地址变换机构-地址翻译\n\n   即将用户地址空间中的**逻辑地址变换为内存空间中的物理地址**\n\n   **页表功能是由一组专门的寄存器来实现的**。一个页表项用一个寄存器(PTR)。\n\n2. 具有**快表**的地址变换机构(类别缓存)\n\n   起因：\n\n   由于页表是存放在内存中的，这使CPU在每存取一个数据时，都要两次访问内存。\n\n   第一次是访问内存中的页表，从中找到指定页的物理块号，再将**块号与页内偏移量W拼接**，以形成**物理地址**。\n\n   第二次访问内存时，才是从第一次所得地址中获得所需数据(或向此地址中写入数据)。\n\n   因此，采用这种方式将使计算机的处理速度降低近1/2\n\n   通过快表查询，可以直接得到逻辑页所对应的物理块号，由此拼接形成**实际物理地址**，减少了一次内存访问，缩短了进程访问内存的有效时间\n\n   > 由于快表的容量限制，不可能将一个进程的整个页表全部装入快表，存在着命中率的问题\n\n### 页表结构的缺点\n\n* 逻辑地址空间很大，页表变得非常大，要占相当大的内存空间\n\n* 解决办法\n\n  * 对页表所需的内存空间采用离散方式\n  * 部分页表调入内存\n\n* 页表结构\n\n  * 两级页表\n  * 多级页表\n  * 反置页表\n\n  \n\n#### TLB(Translation Look-aside Buffer)\n\n是一组相联快速内存\n\n### 反置(反向)页表\n\n目的：**为减少页表占用的内存空间，引入反置页表**，一个系统一张页表\n\n可使用哈希表来将查找限制在一个或少数几个页表条目。\n\n### 分页技术总结\n\n* 实现机理\n  * 地址空间和内存都分开大小相等的片(**页和页框**)\n  * 每个进程用页表(多级、反向等)建立页和页框的映射\n  * 进程创建时申请页，可用**表、位图**等结构管理空闲页\n  * 逻辑地址**通过页表算出物理地址**，到达内存\n  * 进程切换时，页表跟着切换\n\n优点：靠近硬件，结构严格，高效使用内存，分页更适合于自动化(硬件实现)\n\n缺点：不符合程序员思考习惯——**引出分段技术**\n\n# 虚拟存储器\n\n用户眼里的内存：\n\n用户可随意使用该地址空间，就象单独拥有4G内存，**这个地址空间怎么映射到物理内存，用户全然不知**——虚拟内存\n\n优点：\n\n* 地址空间>物理内存\n  * 编写比内存大的程序\n  * 空间使用简化编程\n* 部分程序放入物理内存\n  * 可以放更多进程\n  * 需要的才放进去，用不到的不放，内存利用率高\n  * 程序执行响应效率更高\n\n##  虚拟存储器概述\n\n1. 常规存储管理方式特征\n   1. 一次性：作业被一次性全部装入内存\n   2. 驻留性：作业一直驻留在内存\n2. 局部性原理\n   1. 程序执行仅局限于某个部分，它访问的存储空间也局限于某个区域\n\n局限性：\n\n* 时间局限性：一条指令被执行了，则在不久的将来它可能再被执行\n* 空间局限性： 若某一存储单元被使用，则在一定时间内，与该存储单元**相邻的单元**可能被使用。\n\n工作原理：\n\n基于局部性原理可知，应用程序在**运行之前没有必要将之全部装入内存**，而仅须将那些当前**要运行的**少数页面或段**先装入**内存便可运行，其余部分暂留在盘上。\n\n**虚拟存储器：**具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而成本接近于外存\n\n特征：\n\n* **多次性**。作业中的程序和数据允许被分成多次调入内存允许\n* **对换性**。作业运行时无须常驻内存\n* **虚拟性**。从逻辑上扩充了内存容量，使用户看到的内存容量远大于实际内存容量\n\n### 实现方法\n\n分页请求系统\n 　1) 硬件支持\n 　主要的硬件支持有：\n 　 　 　 　 　 　 　   (1) 请求分**页**的**页表**机制。\n 　 　 　 　 　 　 　   (2) 缺页中断机构。\n 　 　 　 　 　 　 　   (3) 地址变换机构。\n 　2) 实现请求分页的软件\n        请求调页软件、页面置换软件。\n\n\n\n请求分段系统\n 　1) 硬件支持\n 　主要的硬件支持有：\n 　 　 　 　 　 　 　   (1) 请求分**段**的**段**表机制。\n 　 　 　 　 　 　 　   (2) 缺页中断机构。\n 　 　 　 　 　 　 　   (3) 地址变换机构。\n 　2) 软件支持\n       请求调段软件、段置换软件。\n\n### 请求分页中的硬件支持\n\n1. 请求页表机制\n\n![image-20231207092851757](操作系统笔记.assets/image-20231207092851757.png)\n\n2. 缺页中断机构\n\n(1) 在指令执行期间产生和处理中断信号。\n\n(2) 一条指令在执行期间可能产生多次缺页中断\n\n3. 地址变换机构\n\n在分页系统地址变换机构的基础上，为实现虚拟存储器，再**增加了某些功能所形成的**，如产生和处理缺页中断，以及从内存中换出一页的功能等等。\n\n缺页率：\n\n访问页面成功(即所访问页面在内存中)的次数为S，访问页面失败(即所访问页面不在内存中，需要从外存调入)的次数为F，则该进程总的页面访问次数为A = S + F **缺页率：f=F/A**\n\n影响因素：**页面大小、分配内存块的数目、页面置换算法、程序固有属性**\n\n缺页中断处理时间：\n\n假设被置换的页面被修改的概率是β，其缺页中断处理时间为ta，被置换页面没有被修改的缺页中断时间为tb，那么，缺页中断处理时间的计算公式为 t=βxta+(1-β)xtb\n\n![image-20231207093911044](操作系统笔记.assets/image-20231207093911044.png)\n\n## ⭐页面置换算法\n\n* 最佳置换算法（OPT）\n* 先进先出置换算法（FIFO）\n* 最近最久未使用置换算法（LRU）\n* 最少使用算法（LFU）\n* Clock置换算法\n* 页面缓冲算法\n\n> 目标：需要一个最小的缺页率\n\n#### FIFO\n\n![image-20231207095323628](操作系统笔记.assets/image-20231207095323628.png)\n\n#### OPT\n\n![image-20231207095346629](操作系统笔记.assets/image-20231207095346629.png)\n\n未来最远(或不访问的)替换掉\n\n#### LRU\n\n![image-20231207095355497](操作系统笔记.assets/image-20231207095355497.png)\n\n换谁？当前离进入的页最远的，比如D进来，应该把A换掉\n\n需要的条件：\n\n* 每页维护一个时间戳(time stamp)\n* 栈\n\n#### LFU\n\n在采用LFU算法时，应为在内存中的每个页面设置一个移位寄存器，用来记录该页面被访问的频率。该置换算法**选择在最近时期使用最少的页面作为淘汰页。**（代价大，少用）\n\n#### LRU近似算法\n\n##### 简单的Clock置换算法\n\n当利用简单Clock算法时，只需为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。\n\nØ每个页都与一个访问位相关联，初始值位0\n\nØ当页被访问时置访问位为1\n\nØ置换时选择访问位为0的页 ；若为1，重新置为0\n\n![image-20231207102638992](操作系统笔记.assets/image-20231207102638992.png)\n\n![image-20231207101119667](操作系统笔记.assets/image-20231207101119667.png)\n\n> 指针指向上一个缺页的，最近最少\n\n相比于栈，指针效率更高\n\n##### 改进型Clock置换算法\n\n在改进型Clock算法中，除须考虑页面的使用情况外，还须再增加一个因素—**置换代价（页表项里的修改位）**。 \n\n![image-20231207103920663](操作系统笔记.assets/image-20231207103920663.png)\n\n## “抖动”与工作集\n\n人们希望在系统中能运行更多的进程，即增加多道程序度，以提高处理机的利用率\n\n如果没有足够的页框——缺页率将很高，导致\n\n* CPU利用率低下\n* 操作系统认为需要增加多道程序设计的道数\n* 系统中将加入一个新的进程\n\n**抖动：**一个进程的页面经常换入换出\n\n发生“抖动”的根本原因是，同时在系统中运行的进程太多，由此分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁地出现缺页，必须请求系统将所缺之页调入内存。\n\n> 抖动的发生与系统为进程分配物理块（页框）的多少有关\n\n**工作集**\n\n所谓工作集，**是指在某段时间间隔Δ里，进程实际所要访问页面的集合。**Denning指出，虽然程序只需要少量的几页在内存便可运行，但为了较少地产生缺页，应将程序的全部工作集装入内存中。然而我们无法事先预知程序在不同时刻将访问哪些页面，故仍只有像置换算法那样，用程序的过去某段时间内的行为作为程序在将来某段时间内行为的近似。\n\n## 请求分段存储管理方式\n\n![image-20231207104627159](操作系统笔记.assets/image-20231207104627159.png)\n\n![image-20231207104633506](操作系统笔记.assets/image-20231207104633506.png)\n\n\n\n# 文件\n\n## ⭐文件的物理结构(分配方式)\n\n连续分配\n\n连接分配：显式隐式\n\n类似于内存分页，磁盘中的存储单元被分为一个个“块/磁盘块/物理块\"\n\n**一般，磁盘块大小=内存块大小=页面大小，方便数据交换**\n\n* 在内存管理中，进程的逻辑地址空间被分为一个一个页面\n* 同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”于是文件的逻辑地址也可以表示为**（逻辑块号，块内地址）**的形式。\n* 物理块号不可知\n\n>  操作系统仍然需要一个逻辑快号到物理块号的映射\n\n### 连续分配\n\n**逻辑上连续，则在物理上位置也要连续**\n\n如何实现？\n\n查目录项实现\n\n**物理块号=起始块号+逻辑块号**\n\n![image-20231231211954348](操作系统笔记.assets/image-20231231211954348.png)\n\n\n\n优点\n\n* 连续分配的文件在顺序读/写时速度最快(磁头移动距离短\n\n缺点\n\n* 不方便拓展(如果要拓展但是没有相邻的空闲块了，需要整体迁移，拓展不方便)\n* 存储空间利用率低，会产生难以利用的磁盘碎片(可能没有连续的足够长的块大小，那都分配不了了)\n  * 利用紧凑来处理，但是消耗很大资源\n\n### 链接分配\n\n采用离散的方式为文件分配磁盘块\n\n#### 隐式链接\n\n每个磁盘块都会保存指向下一个盘块的指针\n\n取出来一个逻辑块，才知道下一个块存放的物理块号\n\n因此读入i号逻辑块欧总共需i+1次磁盘I/O\n\n结论：\n\n优点\n\n* 采用隐式链接的链接分配方式，很方便文件拓展。\n* 另外，所有的空闲磁盘块都可以被利用，不会有碎片问题，外存利用率高。\n\n缺点\n\n* 采用链式分配（隐式链接）方式的文件，**只支持顺序访问(看作是链表)**，不支持随机访问，查找效率低。\n* 另外，指向下一个盘块的指针也需要耗费少量的存储空间。\n\n![image-20231231213213213](操作系统笔记.assets/image-20231231213213213.png)\n\n#### 显示链接\n\n把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配(**FAT**,File Allocation Table)\n\n一个磁盘有多少块，在FAT就有多少个表项。就是把隐式的指针信息都汇总到一个表方便找\n\n![image-20231231213520195](操作系统笔记.assets/image-20231231213520195.png)\n\n用户给出要访问的逻辑块号，操作系统找到文件对应的目录项(FCB)\n\n找到起始块，查询FAT，然后找到i号逻辑块对应的物理块号\n\n对比隐式链接：逻辑块号转换为物理块号的过程不需要读磁盘操作\n\n优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高。\n缺点：文件分配表的需要占用一定的存储空间。\n\n\n\n* 一个磁盘只会建立一张文件分配表\n* 开机FAT放入内存，并常驻内存\n\n单说链接分配默认是隐式链接\n\n### 索引分配\n\n索引分配允许文件离散地分配在各个磁盘块中，系统会**为每个文件建立一张索引表**，索引表中记录了文件的各**个逻辑块对应的物理块**（索引表的功能类似于内存管理中的页表一一建立逻辑页面到物理页之间的映射关系)。\n\n索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块。\n\n> 在FCB目录项记录索引块\n\n![image-20240102152719095](操作系统笔记.assets/image-20240102152719095.png)\n\n注：区分显式链接和索引分配\n\n* 在显式链接的链式分配方式中，文件分配表**FAT是一个磁盘对应一张**。\n* 而索引分配方式中，索引表是一**个文件对应一张**。\n\n## 文件存储空间的管理\n\n### 存储空间的划分与初始化\n\n存储空间的划分：将物理磁盘划分为一个文件卷(逻辑卷、逻辑盘)\n\n文件卷划分为目录区和文件区\n\n目录区主要存放文件目录信息(FCB)、用于磁盘存储空间管理的信息\n\n文件区用于存放文件数据\n\n![image-20240102181904379](操作系统笔记.assets/image-20240102181904379.png)\n\n## 存储空间管理\n\n### 空闲表法\n\n空闲盘块表，适用于”连续分配方式“，表头第一个空闲盘块号--空闲盘块号\n\n类比内存管理中的动态分区分配，可以用首次适应、最佳适应和最坏适应等来决定分配。\n\n如何回收磁盘块：与内存管理中的动态分区分配很类似，当回收某个\n存储区时需要有四种情况一一\n\n①回收区的前后都没有相邻空闲区：\n\n②回收区的前后都是空闲区：\n\n③回收区前面是空闲区：\n\n④回收区后面是空闲区。\n\n总之，回收时需要注意表项的合并问题。\n\n### 空闲链表法\n\n空闲**盘块**链，空闲**盘区**链\n\n![image-20240102182625800](操作系统笔记.assets/image-20240102182625800.png) \n\n操作系统保存着**链头、链尾指针**。\n**如何分配：**若某文件申请K个盘块，则可以采用**首次适应、最佳适应**等算法\n\n* 从**链头开**始检索，按照算法规则找到一个大小符合要求的空闲盘区分配给文件。\n* 若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据\n\n**如何回收：**\n\n* 若回收区和某个空闲盘区**相邻**，则需要将回收区合并到空闲盘区中.\n* 若回收区没有和任何空闲区相邻，将回收区作为**单独的一个空闲盘区挂到链尾。**\n\n>  离散分配、连续分配都适用，为一个文件分配多个盘块时效率更高\n\n![image-20240102183020350](操作系统笔记.assets/image-20240102183020350.png)\n\n### ⭐位示图法\n\n每一个二进制对应一个盘块，0表示空闲，1表示非空闲\n\n**字号、位号**二元组来定位盘块号\n\n> 注意盘块号、字号、位号是从0开始还是从1开始\n>\n> 0和1哪个代表空闲哪个代表不空闲\n\n从0开始，(字号、位号)=(i,j)的二进制位对应的\n\n* 盘块号 `b=ni+j`\n* 由盘块号推字号位号：字号 `i=b/n`，位号 `j=b%n`\n\n盘块从1开始，正推盘块加，逆推字位号减\n\n* 盘块号 `b=ni+j+1`\n* 字号 `i=(b-1)/n`，位号 `j=(b-1)%n`\n\n**如何分配：**若文件需要K个块，\n\n①顺序**扫描位示图**，找到K个**相邻**或**不相邻**的“0”;\n②根据**字号、位号**算出对应的**盘块号**，将相应盘块分配给文件;\n③将**相应位设置为“1”**。\n\n**如何回收：**\n\n①根据回收的盘块号计算出对应的字号、位号\n②将相应二进制位**设为“0”**\n\n### 成组链接法\n\nUNIX采用的策略\n\n空闲表和空闲链表法不适用于大型文件系统\n\n**超级块：空闲盘块数+空闲盘块号**\n\n**第一个盘块也是一个类似超级块**，记录下一个分组的空闲盘块数+空闲盘块号 \n\n注：一个分组中的块号不需要连续\n\n最后一个分组少一个盘块，原因是他不需要一个超级块指示下一个分组了\n\n如何分配：\n\n当占满一个分组时，需要把这个分组指向下一个分组的信息赋值到超级块，超级块充当链头的作用，否则会丢失后面的链接\n\n![image-20240102185814551](操作系统笔记.assets/image-20240102185814551.png)\n\n如何回收：\n\n第一种：分组未满，插入到空闲块号，并增加空闲盘块数\n\n![image-20240102185758233](操作系统笔记.assets/image-20240102185758233.png)\n\n第二种，若分组已满，回收的时候新建一个分组，并将超级块的信息复制到新的分组，作为一个新的分组，指向下一个分组，超级块指向新分组\n\n![image-20240102185742181](操作系统笔记.assets/image-20240102185742181.png)\n\n# 输入输出系统\n\n![image-20231214084616751](操作系统笔记.assets/image-20231214084616751.png)\n\n**外设如何工作：**\n\n![image-20231214085450083](操作系统笔记.assets/image-20231214085450083.png)\n\n## I/O系统的功能、模型和接口\n\n### 什么是I/O设备？\n\n“I/O” 就是 “输入/输出”（Input/Output）。I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。\n\nUNIX系统将外部设备**抽象为一种特殊的文件**，用户可以使用与文件操作相同的方式对外部设备进行操作。\n\n>  I/O系统管理的主要对象是I/O设备（Terminal）和相应的设备控制器。\n\n最主要的任务\n\n* 完成用户提出的I/O请求，提高I/O速率\n* 提高设备的利用率\n* 能为更高层的进程方便地使用这些设备提供手段\n\n设备的分类\n\n* 块设备\n* 字符设备\n* 低速设备\n* 中速设备\n* 高速设备\n\n### 基本功能\n\n1. 隐藏物理设备的细节\n2. 能够保证OS与设备的无关性\n3. 提高处理机和I/O设备的利用率\n4. 对I/O设备进行控制\n\n![image-20231214095652859](操作系统笔记.assets/image-20231214095652859.png)\n\n> 既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能\n\n**I/O接口**由三部分组成\n\n* 设备控制器与CPU的接口\n* 设备控制器与设备的接口\n* I/逻辑\n\n**I/O端口**，有三类寄存器\n\n* 数据寄存器\n* 状态寄存器\n* 控制寄存器\n\nCPU与I/O端口进行通信两种方法\n\n* 独立编址\n* 统一编制\n\n### I/O控制方式\n\n#### 程序直接控制\n\n* 计算机从外部设备读取每个字\n* CPU需要对外设状态进行循环检查\n* 直到确定改字已经在I/O控制器的数据寄存器种\n\n然而CPU和高速性和I/O设备的低速性，使得CPU都处于等待I/O设备完成循环测试，造成浪费\n\n-》需要不断测试的原因：没有采用中断-I/O无法报告已经完成一个字符操作-CPU要不断测试设备状态\n\n\n\n程序直接控制方式\n\n优点：简单且易于实现，\n\n缺点：由于CPU和I/O设备只能串行工作，导致CPU的利用率相当低。\n\n#### 中断驱动方式\n\n![image-20231214103820357](操作系统笔记.assets/image-20231214103820357.png)\n\n#### DMA方式\n\n特点：\n\n1)基本单位是数据块。\n\n2)所传送的数据，是从设备直接送入内存的，或者相反。\n\n3)仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。\n\n![image-20231214104554948](操作系统笔记.assets/image-20231214104554948.png)\n\n要在主机与控制器之间实现成块数据的直接交换，须在DMA控制器中设置如下4类寄存器：\n\n1)命令状态寄存器(CR)。接收从CPU发来的I/O命令、有关控制信息，或设备的状态。\n\n2)内存地址寄存器(MAR)。在输入时，它存放把数据从设备传送到内存的起始目标地址：在输出时，它存放由内存到设备的内存源地址。\n\n3)数据寄存器(DR)。暂存从设备到内存或从内存到设备的数据。\n\n4)数据计数器(DC)。存放本次要传送的字（节）数。\n\n|          | 中断时机                                                 | 控制                                 |\n| -------- | -------------------------------------------------------- | ------------------------------------ |\n| 中断方式 | 中断方式在每个数据需要传输时中断CPU                      | 数据传送中断处理时由CPU控制完成的    |\n| DMA方式  | DMA方式则是在所要求传送的一批数据全部传送结束时才中断CPU | DMA方式则是在DMA控制器的控制下完成的 |\n\n\n\n#### 通道控制方式\n\n![image-20231214104754559](操作系统笔记.assets/image-20231214104754559.png)\n\n### I/O软件层次结构\n\n| 用户层I/O软件  |\n| :------------: |\n| 设备独立性软件 |\n|  设备驱动程序  |\n|  中断处理程序  |\n|      硬件      |\n\n### 应用程序I/O接口\n\n(1)字符设备接口\n\n(2)块设备接口\n\n(3)网络设备接口\n\n(4)阻塞/非阻塞/O\n\n文件系统：文件+目录\n\n## 缓冲区管理\n\n### 缓冲池\n\n一般将缓冲池中具有相同类型的缓冲区链接成一个队列，于是可形成以下三个队列：\n\n(1) 空白缓冲队列emq。空缓冲区所链成的队列\n\n(2) 输入队列inq。装满输入数据的缓冲区所链成的队列\n\n(3) 输出队列outq。装满输入数据的缓冲区所链成的队列\n\n### 缓存\n\n* 缓存是保存数据副本的高速内存区域：\n  * CPU缓存、磁盘缓存、光驱缓存等\n* CPU缓存（高速缓存）：\n  * 为了缓和CPU运行速率与内存读/写速率不匹配的矛盾；\n  * 当CPU要读取一个数据时，首先从CPU**缓存**中查找，找到就立即读取并送给CPU处理；若没有找到，则从速率相对较慢的**内存**中读取并送给CPU处理，同时把这个数据所在的数据库调入缓存中。\n* 缓存和缓冲\n  * **缓冲**可以保存数据项的唯一的现有版本。\n  * **缓存**只是提供一个位于其他地方的数据项的更快存储副本。\n  * 有时，同一个内存区，既可以是缓冲，也可以是缓存\n\n## 磁盘存储器的性能和调度\n\n![image-20231221090650033](操作系统笔记.assets/image-20231221090650033.png)\n\n**容量=柱面×磁头×扇区**，每扇区存放512B数据\n\nc h s\n\n* 40GB硬盘\n  * cylinder:19710、head:16、sector:255\n  * 计算：19710×255×16×512B=41173401600B=40GB\n* 1.44MB软盘\n  * Sides:2、Tracks:80、Sectors:18\n  * 计算：2×80×18×512B=1.44MB\n\n磁盘的类型*考试几率不大\n\n磁盘-块-块集-文件\n\n**一次磁盘读写操作需要的时间：**寻道时间、旋转延迟时间、传输时间\n\n* 寻道时间：把磁臂（磁头）移动到指定磁**道**上所经历的时间。\n* 旋转延迟时间：把指定扇区移动到磁头下所经历的时间。\n* 传输时间：把数据从磁盘读出或向磁盘写入数据所经历的时间\n\n### 文件目录\n\n查找的时候只关心文件名，因此把除了文件名的描述信息全部放到索引结点\n\n文件名+指向索引结点的指针\n\nFCB一个代表一个目录项\n\n![image-20231229213228364](操作系统笔记.assets/image-20231229213228364.png)\n"},{"title":"数据库&php大作业","url":"/2023/07/10/数据库-php大作业/","content":"\n\n\n<center style=\"font-size:large;font-weight:bold\">数据库&php说明文档</center><center>2023/6/19</center>\n\n{% pdf https://jjuprising.github.io/files/dbphp_homework.pdf  %}\n\n","tags":["项目"],"categories":["本科课程"]},{"title":"磨蹭天气app--安卓大作业","url":"/2023/07/10/磨蹭天气app-安卓大作业/","content":"\n\n\n<center style=\"font-size:large;font-weight:bold\">磨蹭天气app说明文档</center><center>2023/6/12</center>\n\n{% pdf https://jjuprising.github.io/files/and_homework.pdf  %}\n","tags":["项目"],"categories":["本科课程"]},{"title":"数据库笔记","url":"/2023/07/10/数据库笔记/","content":"\n# 习题\n\n* 如何构造出一个合适的数据逻辑结构是_____C_______主要解决的问题。\n\n  A．关系数据库优化        B．数据字典\n\n  C．关系数据库规范化理论     D．关系数据库查询\n\n​\t**关系数据库规范化理论**，一个关系数据库模式由一组关系模式组成，一个关系模式由一组属性名组成。关系数据库设计，就是如何把<u>已给定的相互关联的一组属性名分组，并把每一组属性名组成关系的问题</u>。然而，属性的分组不是唯一的，不同的分组对应着不同的数据库应用系统，它们的效率往往相差很远。为了使数据库设计合理可靠，简单实用，长期以来，形成了关系数据库设计的理论——规范化理论。\n​     **关系数据库的优化**是一个和实际数据库结构密切相关的问题，在实际应用中应该结合具体的数据库服务器，深入的理解服务器的运作模式、资源配置，优化服务器的运行环境，选择合适的操作系统，最大限度的发挥服务器的性能。\n​     **数据字典**是指对数据的数据项、数据结构、数据流、数据存储、处理逻辑、外部实体等进行定义和描述，其目的是对数据流程图中的各个元素做出详细的说明。 其关注点是在数据项、数据元素上。\n​     **关系数据库查询**，是通过查询语言（SQL），从关系数据库中查找符合查询条件信息的过程。\n\n# 1概论\n\n三级模式结构，外模式、模式和内模式\n\n* 模式也称为逻辑模式，对应于逻辑层数据抽象，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。\n* 外模式也称子模式或用户模式，对应于视图层数据抽象，是**数据库用户**(包括应用程序员和最终用户)能够看见和使用的局部数据的逻辑和特征的描述。\n* 内模式称为存储模式，对应于物理层数据抽象，是数据的物理结构和存储方式的描述，是数据在数据库内部的表示方式。\n\n\n\n# 4数据库建模\n\n矩形表示实体集、椭圆表示属性、双椭圆表示多值属性、菱形框表示联系集、双矩形表示弱实体集、双菱形表示表示实体集、虚下划线表示弱实体集部分码，ISA为“is a”表示父类-子类联系，内部包含菱形框的带填充背景的矩形表示联系实体集，\n\n→表示指向参与联系集中的“一”方实体集，—表示参与联系集中的“多”方实体集\n\n![](https://s2.loli.net/2023/07/10/yHosMZjNPvwtX6S.png)\n\n![](https://s2.loli.net/2023/07/10/mPDY2L3QZFTgayi.png)\n\n![](https://s2.loli.net/2023/07/10/elFUbzOv4WgBsn2.png)\n\n![](https://s2.loli.net/2023/07/10/CtrS1uHKic6RIYA.png)\n\n![](https://s2.loli.net/2023/07/10/t5ToRpsXF3WzvZN.png)\n\n## 约束\n\n### 映射约束\n\n![](https://s2.loli.net/2023/07/10/yanWqYbA7gK6w3x.png)\n\n一对一\n\n一对多\n\n多对多\n\n### 码约束\n\n#### 多值属性\n\n1可以转化为多个单值属性\n\n2将多值属性单独建模为一个弱实体集\n\n#### 主码\n\n选取原则：\n\n* 属性长度最短的候选码\n* 包含单个属性的码，而不是复合候选码\n* 在数据库系统生命周期内**属性值最少变化**的候选码\n* 在数据库系统生命周期内**更可能包含唯一值**的候选码\n\n##### 联系集的主码和属性安置\n\n二元联系集主码依赖于联系集的映射基数\n\n* **一对一联系集**：主码使用**任何一方**实体集的主码\n* **一对多(多对一)联系集**：主码由**“多”**的一方实体集的主码组成\n* **多对多联系集**：主码由参与实体集中**所有实体集的主码**组成\n\n| 二元联系集           | 主码             | 属性安置         |\n| -------------------- | ---------------- | ---------------- |\n| 一对一联系集         | 任何一方         | 任一边的实体集上 |\n| 一对多(多对一)联系集 | “多”方           | 联系集或“多”方上 |\n| 多对多联系集         | 所有实体集的主码 | 只能在联系集上   |\n\n例如\n\n![](https://s2.loli.net/2023/07/10/P971wnRGvahHimS.png)\n\n将聘用日期直接定义为多方实体集**教师**的属性。\n\n### 依赖约束\n\n两种：\n\n* 依赖实体集：实体集依赖于联系集\n* 弱实体集：实体集依赖于另一个实体集\n\n### 参与约束\n\n如果实体集A中只有部分实体参与到联系集R的联系中，则称实体集部分参与到联系集R的联系中。每个实体都参与则为全部参与。\n\n全部参与双实线表示\n\n## 弱实体集\n\n弱实体集：其属性不足以形成主码，必须依赖于其他实体集的存在而存在\n\n强实体集：可以形成主码的实体集称为强实体集\n\n标识实体集：弱实体集所依赖的实体集称为标识实体集\n\n联系实体集：聚合功能将一个联系集及其相关联的实体集抽象为联系实体集(高层实体集)对待，然后建立该联系实体集与其他实体集之间的联系集\n\n## ER建模问题\n\n### ER建模的基本原则\n\n* 忠实性\n  * 实体集、联系集、属性都应当反映现实世界，根据事实建模\n* 简单性\n  * 非必须不增加更多成分\n  * 只需对数据库使用者感兴趣的属性建模，例如教师联系集中没必要将身高作为属性\n* 避免冗余\n  * 原则：一个对象指存放在一个地方\n\n* 选择实体集还是属性\n  * 作为属性：①属性不可分②属性不能和其他实体相联系\n  * 对于复合属性，可将该复合属性的每一个子部分直接建模为一个属性，而不必建模为实体集。例如“家庭住址”可分成“省份”、“城市”、“街道”三个部分\n* 选择实体集还是联系集\n  * 实体对应现实世界中实际存在的事物，是名词\n  * 联系对应一般为一种动作，即描述实体间的一种行为\n* 多元联系转化为二元联系\n  * 大部分情况下是建立一个依赖实体集或弱实体集，再与原实体集之间建立二元联系。\n\n\n\n# 5关系数据理论与模式\n\n属性集闭包，由A函数确定的所有属性的集合\n\n## 问题\n\n### 数据冗余导致的问题\n\n拿表举例：字段 studentNo studentName courseNo courseNo score\n\n* 冗余存储\n  * 浪费大量存储空间\n  * 学生姓名和课程名被重复存储多次\n* 更新异常\n  * 重复的副本被修改后，所有副本都必须进行同样的修改\n  * 修改的时候只修改了部分副本的学生姓名或课程名\n* 插入异常\n  * 只有当一些信息事先已经存放在数据库中时，另外一些信息才能存入数据库中\n  * 如果学生没有选修课程，那不能将他的信息插入，因为会违背实体完整性原则\n* 删除异常\n  * 删除某些信息时可能丢失其他信息\n  * 当一个学生的所有选修课程信息都被删除时，该课程的信息也会被丢失\n\n### 模式分解导致的问题\n\n分解后的模式是否具有**无损连接**，**保持依赖**等特性\n\n无损连接：能够通过连接分解后所得到的较小关系**完全还原**被分解关系的所有实例，称为无损连接。\n\n有损连接：无法完全还原回的\n\n保持依赖：分解之后，主码和其他的属性要在同个关系模式中，可以理解为原本属性都依赖主码，分解后，属性依旧依赖于主码。所有依赖关系都应该在分解得到的关系模式中保留。\n\n* 关系就是一个二维表\n\n* 关系模式：用来定义关系\n\n  * Student(Sno,Sname) 就是对关系表的描述，这是R(U)形式\n  * 五元组，R(U,D,DOM,F)，R关系名，U组成该关系的属性名集合，D属性组U中属性所来自的域，DOM属性向域的映像集合，F属性间数据的依赖关系集合。一般用R(U)，R(U,F)表示\n\n* 关系数据库：基于关系模型的数据库，用关系描述现实世界\n\n* 关系数据库的模式：定义这组关系的全体\n\n* 数据依赖\n\n  * 完整性约束，实体完整性，参照完整性，用户自定义完整性\n\n  * 表现形式：\n\n    * 限定属性取值范围\n    * 定义**属性值间的相互关联**(值相等与否)，这就是数据依赖，是数据库模式设计的关键\n\n  * 主要类型\n\n    * 函数依赖FD\n    * 多值依赖\n    * 连接依赖\n\n     \n\n* 关系模式的简化表示\n\n  * 关系模式简化为三元组**R(U,F)** R关系模式，二维表是关系\n  * 当且仅当U上的一个关系r满足F(数据依赖)时，r称为关系模式R(U,F)的一个**关系**\n\n* 规范化理论\n\n  * 用来改造关系模式\n  * 判断数据依赖是否存在是否存在不合适的地方，通过分解消除其中不合适的数据依赖\n  * 解决插入异常、删除异常、更新异常和数据冗余问题\n\n### 函数依赖\n\n在关系模式R的任意一个可能的r，每一个X对应一个Y则X决定Y，称X确定Y，或Y函数依赖于X，X→Y\n\n如学号决定性别，学号决定年龄，姓名决定性别，姓名决定年龄(不同名)；不存在学号相等的情况下性别不等，反过来不一定成立\n\n#### 平凡函数依赖与非平凡函数依赖\n\nX→Y，当Y不包含于X，则称为非平凡依赖，若Y包含于X则为平凡依赖\n\n* 例如关系模式SC(Sno,Cno,Grade)\n  * 非平凡依赖：(Sno,Cno)→Grade，一个学号和的一门课程对应一个唯一的成绩，Grade不包含于(Sno,Cno)中\n  * 平凡依赖：(Sno,Cno)→Sno和(Sno,Cno)→Cno，学号可课程号可以确定唯一学号/课程号，后者包含于前者\n\n#### 完全函数依赖与部分函数依赖\n\n![](https://s2.loli.net/2023/07/10/gTKk5sxGa42tDIY.png)\n\n* 例如关系模式SC(Sno,Cno,Grade)\n  * 完全函数依赖：(Sno,Cno)→Grade，只有学号加课程号才能决定成绩，单独的学号或课程号无法决定成绩Grade\n  * 部分函数依赖，：(Sno,Cno)→Sno和(Sno,Cno)→Cno，其中一个真子集可以决定\n\n#### 传递函数依赖\n\n![](https://s2.loli.net/2023/07/10/dSeD73MOThvp91o.png)\n\n借助中间的Y\n\n#### 码\n\n* 候选码：K为关系模式R(U,F)中的属性或属性组合，U**完全依赖**与K(K完全决定U)，则K称为R的一个**候选码**。(**K可以决定所有的其他属性，且它本身不含多余值)**\n* 若关系模式R有多个候选码，则选定其中一个作为**主码**\n* 候选码能够**唯一地**标识一个关系的元组\n* 主码又和外码一起提供了一个表示关系间联系的手段\n* 组成候选码的属性叫做**主属性**，其他的就是非主属性\n\n## 范式\n\n关系数据库的关系满足一定要求称为一种范式\n\n![](https://s2.loli.net/2023/07/10/zRW31vyUwoVd9Qt.png)\n\n#### 第一范式1NF\n\n是最基本的要求，R的所有属性**都是不可分**的基本数据项\n\n部分函数依赖使得不是一个好的模式——要分解\n\n![image-20230429215614925](D:\\Typora\\images\\image-20230429215614925.png)\n\n（Sno,Cno)能决定其他全部属性，但是是一个部分函数依赖，分解成下图：\n\n![](https://s2.loli.net/2023/07/10/NhQsX42oY8dBctF.png)\n\n但是这样还是不够好，SC是好的，SL中每一个学生都对应一个宿舍楼Sloc，2000个学生就有2000个宿舍，冗余了，因此要求要再严格些\n\n#### 第二范式2NF\n\n![](https://s2.loli.net/2023/07/10/YydNaeq9UJzrxCV.png)\n\nSL仍有异常，因为存在传递依赖，分解掉\n\n![](https://s2.loli.net/2023/07/10/YydNaeq9UJzrxCV.png)\n\n#### 第三范式3NF\n\n上面的例子中，SL属于第二范式2NF，但是有传递函数依赖，去掉之后得到SD、DL，消除了函数依赖\n\n![](https://s2.loli.net/2023/07/10/hsbWgXu2t1IVTQP.png)\n\n注意定理中，第三范式还是建立1NF基础上而不是2NF，其实3NF是一种特殊的2NF，是3NF则一定是2NF\n\n若R∈3NF，则R的每一个**<u>非主属性</u>**既**不部分函数依赖于**<u>候选码</u>也**不传递函数依赖于**<u>候选码</u>。解决的是非主属性，但仍存在问题\n\n![](https://s2.loli.net/2023/07/10/Rdme8AIhFBNjoCT.png)\n\n#### BC范式(BCNF) 候选码一定包含在左端！\n\n修正的第三范式\n\n如果一个关系模式R(属于第一范式)**写出来的所有函数依赖X→Y**，左边X都含有候选码，R是BC范式。\n\n\n\n![](https://s2.loli.net/2023/07/10/8oUcKGJjVT2ENd6.png)\n\n* BCNF的关系模式所具有的性质\n  * 所有**非主属性**都完全函数依赖于每个候选码\n  * 所有**主属性**都完全函数依赖于每个不包含它的候选码\n  * **没有任何属性**完全依赖于**非码**的任何一组属性\n* BC范式与第三范式的关系\n  * BC一定是第三，第三不一定是BC(因为第三只规定了非主属性)\n  * 如果R是第三范式，且R只有一个候选码，则R必属于BCNF。（一般情况下关系模式有一个候选码，第三范式就满足了BC范式）\n* BC是**最高等级了**，消除了异常\n* BCNF范式排除了：\n  * 任何属性(包括主属性和非主属性)对候选码的**部分依赖和传递依赖**；\n  * **主属性**之间的传递依赖。\n\n\n例子：\n\n![](https://s2.loli.net/2023/07/10/PhD63uaMvfKqd8l.png)\n\n这题中关系模式只有三个属性，(S,C)→T，(S,T)→C，则这两个都是候选码，S、T、C都是主属性，所以也满足第三范式即STC∈3NF\n\n但是不是BCNF，因为(S,T)→C同时T→C，主属性部分依赖于码(S,T)因此还需要分解才能变成BC范式。\n\n### 对比3NF和BCNF\n\n* BCNF比3NF严格。\n  * BCNF要求所有的非平凡函数依赖中的是超码，而3NF则放松了该约束，允许不是超码。\n  * 若关系模式属于BCNF范式就一定属于3NF范式。反之则不一定成立。\n* 3NF存在数据冗余和异常问题，而**BCNF是基于函数依赖理论能够达到的最好关系模式。**\n* BCNF范式分解是**无损分解**，但**不一定是保持依赖分解**; 而3NF分解既是**无损分解**，又是**保持依赖分解**。 \n\n### 规范化\n\n![](https://s2.loli.net/2023/07/10/9z13NWcQO5g6STy.png)\n\n| 范式 | 特征                             |\n| ---- | -------------------------------- |\n| 1NF  | 所有的数据项不能再分             |\n| 2NF  | 消除非主属性对码的部分函数依赖   |\n| 3NF  | 消除非主属性对码的传递函数依赖   |\n| BCNF | 函数依赖左端属性集一定包含候选码 |\n\n## 函数依赖理论\n\n### 函数依赖集闭包（重要概念）\n\n* 定义5.11  若给定函数依赖集F，可以证明其他函数依赖也成立，则称这些函数依赖被F逻辑蕴涵。\n* 定义5.12  令F为一函数依赖集，F逻辑蕴涵的所有函数依赖组成的集合称为F的闭包，记为F+。\n* 函数依赖集F的闭包计算方法\n  * Armstrong公理的推理规则\n\n### 属性集闭包（重要概念）\n\n![](https://s2.loli.net/2023/07/10/SrBlvuPmxVHGUAF.png)\n\n![](https://s2.loli.net/2023/07/10/DZvC8byxskaXVcR.png)\n\n\n\n## 无损连接分解\n\n**表格判断法**\n\n![](https://s2.loli.net/2023/07/10/iGgk9yWhMVAjYP8.png)\n\n![image-20230623110907566](D:\\Typora\\images\\image-20230623110907566.png)\n\n![](https://s2.loli.net/2023/07/10/3e857UdwLEsKmor.png)\n\n![](https://s2.loli.net/2023/07/10/JnxEGtMhm9RlFSW.png)\n\n![](https://s2.loli.net/2023/07/10/atfZKhG6RyrU1DN.png)\n\n## 保持依赖分解\n\n## 候选码的计算\n\n把左边写出来，右边写出来，重复的删去，只在左边出现一定是候选码，右边出现的一定不是候选码\n\n如果能推出来全体，则为唯一候选码\n\n![](https://s2.loli.net/2023/07/10/tNa15L9Tnb2OzYy.png)\n\n当去重的左边不能推出全部的时候，从不确定的中任取一个加入到左边的\n\n# 8数据库存储结构与查询\n\n## 启发式优化策略\n\n* 尽早执行选择操作\n* 尽早执行投影运算\n","tags":["笔记"],"categories":["本科课程"]},{"title":"软件需求笔记","url":"/2023/07/10/软件需求笔记/","content":"\n# 第一周\n\n## 软件需求层次\n\n![](https://s2.loli.net/2023/07/10/XkLx1Y5fhqIJjHr.png)\n\n### 业务需求\n\n* 内容：表示组织或客户对系统、产品**高层次**的目标\n* 描述方式：前景（视图）和范围文档\n* 示例：为了让南海校区的同学和老师提供订餐便 利，节约排队打饭时间，同时减少食堂的浪费， 需要开发“南海校区网上订餐系统” 。\n\n### 用户需求\n\n* 内容：描述了用户要求系统、产品**必须能完成**的任务\n* 描述方式：用例模型\n* 示例：“订餐” 、 “变更订单” 、 “查看菜单” 、 “支付订单” 。\n\n### 系统、功能需求\n\n#### 系统需求\n\n* 描述**子系统**包含的需求，实现的功能。\n* 示例： 系统需求：自动订餐系统要能实现选菜、选时间送餐功能等。 通过功能需求来进行细化描述。\n\n#### 功能需求\n\n* 开发人员**必须**在产品中**实现的软件功能**， 用户利用这些功能来完成任务，满足业务需求。 有时称为行为需求。简而言之，描述的是开**发人员需要实现什么。**\n* 描述方式：软件需求规格说明书（SRS）\n* 示例：“订餐” Order.Place、 “创建浏览修改和 删除订餐” 、 “订餐支付” Order.Place.Pay 、 “请求送餐” Order.Deliver.Select等等\n\n### 质量属性\n\n声明各种系统操作特定的性能需求。影响功能需求 \n\n### 外部接口\n\na.用户接口；\n\nb.硬件接口；\n\nc.软件接口；\n\nd.通信接口的需求。\n\n### 业务规则 \n\n 是对业务的**某个方面进行定义或约束**的语句。业务规则用于声明业务机构、或者控制、影响业务的行为。 \n\n## 需求的开发与管理\n\n需求工程分为需求开发与需求管理\n\n![](https://s2.loli.net/2023/07/10/nBq5QNz2j3fHVvK.png)\n\n### 需求开发\n\n#### 需求获取\n\n* 编写**前景和范围文档**\n* 用户代表沟通确定**用例**\n* 召开专门的需求获取**讨论会**\n\n#### 需求分析\n\n* 绘制**关联图**\n* 确定需求**优先级**\n* 为需求**建模**\n* 创建**数据字典**\n\n#### 规格说明\n\n* 采用SRS模板\n* 为需求分配唯一标号\n\n#### 需求验证\n\n* **审查**需求文档\n* **测试**需求\n\n### 需求管理\n\n![](https://s2.loli.net/2023/07/10/nEvjZLUlRQwe6Fr.png)\n\n在需求开发阶段，通过市场、客户、管理三方将需求通过分析、编写文档、评审、商议得到**基准需求说明**\n\n在需求管理阶段，**定义需求变更控制过程**，通过**基准需求说明**获取当前基线。跟踪每项需求的状态，市场、客户、管理会进行需求变更，项目环境会产生项目变更，这个需求变更过程就需要对**基准需求说明**进行基线修正，建立基线和控制需求文档的版本。\n\n# 第二周\n\n关于签字：要建立需求协议的**基线**。将需求 变更控制在基线范围内。\n\n## 需求分析\n\n* 创建关联图\n* 确定需求优先级\n* 为需求建模\n* 创建数据字典\n\n## 需求验证\n\n* 审查需求文档\n\n## 需求管理\n\n* 定义需求变更控制过程\n* 建立基线和控制需求文档的版本\n* 跟踪每项需求的状态\n\n## 项目管理\n\n* 选择合适的软件开发生命周期\n* 管理与需求相关的风险及编写风险文档\n\n## 需求分析员工作\n\n* 获取需求\n* 分析需求\n* 编写需求规格说明\n\n# 第三周\n\n## 前景与范围文档\n\n![](https://s2.loli.net/2023/07/10/7O6eF5CQJhLIkgz.png)\n\n## 关联图\n\n![](https://s2.loli.net/2023/07/10/3pcHuwPIe7NLMoZ.png)\n\n## 生态系统图\n\n![](https://s2.loli.net/2023/07/10/MyvzhB6ASu95LZj.png)\n\n## 特性树\n\n![](https://s2.loli.net/2023/07/10/AoFspth12cyVGxB.png)\n\n# 第四周\n\n## 聆听客户的需求\n\n**需求获取的核心：发现用户需求**\n\n* **强调用户任务，而不是用户界面**\n* **强调根本需求，而不是用户表达**\n\n# 第五周\n\n## 用例图\n\n![](https://s2.loli.net/2023/07/10/GAhkpxC7KsVfQRe.png)\n\n### 子系统\n\n有时多个用例包含一组相同的步骤。为了避免每个用例都重复相同的步骤，可以定 一个单独的用例来包括这些相同的功能， 然后由其他用例来包含这个子用例。\n\n![](https://s2.loli.net/2023/07/10/mbpRzTlSCUrI4P5.png)\n\n### 包含关系\n\n![image-20230620110010476](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620110010476.png)\n\n（2）一个用例的功能太多时，可以用包含关系创建多个子用例。\n\n### 拓展关系\n\n![image-20230620110203026](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620110203026.png)\n\n# 第六周\n\n## 业务规则 \n\n 是对业务的**某个方面进行定义或约束**的语句。业务规则用于声明业务机构、或者控制、影响业务的行为。 \n\n 基本的业务规则是公司的重要资产，如果没有适当的记录和管理，就只会存在于个 人的大脑中，而不同的人对规则的理解可 能是相互矛盾的。如果知道每个应用程序在什么位置，如何实现引用与其相关的业务规则，那么当业务规则发生变化时，修改程序会容易很多。\n\n业务规则影响了业务需求、用户需求、功能需求、质量属性\n\n**用特定数学公式货算法进行的计算:** \n\n例： 订单数量为6-10件，则单价降低10%； 数量为11-20件，单价降低20%； 数量超过20件，单价降低35%。 用表格形式表示更清晰。\n\n![image-20230620092845057](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620092845057.png)\n\n**一些业务规则目录的例子：**\n\n![image-20230620092913807](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620092913807.png)\n\n每条业务规则都有一个唯一的标识符，这样你就能从功能性需求追溯到对应的规则 \n\n规则类型：这里指出是事实、约束、动作触发规则、推论还是计算。 \n\n静态或动态：这一列说明该规则随时间变化的可能性有多大。 \n\n来源：公司政策、管理政策、主题专家、其他人士、政府法规、软件代码、数据库定义。\n\n**如何发现业务规则？ 通过不同角度来提问**\n\n![image-20230620093053561](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620093053561-16872406188361.png)\n\n**大作业：**\n\n\n\n# 第七八周\n\n## 需求规格说明\n\n![](https://s2.loli.net/2023/07/10/aVTQIw9Msx8UuAB.png)\n\n## 优秀需求的特点\n\n* 完整性\n* 一致性\n* 可修改性\n* 可追溯性\n\n## 避免使用有歧义的术语！！\n\n![](https://s2.loli.net/2023/07/10/bWnsyKiheUVlq1D.png)\n\n### 实例\n\n* 只叙述一个实体\n\n  ![](https://s2.loli.net/2023/07/10/zemTPG32KD8J7yr.png)\n\n* 时间起点和预防错误\n\n  ![](https://s2.loli.net/2023/07/10/ZC76HawgcK8iMGN.png)\n\n* 标准宽泛，信息不清\n\n  ![](https://s2.loli.net/2023/07/10/Xn3QBqcl8twTU7P.png)\n\n* 歧义、信息不清\n\n  ![](https://s2.loli.net/2023/07/10/UD29ErOdqKsA7lM.png)\n\n* 操作结果不清晰\n\n  ![](https://s2.loli.net/2023/07/10/OyurLClaN2Txj9Y.png)\n\n* 例子\n\n  ![](https://s2.loli.net/2023/07/10/49OxIqKpQz6bGTr.png)\n\n  ![](https://s2.loli.net/2023/07/10/sygqurdf5m38oRQ.png)\n\n## 数据字典！！\n\n是一个共享存储库，用于定义应用程序中使用的所有数据元素或属性的含义、数据类型、长度、格式、需要的精度以及数据允许的取值范围或数据值的列表。\n\n离散值 [a|b|c]\n\n重复项 3{a}8\n\n基本数据元素 x=\"a\"\n\n\n\n# 第九周\n\n## 数据流图\n\n![image-20230620091720572](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620091720572.png)\n\n## 泳道图\n\n![image-20230620091454213.png](https://s2.loli.net/2023/06/20/2USBdQ7fn6ziAOY.png)\n\n\n\n## 状态转换图\n\n![image-20230620091809896](D:\\Blog\\source\\_posts\\软件需求笔记.assets\\image-20230620091809896.png)\n\n![](https://s2.loli.net/2023/07/10/QybqZSmAh9fXl8B.png)\n\n![](https://s2.loli.net/2023/07/10/O879yE3nRtYes5F.png)\n\n1.DF2 **外部实体**与**实体**之间不存在数据流 \n\n2.DF6 **外部实体**与**数据存储**之间不存在数据流\n\n3.DF7 数据存储与数据存储之间不存在数据流\n\n4.P4 加工的输入和输出不能同名\n\n5.P1 P3 每个加工既有输入又有输出\n\n![](https://s2.loli.net/2023/07/10/JTenoCZDY2qykVt.png)\n\n![](https://s2.loli.net/2023/07/10/VxAl5H2SnJI4O7b.png)\n\n\n\n![](https://s2.loli.net/2023/07/10/jxK7rFZRs1QBaMc.png)\n\n\n\n\n\n电话号码=[校内电话号码|校外电话号码]\n\n校内电话号码=非零数字+ 3 位数字 //后面继续\n\n校外电话号码=[本市号码|外地号码]\n\n本市号码=数字零+8位数字\n\n外地号码=数字零+3位数字+8位数字\n\n3位数字＝3{数字}3    //3至3个数字\n\n8位数字=非零数字+7位数字\n\n7位数字=7{数字}7\n\n非零数字=[1|2|3|4|5|6|7|8|9]\n\n数字零＝0\n\n数字＝[0|1|2|3|4|5|6|7|8|9]\n\n# 第十周\n\n## 实体关系图 ER图\n\n![](https://s2.loli.net/2023/07/10/8XcRH9YQdS1n6Dm.png)\n\n## 类图\n\n### 关联\n\n->\n\n#### 聚合\n\n![](https://s2.loli.net/2023/07/10/kySFzreJ5tMQclg.png)\n\n#### 组合\n\n![](https://s2.loli.net/2023/07/10/e38aKQcq6YVrf25.png)\n\n### 依赖\n\n![](https://s2.loli.net/2023/07/10/coMqvT75CFZD89H.png)\n\n### 泛化\n\n![](https://s2.loli.net/2023/07/10/3mj1UytRcLH9xdp.png)\n\n### 实现\n\n![](https://s2.loli.net/2023/07/10/RdbsVNFUjmPLHBJ.png)\n\n### 区别\n\n**关联VS聚合VS组合**\n\n   三者都体现类之间的“拥有”关系，聚合和组合，都是整体和部分的关系，只是两种关系中类的生命周期不同。**聚合是“弱拥有”**，**组合是“强拥有”**。\n\n\n\n**关联VS依赖**\n\n  这两种关系的区别很明显，**关联**体现的是**“拥有”**，**依赖**体现的是**“使用”**。\n\n \n\n**泛化VS实现**\n\n   泛化体现**两个类**之间的关系，实现是**类与接口**之间的关系。泛化强调的是类之间的继承，实现强调的是类对接口的实现。\n\n   通过对比总结出类图之间4种关系的强弱：依赖<关联<聚合<组合<泛化=实现\n\n# 十二周\n\n![](https://s2.loli.net/2023/07/10/XrnhdFif5PVoSsA.png)\n\nV=E-N+2，11-10+2=3，环路复杂度为3\n\n\n\n# 十三周\n\n![](https://s2.loli.net/2023/07/10/LHFgQtrJbyVzK6m.png)\n\n![](https://s2.loli.net/2023/07/10/kbmslVtX53yjPpw.png)\n\n第一个空正推得到最长的、第二个空倒推，用最长的往前推，而且往前推**要往耗时长的推**，例如L是22，往BD推经过走LK，因为耗时长，找那个最需要满足的\n\n\n\n如果是BF，最长22，到F是十六，就是十六天要到F，而BF路径最快只需要6天，因此可以拖10天。\n","tags":["笔记"],"categories":["本科课程"]},{"title":"人机交互笔记","url":"/2023/07/09/人机交互笔记/","content":"\n# 概述\n\n## 什么是人机交互\n\n人机交互是指关于<u>设计</u>、<u>实现</u>和<u>评估</u>供人们使用的交互式计算机系统，并围绕<u>相关的主要现象</u>进行研究的学科。\n\n## ⭐人机交互技术的研究内容 7点\n\n1. 人机交互界面表示模型与设计方法\n\n2. Web设计\n\n3. 移动界面设计\n\n   移动界面的设计方法、可用性与评估原则、移动界面导航技术以及移动界面的实现技术和开发工具。\n\n4. 认知与智能用户界面\n\n   上下文感知、三维输入、语音识别、手写识别、自然语言理解。\n\n5. 多通道交互技术\n\n   视觉、听觉、触觉和力觉语音、手势、眼神、表情表示模型、评估方法以及多通道信息的融合等。\n\n6. 群件\n\n   群件系统的体系结构、计算机支持的交流与共享信息的方式、交流中的决策支持工具、应用程序共享以及同步实现方法等。\n\n7. 可用性分析与评估\n\n## 人机交互技术所导致的社会问题与解决方案\n\n* 缺点\n  * 焦虑\n  * 疏远\n  * 信息匮乏的少数群体\n  * 个人的无力\n  * 令人困惑的复杂性和速度\n  * 组织脆弱性\n  * 侵犯隐私\n  * 失业和裁员\n  * 缺乏专业的责任制\n  * 恶化的人类形象\n* 解决方案\n  * 以人为本的参与式设计\n  * 组织的支持\n  * 工作设计\n  * 教育\n  * 反馈、认可和奖励\n  * 提高公共意识\n  * 立法\n\n## ⭐设计上的不同观点📑\n\n* 软件工程师(技术视角)\n  * 软件需求分析\n  * 软件设计\n  * 接口软件编码\n  * 交互支撑软件编码\n  * 应用程序编码\n  * 软件验证和确认\n* 人机交互设计师(用户视角)\n  * 用户任务分析\n  * 可用性规格说明\n  * 交互体系结构/设计\n  * 界面设计/规格说明\n  * 软件支撑确认\n  * 可用性评估\n\n## ⭐发展历程\n\n基本交互：命令行\n图形界面：GUI\n语音交互：语音助手\n体感交互：5D电影\n\n## ⭐人机交互的三个革命性产品\n\n鼠标\n多点触控\n体感设备\n\n# 第一章\n\n## 可用性工程\n\n## 🟡交互系统可用性的概念📑\n\n可用性是指当用户在特定的环境中使用产品完成具体任务时交互过程的有**效性**、**交互效率**和**用户满意度**。\n\n![](https://s2.loli.net/2023/07/09/WATK3ecRrnbXQ6Y.png)\n\n## 增强可用性的好处\n\n1. 提高生产力\n2. 增加销售和利润\n3. 降低培训和产品支持的成本\n4. 减少开发时间和开发成本\n5. 减少维护成本\n6. 增加用户的满意度\n\n## 可用性的目标和度量📑 书p9最后\n\n### 🟡目标\n\n**可用性目标**：**有效性、交互效率和用户满意度**，有效性通常是软件测试需要解决的基本问题，因此度量可用性两种只关注后两个目标。\n\n### 🟡度量\n\n1.**学习时间** 典型的用户群体需要花多长时间来学习如何使用与一组任务相关的任务?  效率\n\n2.**运行速度** 执行基准任务需要花多长时间? 效率\n\n3.**用户出错率** 在基准测试任务中会犯多少错误? \n\n4.**记忆保持时间** 使用频率和易于学习有助于提高用户记忆  \n\n5.**主观满意度** 允许用户通过访谈、自由形式的评论和满意度量表进行反馈 用户满意度\n\n### 五个核心人为因素\n\n--易学习 支持用户对产品的入门使用户在以后使用过程中的持续学习。\n\n--有效性 怎样准确、完整地完成工作或达到目标。\n\n--效率 怎样快速地完成工作。\n\n--吸引力 用户界面如何吸引用户进行交互并在使用中得到满意和满足。\n\n--容错 产品避免错误的方式并帮助用户修正错误的能力。\n\n可靠性\n标准化集成一致性和可移植性\n\n可用性分析\n\n## 支持可用性的设计原则（如何保证三个原则--多选题） p47\n\n三个原则\n\n* 可学习性\n  * 可预见性 **用户利用对前面交互过程的了解就足以确定后面交互的结果**。\n  * 同步性 是指**用户依据界面当前状态评估过去操作造成影响的能力**，也就是说用户能不能同步地知道交互操作的结果。\n  * 熟悉性 如果**新系统跟过去使用过的类似系统有一 定相关性**，那使用起来就比较方便。\n  * 通用性 就是在交互中尽可能地提供一些**通用的或能够从现有功能类推出来的功能**\n  * 一致性 **是指在相似的环境下或执行相似的任务时一般会执行相似的行为**。\n* 灵活性\n  * 可定制性 **指用户或系统修改界面的能力**\n  * 对话主动性\n  * 多线程 **同时支持多个交互任务**\n  * 可互换性 可互换性意味着任务的执行可以在**系统控制和用户控制间进行转移**。\n  * 可替换性 可替换性要求**等量的数字可以彼此交换**\n* 鲁棒性\n  * 可观察性\n  * 可恢复性\n  * 响应性\n  * 任务规范性\n\n什么是交互系统的可用性\n可用性的度量\n\n## 可用性动机\n\n* 专业环境：精确\n* 工商业：易学、准确、性能的折中\n* 娱乐：主观满意度\n* 社会：隐私、安全\n\n## 你是否体验过可用性差的软件系统？可否分析其原因？📑\n\n# 第二章 通用性\n\n## 🟡通用性的目标 书p26\n\n**满足所有用户的需求**\n\n作为专业人士，用户会因为我们**满足了他们的需求**而记住我们\n移动设备的巨大国际消费市场，陡然提高了对普遍可用性设计的压力\n\n## ⭐人的感知和知觉的特性 p10\n\n人机交互过程主要是通过**视觉、听觉和触觉**感知进行的。\n\n* **视觉**\n  * 一方面，眼睛特性决定人类无法看到某些事物\n  * 另一方面，视觉系统对不完全信息发挥一定想象力\n  * 所以人机交互设计时需要了解人真正能够看到的信息\n\n* **听觉**\n  * 声音三个属性：**音调、响度和音色**\n\n* **触觉和力觉**\n  * 触觉和上面两个最大不同在于**非局部性**\n    * 温度感受器——冷热\n    * 伤害感受器——疼痛\n    * 机械刺激感受器——压力\n\n  * 力觉指肌肉和关节等感受到的**力量感和方向感**\n\n* **内部感觉**\n  * 体位感觉\n    * 快速适应感受器\n    * 慢速适应感受器\n    * 位置感受器\n  * 深度感觉\n  * 内脏感觉\n\n## ⭐🟡知觉的特性📑 ppt\n\n参考答案：\n\n① **知觉的选择性**：分化对象和背景的选择性是知觉最基本的特性，背景往往衬托着、弥漫着、扩展着，对象往往轮廓分明、结构完整。\n\n② **知觉的整体性**(补全残缺)：当一个残缺不全的部分呈现到眼前时，人脑中的神经联系马上被激活，从而把知觉对象补充完整。格式塔心理学家认为，主要有五种完形法则：图形背景法则，接近法则，相似法则，闭合法则和连续法则。\n\n* 图形背景法则：在界面设计中的实例\n* 接近律：空间距离接近者容易被感知为一个整体\n* 相似律：相似（颜色、形状、纹理）的图形会被认为一个整体\n* 闭合律：知觉具有把不完全图形补充为一个完全图形的倾向\n* 连续律：把经历最小变化或最少阻断的直线或者圆滑曲线感知为一个整体\n\n③ **知觉的理解性**：**旧经验**与**新刺激**建立多维度、多层次的联系，以保证理解的全面和深刻。\n\n④ **知觉的恒常性**：当客观条件在一定范围内改变时,人的知觉映象在相当程度上却保持着它的**稳定性**，即知觉恒常性。(例如红旗不管在什么光照下，人都会把它知觉为红色。)\n\n## 常见认知📑\n\n* **感知与识别**：人们可以使用感官从环境中获取信息，并把它转变为对物品、事件、声音和味觉的体验。\n* **注意**：注意通常是指选择性注意，即注意是有选择的加工某些刺激而忽视其他刺激的倾向。\n* **记忆**：记忆就是回忆各种知识以便采取适当的行动。\n* **问题解决**：问题解决是由一定的情景引起的，按照一定的目标，应用各种认知活动、技能等，经过一系列的思维操作，使问题得以解决的过程。\n* **语言处理**：阅读、说话和聆听这三种形式的语言处理具有一些相同和不同的属性。相似性之一是，不论用哪一种形式表示，句子或短语的意思是相同的。但是，人们对阅读、说话和聆听的难易有不同的体会。\n\n## ⭐影响认知的因素📑\n\n情感，个体差异，动机，兴趣\n\n## 影响感知和运动性能的因素📑\n\n‒警醒度和警惕性 \n\n‒疲劳和睡眠不足 \n\n‒感知(精神)负担 \n\n‒结果和反馈知识 \n\n‒单调和乏味 \n\n‒感官剥夺 \n\n‒营养与饮食 \n\n‒恐惧、焦虑、情绪和情感 \n\n‒吸毒、抽烟和酗酒 \n\n‒生理周期\n\n### ⭐个体差异和不同的使用场所\n\n人是被细分的，但没有针对用户个性的简单分类，不过有迈尔斯-布里格斯类型指标 (MBTI），分为\n\n外向还是内向 感觉和直觉 感知与判断 感受与思考\n\n* 没有“平均”用户，要么必须做出妥协，要么必须创建多个版本的系统\n* 音频大小调节\n* 触摸屏灵敏度调节\n* 屏幕亮度、对比度调节\n\n## 不同的认知和感知能力\n\n* 长期记忆和语义记忆\n* 短期记忆和工作记忆\n* 问题求解和推理\n* 决策和风险评估\n* 语言交流与理解\n* 搜索、表象和感官记忆\n* 学习、技能开发、知识获取和概念获得\n\n## 🟡残疾用户、老年用户、儿童 书p31-36理解\n\n针对三种用户如何来设计软件\n\n### 描述三个有特殊需求的用户群体。对于这些人群中的每一个人，建议有三种方法可以改善当前的界面，以更好地服务于他们。📑\n\n参考答案：\n① 残疾用户： \n\ni. 视觉障碍者(**文本转成语言**)，听觉障碍者（**语音转文本**），身体障碍(**语言输入设备、人眼凝视技术等**)；\nii. 用**脑机接口**等高科技手段，帮助高度残疾或者其他特殊人群（比如渐冻症患者）使用计算机。\n\n② 老年用户：\n\n i. 界面使用**更大的字体**，更**明显的图标**，提高**音量**，方便老年用户进行操\n作。\nii. **减少**动画的**干扰**，增加界面的色彩**饱和度**。\niii. 包含**语音交互**的模式，**降低操作精度**，减少老年用户的点触。\n\n③ 儿童用户：\n\n i. **降低操作精度**，减少精确的操作，比如<u>区域化选择对象</u>、<u>时效性拖动对象</u>等操作，从而提升儿童用户的体验乐趣。\nii. 更多的使用**形象化的**、**生活化的**图形界面设计，<u>减少同一化的、相似的、抽象的概念图形</u>，让界面对儿童用户更加有吸引力。\niii. **简化应用流程**，降低应用程序逻辑的复杂度。\n\n## ⭐通用性设计原则 7条\n\n1. 公平地使用一Equitable Use：对具有不同能力的人，产品的设计应该是可以让所有人都公平使用的。\n2. 可以灵活地使用一一Flexibility in Use：设计要迎合广泛的个人喜好和能力。\n3. 简单而直观一Simple and Intuitive Use：设计出来的使用方法是容易明白的，而不会受使用者的经验，知识，语言能力及当前的集中程度所影响。\n4. 能感觉到的信息一一Perceptible Information：无论四周的情况或使用者是否有感官上的缺陷，都应该把必要的信息传递给到对使用者。\n5. 容错能力一Tolerance for Error：设计应该可以让误操作或意外动作所造成的反面结果或危险的影响减到最少。\n6. 尽可能地减少体力上的付出一Low Physical Effort：设计应该尽可能地让使用者有效地和舒适地使用，而丝毫不费他们的气力\n7. 提供足够的空间和尺寸，使用者能够接近使用一一Size and Space for Approach and Use\n\n人的感知和知觉特性  声音属性听觉现象\n知觉的特性（4个） 晚上的红旗--恒常性\n个体差异和不同的使用场所\n个性差异、文化多样性、国际多样性\n残疾用户、老年用户、儿童\n什么是认知 常见的认知\n影响认知的因素\n作业2\n\n# 第三章 指南\n\n## 成功的用户界面开发\n\n* 用户界面需求\n* 指南文档和过程\n* 用户界面软件工具\n* 专家评审\n* 可用性测试\n\n## ⭐🟡指南、原则与理论（模型） 书p42\n\n什么是指南？基于最佳实践的具体而通用的做法\n\n* 指南(Guidelines)\n  * **底层，具体而实用**\n  * **规定好的做法并警告危险**\n\n* 原则(Principles)\n  **中级，策略和规则，用于分析和比较设计备选方案。**\n* 理论和模型(Theories and model)\n  **高层，用一致的术语描述对象和动作；可用于交流、教学、预测**\n\n## 常用指南\n\n三个常用的指南\n\n* IOS\n* 微信\n* WCAG\n\n## ⭐四个具体导航 p12\n\n* 界面导航 4个要求+NCI指南\n\n  * ![](https://s2.loli.net/2023/07/09/kCGvrMoOAHhVzD5.png)\n\n  * 指南 4个要求\n    * 替代文本。为每个非文本内容提供替代文本。\n    * 基于时间的媒体。为基于时间的媒体（如电影或动画）提供备选项。\n    * 可辨识。使用户更易看到和听到的内容，包括前景和背景的分离。\n    * 可预测。为每一帧加上标题，以方便识别和导航\n\n  * NCI指南\n    * 将任务序列标准化 \n    * 确保嵌入的链接是描述性的 \n    * 使用一致的描述性标题 \n    * 对互斥选择使用单选按钮 \n    * 开发出适合于打印的页面 \n    * 使用缩略图预览较大的图像\n\n* 组织显示 5个目标\n\n  * 五个高水平的目标\n    * 数据显示的一致性：各类术语、字体颜色、格式、大小统一标准 详细的动作序列加快学习进度\n    * 用户信息的有效吸收：数据排列整齐、对齐、适当换算、添加标签 降低了错误率\n    * 用户记忆负担最小化：执行步骤少，不应该被要求记住冗长的代码列表\n    * 数据显示与数据输入的兼容性 数据输入信息的格式应与显示信息的格式紧密相 连，例如电话号码中的破折号\n    * 用户控制数据显示的灵活性 \n\n* 引起用户注意 8个技术点 p34\n\n  * 亮度\n  * 标记\n  * 尺寸\n  * 字体选择\n  * 反视频\n  * 闪烁的\n  * 颜色\n  * 音频\n\n* 数据输入 5个目标 p39\n\n  * 数据输入业务的一致性：加快用户学习速度\n  * 最少的用户输入动作：减少步骤\n  * 用户记忆负担最小化：减少长代码列表\n  * 数据输入与数据显示的兼容性：统一输入和显示的信息格式\n  * 用户控制数据输入的灵活性：按用户喜好灵活调准输入顺序\n\n  \n\n## 🟡图形用户界面的主要思想（要能够解释这三个名词） pptp50❗\n\n* **桌面隐喻 指在用户界面中用人们熟悉的桌面上的图例清楚地表示计算机可以处理的能力直接隐喻、过程隐喻、工具隐喻**\n* **所见即所得 界面中，用户交互行为与应用程序最终产生的结果一致。**\n* **直接操纵：直接操纵是指可以把操作的对象、属性、关系显式地表示出来，用光标、鼠标、触摸屏或数据手套等指点设备直接从屏幕上获取形象化命令与数据的过程**\n  **界面设计的8条黄金法则：**\n\n## 🟡图形用户界面设计的一般原则 （区分八条黄金法则）p54 书p51 ❗非常重要 背！！\n\n1. 坚持一致性\n\n   概念：在相似的环境中应要求一致的动作序列。在设计类似的情况和操作顺序时，通过利用相似的图标、颜色、菜单层次结构等争取一致性，减轻用户认知负担。\n\n   例子：顶部栏结构交互文案高度统一\n\n   违反的例子：①蓝桥杯官方（https://dasai.lanqiao.cn/）：账号不一致。登录官网报名和使用官网练习系统需要登陆两次，不一致，很麻烦\n\n2. 寻求通用性\n\n   概念：随着使用次数的增加，用户需要有更快的完成任务的方法。 常用操作要有快捷方式。认识到不同用户和可塑性的要求，可使内容的转换更便捷。\n\n   例子：搜索显示搜索热点历史，关联搜索，提前显示词条\n\n   违反：华师图书馆公众号的服务门户：没有将用户常用的功能放在较为显眼的位置，也没有将功能分类，而是单纯的堆叠\n\n3. 提供信息反馈\n\n   概念：用户应该始终知道他们当前位于哪里以及发生了什么。 对于每一个行动，在合理的时间内应该有适当的、人类可读的反馈。\n\n   例子：无网络告知状态和操作，给予相关可操作按钮，提供解决方案\n\n   违反：微信好友拉黑无消息反馈、群成员退群群主/管理员无消息反馈\n\n4. 设计对话框产生结束信息\n\n   概念：不要让你的用户猜测。 告诉他们他们的行为把他们导向了哪里。\n\n   例子：支付成功提示、发布成功提示\n\n   违反：Pixiv lite APP ： 违背了第4 条法则， 在图片下载完成后没有弹窗提示下载完成\n\n5. 预防错误\n\n   概念：系统的设计应该尽可能地防止错误，例如不适应的菜单项变为灰色。但是当发生不可避免的错误时，应确保向用户提供简单、直观的分步说明，以尽快、尽可能没有痛苦得解决问题。 \n\n   例子：没有输入不能点击、删除的二次确认，错误后撤回\n\n   违反：华师选课系统：退选操作没有确认提示\n\n6. 提供回退操作\n\n   概念：设计师应该为用户提供明显的方式来扭转他们的行为。因为用户知道错误能够撤销后，就能够减轻焦虑，进而尝试不熟悉的选项。\n\n   例子：撤销、保存、返回\n\n   违反：微信不提供灵活的撤销消息，如果超过一定时间未撤回无法再撤回\n\n7. 用户掌握控制\n\n   概念：让用户作为行动的发起者，让用户感觉到他们完全控制了数字空间中发生的事件。\n\n   例子：保存、不保存、取消\n\n   违反：微信的语音播放：不允许自己拉动播放进度，这对于60 秒这样的长语音很麻烦\n\n8. 减少短期记忆负担\n\n   概念：界面设计应当尽可能简洁，保持适当的信息层次结构，让用户去再认信息而不是去回忆。再认信息总是比回忆更容易，因为再认通过感知线索让相关信息重现。\n\n   例子：观看历史\n\n   微信：表情包不能分组，要发表情包的时候全部在一个组里，挑选困难，记忆负担大\n\n\n\n## 🟡五大人机交互理论 参考案例，会用模型，含义 \n\n* 层次设计理论 pptp60 书p59，\n  * GOMS，以填充猫咪的头为例\n  * G-**Goals（目标**）就是执行任务最终想要得到的结果。 目标是<u>填充猫咪的头</u>\n  * O-**Operations（操作）**是**任务分析**到最底层的行为，是用户为了完成任务必须执行的基本动作。 需要通过<u>涂鸦</u>来填充区域\n  * M-**Methods（方法）**是描述如何完成目标的过程。 填充区域需要<u>点击涂鸦工具</u>，然后给区域上色\n  * S-**Selection rules（选择规则）**是用户要遵守的判定规则， 以确定在特定环境下所使用的方法。 鼠标移动到涂鸦工具20ms-点击2ms-移动到猫咪头位置20ms-点击2ms-填充4ms\n* 行动阶段理论\n* 一致性理论\n* 情境理论\n* 动态理论\n\n## 🟡多层级设计 书p47\n\n**多层级设计：循序渐进地教授新手不同的功能，提供个性化的帮助和相应（更多/少提示信息）&界面设计（更简单/复杂的展示页面）**\n\n\n\n指南、原则和理论 明确概念\n引起用户注意的指南\n\n13.选择交互风格\n\n## 🟡作业 界面设计的八条黄金法则\n\n# 第四章 设计\n\n## 🟡设计进程 （4个阶段）p16 📑 书p76页图❗背\n\n![](https://s2.loli.net/2023/07/09/WQRdx2DKHIruaPf.png)\n\n* 1**需求分析**\n  * 对象\n  * 背景\n  * 用户需求分析\n    * 功能性\n    * 非功能性\n    * 用户体验\n* **2概要和详细设计** p21\n  * **概要设计：明确交互系统的高层次设计或架构。**\n    * 确定技术路线选择\n    * 根据需求划分功能模块\n    * 定义每个模块的职责\n    * 指定各功能模块间的接口\n    * 设计项目数据结构\n    * 编写严谨的数据字典\n    * 指定开发和测试计划\n  * **详细设计：制定每个交互的细节。**\n    * 细化每个模块的输入和输出\n    * 指定每个模块内部数据结构\n    * 规划每个模块内部处理算法\n    * 确定每个模块内部状态转换过程\n  * **概要设计需映射出高层次的概念：用户、控件、界面、导航机制、工作流程等**\n* **3构造与实施**\n  * 将所有精心的设计转化为实际的、可运行的代码。\n* **4评估**\n  * 测试并验证系统的实现情况，以尽可能地确保其符合需求和设计方案。\n\n\n\n## 🟡为医院设计一个系统，使接待员能够更快地为病人登记。 利用四个阶段\n\n参考答案：\n没有标准答案，只要以这个项目的管理计划的形式写下答案就好。对于每个阶段，指出应该分配的周数。提示:注意设计过程的四个阶段:\n\n1. **需求分析**\n\n2. **初步(概念)和详细设计**\n\n3. **建立和实施**\n\n4. **评价**\n   （同学1）\n   **1 需求分析**\n   (1) ⽤户对象：病⼈、接待员\n   (2) 背景：医院\n   (3) 功能性需求：病⼈可以通过系统完成个⼈信息的**注册**，若已存在注册， 则可通过该账户进⾏登录并进⾏**挂号**，同时将信息传送⾄接待员。接待员在得到病⼈的个⼈信息后，可通过该系统帮助⽤户进⾏**信息登记**，并查看该类科室是否有空位可及时提供给病⼈进⾏**问诊**，若⽆，则将其按顺序放置于较少⼈在**排队**的序列中。\n   (4) ⾮功能性需求：⽤户可以**修改**⾃⼰的个⼈信息，如身体状态、电话号码、个⼈地址等；接待员在⽤户修改信息时，可以**看到变更**的信息，并将其记录于系统中。\n   (5) ⽤户体验需求：该界⾯将设计帮助功能，以帮助⽤户解决在登陆或注册过程中存在的问题。例如，⽤户当不知道个⼈症状属于哪类科室时，可以点击上⽅的帮助功能中的科室症状分类，并于其中查看个⼈症状所属科室。\n   (6) 阶段完成时间：三周\n\n  **2 概要和详细设计**\n  (1) 概要设计\n  ①**技术路线**：利⽤⾼保真原型技术进⾏设计，虽花费时间可能较⻓，但能得到⼀个较为完善的模型，他能有基本的计算能⼒，可使设计者可以直观的看到设计的效果。\n  ②**功能模块**：查询、挂号、登录、注册、预约、分配\n  ③**⼯作流程**：病⼈先进⾏注册后再登陆账号，按⾃⼰的症状查询是否存在空余的科室，可以按个⼈需求进⾏提前的预约，并进⾏挂号。接待员帮助病⼈挂号后，查询是否有空余的科室，将病⼈分配⾄指定的科室。\n  (2) 详细设计\n  注册：病⼈或接待员使⽤系统功能前需进⾏个⼈注册，若已有个⼈信息档案则可跳⾄⽤户\n  登录阶段；\n  登录：病⼈或接待员需进⾏登录才可以使⽤系统；\n  预约：病⼈可以以指定⽇期进⾏预约， 防⽌当天指定的医⽣就诊⼈数已满；\n  挂号：病⼈进⾏问诊前，需进⾏挂号才可以进⼊科室；\n  查询：病⼈可以查询需要就诊的科室是否还有空位，或当天指定医⽣是否出诊。\n  分配： 当病⼈挂号未指定医⽣时，接待员通过该系统帮助其查询是否存在科室有空闲，\n  并将病⼈安排⾄该类科室。\n  (3) 阶段完成时间：四周\n  **3 构造和实施**\n  ⼿机：可利⽤微信⼩程序搭建⼀个相对稳定开发的环境进⾏设计，且在微信上可⽅便⽤户的使⽤；\n  ⽹络：利⽤web 前端技术如⽹⻚搭建技术可使⽤html 进⾏⽹⻚的设计，同时利⽤java技术进⾏功能的设计，以及axure 进⾏ui 设计。后期还可以利⽤jjsdk 进⾏⽀付等功能的添加\n\n​\t\t阶段完成时间：四周\n\n**4 评估**\n⾸先需要对注册与登录功能的联动进⾏测试，在进⾏注册后，⽹络**是否保存了⽤户的注册信息**并且⽤户是否可以顺利登录该⽹站，或者未注册的账号是否错误的存在可以登陆的情况。同时验证预约和挂号的功能，⽤户预约后，在指定的⽇期中⽤户是否可以挂号，并且在挂号后，接待员是**否看得⻅病⼈挂号的信息**，以及能否顺利的将病⼈**分配**⾄指定的科室。\n在⽤户查询到指定的科室后，还需验证是否可以顺利的完成预约或挂号。若以上功能的联动都能准确⽆误的完成，则判定该设计已经顺利地完成，若存在部分功能的缺漏， 则需返回上个阶段进⾏功能的补充。\n\n阶段完成时间：两周\n\n## ⭐用户分析方法\n\n* 研究方法\n  * 情景调查\n  * 用户访谈\n  * 问卷调查\n  * A/B测试\n  * 可用性测试\n  * 用户行为分析 最有效的方法之一\n* 分析方法\n  * 漏斗模型\n    * 描述各个 阶段中关键环节的用户转化和流失率情况\n    * ![](https://s2.loli.net/2023/07/09/bonaBU4hgcmpOFK.png)\n* 常用用户指标\n  * 访问用户数\n  * 新用户数\n  * 活跃用户数\n  * 流失用户数\n  * 回访用户数\n\n\n\n\n## ⭐⭐任务分析❗（7种任务分析的方法 前两种是重点 看课件）pptp37  🟡用例图、顺序图\n\n任务分析关心的是如何从用户那里**理解和获取用户的思维模式**\n\n* 使用行为分析 p38\n\n  * 要理解系统中**每个参与者及其所需完成的任务**\n\n  * **一般使用‘用例图’描述** p40\n\n    ![](https://s2.loli.net/2023/07/09/5TaH1k9YLBtbISE.png)\n\n    ![](https://s2.loli.net/2023/07/09/acF6blwOfqJdhKM.png)\n\n    ![](https://s2.loli.net/2023/07/09/1veuZhtdng2UKrp.png)\n\n* 顺序分析 p42\n\n  * 使用**顺序图**进行描述。\n\n  * **用例常常被细化为一个或更多的顺序图** 返回是虚线！！\n\n    ![](https://s2.loli.net/2023/07/09/8gHwIbLdBeP6lVu.png)\n\n* 协作关系分析\n\n  * 某个用户行为中各个系统元素之间的关系\n  * ![](https://s2.loli.net/2023/07/09/kB4oYPupngs6iTS.png)\n\n* 工序约束陈述\n\n  * 工序--步骤，某些工序之间的顺序有一些逻辑关系\n  * **工序约束**例子：eg.系统管理员必须先增加借阅者信息，读者才能登陆。\n\n* 用户任务一览表\n\n  * ![](https://s2.loli.net/2023/07/09/E6y47jITAYnG9cV.png)\n\n* 任务金字塔\n\n  * **任务金字塔描述了不同层次的任务之间的关系** 任务-子任务的结构\n  * ![](https://s2.loli.net/2023/07/09/QdsvXfiV92ZbJ3z.png)\n\n* 故事讲述和情节分析\n\n  * 描述情景，使这些故事能够典型的反映交互任务，具有充分的代表性。\n  * 对故事所反映的交互任务的理性分析，分离出故事中所描述的角色、目标、环境、步骤、策略、感情等诸方面的因素。\n\n### 📑\n\n考虑设计一个还不存在的系统（全新的系统）。例如，一家完全自动化的快餐店，顾客通过触摸屏交互下单，刷借记卡或信用卡付款，然后取餐——类似于一些超市的自助结账系统，但更为极端。请采用一种任务分析方法进行任务分析。\n\n顺序分析：\n\n![](https://s2.loli.net/2023/07/09/5pKsH136TtILRi2.png)\n\n## 🟡设计框架（名词解释3个框架）了解\n\n* 🟡以**用户为中心的设计(UCD)** 书p79\n  * **在设计过程的每个设计阶段都考虑到最终用户的需求、想法和局限性。**\n  * **难点：难以选择代表性用户**\n  * **Gould、Boies和Lewis于1991年提出了以用户为中心设计的四个重要原则：**\n    **①及早以用户为中心：设计人员应当在设计过程的早期就致力于了解用户的需要**\n    **②综合设计：设计的各方面应当齐头并进地发展，而不是顺次发展，使产品的内部设计与用户界面的需要始终保持一致**\n    **③及早并持续性地进行测试：当前对软件测试的唯一可行的方法是根据经验总结出的方法，即若实际用户认为设计是可行的，它就是可行的**\n    **④反复式设计：大问题往往会掩盖小问题的存在。设计人员和开发人员应当在整个测试过程中反复对设计进行修改**\n* 参与式设计(PD)\n  * 人们直接参与到他们所用产品和技术的协同设计中。\n* 敏捷交互设计\n  * 表示一类适用于团队开发的方法，目的是确保灵活性、适应性，并快速对不断变化的需求做出快速反应，并以渐进式开发为基础。\n\n## 🟡敏捷交互设计 不需要被概念，知道什么是，和一般的有什么区别\n\n**敏捷设计强调“make a real change\"而不是\"make a report',<u>频繁的测试与修改</u>是敏捷设计的首要原则**\n**表示一类适用于团队开发的方法，目的是确保灵活性、适应性，并快速对不断变化的需求出快速反应，并以渐进式开发为基础**\n\n* 优点\n  * 更快的交付：快速交付软件，使团队能够更快地向客户提供有用的功能。\n  * 更高的客户满意度：鼓励与客户密切合作，这意味着客户可以更频繁地提供反馈和建议，从而确保软件开发符合客户的需求和期望。\n  * 更强的团队合作：强调团队合作和沟通，这有助于确保所有成员都了解项目的目标和愿景\n  * 更灵活的风险管理：团队可以更快地发现和解决问题，从而降低项目风险。\n\n* 缺点\n  * 缺乏明确的计划：难以预测项目完成的时间和成本，因为每个迭代都可能会引入新的需求和挑战。\n  * 需要高度的自我组织能力：要求团队成员具备高度的自我组织和自我驱动能力\n  * 可能导致质量问题：快速交付软件可能导致团队在快速开发的过程中忽略质量问题\n  * 需要客户积极参与：需要客户积极参与，提供反馈和建议，如果客户不积极参与，团队可能会遇到困难。\n\n作业3\n\n# 第五章\n\n## 专家评审和启发式方法\n\n### 专家评审\n\n* 专家：有形象力的从业人员，或有评审专家资格的人员\n* 🟡**专家评估法(看一下，总结一下)：以专家为索取未来信息的对象，组织各领域的专家运用专业方面的知识和经验，通过直观的归钠，对预测对象过去和现在的状况、发展变化过程进行综合分析与研究，找出预测对象变化、发展规律、从而对预测对象未来的发展与实际状况做出判断。**\n* 流程：使用某种方法，遍历界面中的所有功能，在较短时间内给出评审结果，通常是一份正式报告书。\n\n#### 🟡优点 总结\n\n* 高效地发现不同问题与进行可用性测试\n* 严格测试，短时间内迅速给出评审结果\n\n#### 🟡局限 总结\n\n* 专家可能对任务领域或用户社区没有足够了解\n* 很难了解典型用户，尤其是初次用户的真实行为\n\n**①主要依靠评标专家的知识和经验进行判断，评标的主观性有余，客观性不足；**\n\n**②评标的定性方法与定量方法结合不够即使是经验丰富的专家审查员也很难了解典型用户，尤其是初次用户的真实行为。**\n\n#### 常用评审方法\n\n* 🟡**启发式评估**：**评审专家对界面进行评审，确定这些界面是否符合启发式设计的简要列表。 书**p99概念 **启发式是以一种快速的看起来不费力的方式做复杂的决定或进行推论时应用的一些简单规则**\n* 指南评审：检查界面是否符合组织文档或其他的指南文档是否相符\n* 一致性检查：检查所有同类界面的一致性，检查各种术语、标签等是否与培训材料和在线帮助中所描述的一致。\n* 认知过程走查法：专家模拟用户使用界面来执行典型的任务.\n* 正式的可用性检查：专家会举办一些与庭审类似的会议，由仲裁人或法官参加。在会议上展示界面，并讨论其优缺点。\n\n### 启发性评估的两大原则\n\n* 不能是设计师本人\n* 具有可用性知识\n\n#### 优点\n\n* 成本低、效率高、可以发现大多数可用性问题\n\n#### 缺点\n\n* 不能代表真实用户、比较主观\n* 有时发现问题过多；对评估者的要求较高。\n\n## 可用性评估的方法（多选或选择）\n\n#### 诊查式方法：**没有用户参与**\n\n* 用户模型法：用数学模型来模拟人机交互的过程。\n  * GOMS模型是描述任务和用户执行该任务所需知识的方法\n    * Goals（目标）\n    * Operations（操作）\n    * Methods（方法）\n    * Selection rules（选择规则）\n* 启发式评估：使用一套相对简单、通用、有启发性的可用性**原则**进行可用性评估。\n  * 系统状态可见性\n  * 系统与用户现实世界相互匹配\n  * 用户控制与自由\n  * 一致性与标准\n  * 错误预防\n  * 识别而不是回忆\n  * 使用的灵活性与效率\n  * 美观而精炼的设计\n  * 帮助用户认识、诊断和修正错误\n  * 帮助和文档\n  * 测试方法：A/B测试(分割测试)，两个版本相互比较以确定哪个版本的性能更好的方法\n* 认知性遍历：描述系统原型和用户任务，列出所有操作并确定用户身份。\n  * 进行认知性遍历活动，需要以下四个条件\n    * 1)对系统原型的详尽描述。这种描述不一定是完整的，但要相当详尽。诸如菜单的位置 描述或措辞选择等这样的细节也可能导致相当大的差异。 \n    * 2)对用户在系统中要完成任务的描述，这些任务应当是大多数用户将要执行的有代表性 的任务。 \n    * 3)一个完整的、书面的操作清单，列出使用给定原型完成任务所需执行的操作。 \n    * 4)确定用户的身份，以及评估人员能够确定这些用户已具有哪一类别的知识和经验。\n  * 完成一个任务包括以下步骤\n    * 1在交互界面上**寻找**能帮助完成任务的行动方案\n    * 2选择并采用看起来最能帮助完成任务的行动\n    * 3评估系统作出的反馈，判断在任务上的进展情况\n\n#### 测试式方法：有用户参与\n\n* 1用户测试：让用户使用软件系统，由试验人员观察、记录和测量。\n* 2问卷调查：需求分析——问卷设计——问卷实施——结果分析\n* 3放声思考法：用户一边执行任务一边大声地说出自己的想法\n* 4访谈法：研究人员通过与研究对象进行口头交谈\n\n## 🟡A/B测试 书P108\n\n将两组用户随机分配到对照组(无变化)或实验组(有变化)\n\n例如：将参与者**随机分配到两个测试组(A或B)**，他们看到的界面类似，但要对特定标准进行评估，**且每个测试组得到的是不同版本的界面**。通过对结果进行评估，查看是否存在差异。\n\n## 🟡尼尔森十大原则 ppt 8条法则联系记忆\n\n启发式可用性十大原则\n\n知道是什么\n\t一\n\t\t①一致性与标准\n\t通\n\t\t②系统与用户现实世界相互匹配\n\t反\n\t\t③系统状态可见性\n\t结\n\t防\n\t\t④错误预防\n\t\t⑤帮助用户认识、诊断和修正错误\n\n​\t退\n\n​\t控\n​\t\t⑥用户控制与自由\n​\t记\n​\t\t⑦识别而不是回忆\n​\t⑧使用的灵活性和效率\n​\t⑨美观而精炼的设计\n​\t⑩帮助和文档\n\n## 🟡❓作业 多看看\n\n1)至少描述三种不同类型的专家评审方法\n2)给出两个专家评论有用的理由。同时给出专家评论的两个局限性\n3)反对当前流行的文字处理程序界面设计的一个论点是，它将所有功能菜单项一起显示，\n导致界面过于复杂。这种复杂性会给新手用户带来困惑和祖丧的体验，另一种设计是提供不\n同层次的功能复杂性，用户可以选择适合自己的层次，当他们熟悉工具时，再进一步到更高\n的层次，从而感到更舒适，更有效地学习\n这种情况下应该使用哪种可用性测试？解释为什么。请列出并简要描述可用性测试的步骤\n\n1.评估的决定因素（可能多选）\n\n5.可用性评估遵循的原则\n\n8.启发式评估（十条原则）\n【GOMS】\n12.放声思考法\n作业1 \n\n# 第六章 不存在重点考点\n\n## ⭐敏捷交互设计 p22\n\n* 快速迭代。 简单快捷\n* 让测试人员和开发者参与讨论需求。 轻松定义可测试的需求。\n* 编写可测试的需求文档。用“用户故事”方法编写需求文档。\n* 多沟通，少文档。 好的沟通是敏捷开发的先决条件。\n* 做好产品原型。 用草图和模型阐明用户界面\n* 尽早考虑测试。 需求完成时，可以接受的测试用例也基本一起完成了。\n\n# 第七章 1\n\n## ⭐🟡直接操纵 p10  书p139 特别重要，❗背\n\n* 直接操纵最早由**施耐德曼**提出的\n* 直接操纵界面的**基本思想**是指用<u>**光笔、鼠标、触摸屏或数据手套等坐标指点设备，直接从屏幕上获取形象化命令与数据的过程。也就是说，直接操纵的对象是命令、数据或者对数据的某种操作，直接操作的工具是屏幕坐标指点设备**</u>\n\n\n\n### 特点 4个 p13\n\n* **该系统是真实世界的一种扩展**：用户非常熟悉屏幕中的环境，倾向于关注数据本身\n* **对象和操作一直可见**：“虚拟现实”--纳尔逊，“所见即所得”--哈特菲尔德，“透明”--鲁特科夫斯基\n* **迅速且伴有直观显示结果的增量操作**：操作有反馈\n* **增量操作可以方便地逆转**：提供回退\n\n>  真实世界的扩展，对象可见，增量操作，可逆\n\n### 🟡原则 3个\n\n1. **用有意义的视觉隐喻连续表示感兴趣的对象和动作。**\n2. **用物理动作或按压带标签的按钮来取代复杂的语法，**\n3. **使用快速、斩进式的可逆动作，这些动作对兴趣对象的影响立竿见影。**\n\n### 属性 p17\n\n* 新用户快速学会\n* 专家用户能高效执行任务\n* 知识渊博用户，可以记住各种操作概念\n* 很少需要错误提示信息\n* 用户可立即看到动作是否正促进目标的实现\n* 减少用户焦虑\n* 用户作为动作发起者，能感受到处于控制地位，自信并有掌控感\n\n### 好处\n\n1. 控制/显示兼容性\n2. 更少的语法减少了错误率\n3. 错误更容易预防\n4. 更快的学习和更高的记忆力\n5. 鼓励探索\n\n### 问题\n\n* 空间或视觉表现可能过于分散\n* 高级流程图和数据库一模式可能会变得混乱\n* 设计可能会迫使有价值的信息离开屏幕\n* 用户必须学习图形表示\n* 视觉表现可能会误导人\n* 用键盘输入命令可能会更快\n\n### 🟡优点 p31  6个 可以延伸（❗背\n\n* 形象化地呈现任务概念\n* 允许简单地学习\n* 允许简单地记忆\n* 允许避免错误\n* 鼓励探索\n* 提供较高的主观满意度\n\n### 🟡缺点  2个 可以延伸（❗背\n\np31\n\n* 可能很难编写程序 \n* 需要特别注意可达性\n\n\n\n在实践中，直接操纵对屏幕上所有对象和操作并非都是可行 的，原因如下 p11\n\n1. 此操作在图形化系统中可能很难概念化\n2. 系统图形能力局限性\n3. 窗口中放置操纵控件的空间存在限制\n4. 记住所有需要的操作会很困难\n\n## 🟡间接操纵 大概明白\n\n当出现这些情况时，我们就会使用**间接操纵**。在间接操纵中，文本——**如下拉式或弹出式菜单——取代了符号**，并用键盘键入代替了定位指向。大多数的窗口系统都综合了直接和间接操纵。菜单可以通过指向菜单图标并进行选择（直接操纵）来访问。而菜单本身，是一些操作的名称列表（间接操纵）。当列表上的某个操作通过指向或者键盘选择之后，系统便开始执行相应的命令。\n\n## 🟡直接操纵的平移距离 书p140 分为哪几类，什么是平移距离 大概知道哪种设备是什么平移距离\n\n\n\n**想要了解直接操纵隐喻，并对其进行分类，其中一种办法是观察用户与隐喻的表现之间的平移距离，即隐喻的强度**\n**强度可以通过从“弱”到“沉浸式”的过渡**\n\n* 弱（基本的直接操纵）：\n  使用映射函数，将设备的动作或身体动作转换为虚拟空回中的动作，交互是间接的，转换的差异较大\n  如鼠标与光标之间的移动不是完全一致的、游戏手柄的核键与角色的运动也是不一致的\n* 中等直接操纵：\n  用户直接触摸、移动、捕获屏幕上的实体，而不需要使用设备（屏幕本身除外）与虚拟空同通信。操作支持点击、双击、多点触控等。但无法描述高级的动作，如力度、深度等信息，需要设计专门的手势。（取消了中间设备，单通道输入）\n* 强直接操纵：\n  可使用各种动作，如身体各部位的姿态，可用手、脚、头或全身完成，以上燥作都“真实“的投放在实体空间中，用户在三维空间中可以看到自己的手，实现抓取、投摇、放下等操作\n* ”沉浸式直接操纵\n* 直接操纵与虚拟现实的结合，用户戴上眼镜或其他设备，置身干空间内用户可以看到自己，可以步行、侧身等动作在空间中行走、飞行，看到的影响也会随着用户的移动变化双向多通道\n\n平移距离的例子：\n\n| 平移距离 | 概念                               | 特点                                    | 代表设备                 |\n| -------- | ---------------------------------- | --------------------------------------- | ------------------------ |\n| 弱       | 交互是间接的，转换的差异较大。     | 中间设备，距离远，不平衡的传递          | 早期的电子游戏控制器     |\n| 中等     |                                    | 仅为屏幕，距离为0，二维，不平衡的传递。 | 触摸屏，多点触摸         |\n| 强       | **操作都“真实”的投放在实体空间中** | 距离为0，三维，不平衡的传递。           | 数据手套，手势，操纵实物 |\n| 沉浸式   |                                    | 距离为0，平衡的传递。                   | 虚以现实，如头戴式显示器 |\n\n\n\n## ⭐🟡增强现实和虚拟现实 了解名词解释❗\n\n**虚拟现实**的远程呈现打破了空间限制，使得用户认为身处他处。\n\n**增强现实**可以使用户看到叠加了附加信息的现实世界。\n\n**态势感知**通过在计算机模型中跟踪你的动作来显示你周围的真实世界的信息。\n例子：远程医疗，全尺寸投影的体育赛事、远程会议等\n\n\n\n2.直接操纵的概念和原则\n\n6.直接操纵的优缺点\n11.增强现实和虚拟现实 名词解释\n\n## 🟡作业\n\n![](https://s2.loli.net/2023/07/09/rlYfIZJ7PTmKHFs.png)\n\n# 第八章\n\n## 导航的种类\n\n1. 菜单栏，弹出菜单，工具栏，面板和功能区\n2. 快捷方式和快速交互手势\n3. 长列表\n4. 序列菜单与同步菜单\n\n米勒定律：**人的短时记忆能力广度为7±2个信息块**，超过范围人的记忆容易出错\n\n## 🟡小型显示器❗\n\n小型设备的功能非常集中，可选择的区域很少。菜单的**易发现性**是一个问题\n\n### 难点\n\n* 同屏幕的选项少——>操作深度增加\n* 按钮不能缩小——>点击不到\n\n### 🟡设计考虑 了解 最好能复述\n\n* **简化：“少即是多”--简单就是美**\n\n* **尽量降低或消除数据输入**\n\n* **考虑把不重要的功能转移到其他平台**\n\n* **学习能力是关键**\n\n* **上下文信息的使用**\n\n* **考虑使用的频率和重要性排序**\n\n* **为中断做好计划**\n\n* **清楚什么可选，什么不可选**\n\n* **为滚动和滑动手势留出空间，避免无意的行为**\n\n  \n\n## 内容组织方法 策略有哪一些\n\n要对有意义的菜单项来**分组和排序**，精心编辑**标题 和标签**，适当的**设计布局**，可以缩短选择时间，提 高用户满意度。\n\n* 🟡方法\n  <u>线性序列</u>：按单一方向\n  <u>层次结构：按照层级划分多个级别</u>\n  <u>网络结构：可以通过多个路径（例如网站）到达</u>\n* 注意事项\n  顺序：字母顺序、使用频率顺序、主题关联顺序\n  措辞：术语统一、选项区分、简洁、关键词前置\n  布局\n* 排版原则\n  亲密性\n  对齐\n  重复\n  对比\n\n## ⭐🟡音频菜单 了解优缺点 什么情况用，如何设计\n\n![](https://s2.loli.net/2023/07/09/1tUTLpE2srkioQX.png)\n\n* 可视菜单\n  * 持久性\n  * 比较性\n* 音频菜单\n  * 依赖于记忆，难以比较\n  * 依赖于时间，消磨耐心。\n* 通用的方法：\n  * 先说出描述，再给出选项（数字）\n  * 选项不能多，不能长，不能难理解(3-4个内)。\n  * 提供重复播放和退出机制。\n  * 菜单不能深，可提供跳过功能(如本机号码)。\n* 使用场景：智能语音客服，相比传统的引导播报长、功能节点多，摆脱了这些问题，提供高效服务。\n\n5小型显示器的设计考虑\n8音频菜单使用场景\n作业3\n\n# 第九章\n\n## 语音识别 概念\n\n**将人的语言转化为机器可识别的文本或命令的的过程**\n\n### 用处\n\n语音转文本\n翻译\n命令识别\n\n* 语音输入：语音生成文本 （快速录入、字幕自动生成、专业词汇更正） \n* 语音命令：有效识别某些命令 （语音助手） \n* 对话翻译\n\n### ⭐完整的语音识别系统\n\n**语音特征提取：提取声音信息**\n\n**声学模型与模式匹配：匹配内容**\n\n**语言模型与语义理解：理解意义做出反应**\n\n## 🟡✍口语交互 重点理解\n\n### ⭐优点\n\n## \n\n* 残疾用户、无法进行读写的用户（如儿童）\n* 腾不出手的说话者\n* 不断移动的人员\n* 妨碍键盘使用的恶劣或狭小环境\n* 词汇和任务有限的应用领域\n* 比打字快：听写比打字快，对用户来说更方便。\n* 易用性：并非所有人都能很好地使用技术设备。但任何用户都可以使用语音向VWUI设备或AI助手请求任务。\n* 免提：在某些情况下，例如开车、做饭或当你远离设备时，说话比打字或敲击要实用得多。\n* 免视：UI提供免视用户体验。在驾驶等情况下，你可以专注于道路而不是设备。它对于屏幕疲劳问题也很实用。\n\n### ⭐缺点\n\n* 嘈杂环境和劣质麦克风的干扰\n* 强烈的口音或不正常的词汇表会对识别产生影响\n* 说话并非总是可被用户接受的（如在公共办公室中和会议期间)\n* 命令需要学习和记忆\n* 纠错很耗费时\n* 与打字或指向相比，增加了认知负担\n* 没有独特的定制功能，编程困难\n\n### ⭐发展障碍\n\n* 与视觉显示相比，语音输出的速度较慢\n* 语音具有短暂性\n* 隐私问题：对VUI的潜在隐私侵犯涉及到一些用户。\n* 误解和缺乏准确性：软件无法理解和解释语言的环境，从而导致错误和误解。VUI可能并不总是区分同音异义词。\n* 公共空间：由于隐私和噪音问题，很难向公共空间中的设备和A!助手发出语音命令。\n\n### 设计口语交互 6种\n\n1.发起交互：用户表明要开始语音交互。 • （欢迎提示音、语音命令（hey siri）、开始按钮） \n\n2.知道该说什么：有针对性，学习和记忆有效命令。\n\n3.反馈与对话：显示给用户的信息中应给出建议动作的细节，并要求 用户确认或取消。\n\n4.错误识别：口吃、说错及背景噪音，地方口音或外国口音 \n\n5.纠错：费时耗力，取消，重新说一遍或换表达方式。\n\n6.映射可能的动作：将程序限制到有限的应用领域，依靠上 下文信息，这是目前语音交互成功的关键。\n\n### ⭐语音生成方法 三种\n\n1. **峰段合成**-通过一组基于文本语音表示的算法生成语音\n2. **串联合成**-将事先录好的较短人类语音片段拼接为完整的句子。\n3. **语音录音**-可将各个语音片段拼合在一起，形成更长的语音片段。 衡量语音质量：易懂性、自然性和可接受性。小冰\n\n1语音技术应用场景 多选\n  警报类型\n2语音识别技术 概念 识别系统三部分 \n口语交互的优缺点 障碍\n3语音识别的优点\n4.语音识别的障碍\n8语音生成三种方法\n作业1\n\n# 第十章 设备\n\n## 指向设备\n\n![](https://s2.loli.net/2023/07/09/3ihnqJHbQVSaWRk.png)\n\n## 🟡菲茨定律 理解 利用来分析界面 作业！\n\n菲茨定律是用来预测从任意一点到目标中心位置所需时间的数学模型。这个模型考虑了用户定位点的初始位置与目标的相对距离以及目标的大小。用于估算用户移动光标点击链接或控件按钮所需的时间。\n\n## 应用\n\n加大按钮\n\n关联内容靠近\n\n屏幕边放菜单栏\n\n## 思考\n\n1.你手边有多少触屏设备，你能分析他们是哪种屏幕么？ \n\n2.在设计导航系统时，是如何 使用菲茨定律的？ \n\n3.你的电脑屏幕是哪种屏幕？其指标是什么？ \n\n4.能否列出你身边的输入输出设备分别有什么（大于15个）？\n\n设备类型 手写板有哪几种类型等\n\n2.输入设备\n   评测指标 手机是电容 指点输入设备包括哪些、优缺点-设备pdfP53 \n   了解菲茨定律\n3.输出设备\n   光栅显示器性能指标\n作业3\n\n# 第十一章\n\n## 🟡协作模型 七个指标维度 列举实例说明分析 在线市场如何应用(抖、红、淘宝等) p17 每个维度意思，用MOCA模型分析软件✍\n\n![](https://s2.loli.net/2023/07/09/UwaNPqMksm67IxF.png)\n\n\n\n![](https://s2.loli.net/2023/07/09/gXviBCZYwhalzML.png)\n\n![](https://s2.loli.net/2023/07/09/yNQhdnK7sAr6mID.png)\n\n![](https://s2.loli.net/2023/07/09/gbSUiZCJRD2oFuI.png)\n\n![](https://s2.loli.net/2023/07/09/vL9cq8nxRsfjbJN.png)\n\n![](https://s2.loli.net/2023/07/09/2gYAkyTJR3UFCon.png)\n\n![](https://s2.loli.net/2023/07/09/bL5W3PJwheYi6pT.png)\n\n3.设计考虑\n作业1\n\n# 第十二、十三章\n\n## 5网页设计 避免十大错误 重点\n\n* 基于Web显示信息的十大错误(Tullis,2005)\n* 信息在网站中藏得太深。\n* 页面加载了过多的内容。\n* 提供的导航笨拙或令人困惑。\n* 信息放到了页面之外。\n* 链接不明显、不清楚。\n* 显示信息的表格设计拙劣。\n* 文本太小，导致很多用户无法阅读。\n* 文本使用了用户无法阅读的颜色组合。\n* 使用了很差的表单。\n* 隐藏（或不提供）能帮助用户的功能。\n\n## 7非拟人化设计 指南 避免分散用户注意力 重点❗\n\n**拟人化界面的倡导者认为，拟人化设计最有用的可能是教师、销售人员、治疗师或娱乐人物。另一种设计是通过预先录制的音频或视频呈现包的人类作者**\n\n### 🟡非拟人化界面指南❗ 7\n\n**–将计算机呈现为人时，无论是合成人物还是卡通人物，均需谨慎。** \n\n**–在游戏或儿童软件中使用卡通人物，但在其他地方应避免使用它们。**\n\n**–设计可理解、可预测和可控制的界面。**\n\n**–提供以用户为中心的概要，用于概述性和总结性内容。** \n\n**–利用适当的人来做音频或视频介绍或向导。** \n\n**–计算机响应人的动作时，不使用第一人称代词“我”。** \n\n**–使用“你”来指导用户或仅陈述事实。**\n\n![](https://s2.loli.net/2023/07/09/exB67E2gk5TOwmb.png)\n\n## 8错误消息P284\n\n**错误消息要有特异性、具体的建设性指南和积极的语气：**\n\n* **消息应该在可能的情况下指出用户应该做什么来纠正问题**\n* 使用暴力术语的不必要的敌意信息会干扰非技术用户：\n  **最终产品和开发过程的错误消息指南**\n  最终产品\n  * 尽可能具体、精确、确定必要的、相关的错误消息\n  * 有建设性、指出用户需要做什么\n  * 使用积极的语气，避免谴责，有礼貌\n  * 选择以用户为中心的措辞，陈述问题、原因、解决方案\n\n2.显示设计\n.多窗口的协调 考虑因素\n\n6颜色 考太多次 \n\n8错误消息的比较 列出错误消息设计更好的方案\n\n## 9🟡系统响应时间SRT 知道概念定义 书p294两张图看懂\n\n![](https://s2.loli.net/2023/07/09/C6iPeXLKbVrE2Mw.png)\n\n![](https://s2.loli.net/2023/07/09/zKTHbRBeyq7Lwhi.png)\n\n![](https://s2.loli.net/2023/07/09/JmPGVOpeDBHYc3z.png)  \n\n减轻用户**等待**时的负面情绪\n用户对SRT的期望值和态度\n\n* SRT(系统响应时间)：**从用户发起动作（通常为触碰图标、按回车键或点击鼠标)到计算机开始呈现反馈结果所需要的秒数。**\n* 用户思考时间：从计算机响应到用户发起下一动作所花的秒数\n\n### 🟡影响用户对SRT的因素\n\n用户🟡 三个因素\n\n* **以往的经验**：设计能够快速引导用户上手的操作\n* **个性的差异**：每个人对时延 的忍耐度不同\n* **任务的不同**：任务的复杂性与用户对任务的熟悉程度\n\n19.SRT指南\n\n## 🟡作业3 4\n\n![](https://s2.loli.net/2023/07/09/SisG1Iy4AM52hgC.png)\n\n# 第十四章 文档和用户支持\n\n## 3🟡在线文档的优势❗\n\n* **物理优势**\n  * **可在上网的电子设备上随时使用，不会丢失或放错地方，不需要物理空间，能闭速更新。**\n* **导航功能**\n  * **可提供索引和其他搜索工具，可链接到其他外部资源**\n* **交互式服务**\n  * **可添加书签、注释和标签；可包含图形、声音、颜色和动画**\n  * **可为残疾用户提供屏幕阅读器或其他工具**\n\n## 🟡纸面阅读和显示器阅读的比较 优缺点 书p313❗\n\n纸张印刷的历史有500多年，人们对纸张、颜色、字体、字形等进行了大量的实验，得出很有吸引力的阅读格式。\n\n**阅读计算机显示的内容会造成<u>视觉被劳</u>，但疲劳的原因也与休息方式中断及任务的多样性紧密相关**\n\n**即使用户没有察觉到视觉疲劳或压力，他们使用<u>显示器的效率</u>也会能低于使用纸质文档的工作效率**\n\n**设计师应该认识到，<u>槽糕的设计</u>会导致阅读困难，而且会干扰整个阅读过程**\n\n支持阅读的一些准则：\n\n* 不使用不常见或不熟悉的词汇\n* 避免使用难以阅读的字形（如全大写）\n* 使用清晰不凌乱的无衬线字体\n* 响应快，刷新率高\n* 采用文档分页而非滚动方式\n\n![](https://s2.loli.net/2023/07/09/dyi9xagStXOj1zP.png)\n\n作业\n\n# 第十五章没有要求\n\n# 第十六章\n\n## 🟡数据可视化 名词解释  p347\n\n**这种数据驱动图片的想法，称为可视化**\n\n## 🟡2.数据可视化任务三个类别 \n\n**明白三个大类，怎么区分**\n\n![](https://s2.loli.net/2023/07/09/fdk2oc7RgnQPAIE.png)\n\n* 这三个类别合并了支持迭代视觉分析的关键任务：包括可视化创建、交互式查询、多视图协调、历史和协作\n\n3.数据可视化数据类型 一维二维..\n\n## 🟡数据类型P353 不需要背大概知道\n\n![](https://s2.loli.net/2023/07/09/2TnY9pGtWsN8Drx.png)\n\n## 🟡数据可视化挑战 作业\n\n* 导入和清理数据\n* 集成数据挖掘\n* 查看大数据\n* 实现通用性\n* 支持临时用户\n* 传播和讲故事\n* 适配任何设备\n* 评估\n\n# 后记\n\n## 🟡未来界面 书p366 开放想法\n\n1.未来的界面和巨大的挑战P366\n\n这些设备无处不在，且又小又便宜\n\n新设各是可穿戴的、移动的、个人的和便携的\n\n新设各是嵌入式的、上下文感知的和环绕的，内置于我们的环境中（因此不可见\n\n即可访问，并能响应用户需求。通过视觉、听觉、触觉、手势和其他刺激进行交互\n\n2.信息时代十大顽疾\n","tags":["笔记"],"categories":["本科课程"]},{"title":"计算机网络笔记","url":"/2023/07/09/计算机网络笔记/","content":"\n# 错题\n\n* 无效Mac帧\n\n  * 帧的长度不是整数字节\n  * 数据字段的长度不在46-1500字节之间\n  * 帧的长度不在64-1518字节之间\n  * 用收到的帧检验序列FCS查出有差错\n\n* 网桥从某一端口收到正确的数据帧后，在其他址转发表中查找该帧要到达的目的站，若查找不到，则会  **<u>向除该端口以外的所有端口转发此帧</u>**\n\n* 以太网交换机进行转发决策时使用的PDU地址是 **<u>目的物理地址</u>**\n\n* 关于100BASE-T以太网，错误的是：A，表示双绞线组网\n\n  A.T表示粗同轴电缆组网\n\n  B.100指的是传输速率为100Mb/s\n\n  C.BASE指的是基带传输\n\n  D.100BASE-T是一种星形以太网\n\n* 属于虚电路操作特点的是：D\n\n  A 每个分组携带有终点的地址信息，它的传送是自身寻址的\n\n  B 在整个传送过程中，不需要建立虚电路\n\n  C 网络节点要为每个分组做出路由选择\n\n  D 使所有分组按顺序到达目的系统\n\n* 下面哪个协议不属于网络层？ C\n\n  A ARP\n\n  B ICMP\n\n  C TCP\n\n  D IP\n\n  **TCP/IP 体系中网络层的协议：****IP 协议****、ARP协**\n\n  **议、ICMP协议、IGMP协议** TCP属于传输层\n\n* 点分十进制：**-A类-127-B类-191-C类-223-D类**\n\n* 在因特网中，IP数据报从源结点到目的结点可能需要经过多个网络和路由器在整个传输过程中，IP数据报报头的：**源地址和目的地址都不会变化**，读取过程只是找到下一跳地址\n\n* IP数据报需要由源主机和中途路由器到达目的主机，通常：；**源主机和中途路由器都不知道**IP数据报到达目的主机需要经过的完整路径。源主机只知道默认网关是谁，中途路由器根据路由表转发给下一跳\n\n* 在因特网中，路由器可连接多个物理网络，此时路由器 **B**\n\n  A具有单一IP地址\n\n  B具有多个IP地址，每个IP地址与各相连的物理网中具有相同网络号，并占用**一个主机号**\n\n  C具有多个IP地址，每个IP地址与各相连的物理网中具有相同网络号，并占用多个主机号\n\n* 以下为源和目标主机的不同IP地址组合，其中()组合可以不经过路由直接寻址 B\n\n  A.125.2.5.3/24和136.2.2.3/24\n\n  B125.2.5.3/16和125.2.3/16\n\n  C126.2.5.3/16和126.2.2.3/21\n\n  A，24位为网络号，不同；B，16位，相同；C，126.2.2.3借前21，换成2进制发现网络号一样，但是子网掩码(网络段)是不一样的，不能选\n\n* 关于无分类编址CIDR，下列说法**错误**的是(C)\n  ACIDR使用各种长度的“网络前缀”来代替分类地址中的网络号和子网号。\n\n  BCIDR将网络前缀都相同的连续的IP地址组成“CIDR”地址块。\n\n  C.网络前缀越短，其地址块所包含的地址数就越少\n\n  D使用CIDR，查找路由表时可能会得到多个匹配结果应当从匹配结果中选择具有最长网络前缀的路由。因为网络前缀越长，路由就越具体。 最长前缀匹配原则\n\n* 对网际控制报文协议 (ICMP) 描述错误的是()。\n  A.ICMP封装在IP数据报的数据部分\n  B.ICMP是属于应用层的协议\n\n  C.ICMP是IP协议的必需的一个部分\n\n  D.Ping命令使用了ICMP回送请求与回送应答报文\n\n* 下列前缀中的哪一个和地址152.7.77.159及15231.47.252都匹配?(D)\n\n  A.152.40/13 \n\n  B.153.40/9\n\n  C.152.64/12\n  D.152.0/11\n\n  聚合，152.7->152.00000111 \n\n  ​          152.31->152.00011111 前三个都是0\n\n  因此网络号为152.00000000.0.0 后面全0，一共11为网络号，是152.0/11\n\n* 不属于路由选择协议 B\n\n  A RIP\n\n  B ICMP\n\n  C BGP\n\n  D OSPF\n\n* RIP适用小型，OSPF适用大型\n\n* 某自治系统采用RIP协议，R1收到邻居R2距离向量，包含信息**<net1,16>**，则可以得到结论 B\n\n  A R2 通过 R1 到net1，跳数为17\n\n  B R2 不能到 net1\n\n  C R1 通过 R2 到net1，跳数为17\n\n  D R2 能到 net1，条数为16\n\n  **忘记了16跳表示不可达了**\n\n* 下一跳路由器分别为N2、2、X，新收到从X发来的路由信息中目的网络、跳数、下跳路由器分别为N2、5、Y，则路由表D中更新后关于N2的路由信息为(C)。\n\n  A N2、2、X 错选\n\n  B N2、5、X\n\n  C N2、6、X **注意自加1**\n\n  D N2、5、Y\n\n  若下一跳字段给出的路由器地址**相同**，则把收到的项目**替换源**路由表项目。\n\n  如果收到项目中的距离小于路由表中的距离，则进行更新\n\n* 下列关于IPv6的表述中，(D) 是错误的。、\n\n  AIPv6的头部长度是不可变的\n\n  BIPv6不允许路由设备来讲行分片\n\n  CIPv6采用了16B的地址号，理论上不可能用完\n\n  DIPv6使用了头部校验和来保证传输的正确性\n\n  基本首部40字节，不可变；开始的mpu值就设定好了，不需要分片；IPV4有首部检验，而IPV6反而没有，取消\n\n* 下面哪个地址属于专用IP地址？(C)\n\n  A127.0.0.1 环回地址\n\n  B192.32.116.22 \n\n  --192.168开头\n\n  C172.16.1.31\n\n  --172.16-172.31\n\n  D255.0.0.0\n\n* 属于传输层协议的是C\n\n  AIP\n\n  网络层\n\n  BARP\n\n  网络层\n\n  CTCP\n\n  DRARP\n\n* TCP流量控制 A\n\n  对发送方\n\n  对接收方\n\n  对发、接双方\n\n  链路上任两结点间数据\n\n* 一个TCP连接的数据传输阶段，如果发送端的发送窗口值由2000变为3000，意味着可以 C\n\n  在收到一个确认之前可发3000个TCP报文段\n\n  可发1000B\n\n  可发3000B\n\n  可发2000个TCP报文段\n\n* A和B之间建立了TCP连接，A向B发送了一个报文段，其中序号字段seq=300，确认号字段ack=101，数据部分包含7个字节，那么B在对该报文的确认报文段中seq,ack分别为(D) \n\n  A307,101\n\n  B301,108\n\n  C101,306\n\n  D101,307\n\n  序号就是收到的确认号，确认号为上一个序号加数据300+7=307\n\n* 在一个TCP连接中，MSS为1KB，当拥塞窗口为34KB时收到了3个元余ACK报文。如果在接下来的4个RTT内报文段传输都是成功的，那么当这些报文段均得到确认后，拥塞窗口的大小是(D)\n  A 8KB\n\n  B16KB\n\n  C27KB\n\n  D21KB\n\n  3个ACK，超时减半，然后根据4个RTT(往返时间)线性增加，34/2+4=21\n\n* DNS说法错误的是 A\n\n  A.DNS系统运行在TCP协议之上\n\n  对于数据小，用的少的用**UDP**\n\n  B.DNS采用客户服务器工作模式\n\n  C.域名的命名原则是采用层次结构的命名树\n\n  D.域名不能反映计算机所在的物理地址\n\n  逻辑地址\n\n* 一台主机希望解析域名www.bit.edu.cn，如果这台主机配置的本地域名服务器为202.120.6688，internet根域名服务器为10.1.2.3而存储www.bit.edu.cn与其IP地址对应关系的权限域名服务器为202.110.6.8，那么这台主机解析该域名时首先查询 ()。\n\n  A.地址为202.120.66.88的域名服务器\n\n  B.地址为10.1.2.3的域名服务器\n\n  C.地址为202.110.6.8的域名服务器\n\n  D.不能确定\n\n  主机想进行域名解析先查询本地域名服务器，如果其不知，查询根域名，再查顶级，再查权限 \n\n  ![image-20230609085517082.png](https://s2.loli.net/2023/07/09/jC2kSc6KNIFVpHy.png)\n\n\n\n# 一\n\n## 计网的作用\n\n* 三网融合：电信网络、有线电视网络、计算机网络\n* 互联网两个重要特点：连通性、共享\n\n## 概述\n\n起源 ARPANET\n\n## 组成\n\n* 边缘部分，端系统之间的通信方式：C/S、P2P\n* 核心部分，三种交换方式：电路交换、分组交换(路由器)、电报交换\n\n### 电路交换\n\n1950S，电报采用基于存储转发的报文交换\n\n电路交换——整个报文的比特流连续地从源点直达终点。好像在一个管道传输。\n\n### 报文交换\n\n报文交换——整个报文先传送到相邻节点、全部存储下来后查找转发表，转发到下一个节点。\n\n### 分组交换\n\n分组又称为“包”，分组交换——单个分组传送到相邻节点，存储下来后查找转发表，转发到下一个节点。\n\n#### 路由器\n\n注意分组的**存储转发**过程，在路由器分组放入缓存，查路由表，转发\n\n路由器输入和输出端口没有直接连线的，而交换机有\n\n路由器利用软件时间数据交换，交换机是依靠硬件，前者比后者慢\n\n> 注意路由器和交换机的区别\n\n**带来的问题：**\n\n* 要排队，会造成一定时延。（如果分组太多，造成时延太大，会直接丢掉分组）\n* 必须携带首部，造成了一定的开销\n\n### ⭐三种交换比较\n\n![image.png](https://s2.loli.net/2023/03/03/DrENTCmXzG9htiJ.png)\n\n* 稳定性：电报交换传输更加稳定，报文和分组交换存在丢包可能。\n\n* 传输速率：当要连续传输大量的数据，电路交换的传输速率较快。\n\n* 传输效率和信道利用率：传输突发式的计算机数据时，电报交换速率由于线路被占用，且需要预先分配带宽，使得传输效率和信道利用率很低；报文交换和不需要预先分配传输带宽，且不必先占用一条端到端的通信资源，省去了开销，数据的传输效率和信道利用率更高。\n* 例子：有线电话和IP电话\n  * IP电话成本低，计算机网络连接分组交换逐端占用，通话质量没那么高\n  * 有线电话稳定，通话质量高，专用链路连接，成本高\n\n\n\n## 计网在我国的发展\n\n94年被正式承认为接入互联网的国家\n\n《中国互联网络发展状况统计报告》\n\n\n\n## 计算机网络的类别\n\n### 定义\n\n地理位置不同的具有独立功能的多台计算机及其外部设备（硬件），通过通信线路连接，在网络操作系统、网络管理系统和协议等（软件）的管理和协调下，实现 资源共享和i信息传递的计算机系统\n\n### 分类\n\n* **从作用范围上分类**\n  * 广域网WAN(Wide) 作用距离在几十到几千公里，是互联网核心部分。\n  * 域域网MAN(Metroplitan) 作用距离在5-50公里 作用范围可跨越几个街区/整个城市。\n  * 局域网LAN(Local) 作用距离1公里以内，作用范围一般是一个学校、公司或工厂。\n  * 个人区域网PAN(Personal) 作用距离10米以内，是用无线技术将个人使用的电子设备连接起来形成的网络。\n\n* **从网络的使用者上分类**\n  * 公用网 简单理解就是大家都可以用的网络(只要交了钱)，由电信公司出资建设。\n  * 专用网 某个部分/机关由于内部需要专用的网络，不对外提供服务。\n\n## 计算机网路的性能\n\n### 性能指标\n\n**比特** 一个比特就是二进制数字中的0或1\n\n**带宽** \n\n本来是指信号具有的频带宽度\n\n在计网中表示**在单位时间内网络中的某通道所能通过的“最高数据率”**。单位是bit/s，即比特每秒\n\n在时间轴上的**信号的宽度**随带宽的增大而变窄，频率增大\n\n**吞吐量**\n\n在单位时间内通过某网络（或信道、接口）的数据量\n\n**时延**\n\n数据从网络的一端传送到另一端所需的时间，有时也称位延迟或迟延。\n\n由四部分组成，发送时延、传播时延、处理时延、排队时延\n\n发送时延：\n$$\n发送时延=\\frac{数据帧长度(bit)}{发送速率(bit/s)}\n$$\n传播时延：\n$$\n传播时延=\\frac{信道长度(m)}{电磁波在信道上的传播速率(m/s)}\n$$\n处理时延\n\n排队时延\n$$\n总时延=发送时延+传播时延+处理时延+排队时延\n$$\n\n\n总时延\n\n发10个分组的用时：每个分组的发送时延之和+最后一个分组的传播时延和处理时延\n\n**时延带宽积**\n$$\n时延带宽积=传播时延×带宽\n$$\n![image.png](https://s2.loli.net/2023/03/03/OW31DC2Ge4h6YFp.png)\n\n**往返时间RTT**\n\n\n$$\n发送时间=\\frac{数据长度}{发送速率}\n$$\n\n$$\n有效数据率=\\frac{数据长度}{发送时间+RTT}\n$$\n\n\n\n**利用率**\n\n利用率越大，时延增加\n\n### 非性能特征\n\n**费用**\n\n**质量**\n\n**标准化**\n\n**可靠性**\n\n**可拓展性和升级性**\n\n**易于管理和维护**\n\n## 计算机网络的体系结构\n\n### 体系结构的形成\n\n* 为什么分层？分层次结构有很多好处，比如：\n  * 能够使各层之间独立，问题的复杂度变小了；\n  * 灵活性好，各层互不影响；\n  * 结构上可分割，各层都采用最合适的技术来实现；\n  * 易于实现和维护；\n  * 能促进标准化工作，每一次的功能都很明确。\n  * 比如我们学生组织分为几个部门，有些部门负责统筹组织，有些部门负责整合资料，有些部门负责宣传推广，分层次地把一个大的项目和任务实施解决。\n\n\n* 缺点\n  * 麻烦\n* 各层完成的主要功能\n\n  * 差错控制\n  * 流量控制\n  * 分段和重装\n  * 复用和分用\n  * 连接建立和释放\n\n### 协议与划分层次\n\n* 网络协议三个要素\n  * 语法，即数据与控制信息的结构或格式\n  * 语义，即需要发出何种控制信息，完成何种动作以及做出何种响应；\n  * 同步，即事件实现顺序的说明。\n\n#### 三种分层概念\n\n具有五层协议的体系结构\n\nOSI的七层协议\n\nTCP/IP的四层体系结构\n\n#### 五层协议\n\n![image.png](https://s2.loli.net/2023/03/03/Zs3TeWgtJKkHYoL.png)\n\n* 应用层 处理不同应用\n  * 应用层是体系结构的最高处。任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。\n\n* 运输层 运输\n  * 运输层的任务就是负责向两台主机中进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。主要使用传输控制协议TCP和用户数据报协议UDP。流量控制\n\n* 网络层 路由，找路线\n  * 网络层负责为**分组**交换网上的不同主机提供通信服务，将用户数据封装成IP数据报，主要功能是路由。\n\n* 数据链路层 封装，拆分成**帧**\n  * 将数据报组装成帧，包括了数据和必要的控制信息，是链路上传输数据的协议。\n\n* 物理层 接口有关\n  * 物理层上传输数据的单位是**比特**，需要考虑传输的编码方式和硬件条件。\n\n#### 协议与服务有何区别？有何关系？\n\n协议是水平的，服务是垂直的。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。只有那些能被高一层实体“看得见”的功能才能称之为“服务”。\n\n## 一些名词\n\n* 协议栈：协议栈是指由**多个协议层组成**的一种网络通信协议体系结构。每一层协议都负责特定的功能，例如物理层、数据链路层、网络层、传输层、应用层等。协议栈中的每一层都通过接口与上下层交换信息，并对其上层提供服务。\n\n* 实体：实体是指一个网络节点上的一个网络通信实体，它可以是硬件设备、软件程序、网络服务器等。实体在网络中通过地址进行标识，通常使用IP地址或MAC地址。\n\n* 对等层：对等层是指在协议栈中相互配对的**同级协议层**。在对等层之间，通信双方具有相同的角色和功能，并且它们通过接口进行通信。\n\n* 协议数据单元：协议数据单元是在网络通信中，不同层之间传递信息的**基本单元**。在不同层之间，PDU的命名和格式可能不同。\n\n* 服务访问点：服务访问点是指在同一层协议中，**对上下层提供服务的接口**。每个SAP都有一个唯一的标识符，用于标识服务提供者和服务请求者之间的通信关系。\n\n* 客户（Client）：客户指的是通过网络**请求服务**的设备或应用程序。在客户-服务器模型中，客户向服务器发出请求，等待服务器响应并接收数据。\n\n* 服务器（Server）：服务器指的是**提供服务**的设备或应用程序。在客户-服务器模型中，服务器接收客户端请求，处理请求并向客户端发送响应数据。\n\n* 客户-服务器方式（Client-Server）：客户-服务器方式是一种网络通信模型，其中客户端设备或应用程序通过网络向服务器发出请求，等待服务器响应并接收数据。服务器接收客户端请求，处理请求并向客户端发送响应数据。这种模型在分布式计算和Web服务中广泛使用\n\n# 二 物理层\n\n数据通信的基础知识：奈氏准则、香农定理\n\n传输媒体：导引型，非导引型\n\n信道复用：频分、时分、波分、码分\n\n## 主要任务\n\n解决与接口有关的任务，包括：\n\n* 机械特性\n* 电气特性\n* 功能特性\n* 过程特性\n\n数据在计算机内部是并行传输，在通信线路上是串行传输\n\n## 数据通信\n\n### 模型\n\n通信系统分为：\n\n* 源系统\n* 传输系统\n* 目的系统\n\n### 信道\n\n* 单工通信\n* 半双工通信\n* 全双工通信\n\n来自信号源的信号称为基带信号（基本频带信号）\n\n解决通信问题需要对基带信号进行调制。\n\n* 基带调制 变换后还是基带信号\n* 带通调制 使用载波\n\n#### 常见编码方式\n\n* 不归零制\n* 归零制\n* 曼彻斯特编码\n* 差分曼彻斯特编码\n\n#### 基本的带通调制方法\n\n* 调幅\n* 调频\n* 调相\n\n正交振幅调制\n\n### ⭐信道的极限容量\n\n**奈氏准则**\n\n单位波特率，码元传输最高速率是带宽的两倍，2W（码元/秒）\n\n比特率=波特率×log<sub>2</sub>N\n\n**信噪比**\n$$\n信噪比(dB)=10log(S/N)\n$$\n**香农定理**\n$$\nC=Wlog2(1+S/N)\n$$\n\n## 传输媒体\n\n传输媒体分为\n\n* 导引型 （有线）\n* 非导引型 （无线）\n\n### 导引型\n\n#### 双绞线\n\n无屏蔽双绞线UTP\n\n非屏蔽双绞线STP PVC套层与带绝缘层的铜线之间有一层**铝箔屏蔽层**\n\n![image.png](https://s2.loli.net/2023/03/17/aSLOkYfym89niju.png)\n\n* 导线相互缠绕可降低电磁干扰\n  * 同向的导线，磁场抵消，消除导线之间的串扰\n  * 差值法避免了噪声干扰\n\n* 八个脚位\n  * 1、2发送数据正/负极，3、6接收数据正/负极\n  * 交换机内部做了翻转，1、2收，3、6发\n  * 主机和路由也用交叉\n  * RJ45：接头+水晶头\n\n![image.png](https://s2.loli.net/2023/03/17/UqPMRhs2jIaXor1.png)\n\n#### 同轴电缆\n\n#### 光缆\n\n光纤做成结实的光缆\n\n![image.png](https://s2.loli.net/2023/03/17/WucFAkwlrvIS2Ee.png)\n\n光线入射角足够大就会出现全发射，即光线碰到包层时就会折射会纤芯\n\n![image.png](https://s2.loli.net/2023/03/17/ox4bszGPlFfDTjN.png)\n\n|          | 纤芯直径               | 光源       | 传输速率   | 应用         |\n| -------- | ---------------------- | ---------- | ---------- | ------------ |\n| 多模光纤 | 较大，同时传输多条光线 | 发光二极管 | 低、性能差 | 局域网       |\n| 单模光纤 | 较小，一次传输一条光线 | 激光       | 高         | 楼间、广域网 |\n\n多模光线传输速率低、性能差但是成本低，一般用于局域网\n\n单模光纤通常用于楼间连接或广域网连接\n\n**光纤优点**\n\n* 通信容量非常大\n* 传输损耗小，中继距离长\n* 抗雷电和电磁干扰性能好\n* 无串音干扰，保密性好\n* 体积小，重量轻\n\n缺点\n\n* 成本\n* 脆弱\n\n### 非导引型\n\n波长越长、频率越小\n\n#### 短波通信\n\n主要靠电离层的反射，会产生多经效应\n\n一次反射可传输4000km，一般用于军事通讯\n\n![image.png](https://s2.loli.net/2023/03/17/1y3rlwizaoNBZ9b.png)\n\n#### 微波通信\n\n频谱范围：300MHz-300GHz\n\n特性：在空间主要是直线传播，难以传过建筑物\n\n两种方式：地面微波中继通信、卫星通信\n\n## ⭐信道复用技术\n\n**复用**技术允许共享信道进行通信，降低成本，提高利用率\n\n### 频分复用、时分复用和统计时分复用\n\n#### 频分复用\n\n在同样时间占用不同的带宽(频率带宽)资源.例子：同时听到猫叫和狗叫，可以区分，因为频率不同\n\n![image.png](https://s2.loli.net/2023/03/17/JxbA7GnuCjvYkrz.png)\n\n#### 时分复用\n\n所有用户在不同的时间占用同样的频带宽度\n\n是将时间划分为一段段等长的时分复用帧 （TDM 帧）。每一个时分复用的用户在每一个 TDM  帧中占用固定序号的时隙。\n\n![image.png](https://s2.loli.net/2023/03/17/dCZ5YxwuXRANGcp.png)\n\n#### 波分复用\n\n波分复用就是光的频分复用。使用一根 光纤来同时传输多个光载波信号。\n\n![image.png](https://s2.loli.net/2023/03/17/16PUFdW9Ty2QSLY.png)\n\n#### ⭐码分复用CDMA\n\n* 码分复用 CDMA\n* 特殊挑选不同码型，因此彼此不会相互干扰\n* 有较强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现\n* 应用：第三代数字移动通信系统（3G)\n\n##### 码片序列\n\n每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。\n\n◼ 每个站被指派一个唯一的 m bit 码片序列。 \n\n​\t◼ 如发送比特 1，则发送自己的 m bit 码片序列。\n\n​\t◼ 如发送比特 0，则发送该码片序列的二进制反码。\n\n◼ 例如，S 站的 8 bit 码片序列是 00011011。 \n\n​\t ◼ 发送比特 1 时，就发送序列 00011011， \n\n​\t ◼ 发送比特 0 时，就发送序列 11100100。 \n\n◼ S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) ，-1表示0\n\n**两个不同站的码片序列正交**，因此有规格化内积为0：\n$$\nS\\cdot T=\\frac{1}{m}\\sum_{i=1}^m{S_iT_i=0}\n$$\n和别人为0，和自己为1，和反码为-1\n\n##### 应用\n\n接收信号的时候接收到不止一个站发送的信号，比如此时我想要接收S站的信息，假设收到的是\n$$\n(S+T)\n$$\n此时用S的码片序列去做规格化内积：\n$$\nS·(S+T)=S·S+S·T\n$$\n此时S·T得到的结果是0，所以最终规格化内积后可得结果为：\n$$\nS·S\n$$\n**将它除以码片序列的长度，结果为1时说明发了1，结果为-1时说明发了0**\n\n* 共有四个站进行码分多址CDMA通信。四个站的码片序列为:\n\nA: (-1 -1 -1 +1 +1 -1 +1 +1)  B: (-1 -1 +1 -1 +1 +1 +1 -1)\n\nC: (-1 +1 -1 +1 +1 +1 -1 -1)  D: (-1 +1 -1 -1 -1 -1 +1 -1)\n\n现收到这样的码片序列：(-1 +1 -3 +1 -1 -3 +1 +1)。问哪个站发送了数据？发送数据的站发送的是1还是0？\n$$\nA站：\\left( -1-1-1+1+1-1+1+1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) /8=1\n$$\n\n$$\nB站：\\left( -1-1+1-1+1+1+1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) /8=-1\n$$\n\n$$\nC站：\\left( -1+1-1+1+1+1-1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) /8=0\n$$\n\n$$\nD站：\\left( -1+1-1-1-1-1+1-1 \\right) \\cdot \\left( -1+1-3+1-1-3+1+1 \\right) /8=1\n$$\n\nA、D站发送的是1，B结果为-1发送的是0，而C站没有发送数据\n\n## 例题\n\n模拟信道的信号功率为0.62W，噪声功率为0.02W，传输频率为3.5-3.9MHz，问最大传输速率？\n\n有噪声，利用香农公式，其实频带W=(3.9-3.5)M（带宽：信号具有的频带宽度）\n\n\n\n## 数字传输系统\n\n脉码调制 PCM般包括三个过程：采样、量化和编码。\n\n![image.png](https://s2.loli.net/2023/03/24/mgIk9MnStpUqer1.png)\n\n![image.png](https://s2.loli.net/2023/03/24/DxqXcyfIb5uVpGR.png)\n\n\n\n### 同步光纤网SONET\n\n1988美国提出一个数字传输标准，叫做同步光纤网SONET\n\n### 同步数字序列SDH\n\nSDH相当于SONET的同义词，标准近似\n\n\n\n> 首次实现了数字传输体制上的世界性标准\n\n## 宽带接入技术\n\n用户要连接到互联网，必须先连接到某个ISP\n\n初期用户利用电话的用户线通过调制解调器连接到ISP，最高速率56kbit/s\n\n美国联邦通信委员会FCC认为只要**双向速率和超过200kbit/s就是宽带**\n\n### ADSL技术\n\nADSL非对称数字用户线，上行与下行速率不同。\n\n* 特点\n  * 下行速率远大于上下\n  * 采用非对称传输的原因：在网络应用中，用户 的下载数据量要远大于上传的数据量\n  * ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。 \n  * 我国目前采用的方案是离散多音调(频率) DMT  (Discrete Multi-Tone)调制技术。\n  * 打电话、上网、上传、下载、多用户，都不互相影响\n\n![image.png](https://s2.loli.net/2023/03/24/LCHX7O9IsjEhaPF.png)\n\n### 光纤同轴混合网（HFC网）\n\nHFC 网对 CATV 网进行了改造。HFC 网将原 CATV 网中的同轴电缆**主干部分改换为光纤**，并使用模拟光纤技术。\n\n\n\n### FTTx技术\n\n代表多种宽带光纤接入方式\n\n# 🖼图床至此为止\n\n# 三 数据链路层\n\n* 数据链路的主要功能\n* **数据链路层协议的三个基本问题**\n* 数据链路使用的信道类型\n* PPP协议的特点、帧格式、工作状态\n* 局域网拓扑结构\n* **CSMA/CD 协议**\n* **以太网V2的MAC帧地址**\n* 如何实现在物理层、**数据链路层扩展以太网**\n* **集线器、交换机的特点与区别**\n* **交换机的工作原理**\n* 生成树协议的作用、工作原理\n* VLAN的作用和特点\n* 以太网的演进\n\n## 数据链路和帧\n\n链路是一条无源的点到点的物理线路段，中间没有任何其他的交换结点\n\n不同的链路层可能采用不同的数据链路层协议：\n\n![image-20230324105441524.png](https://s2.loli.net/2023/07/09/gCY8GSp1TUHLkcf.png)\n\n### 三个基本问题\n\n* 封装成帧\n* 透明传输\n* 差错控制\n\n#### 封装成帧\n\n首部和尾部进行帧定界\n\n#### 透明传输\n\n透明：实际存在但是又摸不到看不着，这里是相对上层来说透明\n\n任何一个二层协议都要解决透明传输问题\n\n控制字符在数据出现会导致帧定界出错！\n\n解决方法：**字节填充**\n\n如果数据中有控制字符，那么在控制字符前进行字节填充\n\n#### 差错控制\n\n传输过程中可能会产生比特差错：1 可能会变 成 0 而 0 也可能变成 1。\n\n传输错误的比特占所传输比特 总数的比率称为**误码率 BER**\n\n误码率与信噪比有很大的关系。\n\n为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。\n\n* 广泛使用循环冗余检验CRC的检测方法：\n\n假设待传送的一组数据 M = 101001（现在 k =  6)。我们在 M 的后面再添加供差错检测用的 n 位冗余码一起发送\n\n**二进制模2运算**：进行2^n乘M的运算，相当于在M后面**添加n个0**\n\n* 冗余码计算举例\n\n  现在 k = 6, M = 101001。  设 n = 3, 除数 P = 1101，  被除数是 2^nM = 101001000。  模 2 运算的结果是：商 Q = 110101， 余数 R = 001。  把余数 R 作为冗余码添加在数据 M 的后面发送出去。 发送的数据是：2^nM+R，即101001001，共(k+n)位\n\n![image-20230331091534750.png](https://s2.loli.net/2023/07/09/97askT6t3A4DQIR.png)\n\n余数001作为FCS\n\n**任意一个比特出错都能查出来**\n\n![image-20230331090019952.png](https://s2.loli.net/2023/07/09/hlMjO5bPqY1Cnpv.png)\n\nP=1*X^3+1*X^2+0*X+1，表示1101\n\n* 检验\n\n  若得出余数R=0，则判断这个帧没有差错，就接收\n\n  若余数R≠0，则有差错，丢弃\n\n* 这种方法并不能确定究竟是哪一个或哪几个比特出现了差错，只要经过严格的挑选，并使用位数足够多的除数P，则检测不出差错的概率将很小\n\n> 仅用循环冗余检验 CRC 差错检测技术只能做到无差错 接受 (accept)。也就是说：“凡是接收端数据链路层接受的帧都没有 传输差错”（有差错的帧就丢弃而不接受）\n\n要做到**“可靠传输”**（即发送什么就收到什么）就必 须再加上**确认**和**重传**机制。\n\n* 奇偶校验这能检测出奇数个位出错，偶数位出错查不出来\n\n**练习：**要发送的数据是101110，采用CRC的生成多项 式是P(X)=X^3+1。试求应添加在数据后面的余数。\n\n![image-20230331091534750.png](https://s2.loli.net/2023/07/09/97askT6t3A4DQIR.png)\n\n> 不借位，注意补零，算错两次了\n\n## 3.2点对点协议PPP\n\n特点、组成、工作状态、帧格式、透明传输\n\nPoint-to-Point\n\n![image-20230331095445730.png](https://s2.loli.net/2023/07/09/J8jOKrzomaVL7bx.png)\n\n### 3.2.2PPP 协议的帧格式\n\n* PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。\n\n* 标志字段 F = 0x7E （符号“0x”表示后面的字符是用 十六进制表示。十六进制的 7E 的二进制表示是 01111110）。 \n\n* 地址字段 A 只置为 0xFF。地址字段实际上并不起作用。 \n\n* 控制字段 C 通常置为 0x03。 \n\n* PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节\n\n#### 透明传输问题\n\n字符填充\n\n零比特填充\n\n在PPP协议中，为了解决传输中出现的数据丢失或者错误，采用了同步传输技术，并在数据帧中使用了零比特填充（Zero-bit stuffing）的方法。具体地，当数据帧中出现连续的五个1时，在第六个1之后自动插入一个零，以避免在传输过程中与控制帧的标识字段发生混淆。\n\n## 3.3使用广播信道的数据链路层\n\n* 以太网的两个标准\n\n  * DIX Ethernet V2\n  * IEEE 802.3\n    * 逻辑链路控制 **LLC**子层\n    * 媒体接入控制 **MAC**子层\n\n  > 由于TCP/IP经常试验DIX Ethernet V2，LLC作用不大，很少有了\n\n![image-20230331103324404.png](https://s2.loli.net/2023/07/09/BZmRXpDM4W6lTYt.png)\n\n* 适配器作用\n  * 网络接口板又称为通信适配器 (adapter) 或网络 接口卡 NIC (Network Interface Card)，或“网 卡”。\n  * 重要功能\n    *  进行串行/并行转换\n    *  对数据进行缓存\n    *  在计算机的操作系统安装设备驱动程序\n    *  实现以太网协议\n* 以太网采取了两种重要的措施，为了通信方便\n  *  采用较为灵活的无连接的工作方式\n  *  以太网发送的数据都使用曼彻斯特 (Manchester) 编码\n\n![image-20230331103533420.png](https://s2.loli.net/2023/07/09/NOYJ7twhGP8p4EW.png)\n\n**媒体共享技术**：\n\n\n\n* 动态媒体接入控制（多点接入）\n  * 随机接入方式：争用，可能会起冲突\n  * 受控接入方式，每一个站点轮流拿令牌，把信息加载令牌后\n* 动态分配的特点\n  * 信息是开放的\n  * 没有预分配\n\n> 通过多点接入协议动态分配信道资源，提高信道利用率。\n>\n> 常用的还是随机接入\n\n* 典型的随机接入协议\n  * ALOHA协议：想发就发\n  * CSMA协议：先听后发\n  * **CSMA/CD协议**：**先听后发、边发边听**\n\n####  **CSMA/CD协议**\n\n“多点接入”表示许多计算机以多点接入的方式连接 在一根总线上。\n\n“碰撞检测”就是计算机边发送数据边检测信道上的信 号电压大小。\n\n“载波监听”是指每一个站在发送数据之前先要检测 一下总线上是否有其他计算机在发送数据，如果有， 则暂时不要发送数据，以免发生碰撞\n\n##### 争用期 \n\n![image-20230331110122116.png](https://s2.loli.net/2023/07/09/E6YGCdueqO1WrKv.png)\n\n最迟检测时间就是A到B的**往返时延**$2τ$。过了$2τ$说明就可以了，没有冲突。因此$2τ$称为征用期。\n\n对于10Mbit/s以太网，在争用期内可发送10Mbit/s/*51.2\\*10^-6=64B，因此以太网最短的帧为64B。\n\n如果发生冲突，就一定是在发送的前 64 字节之 内。由于一检测到冲突就立即中止发送，这时已经 发送出去的数据一定小于 64 字节。以太网规定了最短有效帧长为 64 字节，凡长度 小于 64 字节的帧都是由于冲突而异常中止的无 效帧。\n\n##### 二进制指数类型退避算法\n\n* 发生碰撞的站在停止发送数据后，要推迟（退避）一 个**随机时间**才能再发送数据。说话有冲突，双方都等一下再说，等多久呢\n\n* 从整数集合[0,1,...,(2<sup>k</sup>-1)]中**随机取一个数**，记为r。重传所需的时延就是r倍基本退避时间\n\n* 比如k=1，集合就是[0,1]，随机到0，那么冲突之后不等待，直接重传\n* 当k≤10时，参数k等于重传次数\n* 当重传达16次仍不成功则丢弃帧，并向高层报告\n\n##### 要点\n\n1. 准备发送。\n2. 检测信道。忙则等待，若检测到信道空闲，并在96比特时间内信道保存空闲（保证了帧间最小间隔），就发送这个帧。\n3. 检测碰撞\n   1. 发送成功：未检测到碰撞，发送完毕，回到准备发送\n   2. 发送失败：检测到碰撞，立即停止，发送人为干扰信号，然后执行指数退避算法，等待r倍512比特时间后，回到检测信道步骤。若重传16次仍不成功，停止重传向上报错。\n\n### 使用集线器的星形拓扑\n\n1990年 IEEE 制定出星形以太网 10BASE-T 的 标准 802.3i。\n\n**10BAST-T**,110BASE-T 中的“10”表示信号在电缆上的传输速率为 10Mbit/s ，“BASE” 表示电缆上的信号是基带信号，“T” 代表双绞线星形网，奠定了以太网在局域网的统治地位，既降低了成本，又提高了可靠性，具有很高的性价比\n\n从此以太网的总线型变为星形网络。\n\n#### 参数α与利用率\n\n在以太网中定义了参数 α，它是以太网单程端到 端时延  与帧的发送时间 T0 之比：α=$τ$/T<sub>0</sub>\n$$\nSmax=\\frac{T0}{T0+τ}=\\frac{1}{1+α}\n$$\n\n* 集线器工作在物理层MAC，所有接收的数据都发出去。 \n* 使用集线器的以太网在逻辑上仍是一个总线网， 工作站使用CSMA/CD 协议共享逻辑上的总线。 \n* 使用集线器的以太网**利用率很低**。\n\n### 以太网的MAC层\n\n#### MAC层硬件地址\n\n硬件地址又称为物理地址，或 MAC 地址。6个字节，48位\n\n表示的是某个端口的地址。\n\n#### 适配器检查MAC地址\n\n发往本站的帧，包括以下三种帧\n\n* 单播帧（一对一）\n* 广播帧（一对全体）\n* 多播帧（一对多）\n\n混杂方式工作只要“听到”有帧在以太网上传输都接收下来。\n\n帧头：目的地址、源地址、类型（协议）\n\n![image.png](https://s2.loli.net/2024/05/29/ncDAmjobgyeHtU8.png)\n\n加上前后帧，就是64-1518\n\n在帧前面插入的8字节，第一个字段共7个字节，是前同步码，用来迅速实现MAC帧的比特同步。第二个字段1个字节是帧开始定界符，表示后面的信息就是MAC帧\n\n7相当于1，2，1，1，2，1的准备指令，最后的1就是齐步走的指令，\n\nIEEE 802.3规定的MAC帧第三个字段是“长度/类型”\n\n## 3.4 扩展以太网\n\n### 在物理层扩展以太网\n\n\n\n### 在数据链路层扩展以太网\n\n早期使用网桥，现在使用以太网交换机\n\n#### 以太网交换机\n\n**特点：**\n\n* 实质上就是一个多接口的网桥\n* 每个接口都是与主机或交换机直接相连，并且全双工方式工作\n* 以太网交换机具有并行性\n\n**优点：**\n\n* 用户独享带宽，增加了总容量\n  * 对于普通共享式以太网，所有用户平分带宽\n  * 而以太网交换机每个接口带宽都是一样，接口越多，带宽总容量越大\n* 共享转交换不用改动\n* 具有多种速率接口，适合不同用户\n\n交换机要分割广播域，需要用到虚拟局域网(vlan)\n\n**工作原理：**\n\n交换机起初有一张空的mac地址表，通信之后自动学习mac地址，然后转发信息\n\npc0第一次ping pc1，交换机会**广播**包，然后pc1和pc2都收到，但是是pc1需要的，pc1接到后返回包给交换机，这时候交换机已经知道两者的mac地址了，将包返回给pc0。此后发包交换机都会直接在二者进行，不用广播了。\n\n若在有效时间内两主机都没通信，该条目会被删除\n\nMAC地址表空间有限，一旦表满，就会**泛洪**到所有新MAC地址的帧，知道现存地址条目老化未知\n\n* 监听\n\n  * 短时间大量发送错误的mac地址进行攻击，造成内存溢出\n\n  * > 交换机就会从点对点的交换式退回共享式hub，****监听其他主机的数据了![image-20230407110421469](D:\\Typora\\images\\image-20230407110421469.png)\n\n![](https://s2.loli.net/2023/07/09/M5SbZDyWxpdQaKA.png)\n\n**交换方式：**\n\n* 把整个数据帧先缓存，检查是否出错，如无错才送往目的端口。\n* 有差错控制；交换时延较长。\n\n#### **从总线以太网到星形以太网**\n\n* 早期，以太网采用**无源**的总线结构。\n* 现在，采用以太网交换机的星形结构成为以太网的首选拓扑。\n* 总线以太网使用 **CSMA/CD 协议**，以**半双工**方式工作。\n* 交换机不使用共享总线，没有碰撞问题，因此不使用CSMA/CD协议，而是以全双工式工作，但仍然采用以太网的帧结构\n\n使用了生成树协议，不改变网络的实际拓扑，但在**逻辑上则切断**某些链路，使得从一台主机到所有其他主机的路径是**无环路的树状结构**，从而消除了兜圈子现象。\n\n![](https://s2.loli.net/2023/07/09/hOk4MWtriClZaqY.png)\n\n### 虚拟局域网\n\n虚拟局域网（ VLAN ）：它是将局域网从逻辑上划分为一个个的**网段**，从而实现虚拟工作组的一种交换技术。\n\n因此同一个网段下的主机都要设置同一个网络号。\n\n补充：当子网掩码为255.255.255.0，则ip前三个段表示网络号；255.255.0.0，前两个为网络号。(255在8位二进制表示全1)\n\n：那么不同网段设置不同网络号就好了为什么要设VLAN？\n\n：IP是逻辑地址，随时改，不安全不严谨\n\n> 一个VLAN=一个广播域=逻辑网段(子网)\n\n\n\n## 3.5 高速以太网\n\n吉特以太网，上层链路速度要比下层所有加起来要大(或等于)\n\n\n\n# 四 网络层\n\n网络层提供的两种服务：\n\n* 虚电路服务(面向连接，让网络负责可靠交付)\n* 数据报服务(无连接，让主机负责可靠交付)\n\n| **网络层两种服务** | **含义**                                                     | **优点**                                                     | **缺点**                                                     |\n| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| **虚电路服务**     | 借助电信网经验，通信之前先建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源。 | 使所发送的分组无差错按序到达终点，不丢失、不重复。           | 占用一定的网络带宽，造成资源浪费                             |\n| **数据报服务**     | 网络在发送分组时不需要先建立连接。每一个分组（即IP 数据报）独立发送，与其前后的分组无关（不进行编号）。 | 传输网络不提供端到端的可靠传输服务，网络的造价大大降低，运行方式灵活，能够适应多种应用。 | 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），不保证分组传送的时限 |\n\n## 4.2 网际协议IP\n\nARP协议：IP到MAC的映射\n\nICMP( Internet Control Message Protocol )：报告出错情况\n\n### 4.2.1 虚拟互连网络\n\n**意义：**\n\n* **所谓虚拟互连网络也就是逻辑互连网络**\n* 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。\n* 如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet)\n\n核心层--汇聚层--接入层\n\n为什么要有IP而不单独用MAC，因为MAC就像一个人的名字，找是很难找的，IP就像学号，具备逻辑信息，找起来方便\n\n### 4.2.2 分类的IP地址\n\n![](https://s2.loli.net/2023/07/09/d8PiGq1hNlMVXJ6.png)\n\nA类地址的第一个十进制数范围从(1-126)\n\nB类地址的第一个十进制数范围从(128-191)\n\nC类地址的第一个十进制范围(192-223)，例如192.168.1.1 网络号字段即192.168.1.0\n\n**-A类-127-B类-191-C类-**\n\n![](https://s2.loli.net/2023/07/09/tAVEsLlrjCfNo4G.png)\n\n#### 点分十进制记法\n\n机器中存放IP地址是32位二进制代码，8位为一组，转换为十进制数，提高可读性。\n\n![](https://s2.loli.net/2023/07/09/vuxY8jhAZMTrbm3.png)\n\n**※转换：**\n\n为1的位代表的十进制数相加。\n\n![](https://s2.loli.net/2023/07/09/V1OMYrks2JWECLK.png)\n\n**一般不使用的特殊的IP地址：**\n\n| 网络号 | 主机号  | 源地址实验 | 目的地址实验 | 代表的意思                               |\n| ------ | ------- | ---------- | ------------ | ---------------------------------------- |\n| 0      | 0       | 可以       | 不可         | 在本网络上的本主机（6.6节DHCP协议）      |\n| 0      | host-id | 可以       | 不可         | 在本网络上的某台主机host-id              |\n| 全1    | 全1     | 不可       | 可以         | 只在本网络上进行广播（各路由器均不转发） |\n| net-id | 全1     | 不可       | 可以         | 对net-id上的所有主机进行广播             |\n|        |         |            |              |                                          |\n\n![](https://s2.loli.net/2023/07/09/AOFXCgrntybdHJN.png)\n\n调试网络：\n\nping自己，ip没错\n\nping网关，网关没错\n\nping下一跳，没问题再ping下一跳\n\n#### IP地址的重要特点\n\n1. **分等级的地址结构**，两个好处\n   * IP 地址管理机构在分配 IP 地址时**只分配网络号**，由该网络号的单位自行分配剩下的主机号，方便IP地址管理。\n   * 路由器仅根据目的主机所连接的**网络号**来转发分组；使路由器中的项目数大幅减少，从而减小路由表所占的存储空间\n2. 实际上 IP 地址是标志**一个主机（或路由器）**和**一条链路**的**接口。**\n   * 因此，当一个主机连接到两个网络上时，就必须同时具有两个相应的IP地址，这两个网络号必须不同，称为多归属主机。\n   * 一个路由器至少应对连接到两个网络，这样才能将数据报从一个网络转发到另一个，即路由器至少要有两个不同的IP地址。\n3. 用**转发器**或**网桥**连接起来的若干个局域网**仍为一个网络**，因此这些局域网都具有**同样的网络号 net-id**。\n4. 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，**都是平等的**。\n\n### 小结\n\n* IP 地址是一种分等级的地址结构\n* 路由器用于连接不同网络，一个路由器至少有两个网络号不同的IP 地址。\n* 用转发器或网桥连接起来的局域网仍属于一个网络。\n\n* 在同一个网络上的主机或路由器的IP地址中的**网络号必须是一样的**。\n\n\n\n### 4.2.3 IP地址与硬件地址\n\nIP数据报头部是IP地址，MAC帧首部是硬件地址\n\n![](https://s2.loli.net/2023/07/09/Wtn7s2M84xgb6Oq.png)\n\n**在 IP 层抽象的互联网上只能看到 IP 数据报。**\n\n图中的 IP1→IP2 表示从源地址 IP*到目的地址 IP2 。两个路由器的 IP 地址并不出现在 IP 数据报的首部中。路由器只根据目的站的 IP 地址的网络号进行路由选择。**那怎么知道到哪个路由器呢？**\n\n这个时候就需要MAC地址了，**IP 层抽象的互联网屏蔽了下层很复杂的细节。**在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址*研究主机和主机或主机和路由器之间的通信 。**\n\n![](https://s2.loli.net/2023/07/09/H3xyW4R1whNLZKg.png)\n\n### 4.2.4 地址解析协议ARP\n\n* 通信时使用了两个地址\n  * IP地址(网络层地址)\n  * MAC地址(数据链路层地址)---ARP来找\n* 地址解析协议ARP作用就是从网络层使用的IP地址**解析出在数据链路层使用的硬件地址。**\n\nARP 作用：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。\n\n![](https://s2.loli.net/2023/07/09/fVsAjM5cZCbe4n9.png)\n\nARP要点：\n\n* 不管网络层是什么协议，当网络上传输数据帧时还是需要**使用硬件地址的。**\n\n* 每一个主机都设有一个**ARP 高速缓存 (ARP cache)**，里面有所在的局域网上的各主机和路由器的**IP 地址到硬件地址**的**映射表**。\n\n  > <IP address; MAC address; TTL>，TTL(Time To Live):地址映射有效时间\n\n* A向B发IP数据报先查ARP cache有无B的IP地址\n\n  * Yes，就可以查到**硬件地址并写入MAC帧**，通过局域网将MAC帧发往硬件地址\n  * No，ARP进程在本局域网**广播**发送一个**ARP请求分组**，收到响应后，将映射写入ARP cashe\n\n**注意：**\n\n* ARP是解决**同一个局域网**上的主机或路由器的IP地址和硬件地址的映射问题。\n* 如果目的主机不在同一个局域网，则现有ARP找到一个位于本局域网上的**某个路由器的硬件地址**，**将分组发送给路由器进行转发**，剩下的工作由下一个网络来做。\n* 从IP 地址到硬件地址的解析是自动进行，主机用户不知道\n* 只要与已知IP的设备进行通信，ARP协议就会**自动地**将该IP 地址解析为链路层所需要的硬件地址。\n\n#### 为什么我们不直接使用硬件地址进行通信？\n\n* 异构网络，转换复杂：由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。\n* IP编址解决这一问题，统一标准，进行编号：连接到互联网的主机只需各自拥有一个唯一的IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。\n* 因此，在虚拟的IP 网络上用**IP 地址**进行通信给广大的计算机用户带来了很大的方便。\n\n\n\n![](https://s2.loli.net/2023/07/09/jcgl74I8mq5Ahyd.png)\n\n第一个是广播，发送全1地址；发送路由器的MAC地址，让路由器转发分组\n\n![image-20230522093726982](D:\\Blog\\source\\_posts\\计算机网络笔记.assets\\image-20230522093726982.png)\n\n主机1可以访问WWW服务器，但不能访问Internet。\n\n**以太网 数据部分46-1500B 整个帧64-1518B**\n\n#### 小结\n\n* ARP协议的作用：从**IP地址解析出硬件地址**。\n* 每一个主机都设有一个**ARP高速缓存**，用于存放最近获得的IP 地址到MAC 地址的绑定。\n* 当目的主机和源主机**不在同一个局域网时**，通过ARP找到默认网关的硬件地址，然后**由默认网关把分组转发**给下一个网络。\n\n### 4.2.5IP数据报的格式\n\n* 一个 IP 数据报由首部和数据两部分组成。\n\n* 首部的前一部分是固定长度，**共 20 字节**，是所有 IP 数据报必须具有的。\n\n* 在首部的固定部分的后面是一些可选字段，其长度是可变的。\n\n\n\n####  IP 数据报首部的固定部分中的各字段\n\n\n\n![](https://s2.loli.net/2023/07/09/KNXFhwnms1AB6tZ.png)\n\n* 首部前一部分是固定长度，共**20字节**，是所有IP数据报必须具有的\n* 可选字段说明长度是可变\n\n第一行从左到右：\n\n* **版本**——占4 位，指IP 协议的版本。目前的IP 协议版本号为4 (即IPv4)。\n\n* **首部长度**——占4 位，可表示的最大数值是15 个单位(一个单位为4 字节)，因此IP 的首部长度的最大值是60 字节。\n\n* 区分服务，只有使用区分服务才起作用，一般不使用\n\n* **总长度**——占16 位，指**首部和数据之和**的长度，单位为字节，因此数据报的最大长度为**65535 字节**。总长度必须不超过**最大传送单元MTU**。\n\n  > 最大传输单元MTU：一个帧可传输的数据量的上界。\n  >\n  > 数据经MTU先分片，到目的站再重组\n\n第二行从左到右：\n\n* **标识**(identification) ——占16 位，它是一个计数器，用来产生IP 数据报的标识。\n\n* **标志**(flag) ——占3 位，目前只有前两位有意义。MF=1表示后面还有分片，MF=0表示最后一个分片。DF=0时才允许分片\n\n* **片偏移**—— 占13 位，指出：较长的分组在分片后，某片在原分组中的某片**在原分组**中的**相对位置**。片偏移以**8 个字节**为偏移单位。**(除以8)**\n\n* 例子\n\n  ![](https://s2.loli.net/2023/07/09/Y8EpiyvMm5PtboO.png)\n\n  ![](https://s2.loli.net/2023/07/09/8XoukmV2sgQb5pr.png)\n\n  ![](https://s2.loli.net/2023/07/09/Nx1CutzJiscSQmB.png)\n\n第三行从左到右：\n\n* 生存时间——占8 位，记为TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。\n* 协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的IP 层将数据部分上交给那个处理过程\n* 首部检验和——占16 位，**只检验数据报的首部**，不检验数据部分。这里不采用CRC 检验码而采用简单的计算方法。\n\n![](https://s2.loli.net/2023/07/09/Y8EpiyvMm5PtboO.png)\n\n![](https://s2.loli.net/2023/07/09/8XoukmV2sgQb5pr.png)\n\n![](https://s2.loli.net/2023/07/09/Nx1CutzJiscSQmB.png)\n\n#### 死亡之ping\n\nping -l [包尺寸] 目标IP -t\n\nIP包最大65535，而实际规定的最大尺寸并达不到。\n\n一直发大包，分片之后没问题，接收到重组之后就发现超过了尺寸，使得额外数据被写入其他正常区域，造成缓存溢出(**Buffer Overflow**)攻击\n\n解决办法：对超出规定长度的包直接丢掉不重组\n\n\n\n* 生存时间\n* 协议\n* 首部检验和\n  * 并不检验数据，为了减少路由器处理时延，转发分组更快\n  * 缺点，出现差错不能及时发现\n  * 计算距离了解即可\n* 目的地址、源地址\n* 可变部分，从1字节到40字节不等，现在少用，一般都是固定的\n\n#### 练习\n\n一行由8位16进制标识，当有一个IP分组表，每个单元是一个8位16进制，那么源地址就是第四个单元，如c0 a8 00 08-->1100 0000. . . -->192.168.0.8\n\n![](https://s2.loli.net/2023/07/09/Let4H8WYjhxQfEK.png)\n\n![](https://s2.loli.net/2023/07/09/dzI7rXMQH8sRLbu.png)\n\n**【解答】**（1）H主机的IP地址是**192.169.0.8**，**对应的十六进制是c0 a8 00 08**，根据IP分组的源IP地址知道，分组1、3和4是H发送的。\n\n（2）快速以太网数据帧的数据最小长度为46B，当IP分组**总和小于46B时，需要填充。**\n\n根据IP分组的“总长度”字段，5个分组的长度分别为00  30H、00 30H、00 28H、00 38H、00 28H，即：\n\n 第1、2、4个分组大小分别为48B、48B、52B（均大于最小帧长46B），不需要填充；\n\n 第3、5个分组28H**（分组大小为40B）**，因此**需要填充**。\n\n#### 小结\n\n* IP 数据报由**首部**和**数据**组成。\n* 途径MTU较小网络，数据报会被**分片**，到达目的站后再进行**重组**。\n* IP 数据报采用**16 位二进制反码**求和算法检验数据报的首部。\n\n### 4.2.6 **IP 层转发分组的流程**\n\n**在路由表中，对每一条路由，最主要的是**\n\n**（目的网络地址，下一跳地址）**\n\n![](https://s2.loli.net/2023/07/09/ZBeM6culfJEFikV.png)\n\n* 查找路由表\n  * **根据目的网络地址**就能确定下一跳路由器，这样做的结果是：\n    * IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的**间接交付**）。\n    * 只有到达最后一个路由器时，才试图向目的主机进行**直接交付**。\n\n* 特定主机路由\n  * 分组转发基于目的主机所在网络，特例是为特定目的主机指明一个路由\n  * 方便控制和测试\n* 默认路由\n  * 减少路由表占用空间和搜索路由表时间\n  * ![](https://s2.loli.net/2023/07/09/SAkEeX8bNlhUTHy.png)\n\n* 注意\n  * 数据报首部没有指明下一跳路由器的IP\n  * 当路由器接到数据报，是将下一跳地址递交下一层网络接口软件而非填入IP数据报\n  * 网络接口软件使用 ARP 负责将下一跳路由器的IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。\n* 路由器分组转发算法\n  1. 从首部提取**目的主机IP地址D**，得出**目的网络地址N**\n  2. 若直接相连，则**直接交付**目的主机，否则**间接交付**，执行3\n  3. 若有**特定主机路由**，则传送给指明的下一跳路由器，否则执行4\n  4. 若有**到达网络N的路由**，传送，否则5\n  5. 若有**默认路由**，传送给指明的默认路由器，否则6\n  6. 报告转发分组出错\n\n\n\n## ⚠4.3划分子网和构造超网\n\n### 4.3.1划分子网\n\n原因：早期IP地址设计不够合理，利用率低，两级的IP地址不够灵活\n\n解决：在IP地址中增加一个“子网号字段”，从两级IP变成三级IP地址，叫做划分子网\n\n基本思路：\n\n* 划分子网纯属单位内部的事。借助主机位划分子网，对外仍然是一个网络\n* 从主机号再借用若干位作为子网号，因此主机号就相应减少了若干位\n* 从其他网络发来的数据报，仍然根据IP数据包的目的网络号找到本单位网络上的路由器\n* 此路由器再按目的**网络号**和**子网号**找到目的子网\n\n优点：\n\n* 减少了IP 地址的浪费\n* 使网络的组织更加灵活\n* 更便于维护和管理\n\n#### 子网掩码\n\n原因：根据IP数据报首部无法判断目的网络是否进行子网划分\n\n解决：通过子网掩码可以找到IP地址中的子网部分\n\n规则：\n\n* 子网掩码长度＝32位\n* 某位＝1：IP地址中的对应位为网络号和子网号\n* 某位＝0：IP地址中的对应位为主机号\n\n**看例题**\n\n因此无法仅通过首部判断源主机或目的主机所连接的网络是否进行了子网划分。\n\n与运算\n$$\n(IP地址)AND(子网掩码)=网络地址\n$$\n![](https://s2.loli.net/2023/07/09/KXT2njZ9JReU1cE.png)\n\n\n\n借的位数越多，子网越多但是每个子网能带的主机数越少,如何理解借用呢，看下面的例子\n\n![image.png](https://s2.loli.net/2024/05/29/SrsUkdaXuw6nVyI.png)\n\n通过ip地址可以看到是个C类，但是子网掩码不是默认的255.255.255.0而是.224，写出224的2进制，是11100000，前面3个1，借了3位，也就是划分了2<sup>3</sup>个子网，三位二进制有8种组合，每一种组合加上后面全0就对应一个子网号\n\n![image-20230428105145702](D:\\Typora\\images\\image-20230428105145702.png)\n\n**网络地址：192.168.10.0**\n\n**子网掩码：255.255.255.192(/26)** ：192(11000000)说明借了两位产生子网\n\n**1.子网数？ **借了多少位产生多少子网\n\n**2.主机数？**\n\n**3.有效子网？**\n\n**4.广播地址？** 网络段不变(包括借位的部分)，后面全1\n\n**5.有效主机范围是？**\n\n![](https://s2.loli.net/2023/07/09/OUvtdJEs4HlFX9w.png)\n\n![](https://s2.loli.net/2023/07/09/Z9UnDyAmcT1Vr5j.png)\n\n| IP地址类别 | 分段    | 网络号 | 主机号 | 默认子网掩码  |\n| ---------- | ------- | ------ | ------ | ------------- |\n| A          | 0-127   | 8位    | 24位   | 255.0.0.0     |\n| B          | 128-191 | 16位   | 16位   | 255.255.0.0   |\n| C          | 192-223 | 24位   | 8位    | 255.255.255.0 |\n\n\n\n![](https://s2.loli.net/2023/07/09/bUhN129rsGRijfg.png)\n\n### 4.3.2 使用子网时分组的转发\n\n![](https://s2.loli.net/2023/07/09/yovxnePRO7bfhAL.png)\n\n### 4.3.3 无分类编址 CIDR\n\n128.14.32.0/20 网络前缀的**位数**(即网络号)为20，/20地址块\n\n* 例 192.199.170.82/27\n  *  有多少ip地址？一个32位，网络占27，则ip地址有2^5=32\n  *  最大最小地址：看82:(01010010)，最后5位全0则为最小网络号，全1为最大网络号\n  *  CIDR地址块.后5位全0，即最小地址\n  *  子网掩码，令27位全1，后5位全0\n\n#### 路由聚合\n\n![](https://s2.loli.net/2023/07/09/4v3o6hO8XTJb2SP.png)\n\n#### 构成超网\n\n将多个子网聚合成一个较大的子网，构成超网或网络聚合\n\n**方法：将网络前缀缩短所有网络取交集**\n\n206.1.0.0/17\n\n206.1.128.0/17\n\n这两个网络只有前16位相同，因此取交集，网络前缀缩短为16，即206.1.0.0/16\n\n划分子网：从少到多；构成超网：从多变少\n\n#### 最长前缀匹配\n\n使用CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到**不止一个匹配结果**。\n\n使用CIDR时，查找路由表可能得到几个匹配结果(跟网络掩码**按位相与**)，应选择具有最长网络前缀的路由。前缀越长，**地址块越小，路由越具体**。\n\n根据最长前缀匹配，如果匹配成功则**选择网络前缀最长**的，就是目标路由器\n\n解题步骤：\n\n* 先将目的地址和路由表所有项目的子网掩码进行与运算\n\n* 看看结果是否等于路由表的项目IP\n\n* 如果有多个相同的结果，取子网掩码长的\n\n* 例：\n\n  ![](https://s2.loli.net/2023/07/09/C8resPvTSiO7yX6.png)\n\n  ![](https://s2.loli.net/2023/07/09/3tLwgYubH6z2Dlj.png)\n\n  这里就匹配到了两个结果，选择子网掩码最长的，即206.71.128/25，因此下一跳为2\n\n#### 二叉线索法\n\n## 4.4网际控制报文协议ICMP\n\n目的：为了更加**有效转发IP数据报**和提高交付成功的机会\n\n作用：ICMP 允许主机或路由器报**告差错情况**和**提供**有关**异常**情况的报告。\n\n注意：**不是高层协议**，它封装在IP数据报中，作为数据部分，是IP层的协议\n\n![](https://s2.loli.net/2023/07/09/7ZVnztNPhMoE15C.png)\n\n![](https://s2.loli.net/2023/07/09/nuTxl4EYoivc1CF.png)\n\n### 4.4.1ICMP报文的种类\n\n两种：\n\n* ICMP 差错报告报文\n* ICMP 询问报文。\n\n报文格式：\n\n* 前4 个字节统一格式，三个字段：类型、代码和检验和。接着4个字节与ICMP类型有关\n\n#### ICMP 差错报告报文\n\n四种：\n\n* 终点不可达\n* 时间超过\n* 参数问题\n* 改变路由（重定向）(Redirect)\n\n不应发送ICMP 差错报告报文的几种情况\n\n* 对ICMP 差错报告报文不再发送ICMP 差错报告报文。\n* 对第一个分片的数据报片的所有后续数据报片都不发送ICMP 差错报告报文。\n* 对具有多播地址的数据报都不发送ICMP 差错报告报文。\n* 对具有特殊地址（如127.0.0.0 或0.0.0.0）的数\n  据报不发送ICMP 差错报告报文。\n\n#### ICMP 询问报文\n\n* 回送请求和回答报文\n* 时间戳请求和回答报文\n\n### 4.4.2ICMP的应用距离\n\n#### PING(Packet InterNet Groper)\n\n* PING用来测试两个主机之间的连通性\n* PING使用了**ICMP 回送请求**与**回送回答**报文。\n* PING是应用层**直接使用网络层ICMP** 的例子，它没有通过运输层的TCP 或UDP。\n\n#### Traceroute\n\n* Windows中命令是tracert\n* 用来跟踪一个分组从源点到终点的路径\n* 它利用IP 数据报中的TTL 字段和ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。\n\n### 小结\n\n* ICMP用于主机或路由器报告差错情况和提供有关异常情况的报告\n* ICMP报文包括ICMP差错报告报文和ICMP询问报文两种\n* ICMP应用：PING、Traceroute\n\n## 4.5互联网的路由选择协议\n\n### 4.5.1有关路由选择协议的几个基本概念\n\n| 路由算法         | 路由选择         | 优点                       | 缺点                             |\n| ---------------- | ---------------- | -------------------------- | -------------------------------- |\n| 静态路由选择策略 | 非自适应路由选择 | 简单和开销较小             | 但不能及时适应网络状态的变化     |\n| 动态路由选择策略 | 自适应路由选择   | 能较好地适应网络状态的变化 | 实现起来较为复杂，开销也比较大。 |\n\n#### 分层次的路由选择协议\n\n互联网采用分层次的路由选择协议，原因：\n\n* 互联网的规模非常大，为了节省路由表空间，同时避免通信链路饱和\n* 单位不想让外界了解自己的网络\n\n自治系统AS：\n\n* 在单一的技术管理下的一组路由器，使用AS内部的**路由选择协议**和**共同的度量**来确定其中的路由，还使用AS之间的路由选择协议来确定分组在AS之间的路由。\n* 尽管一个AS 使用了多种内部路由选择协议和度量，一个AS 对其他AS 表现出的是一个**单一的和一致**的路由选择策略。\n\n#### 互联网有两大类路由选择协议\n\n* 内部网关协议IGP (Interior Gateway Protocol)\n  * 在一个**自治系统内部使用**的路由选择协议。\n  * 这类使用的最多，如RIP和OSPF\n* 外部网关协议EGP (External Gateway Protocol)\n  * 源站和目的站不在一个自治系统，数据报传到自治系统边界就要用一种协议将路由选择信息传递进另一个自治系统，这个系欸就是EGP。\n  * 使用最多的是BGP-4\n\n![](https://s2.loli.net/2023/07/09/anNqrygvJ62xCRb.png)\n\n> 自治系统之间路由选择叫域间路由选择，内部路由选择叫做域内路由选择。\n\n路由器和网关可以当作同义词\n\n#### 小结\n\n* 路由选择包括**静态**和**动态**两种路由选择策略。\n* 一个**自治系统**表现出一致的路由选择策略。\n* 根据是在自治系统内部使用，还是在自治系统之间使用，路由选择协议可以分为**内部网关协议IGP**和**外部网关协议EGP**。\n\n### 4.5.2RIP内部网关协议\n\n* 内部网关协议IGP中最先得到广泛使用协议\n* 一种**分布式的、基于距离向量的路由选择协议**\n* RIP 协议要求网络中的每一个路由器都要维护**从它自己到其他每一个目的网络的距离记录**。\n\n**距离(指最短距离)：**\n\n* 路由器到直连网络距离定义为1\n* 到非直连的距离定义为所经过的路由器数加1\n* 也成为跳数，经过一个路由器跳数加1\n* 好的路由就是经过路由器数目少，即**距离短**\n* RIP允许一条路径最多**只能包含15个路由器**，加上自己就是16，**16跳就表示不可达，**因此只适用于小型网络\n* RIP**不能使用多条路由**，这导致它永远选最短的那条，哪怕另外还有一条低时延的路由\n\n把“下一跳”字段中的地址都改为X，并把所有的“距离”字段的值**加1**\n\n#### 特点\n\n* 仅和**相邻路由器**交换信息。\n* 交换自己的**路由表**。\n* 按固定的时间间隔**交换路由信息**\n\n\n\n查看错题\n\n* 若下一跳字段给出的路由器地址**相同**，则把收到的项目**替换源**路由表项目。\n\n* 如果收到项目中的距离小于路由表中的距离，则进行更新\n\n  \n\n#### RIP2报文\n\n存在划分子网情况要用version2\n\nRIP2 具有简单的鉴别功能\n\n#### 小结\n\n* 使用跳数判断到其他网络的距离。\n* **周期性**地和**相邻路由器**交换**自己的路由表**。\n* RIP能使用的最大距离为**15跳**(16不可达)，适用于小型网络。\n* RIP好消息传播得快，**坏消息传播得慢**(信息一直不匹配，要不断更新，直到超过15)，导致更新过程**收敛时间过长**。\n\n### OSPF内部网关协议\n\n采用分布式的链路状态协议(link stateprotocol)。\n\n* 邻居表\n\n  邻居路由器的信息\n\n* 拓扑表\n\n  也叫链**路状态数据库（LSDB）**，同区域中所有路由器的LSDB信息必须保持一致。\n\n* 路由表\n\n  到达目标网络的最佳路径\n\n链路状态数据库(拓扑表)\n\n* “链路状态”即本路由器和哪些路由器**相邻**，以及该链路的**度量**\n* 所有路由器最终建立**一个链路状态数据库**，全网的拓扑结构图，它在全网范围内是一致的(同步)\n* 能较快地更新，收敛快是其重要优点\n\nOSPF区域 (area)\n\n* OSPF用于规模大地网络，将一个自治系统再划分为若干个更小的范围即区域\n* 每个区域有32位的区域标识符(点分十进制表示)\n* 区域最好不超过200个\n\n#### 划分区域\n\n* 主干区域，全0\n* 常规区域，非0\n\n好处：\n\n* 利用洪泛法**交换链路状态信息的范围**局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。\n\n* 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。\n\n* OSPF 使用**层次结构的区域划分**。在上层的区域叫作**主干区域**(backbone area)。\n\n* 主干区域的标识符规定为0.0.0.0。主干区域的**作用**是用来连通其他在下层的区域。\n\nOSPF 不用UDP 而是直接用IP 数据报传送，数据报短，不必分片，但只要丢失一个就得整个重传\n\n支持可变长度的子网划分和无分类编址CIDR。\n\nOSPF五种分组类型：\n\n* 类型1，问候(Hello) 分组。\n* 类型2，数据库描述(Database Description) 分组。\n* 类型3，链路状态请求(Link State Request) 分组。\n* 类型4，链路状态更新(Link State Update) 分组，用洪泛法对全网更新链路状态。\n* 类型5，链路状态确认(Link State Acknowledgment)\n  分组。\n\n\n\n* 与RIP比较\n  * 每隔一段时间，如30 分钟，要刷新一次数据库中的链路状态。\n  * 当互联网规模很大时，OSPF协议要比距离向量协议RIP 好得多。\n  * OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于100 ms。\n\n#### 小结\n\n* 包括**邻居表、拓扑表（链路状态数据库）、路由表。**\n* 链路状态数据库在**全网范围内一致（同步）**\n* OSPF的**更新过程收敛速度快**。\n* 将一个自治系统划分为若干个**区域**，区域内部的路由器**只需要知道本区域**的网络拓扑。\n* 区域包括**主干区域**和**常规区域**两种。\n* 通过**洪泛**发送更新分组。\n\n### *4.5.4BGP外部网关协议\n\n### *4.5.5路由器的构成\n\n## 4.6 IPV6\n\n### 4.6.1 IPv6的基本首部\n\n![](https://s2.loli.net/2023/07/09/rDPdFVS6lxOkNp5.png)\n\n* 主要变化：\n  * 更大的地址空间，从IPv4 的32 位增大到了128 位。\n  * 扩展的地址层次结构。\n  * 灵活的首部格式。IPv6 定义了许多可选的扩展首部。\n  * 改进的选项。\n  * 允许协议继续扩充。\n  * 支持即插即用（即自动配置）。因此IPv6 不需要使\n    用DHCP。\n  * 支持资源的预分配\n  * IPv6 首部改为8 字节对齐。首部长度必须是8 字节的整数倍。原来的IPv4 首部是4 字节对齐。\n* 扩展首部\n  * Pv6 把原来IPv4 首部中选项的功能都放在扩展首部中\n  * 数据报途中经过的路由器**都不处理**这些扩展首部（只有一个首部例外，即逐跳选项扩展首部）。\n  * 这样就大大提高了路由器的处理效率\n\n### 4.6.2 IPv6的地址\n\n* 目的地址可以是以下三种基本类型地址之一\n  * 单播，点对点\n  * 多播，一点对多点\n  * 任播，目的是一组计算机，数据包交付时只交付其中一个，通常为距离最近的一个\n\n#### 冒分十六进制\n\n* 允许**零压缩**，即一连串连续的零可以为一对冒号所取代。例如FF05:0:0:0:0:0:0:B3 可压缩为：FF05::B3\n* 注意：在任一地址中只能使用一次零压缩。\n* CIDR 的斜线表示法仍然可用。\n\n### 4.6.3 从IPv4向IPv6过渡\n\n* 两种策略\n  * 使用双协议栈，网络地址转换/协议转换技术NAT-PT\n  * 使用隧道技术，把IPv6 数据报封装成为IPv4 数据报，整个的IPv6 数据报变成了IPv4 数据报的数据部分。离开IPv4 网络中的隧道时，再把数据部分（即原来的IPv6 数据报）交给主机的IPv6 协议栈。\n\n![](https://s2.loli.net/2023/07/09/W4ThVUGZPdmMfDt.png)\n\n### *4.6.4 ICMPv6\n\n## 4.8 虚拟专用网VPN和网络地址转换NAT\n\n### 4.8.1 虚拟专用网VPN\n\n原因：IP地址紧缺，对于机构内部可以自行分配IP地址。\n\n然而很容易有本地地址和全球地址相同的情况，造成二义性，因此需要作出规定。\n\n* 三个专用IP 地址块：\n\n(1) 10.0.0.0 到10.255.255.255，即10开头\n\nA类，或记为10.0.0.0/8，它又称为24位块\n\n(2) 172.16.0.0 到172.31.255.255，即172.16-172.31\n\nB类，或记为172.16.0.0/12，它又称为20位块\n\n(3) 192.168.0.0 到192.168.255.255，即192.168开头\n\nC类，或记为192.168.0.0/16，它又称为16位块\n\n这类地址不需要申请，直接可以使用，仅在本机构内部使用，不能出公网\n\n#### 虚拟专用网\n\n一般专用网就是专线直接相连使用专用IP地址，然而直接用线路连成本过高，对大部分机构不实际\n\n需要“虚拟”，利用公用的互联网作为本机构各专用网之间的通信载体。表示“好像是”，但实际上并不是，因为现在并没有真正使用通信专线，而VPN只是在效果上和真正的专用网一样。\n\n\n\n![](https://s2.loli.net/2023/07/09/UPzHEjO1MFKcl4X.png)\n\n#### 远程接入VPN\n\n* 远程接入VPN (remote access VPN)可以满足**外部流动员工**访问公司网络的需求。\n\n#### 小结\n\n* 专用地址只能用作本地地址，互联网中的路由器不转发目的地址为专用地址的数据报。\n\n* 采用专用IP 地址的互连网络称为专用网。\n\n* 虚拟专用网VPN利用公用的互联网作为本机构各专用网之间的通信载体。\n\n* 使用隧道技术实现VPN。\n\n### 4.8.2 网络地址转换NAT\n\n问题：在专用网上使用专用地址的主机如何与互联网上的主机通信（并不需要加密）？\n\n* 申请全球IP地址\n* 采用网络地址转换NAT\n\n装有NAT 软件的路由器叫作NAT路由器，它至少有一个有效的外部全球IP地址。\n\n所有使用本地地址的主机在和外界通信时，都要在NAT 路由器上**将其本地地址转换成全球IP地址**，才能和互联网连接。\n\n优点\n\n* 避免重新编址\n* 节约全局地址使用\n* 不直接使用全局地址，在互联网上不直接可见，增加了安全性\n\nNAT三种类型\n\n* 静态，每个主机被**永久映射**成外部网络中的某个合法的地址。-一对一\n* 动态，定义了**一系列合法地址**，利用**动态分配**进行映射。-一对一\n* 重载(PAT)，把内部地址映射到外部网络**一个IP地址的不同端口(port)**上。-多对一\n\n## *4.9 多协议标记交换MPLS\n\n### 本章总结 \n\n* ⭐网络层提供的两种服务:面向连接(虚电路)、**无连接(数据报)**\n* ⭐网络互联设备：**集线器、交换机、路由器、多层交换机**\n* ⭐**两级的IP 地址结构：网络号、主机号**\n* IP 地址的点分十进制记法\n* ⭐IP 地址的分类：**A类、B类、C类**、D类、E类\n* ⭐**IP 地址与硬件地址的区别**\n* ⭐**ARP协议的作用、工作原理**（如何知道硬件地址）\n* IP 数据报的格式 大题\n* ⭐**路由器分组转发算法**\n* ⭐**划分子网的基本思路、优点 计算题**\n* 子网掩码\n* ⭐使用子网时**分组的转发**\n* CIDR的特点\n* ⭐**最长前缀匹配**\n* 使用二叉线索查找路由表\n* ⭐**ICMP 作用**、ICMP报文的格式、种类、**ICMP应用**\n* 路由选择协议: 内部网关协议、外部网关协议\n* ⭐**RIP、OSPF协议的特点**\n* IPv6的基本首部、IPv6的地址、IPv4向IPv6的过渡\n* VPN、NAT的作用、特点\n* ⭐**专用IP 地址块**\n\n> 每一点都有关联，理清关系，为什么要有这样的协议/技术，解决何种问题\n\n# 5传输层\n\n**运输层在协议栈中的地位**\n\nØ 从通信和信息处理角度，运输层为上面的应用层提供通信服务，是面向通信部分的最高层和用户功能的最底层。端到端通信时，只有主机协议栈才有运输车，而路由器在转发分组时都只用到下三层。\n\nØ 从网络层来说，IP协议虽然能把分组送到目的主机，但是分组还停留在主机的网络层，没有交付主机的应用程序。然而真正的通信实体是主机间的进程。所以还需要运输层完成交付。\n\nØ 从运输层来看，通信真正的端点并不是主机，而是主机的进程，即端到端的通信是应用进程之间的通信。同时，运输层还有复用、分用的功能，还要对收到的报文进行差错检测。\n\nØ 因此运输层在协议栈中非常重要，必不可少\n\n**运输层和网络层的重要区别：**\n\n|                 | ***运输层\\***              | ***网络层\\***          |\n| --------------- | -------------------------- | ---------------------- |\n| ***位置\\***     | 七层网络结构的第四层       | 七层网络结构的第三层   |\n| ***重要区别\\*** | 提供应用进程之间的逻辑通信 | 提供主机之间的逻辑通信 |\n| ***服务协议\\*** | UDP、TCP                   | IP协议                 |\n\n## 5.1 运输层协议概述\n\n### 5.1.1 进程之间的通信\n\n路由器工作在下三层。不单只是主机之间通信，还得提供**应用进程**的通信\n\n![](https://s2.loli.net/2023/07/09/lgOurvG5VwEbIKA.png)\n\n复用和分用功能\n\n![](https://s2.loli.net/2023/07/09/mc1MwCp9JqotyHZ.png)\n\n#### 两大类端口\n\n(1) 服务器端使用的端口号\n\n* **熟知端口**，数值一般为**0~1023**。\n* **登记端口号**，数值为**1024~49151**，为没有熟知端口号的应\n  用程序使用的。使用这个范围的端口号必须在IANA 登记，\n  以防止重复。\n\n(2) 客户端使用的端口号\n\n* **又称为短暂端口号**，数值为**49152~65535**，留给客户进程选\n  择暂时使用。\n* 当服务器进程收到客户进程的报文时，就知道了客户进程所\n  使用的动态端口号。通信结束后，这个端口号可供其他客户\n  进程以后使用。\n\n#### 常用的熟知端口--记忆\n\n![](https://s2.loli.net/2023/07/09/gHRKy9zX7JOtM5A.png)\n\nhttp协议明文传输，抓包就能看到具体信息，而https在http基础上加上Secure Sockets Layer安全套接层，加密\n\n### 5.1.2 运输层的两个主要协议\n\n(1) 用户数据报协议 UDP (User Datagram Protocol)\n\n(2) 传输控制协议 TCP (Transmission Control)\n\n#### TCP与UDP 表格\n\n* UDP：一种无连接协议\n  * 提供无连接服务。\n  * 在传送数据之前**不需要先建立连接**。\n  * 传送的**数据单位协议**是**UDP 报文**或**用户数据报**。\n  * 对方的运输层在收到UDP 报文后，不需要给出任何确认。\n  * 虽然 **UDP 不提供可靠交付**，但在某些情况下UDP是一种最有效的工作方式。\n* TCP：一种面向连接的协议\n  * 提供**面向连接**的服务。\n  * 传送的数据单位协议是**TCP 报文段**(segment)。\n  * **TCP 不提供广播或多播服务。**\n  * 由于TCP 要**提供可靠的、面向连接的运输服务**，因\n    此不可避免地增加了许多的开销。这不仅使协议数\n    据单元的首部增大很多，还要占用许多的处理机资\n    源。\n\n## 5.2 用户数据报协议UDP\n\n在IP数据报服务增加了：\n\n* 复用和分用的功能\n* 差错检测的功能\n\n#### UDP主要特点\n\n* 无连接\n* 尽最大努力交付\n* 面向报文\n* 没有拥塞控制\n* 支持一对一、一对多、多对一和多对多\n* 首部开销小，只有8字节，而TCP有20字节\n\n#### 检验和\n\n\\1.   检验和字段置零，UDP用户数据报凑够偶数字节；\n\n\\2.   把所有位（UDP伪首部+UDP首部+UDP数据部分）按16位划分为不同的字；\n\n\\3.   计算上述所有16位字的和，如果有进位导致总位数超过16位，则把进位值加到末位；\n\n\\4.   将上述计算的和取反即为UDP用户数据报的检验和。\n\n#### UDP的应用\n\n* 对传输协议的可靠性要求不高，需要传送的数据不多，使用频率不高。如：DNS服务(域名映射IP)、DHCP服务、SNMP服务等。\n* 实时应用，如：IP电话、视频会议、QQ等。\n\n#### IP、ICMP、UDP、TCP报文首部检验和字段\n\n校验和算法一样，但作用范围不同。\n\n* IP校验和只校验IP数据报的首部；\n* ICMP校验和覆盖整个ICMP报文(首部+数据)；\n* UDP和TCP校验和不仅覆盖整个报文，而且还有12\n  个字节的伪首部。\n\n## 5.3 传输控制协议TCP 概述\n\n### 5.3.1 TCP 最主要的特点\n\n* 面向连接\n* 只有两个端点\n* 点对点\n* 可靠交付\n* 全双工\n* 面向字节流\n\n5.3.2TCP的连接\n\n* TCP 连接的端点叫做**套接字(socket)** 或插口。\n\n* 端口号+IP地址构成套接字\n\n套接字socket = (IP地址: 端口号)\n\nTCP 连接::= {socket1, socket2}== {(IP1: port1)，(IP2: port2)}\n\n\n\n## 5.4可靠传输的工作原理\n\n### 5.4.1 停止等待协议\n\n理想的传输条件有以下两个特点：\n\n(1)传输信道**不产生差错**。\n\n(2) 不管发送方以多快的速度发送数据，接收方总是**来得及处理**收到的数据。\n\n* 每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。\n\n* 全双工通信的双方既是发送方也是接收方。\n\n1.无差错情况\n\n发完暂停，等待确认，收到确认后，再发送\n\n2.出现差错\n\n传输过程丢失/接收时出错\n\n解决办法：超时重传\n\n3.确认丢失和确认迟到\n\n* 确认丢失\n\n此A 在**超时计时器**到期后就要**重传**M1\n\nB接收到后可以1丢弃M1 2向A发送确认\n\n* 确认重传\n\nB 对分组M1 的确认迟到\n\nA 会收到重复的确认后丢弃\n\nB 仍然会收到重复的M，丢弃重复的M1，并重传确认分组\n\n![](https://s2.loli.net/2023/07/09/pVMHaGbQcdZSPux.png)\n\n**注意**\n\n* 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发\n* 分组和确认分组都必须进行编号。\n* 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发\n\n4信道利用率\n\n停止等待协议的优点是简单，缺点是信道利用率太低。\n\n### 5.4.2 连续ARQ 协议\n\n连续ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前**滑动一个分组**的位置。\n\n![](https://s2.loli.net/2023/07/09/OINACmrnEJTuHWB.png)\n\n#### 累计确认\n\n不必对分组逐个发送确认，对到达的最后一个分组发送确认，表示之前的所有我都收到了\n\n优：容易实现，即使确认丢失也不必重传。\n\n？缺：不能向发送方反映出接收方已经正确收到的所有分组的信息。\n\n#### Go-back-N（回退N）\n\nGo-back-N（回退N），表示需要再退回来重传已发送过的N 个分组。\n\n比如A发的前5个分组是12345，B收到1245，由于3开始不联系，B只确认2(即2以前都收到)，A不知道后三个分组下落超时后重传\n\n\n\nTCP 连接的每一端都必须设有两个窗口——一个**发送窗口**和一个接**收窗口**。\n\n#### 小结\n\n* 流水线传输允许发送方连续发送多个分组，而不需要等待对方的确认，从而提高信道利用率。\n\n* 位于发送窗口内的分组可连续发送出去。\n* 发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置\n* 接收方采用累积确认的方式对按序到达的最后\n  一个分组发送确认。\n\n\n\n## 5.5TCP 报文段的首部格式\n\n面向字节流，传送的数据单元却是报文段。\n\n![](https://s2.loli.net/2023/07/09/FSuVDcPkohBpa8Z.png)\n\n❗源端口和目的端口字段——各占2 字节：端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。\n\n❗序号字段——占4 字节：数据流每个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的**第一个字节的序号**\n\n❗确认号字段——占4 字节：期望收到对方的**下一个报文段的数据的第一个字节**的序号。 比如发的1234，确认号字段就是5\n\n\n\n⭐序号确认号\n\n![](https://s2.loli.net/2023/07/09/GYQApSb5XJPuhnE.png)\n\n\n\n![](https://s2.loli.net/2023/07/09/eEPzRwSKkXbQUA9.png)\n\n![](https://s2.loli.net/2023/07/09/Ldb8a9EnXloqG26.png)\n\n数据偏移（即首部长度）——占4 位，它指出TCP 报文段的数据起始处距离TCP 报文段的起始处有多远。“数据偏移”的单位是32 位（以**4 字节**为计算单位）。\n\n保留字段——占6 位 目前为0\n\n紧急URG —— 当URG = 1 时，表明**紧急指针**字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于**高优先级**的数据)。\n\n❗确认ACK —— 只有当**ACK = 1 时确认号字段才有效**。当ACK = 0 时，确认号无效。\n\n推送PSH (PuSH) —— 接收TCP 收到PSH = 1 的报文段，就**尽快地交付**接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n\n复位RST (ReSeT) —— 当RST  1 时，表明TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再**重新建立运输连接**。\n\n❗同步SYN —— 同步SYN = 1 表示这是一个连接请求或连接接受报文。\n\n❗终止FIN (FINish) —— 用来释放一个连接。FIN = 1 表明此报文段的**发送端的数据已发送完毕**，并要求**释放运输连接**。\n\n❗窗口字段—— 占2 字节，窗口字段用来控制对方发送的数据量，单位为字节。TCP 连接的一端**根据设置的缓存空间大小确定自己的接收窗口大小**，然后通知对方以**确定对方的发送窗口的上限**。\n\n> 窗口字段指出了现在允许对方发送的数据量。窗口值是经常在动态变化的。\n>\n> 如：设确认号是701，窗口字段是1000。这就表明，从701号算起，发送此报文段的一方还有1000个字节数据（字节序号是701-1700）的接收缓存空间。\n\n检验和(和IP类似)—— 占2 字节。检验和字段检验的范围包括**首部和数据**这两部分。在计算检验和时，要在TCP 报文段的前面加上12 字\n节的伪首部。\n\n紧急指针字段—— 占16 位 指出紧急数据多少字节 紧急数据放在本报文段**数据的最前面**\n\n选项字段—— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度MSS(Maximum Segment Size，TCP报文段长度减去首部长度)\n\n填充字段:使整个首部长度是4字节的整数倍\n\n### 小结\n\n* TCP的每条连接都有发送序号和确认号。\n* 序号字段是本报文段所发送的数据的第一个字节的序号。\n* 确认号字段是期望收到对方的下一个报文段的数据的第一个字节的序号。\n* TCP 连接的一端根据缓存空间大小确定自己的窗口大小，利用窗口字段控制对方发送的数据量。\n\n## 5.6 TCP 可靠传输的实现\n\nTCP 的滑动窗口是以字节为单位的。\n\n* 根据B 给出的**窗口值**，A 构造出自己的发送窗口。\n* 发送窗口表示：在没有收到B 的确认的情况下，A 可以**连续把窗口**内的数据都发送出去。\n* 发送窗口里面的序号表示**允许发送的序号**\n* 显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。\n\n#### 小结\n\nTCP连接的一端根据另一端给出的窗口值构造\n自己的发送窗口。\n TCP连接的一端可以连续把发送窗口内的数据\n都发送出去，而不需要等待对方的确认。\n 收到新的确认号，发送窗口向前滑动。\n\n### 5.6.2 超时重传时间的选择\n\n**重传时间的选择是TCP 最复杂的问题之一。**\n\n![](https://s2.loli.net/2023/07/09/Z73TyxQvr81aIng.png)\n\n**TCP 采用了一种自适应算法**它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT。\n\n![](https://s2.loli.net/2023/07/09/yX12DH5ZT6cRfum.png)\n\n慢慢更新平均往返更新\n\n通过加权平均往返时间RTTs计算**超时重传时间RTO**\n\n![](https://s2.loli.net/2023/07/09/fFd9UeWvzQc6VJY.png)\n\n### 5.6.3 选择确认SACK\n\n缺少部分只发送缺少的不全部重传\n\nTCP 的接收方在接收对方发送过来的数据字节流的序号不连续，结果就形成了一些不连续的字节块。\n\n如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在TCP 报文段的首部中都增加了SACK 选项，以便**报告收到的不连续的字节块的边界**。\n\n#### 小结\n\n* TCP 采用**自适应算法**计算报文段的往返时间\n  RTT。\n* 超时重传时间RTO**略大于**往返时间RTT。\n\n\n\n## 5.7TCP的流量控制\n\n### 5.7.1利用滑动窗口实现流量控制\n\n* 流量控制(flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。\n\n方法：滑动窗口机制\n\n\n\n![](https://s2.loli.net/2023/07/09/6SxcYyeQFVk1H8A.png)\n\n可能发生的问题：互相等待的死锁\n\n方法：持续计时器\n\n#### 持续计时器\n\n只要TCP 连接的一方收到对方的零窗口通知（举例的最后一条），就启动该持续计时器。\n\n若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。\n\n若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。\n\n若窗口不是零，则死锁的僵局就可以打破了。\n\n## 5.8 TCP 的拥塞控制\n\n### 5.8.1 拥塞控制的一般原理\n\n某资源需求超过了提供的可用部分，网络性能变坏，发生拥塞\n\n拥塞问题很复杂\n\n![](https://s2.loli.net/2023/07/09/ysg6Pt1EQCGLblw.png)\n\n#### 开环控制和闭环控制\n\n* 开环控制\n* 闭环控制\n\n### 5.8.2 TCP 的拥塞控制方法\n\nTCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。\n\n#### 拥塞判断\n\n重传定时器超时：超时\n\n收到三个相同（重复）的ACK：丢包\n\n#### TCP拥塞控制算法\n\n| 拥塞控制算法 | 含义                                                         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 慢开始       | 由小到大逐渐增大拥塞窗口数值                                 | 防止拥塞窗口增长过大引起网络拥塞                             |\n| 拥塞避免     | 每经过一个往返时间就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长 | 加法增大的特点，按线性规律缓慢增长比慢开始算法的增长速率缓慢很多 |\n| 快重传       | 首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即时收到了失序的报文段也要立即发出对已收到的报文段的重复确认。 | 让发送方尽早知道发生了个别报文段的缺失。发送方只要一连收到三个重复确认，就知道接收方确实没有收到，应当立即重传，因此不会出现超时，发送方也不会误认为出现了网络拥塞 |\n| 快恢复       | 发送方收到三次确认可以认为网络没有发送拥塞，不执行慢开始而执行快恢复，新的拥塞窗口等于当前拥塞窗口的一半，并执行拥塞避免算法进行缓慢线性增长 | 提高网络传输效率，提升吞吐量                                 |\n\n\n\n**慢开始(slow-start)**\n\n算法的思路：由小到大逐渐增大拥塞窗口数值。\n\n发1，收1\n\n发2，收2\n\n发4，收4\n\n发8，收8\n\n指数级增长\n\n![](https://s2.loli.net/2023/07/09/hjuLDso74NgeRY9.png)\n\n\n\n**拥塞避免(congestion avoidance)**\n\n避免办法：设定阈值，超过后下一轮只加1。当计时器超时(拥塞)，将阈值改为一半，重新进行慢开始\n\n![](https://s2.loli.net/2023/07/09/Qq7PRsbBZ4S2vIg.png)\n\n**快重传(fast retransmit)**\n\n3-ACK确认，发送方改为执行快重传和快恢复算法。\n\n发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。\n\n不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。\n\n**快恢复(fast recovery)**\n\n由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法\n\n可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI(Additive Increase)。\n\n当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的**一半**，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD(Multiplicative Decrease)\n\n**乘法减小和加法增大**\n\n|          | 用途                                                         |\n| -------- | ------------------------------------------------------------ |\n| 乘法减小 | 当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。当网络频繁出现拥塞时，门限值就下降得很快，以大大减少注入到网络中的分组数 |\n| 加法增大 | 在拥塞避免阶段，拥塞窗口是按照线性规律增大的，例如在收到对所有报文段得确认后(即经过一个往返时间)，就把拥塞窗口增加一个MSS大小，使拥塞窗口缓慢增大，防止网络过早出现拥塞。 |\n\n**小结**\n\n* 对网络资源的需求超过了可用资源，网络就会\n  出现拥塞。\n* TCP 采用基于窗口的方法进行拥塞控制。\n* 拥塞窗口的大小取决于网络的拥塞程度。\n* 发送窗口大小取决于接收方公告的窗口和拥塞窗口。\n\n后面的跳过了\n\n### 5.9 TCP 的运输连接管理\n\n### 5.9.1 TCP 的连接建立\n\nTCP 建立连接的过程叫做握手。握手需要在客户和服务器之间交换三个TCP 报文段。称之为三报文握手。\n\n防止失效又突然传送到了，产生错误\n\n1SYN→\n\n2←SYN+ACK\n\n3ACK→\n\nSYN=1说明TCP进行确认，确认包ACK=1，ack的值是收到的seq+1\n\n![](https://s2.loli.net/2023/07/09/8RbK23pQO74mGFz.png)\n\n![](https://s2.loli.net/2023/07/09/f9CPk18DlFL4qXE.png)\n\n**练习**\n\n![](https://s2.loli.net/2023/07/09/A83rSCbiIpyuhtf.png)\n\n![](https://s2.loli.net/2023/07/09/upCVhtfyoDTQAOi.png)\n\n### 5.9.2 TCP 的连接释放\n\n* 数据传输结束后，通信的双方都可释放连接。\n* TCP 连接释放过程是四报文握手。\n\n### 总结\n\n* 掌握运输层的端口的概念及作用；\n* 掌握UDP、TCP的特点；\n* 可靠传输：停止等待协议, 连续ARQ 协议；\n* 了解UDP、TCP 的首部格式**(源端口、目的端口、序号、确认号、窗口)；**\n* 掌握TCP **可靠传输、流量控制、拥塞控制的实现；**\n* 掌握TCP 的**连接建立、连接释放**的过程。\n* \n\n**TCP 连接处于 FIN-WAIT-1 状态。以下的事件相继发生：**\n\n（1）收到 ACK 报文段\n\n（2）收到 FIN 报文段\n\n（3）发生了超时\n\n在每一个事件之后，连接的状态是什么？在每一个事件之后发生的动作是什么？\n\n(1) FIN-WAIT2 等待接收方发送连接释放报文\n\n(2) close-wait 进入关闭等待状态半连接\n\n(3) FIN-WAIT1 重传连接释放报文\n\n# 第6章应用层\n\n## 6.1 域名系统DNS\n\n### 6.1.1 域名系统概述\n\nIP地址不便记忆\n\n管理域名的系统就是DNS (Domain Name System) 。\n\n### 6.1.2 互联网的域名结构\n\n互联网采用了层次树状结构的命名方法。\n 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。\n 域名的结构由标号序列组成，各标号之间用点隔开：\n\n各标号分别代表不同级别的域名。\n\n域名只是个逻辑概念，并不代表计算机所在的物理地点。\n\n### 6.1.3 域名服务器\n\n 一个服务器所负责管辖的（或有权限的）范围\n叫做**区(zone)**。\n 每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到IP地址的映射。\n\n#### 四种类型\n\n根域名服务器\n\n顶级域名服务器\n\n权限域名服务器\n\n本地域名服务器\n\n## 6.2 FTP\n\n#### 特点\n\n使用TCP\n\n主要功能：减少不同操作系统处理文件不兼容性\n\n使用客户服务器方式。服务器进程由一个主进程负责接受新的请求和若干从属进程负责处理单个请求。\n\n#### 两个连接\n\n21端口控制连接\n\n20端口数据连接\n\n## *6.3远程终端协议TELNET\n\n本节了解即可\n\n用户用TELNET 就可在其所在地通过TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或IP 地址）。\n\n用户感觉到好像键盘和显示器是直接连在远地主机上。\n\n## 6.4万维网www\n\n### 概述\n\n万维网是一个大规模的、联机式的信息储藏所。并非某种特殊的计算机网络。\n\n#### 工作方式\n\n以客户-服务器方式工作\n\n浏览器就是在用户计算机上的万维网**客户程序**\n\n万维网文档所驻留的计算机则运行**服务器程序**，\n\n客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的**万维网文档**。\n在一个客户程序主窗口上显示出的万维网文档称为**页面(page)**。\n\n#### 解决的问题\n\n（1）怎样标志分布在整个互联网上的万维网文档？\n使用URL统一资源定位符，唯一标识\n\n![](https://s2.loli.net/2023/07/09/WADCSdK9JUN4rQ2.png)\n\n输入URL：\n\n解析域名-建立tcp连接-http请求报文--http响应报文--释放TCP连接\n\n![](https://s2.loli.net/2023/07/09/7pzaB6Y5jwrG9Vu.png)\n\n#### 代理服务器\n\n使用高速缓存可减少访问互联网服务器的时延\n\n### 6.4.4万维网的文档 了解\n\n超文本标记语言HTML\n\n### 6.4.5 万维网的信息检索系统 了解\n\n### 6.4.6 博客和微博  了解\n\n\n\n### 小结\n\n* 万维网是一个大规模的、联机式的**信息储藏所**；\n* 万维网用**链接**的方法从互联网上的一个站点访问另一个站点；\n* 万维网以**客户服务器**方式工作；\n* 万维网使用**URL** 来标志文档；\n* 万维网使用**HTTP协议**在客户程序与服务器程序之间进行交互；\n* 万维网使用**HTML语言**令页面显示出来；\n* 可以使用**搜索引擎**在万维网上查找信息。\n\n## 6.5电子邮件\n\n发件人调用PC 中的用户代理撰写和编辑要发\n送的邮件。\n\n发件人的用户代理把邮件用**SMTP 协议**发给发送方邮件服务器，\n\nSMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。\n\n发送方邮件服务器的SMTP 客户与接收方邮件服务器的SMTP 服务器建立TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。\n\n### 6.5.2 简单邮件传送协议SMTP\n\n使用**客户服务器**方式\n\n#### SMTP通信的三个阶段\n\n1. **连接建立**：连接是在发送主机的SMTP 客户和接收主机的SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。\n2. **邮件传送**\n3. **连接释放**：邮件发送完毕后，SMTP 应释放\n   TCP 连接\n\n### 6.5.4 邮件读取协议POP3 和IMAP\n\n非常简单、但功能有限的邮件读取协议，现在使用的是它的第三个版本POP3。\n\nPOP 也使用客户-服务器的工作方式。\n\n缺陷：读取完就在服务器删掉了\n\n#### IMAP 协议\n\n客户服务器，IMAP 是一个联机协议\n\n需要的时候才传到用户计算机，附件可以先不下载，存在服务器，节省资源\n\n### 6.5.5 基于万维网的电子邮件\n\n 电子邮件从A 发送到网易邮件服务器**使用HTTP 协议**。\n 两个邮件服务器之间的传送使用**SMTP**。\n 邮件从新浪邮件服务器传送到B 是使用**HTTP 协议**。\n\n> 万维网电子邮件的好处：只要能够找到上网的计算机，打开任何一种浏览器就可以非常方便地收发电子邮件。\n\n![](https://s2.loli.net/2023/07/09/hr8XmjIZlqsVFWa.png)\n\n### 6.5.6 通用互联网邮件扩充MIME\n\n受限于ASCII，无法传输\n\n![](https://s2.loli.net/2023/07/09/7NI14VChzauGLvp.png)\n\n### 错题\n\n![](https://s2.loli.net/2023/07/09/j3V7EKaGOmRFlke.png)\n\n## 6.6 动态主机配置协议DHCP\n\n互联网广泛使用的动态主机配置协议DHCP提供了**即插即用连网**的机制\n\n#### 客户-服务器方式\n\n需要IP 地址的主机在启动时就向DHCP 服务器**广播发送**发现报文（DHCPDISCOVER），这时该主机就成为DHCP 客户。\n\nDHCP 服务器先在其数据库中**查找**该计算机的**配置信息**。若找到，则返回找到的信息。若找不到，则从服务器的IP 地址池(address pool)中取一个地址**分配给该计算机**。DHCP 服务器的回答报文叫做提供报文（DHCPOFFER）。\n\n#### DHCP 中继代理(relay agent)\n\n原因：使得DHCP 服务器的数量太多。代理它配置了DHCP 服务器的IP 地址信息。\n\n方法：当DHCP 中继代理收到主机发送的发现报文后，就以**单播**方式向DHCP 服务器转发此报文，并等待其回答。收到DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。\n\n![](https://s2.loli.net/2023/07/09/ElcWOy3pi5oFTLv.png)\n\n","tags":["笔记"],"categories":["本科课程"]},{"title":"Android Studio降雨热力图","url":"/2023/06/08/Android-Studio降雨热力图/","content":"\n\n\n![image-20230608163650808](D:\\Typora\\images\\image-20230608163650808.png)\n\n# 基础配置\n\n## AndroidManifest.xml\n\n配置定位服务和百度地图key\n\n```xml\n<!-- 百度地图定位服务-->\n<service android:name=\"com.baidu.location.f\" \n         android:enabled=\"true\" \n         android:process=\":remote\">\n</service>\n<!--百度地图配置key-->\n<meta-data\n         android:name=\"com.baidu.lbsapi.API_KEY\"\n         android:value=\"填写百度地图key\" />\n```\n\n加权限\n\n```xml\n    <!-- 访问网络，进行地图相关业务数据请求，包括地图数据，路线规划，POI检索等 -->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <!-- 获取网络状态，根据网络状态切换进行数据请求网络转换 -->\n    <uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n\n    <!-- 读取外置存储。如果开发者使用了so动态加载功能并且把so文件放在了外置存储区域，则需要申请该权限，否则不需要 -->\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <!-- 写外置存储。如果开发者使用了离线地图，并且数据写在外置存储区域，则需要申请该权限 -->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />\n\n    <!-- 这个权限用于进行网络定位-->\n    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"></uses-permission>\n    <!-- 这个权限用于访问系统接口提供的卫星定位信息-->\n    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"></uses-permission>\n    <!-- 用于访问wifi网络信息，wifi信息会用于进行网络定位-->\n    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"></uses-permission>\n\n    <!-- 这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位-->\n    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"></uses-permission>\n<!--读取手机状态-->\n    <uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/>\n```\n\n## 下载sdk\n\n放到jinLibs下\n\n![image-20230608162854413](D:\\Typora\\images\\image-20230608162854413.png)\n\n## build.gradle\n\n添加\n\n```gradle\nandroid {\n\t...\n\tdefaultConfig {\n\t\tndk {\n            // 设置支持的SO库架构（开发者可以根据需要，选择一个或多个平台的so）\n            abiFilters \"armeabi\", \"armeabi-v7a\", \"arm64-v8a\", \"x86\",\"x86_64\"\n        }\n\t}\n\t...\n\t//百度地图api用\n    sourceSets {\n        main {\n            jniLibs.srcDir 'libs'\n        }\n    }\n\n}\ndependencies {\n\t...\n\t implementation 'com.squareup.okhttp3:okhttp:4.8.1' //http请求\n    implementation 'com.google.code.gson:gson:2.8.8' //GSON解析JSON\n    implementation files('libs\\\\BaiduLBS_Android.jar') //百度地图sdk\n}//导入了sdk就不用导入其他的百度地图以来了了，sdk基本都包含了，否则会发生冲突\n```\n\n\n\n# 生成地图\n\n## 初始化\n\n调整缩放\n\n```kotlin\n//地图初始化\nprivate fun initloc() {\n    //定位初始化\n    mLocationClient = LocationClient(requireActivity())\n    //通过LocationClientOption设置LocationClient相关参数\n    val option = LocationClientOption()\n    option.isOpenGps = true // 打开gps\n    option.setCoorType(\"bd09ll\") // 设置坐标类型\n    option.setScanSpan(1000)\n    option.setAddrType(\"all\")\n    option.setIsNeedAddress(true) // 可选，设置是否需要地址信息，默认不需要\n    option.setIsNeedLocationDescribe(true) // 可选，设置是否需要地址描述\n    //设置locationClientOption\n    mLocationClient!!.locOption = option\n    //注册LocationListener监听器\n    val myLocationListener = MyLocationListener() \t\n    mLocationClient!!.registerLocationListener(myLocationListener)\n    //设置缩放\n    //缩放级别\n    val builder = MapStatus.Builder()\n    builder.zoom(8.0f)\n    mBaiduMap?.setMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()))\n    //开启地图定位图层\n    mLocationClient!!.start()\n    //设置当前视图位置\n    mBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间\n}\n\n//定位监听器\ninner class MyLocationListener : BDAbstractLocationListener() {\n    override fun onReceiveLocation(location: BDLocation) {\n        //mapView 销毁后不在处理新接收的位置\n        if (location == null || mMapView == null) {\n            return\n        }\n        val locData = MyLocationData.Builder()\n        .accuracy(location.radius) // 此处设置开发者获取到的方向信息，顺时针0-360\n        .direction(location.direction).latitude(location.latitude)\n        .longitude(location.longitude).build()\n        mBaiduMap?.setMyLocationData(locData)\n    }\n}\n```\n\n\n\n```kotlin\n//地图初始化\nprivate fun initloc() {\n    //定位初始化\n    mLocationClient = LocationClient(requireActivity())\n    //通过LocationClientOption设置LocationClient相关参数\n    val option = LocationClientOption()\n    option.isOpenGps = true // 打开gps\n    option.setCoorType(\"bd09ll\") // 设置坐标类型\n    option.setScanSpan(1000)\n    option.setAddrType(\"all\")\n    option.setIsNeedAddress(true) // 可选，设置是否需要地址信息，默认不需要\n    option.setIsNeedLocationDescribe(true) // 可选，设置是否需要地址描述\n    //设置locationClientOption\n    mLocationClient!!.locOption = option\n    //注册LocationListener监听器\n    val myLocationListener = MyLocationListener() \t\n    mLocationClient!!.registerLocationListener(myLocationListener)\n    //设置缩放\n    //缩放级别\n    val builder = MapStatus.Builder()\n    builder.zoom(8.0f)\n    mBaiduMap?.setMapStatus(MapStatusUpdateFactory.newMapStatus(builder.build()))\n    //开启地图定位图层\n    mLocationClient!!.start()\n    //设置当前视图位置\n    mBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间\n}\n\n//定位监听器\ninner class MyLocationListener : BDAbstractLocationListener() {\n    override fun onReceiveLocation(location: BDLocation) {\n        //mapView 销毁后不在处理新接收的位置\n        if (location == null || mMapView == null) {\n            return\n        }\n        val locData = MyLocationData.Builder()\n        .accuracy(location.radius) // 此处设置开发者获取到的方向信息，顺时针0-360\n        .direction(location.direction).latitude(location.latitude)\n        .longitude(location.longitude).build()\n        mBaiduMap?.setMyLocationData(locData)\n    }\n}\n```\n\n\n\n```\n\n```\n\n\n\n## 显示定位\n\n监听器，获取当前位置，根据定位数据设置状态\n\n```kotlin\ninner class MyLocationListener : BDAbstractLocationListener() {\n    override fun onReceiveLocation(location: BDLocation) {\n        ...\n        //获取经纬度 并保留两位小数''\n        preLatitude = String.format(\"%.2f\", location.latitude).toDouble()\n        preLongitude = String.format(\"%.2f\", location.longitude).toDouble()\n\n        //获取当前地址\n        preAddress = location.addrStr\n\n        //保证经纬度\n        val ll = LatLng(location.latitude, location.longitude)\n        //设置位置状态\n        preStatus = MapStatusUpdateFactory.newLatLng(ll)\n    }\n}\n```\n\n动画方式回到定位位置\n\n```kotlin\n//点击按钮回到当前位置\nval setStatusBtn = binding.setStatusBtn\nsetStatusBtn.setOnClickListener {\n\t//设置当前视图位置\n\tmBaiduMap?.animateMapStatus(preStatus) //动画的方式到中间\n}\n```\n\n\n\n# 获取降雨数据\n\n## 组建城市列表\n\n预设几个城市，生成地图步骤获取当前位置的经纬度数据\n\n```kotlin\nprivate fun getRainData() {\n    thread {\n        //城市列表\n        val cities = listOf(\n            Pair(preLatitude, preLongitude),//当前位置\n            Pair(39.90, 116.41),  // 北京\n            Pair(31.23, 121.47),  // 上海\n            ...\n        ) // 假设要查询的城市经纬度列表\n\n    }\n}\n```\n\n\n\n## 准备类和取数据方法\n\n查看和风天气实例数据结构和属性，构建类\n\n观察[逐小时天气预报](https://dev.qweather.com/docs/api/weather/weather-hourly-forecast/)返回数据，我们需要的是hourly里的pop数据，并希望把24小时的数据组成一个列表。\n\n```json\n{\n  \"code\": \"200\",\n  \"updateTime\": \"2021-02-16T13:35+08:00\",\n  \"fxLink\": \"http://hfx.link/2ax1\",\n  \"hourly\": [\n    {\n      \"fxTime\": \"2021-02-16T15:00+08:00\",\n      \"temp\": \"2\",\n      \"icon\": \"100\",\n      \"text\": \"晴\",\n      \"wind360\": \"335\",\n      \"windDir\": \"西北风\",\n      \"windScale\": \"3-4\",\n      \"windSpeed\": \"20\",\n      \"humidity\": \"11\",\n      \"pop\": \"0\",\n      \"precip\": \"0.0\",\n      \"pressure\": \"1025\",\n      \"cloud\": \"0\",\n      \"dew\": \"-25\"\n    },\n...\n```\n\n因此我们需要先准备好类来接收数据，并准备读取pop列表的方法。并设置方法，提取需要的数据属性。\n\n```kotlin\n//接收api逐小时数据hourly类\ndata class HourlyData(\n    val fxTime: String,\n    val temp: String,\n    val icon: String,\n    val text: String,\n    val wind360: String,\n    val windDir: String,\n    val windScale: String,\n    val windSpeed: String,\n    val humidity: String,\n    val pop: String,\n    val precip: String,\n    val pressure: String,\n    val cloud: String,\n    val dew: String\n)\n\n//获取降雨概率方法\nclass CityRainProbability(private val hourlyData: List<HourlyData>) {\n    //降雨概率\n    fun getHourlyPop(): List<Double> {\n        return hourlyData.map { it.pop.toDouble() }\n    }\n}\n```\n\n\n\n## 调用API组成降雨数据\n\n遍历列表，解析读取JSON\n\n在`getRainData()`中补充，遍历城市列表，请求解析完数据后，构造成`city`类，并存入城市降雨列表`citiesRain`中\n\n```kotlin\n//获取每个城市降雨数据，先放入citiesRain中\nfor (city in cities) {\n    val location = city.second.toString() + \",\" + city.first.toString()\n    println(location)\n    val url = \"https://devapi.qweather.com/v7/weather/24h?location=$location&key=$key\"\n    println(url)\n    readJSONData(url, city)\n}\n```\n\ncity类，包含了经纬度信息和24小时降雨概率列表\n\n```kotlin\n//城市名称，降雨概率\ndata class City(\n    val latLng: LatLng,\n    val hourlyProbabilities: List<Double>?\n)\n```\n\n\n\n实例化类，获取降雨数据\n\n主要分为两步，首先请求数据 ，然后解析数据。\n\n```kotlin\n//请求数据\nprivate fun readJSONData(url: String, city: Pair<Double, Double>) {\n    thread {\n        try {\n            val client = OkHttpClient()\n            val request = Request.Builder().url(url).build()\n            val response = client.newCall(request).execute()\n            val responseData = response.body?.string()\n            if (responseData != null) {\n                dealRainData(responseData, city)\n                Log.d(\"responseData\", responseData)\n                //                  println(responseData)\n            }\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n\n//提取降雨数据\nprivate fun dealRainData(JsData: String, city: Pair<Double, Double>) {\n    val gson = Gson()\n    val cityData = gson.fromJson(JsData, JsonObject::class.java)\n    val hourlyData =\n    gson.fromJson(cityData.getAsJsonArray(\"hourly\"), Array<HourlyData>::class.java).toList()\n    val City = CityRainProbability(hourlyData)\n    hourlyPop = City.getHourlyPop()// 获取到一个城市24小时天气数据\n    val hourlyRainProb = hourlyPop?.toList()\n    val thiscity = City(LatLng(city.first, city.second), hourlyRainProb) //单个城市降雨数据\n    citiesRain.add(thiscity) //插入城市降雨数据列表\n}\n```\n\n组成降雨数据citiesRain，是一个City类的列表\n\n```kotlin\nprivate val citiesRain = mutableListOf<City>()//城市降雨数据\n```\n\n\n\n# 显示热力图和信息窗\n\n## 热力图\n\n### 帧数据\n\n构建24帧数据\n\n提取城市列表每个城市经纬度和当前小时的降雨概率组成代表当前小时的帧数据，**降雨概率作为权重**\n\n```kotlin\nprivate fun showheat() {\n    // 创建热力图数据\n    val builder = HeatMap.Builder()\n    // 添加热力图数据点\n    //构造24帧数据\n    val frames = MutableList(24) { mutableListOf<WeightedLatLng>() }\n    // 遍历每个城市\n    citiesRain.forEach { city ->\n       val hourProbabilities = city.hourlyProbabilities\n       // 遍历每个小时的降雨概率\n        hourProbabilities?.forEachIndexed { index, probability ->\n           val weightedLatLng = WeightedLatLng(city.latLng, probability)\n           frames[index].add(weightedLatLng)\n        }\n     }\n    builder.weightedDatas(frames)\n\n}\n```\n\n\n\n### 配置热力图\n\n设置帧变化动画属性，热力图半径，渐变颜色，透明度\n\n热力图权值范围0-100\n\n添加热力图覆盖物\n\n```kotlin\nprivate fun showheat(){\n    // 设置开始动画属性：开启初始动画，时长100毫秒，动画缓动函数类型为线性\n    val init = HeatMapAnimation(true, 100, HeatMapAnimation.AnimationType.Linear)\n    // 设置帧动画属性：开启帧动画，时长10000毫秒，动画缓动函数类型为线性\n    val frame = HeatMapAnimation(true, 10000, HeatMapAnimation.AnimationType.Linear)\n    builder.initAnimation(init)\n    builder.frameAnimation(frame)\n    // 设置热力图半径范围\n    builder.radius(35)\n    // 设置热力图渐变颜色\n    val colors = intArrayOf(\n        Color.rgb(255, 0, 0), Color.rgb(0, 225, 0), Color.rgb(0, 0, 200)\n    )\n    builder.gradient(Gradient(colors, floatArrayOf(0.2f, 0.5f, 1.0f)))\n    builder.maxIntensity(100.0f)\n    builder.opacity(0.8)\n    val heatMapData = builder.build()\n    Log.d(\"showHeat\", \"添加覆盖物\")\n    // 添加热力图覆盖物\n    mBaiduMap?.addHeatMap(heatMapData)\n    mBaiduMap?.startHeatMapFrameAnimation()\n}\n```\n\n## 进度条\n\n进度条\n\n```xml\n<ProgressBar\n\tandroid:id=\"@+id/determinateBar\"\n\tstyle=\"?android:attr/progressBarStyleHorizontal\"\n\tandroid:layout_width=\"match_parent\"\n\tandroid:layout_height=\"wrap_content\"\n\tandroid:max=\"24\"\n\tandroid:progress=\"1\"/>\n```\n\n回调动态热力图帧索引，给进度条赋值，让进度条提示当前是第几帧(小时)的热力图\n\n```kotlin\nval progressText = binding.progressText //进度条提示文字\n// 回调动态热力图帧索引\nmBaiduMap?.setOnHeatMapDrawFrameCallBack { indexCallBack -> // 更新进度条和帧数\n\tprogressBar.progress = indexCallBack\n\t//                Log.d(\"帧数\",indexCallBack.toString())\n\tprogressText.text = \"$indexCallBack 小时后\"\n}\n```\n\n\n\n## 信息窗\n\n遍历降雨数据找最大值，记录索引和最值\n\n```kotlin\n    //计算当前位置最大降雨概率\n    private fun countRainpro() {\n        val preCity = citiesRain.firstOrNull()\n        maxRainIndex = -1\n        maxRainValue = Double.MIN_VALUE\n\n        preCity?.let { city ->\n            val attributeList = city.hourlyProbabilities\n\n            if (attributeList != null) {\n                for ((index, value) in attributeList.withIndex()) {\n                    if (value > maxRainValue) {\n                        maxRainValue = value\n                        maxRainIndex = index\n                    }\n                }\n            }\n        }\n    }\n```\n\n设置信息窗内容和位置\n\n```kotlin\n            if (maxRainValue == 0.0) {\n                //24小时内不会下雨\n                messageBtn.text = \"$preAddress \\n24小时内不会下雨\"//信息窗显示当前地址\n\n            } else {\n                var rat = maxRainValue.toInt()\n                messageBtn.text = \"$preAddress \\n $maxRainIndex 小时后有$rat %概率会下雨\"\n            }\n            //构造InfoWindow\n            //point 描述的位置点\n            //-100 InfoWindow相对于point在y轴的偏移量\n            mInfoWindow = InfoWindow(messageBtn, LatLng(preLatitude, preLongitude), -100)\n```\n\n监听器中使InfoWindow生效，这样子就能满足当移动地图时，信息窗能够保持在初始位置，不会乱飞。\n\n```kotlin\ninner class MyLocationListener : BDAbstractLocationListener() {\n        override fun onReceiveLocation(location: BDLocation) {\n            ...\n            //实时更新信息窗位置\n            if (mInfoWindow != null) {\n                mBaiduMap?.showInfoWindow(mInfoWindow)\n            }\n        }\n}\n```\n\n\n\n# 遇到的问题\n\n## 无法在模拟器显示\n\n进行真机调试，数据线连接安卓手机，手机开启usb调试，修改编辑器运行设备为手机\n\n## 异步问题\n\n协程方法/用按钮\n","categories":["编程"]},{"title":"脑电笔记","url":"/2023/04/01/脑电笔记/","content":"\n# s实验常用评估指标\n\n![image-20231018192044991](C:\\Users\\chan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20231018192044991.png)\n\n# 背景\n\n**静息态脑电**一般在频域进行分析，以刻画信号的周期性特征\n\n需要使用频谱分析来描述脑电信号功率沿频率的分布特征。\n\n**任务态脑电** 通常采用时频分析——时间-频率域中分析\n\n事件相关的频谱变化被称为事件相关同步化/去同步化(ERS/ERD)，通常在时间-频率域中随时间变化的频谱功率可以通过时频分析方法进行估计\n\n## 频谱估计基本概念\n\n### 时间序列信号\n\n在某通道连续记录的脑电信号，在时间域表征为信号幅度相对于时间的变化；也可以在频率域表征为信号功率沿评论变化的分布\n\n### 频率\n\n描述振荡波形在单位时间内周期获得的基本参数，单位为赫兹(Hz),即每秒一个周期\n\n### 频谱\n\n时序信号的功率、幅度或相位等在频率域沿频率的分布曲线\n\n### 频谱分析\n\n将时域信号变换到频域频谱的估计方法，目的是观察对应周期的频率峰值以检测信号周期性\n\n## 频域和时域\n\n频域和时域是信号处理中两个重要的概念。\n\n时域是指信号在时间轴上的变化，即信号在时间上的波形表现。时域分析可以用来研究信号的幅度、频率、相位等特征，例如我们可以通过时域分析来计算信号的均值、方差、峰值、波形形状等。\n\n频域是指信号在频率轴上的变化，即信号在频率上的分量组成。频域分析可以用来研究**信号的频率、谐波、相位等特**征，例如我们可以通过频域分析来计算信号的功率谱密度、频率分布、滤波等。\n\n在脑电信号分析中，时域和频域分析常常是同时使用的，可以用来研究不同的脑电波形态、频率特征以及它们之间的相互作用关系。例如，我们可以通过时域分析来计算脑电信号的平均值、方差、峰值等，而通过频域分析则可以计算脑电信号在不同频段的能量分布、频率成分等。\n\n## 频谱图和波形图\n\n频谱图和波形图是两种不同的图像展示方式，分别用于展示信号在频域和时域的特征。\n\n波形图是一种**时域**表示方法，它将信号的振幅与时间轴关联起来，用于显示信号在时间上的变化情况，通常为一条连续的曲线。波形图可以直观地反映信号的幅度、频率、相位等时域特征。\n\n频谱图是一种**频域**表示方法，它将信号的振幅与频率轴关联起来，用于显示信号**在不同频率下的分布情况**，通常为一张二维图像。频谱图可以直观地反映信号的频率成分、频率分布情况等频域特征。\n\n在脑电信号处理中，频谱图和波形图都有广泛的应用。例如，可以通过分析脑电信号的频谱图来研究脑电信号的频率成分和频率分布情况，进一步研究脑电信号的生理意义；而波形图则可以用于显示不同条件下脑电信号的时域变化情况，例如事件相关电位（ERP）的波形图可以直观地反映某个事件对脑电信号的影响。\n\n## ssvep\n\nSSVEP 本质是当人的眼受到外界的周期的视觉刺激时，大脑皮层枕区就会\n周期性的相应\n\n交叉调制频率刺激会引起大脑皮层的周期性脑电活动，通过分析由刺激引起的脑电信号，可以识别刺激目标。根据人眼中不同椎体细胞对颜色反应不同，蓝光最强、绿光次之，红光最弱。\n\n其中刺激信号的幅值和诱发的SSVEP信号成正比、刺激范式的频率5~12Hz所激发的 SSVEP 最强，同时随着刺激信号的频率的增加，所激发的 SSVEP 信号幅值逐渐下降。但是占空比对 SSVEP 信号的诱发规律，还不清楚。\n\n# 信号处理\n\n\n\n# P300\n\n## p300+ssvep 潘老师\n\n### P300 SD\n\n当系统开始字符输入时，每个字符以随机的次序依次闪烁60毫秒\n\n即在某个字符闪烁结束的一段时间后，才开始闪烁下一个字符，而不是同一行（或列）的字符同时闪烁。一个round包含36次闪烁，对应36个字符。每次输出一个字符，受试者只需要注视该目标字符并默数其闪烁的次数。因此，在每个round中，目标字符的闪烁概率为1/36，即0.028。在**若干个round后，系统通过检测P300就能确定目标字符**。\n\n对于SD字符输入系统，每个字符的输入需要10个round的闪烁，每个round包含36次闪烁，因此需要21.6秒（10 × 36 × 60𝑚𝑠）。每输入一个字符后都休息4秒\n\n其中，根据国际10-20系统的标准[66]，本章只采用视觉区“Fz”、“Cz”、“P3”、“Pz”、“P4”、 “O1”、 “Oz”与“O2”这8个通道的脑电信号。\n\n所有电极的阻抗值皆为5𝐾Ω以下。脑电信号以250Hz的频率采样，首先在**0.1至30Hz**的范围内进行带通滤波，然后对滤波后的信号进行1/5下采样。对应每个闪烁刺激，我们取每个通道中刺激开始的0-600毫秒的这一段数据，再将8个通道中处理后的数据连接成一个特征向量。\n\n对于每位受试者，我们把所有特征向量都进行归一化化到0到1之间。这些归一化的特征向量将作为SVM分类器的输入[67]。\n\n### SSVEP\n\n我们选择4个闪烁的刺激频率5.45Hz，6.0Hz，6.67Hz和7.5Hz。这是因为（1）在5-20Hz范围内的刺激频率能更稳定地激发SSVEP[95]；（2）如果刺激频率在8-13Hz范围内，当受试者处在空闲状态时，SSVEP检测将容易受到alpha节律的影响[91]；（3）与屏幕分辨率（60Hz）成倍数关系的闪烁刺激频率（如6.0Hz或7.5Hz等）在硬件上能更准确地产生\n\n根据实时采集的信号进行SSVEP检测，**每隔500毫秒**进行一次检测。首先，在**3Hz至20Hz**的范围内进行带通滤波。然后，我们选取6个所选通道中当前时间点的前3.2秒数据段进行SSVEP检测。因此，每两次连续的SSVEP检测中包含有**2.7秒的数据是重叠**的。(3.2-0.5)\n\n使用傅立叶变换，我们计算新定义的𝑁个信号向量的功率密度谱（Power densityspectrum，PSD）。\n\n控制状态下，受试者注视着以频率𝑓闪烁的目标键，并忽视其他闪烁频率的伪键。在这种情况下，绝大部分受试者会产生以下两种生理现象：第一，有一个**明显的波峰**出现在目标键闪烁频率的功率密度谱中。第二，在所有闪烁频率中，目标键的闪烁频率所产生的SSVEP能量**最大**。因此，我们在SSVEP检测中利用了下列的2个准则：\n\n* 阈值准则: 能量比率𝛿要大于一个预设的阈值。该准则已经普遍应用于SSVEP的研究，例如[83, 90]。\n* 比较准则：目标键频率的SSVEP能量 ^𝑃 (𝑓𝑡) 在所有的闪烁频率中是最大的。\n\n当这2个准则同时满足，则表示系统检测到目标键产生的SSVEP。在这个时候，系统处于控制状态中，即发出“开/关”的控制指令。\n\n#### 实验\n\n每一个实验Session包含两个Run\n\n第一个Run用于设置GUI中目标键的刺激频率，因为不同的受试者在不同刺激频率下产生SSVEP电位的幅度是不一样的[97]，第一个Run包含32个trial，共需要6分钟的时间。在每个trial中，受试者需要注视GUI中的一个闪烁按钮10秒钟（由屏幕中的箭头来指示）。在32个trial中，4个闪烁按钮的次序由系统随机产生的，每个闪烁按钮将被标示8次。响应最大的设为目标键，其他是伪键\n\n### p300+ssvep\n\n本实验只采用“Fz”、“Cz”、“P7”、“P3”、“Pz”、“P4”、“P8”、“O1”、\n“Oz”与“O2”这10个通道的脑电信号。所有电极的阻抗值皆为5𝐾Ω以下。脑电信号以**250Hz**的频率采样，并在**0.1至30Hz**的范围内进行带通滤波。\n\n四组按钮中的四个大按钮分别以随机的顺序闪烁（形状变为方形，颜色变为绿色），每两次闪烁之间包含100ms的增强和100ms的间隔。因此，一个round包含四个大按钮的闪烁，共需要持续800ms（一个round被定义为每个大按钮闪烁一次的完整周期）\n\n![image-20230402145312464](D:\\Typora\\images\\image-20230402145312464.png)\n\n也就是小圈跟大圈固定频率黑到红闪，每隔100ms有一个随机的增强，即大按钮变为绿色方形，持续100ms\n\n#### 检测\n\nP300检测是**每800毫秒**(1round)进行一次，对应一轮所有按钮组的闪烁\n\nssvep检测是每200毫秒进行一次,我们选取8个通道中当前时间点的**前3.2秒数据单元（3.2X250Hz，800数据点）进行SSVEP检测。**\n\n#### **实验**\n\n8位来自本实验室的20～33岁的健康受试者参加了3个实验，包括1个离\n线实验和2个在线实验。在实验之前，每位受试者参加一个包括30个trial的Session，采用如图4-2所示的GUI进行P300模型的训练。特别地，在每一个trial中，所有4组按钮中的大按钮以随机次序闪烁，每个大按钮闪烁10次。同一时刻，受试者要求注视着给定的目标按钮。收集的数据用于构建一个P300分类模型，用于后面3个实验。\n\n进行3个Session，每 一个Session由80个trial组成\n\n![image-20230402145429594](D:\\Typora\\images\\image-20230402145429594.png)\n\n# P300+ssvep 薛仲林\n\nP300 电位检测：首先将采集 P300 信号进行带通滤波，其中通带频率为 0.1− 10Hz，然后进行 200 降采样，即每 5 个数据点选 1 个。提取每个导联的在脑电范式刺激范式后800毫秒的P300脑电数据，将8个导联脑电数据归一限制到[-1,1]之内，将 8 个导联脑电数据归一化数据特征向量，组成一个脑电数据特征向量矩阵。 \n\n每个被试人员均进行 6 次实验，一次实验输入 5 个目标字符，共输入字符30 个。在每两次实验之后被试人员休息 2 分钟，其中每次实验定义为一个 session，每输入一个目标字符为一个 run，每一个字符闪烁为trial，其中包含受试人员目标字符定义为一个 target，不包含受试人员的目标字符为 nontargat。此外依次从左到右定义行列闪烁 trail 编号为 1~36，共 36trial。1~36 号 trail 有且仅有一个target，35 个nontargat。36 个 trail 随机闪烁一次为一个 sequence。15 个sequence为一个 run，完成一个字符输入如下图 2.9 所示。\n\n![image-20230402153653507](D:\\Typora\\images\\image-20230402153653507.png)\n\n## p300+ssvep\n\n为了将SSVEP频带与P300频带分离，以0.2Hz的步长选择12个高于12Hz的闪烁频率，从12.4到14.6Hz。根据 [35]，可以通过模拟方法对40个频率 (范围从8hz到15.8Hz，步长为0.2Hz) 的任何刺激相位的ssvep进行模拟，其中涵盖了该实验的所有刺激频率。因此，通过使用具有200ms的刺激持续时间的模拟方法在公共SSVEP数据集上搜索JFPM方法的相位间隔 (从0到0.05 π) 来优化初始相位，从而在两个相邻频率之间产生0.35 π 的相位间隔。\n\n# 传统方法\n\n## SSVEP\n\n### TRCA提取任务相关成分\n\n虽然基于CCA的方法在识别SSVEP信号方面具有不错的表现,但这类方法的性能仍旧**易受到自发脑电活动的干扰的影响**。除此之外,研究人员们考虑到基于CCA的方法还有一个很大的问题,即**没有利用到相位信息**(参考信号中正余弦中没有包含相位项)。那么如果能够有效地利用相位信息,想必会给SSVEP的识别性能带来较大的提升。\n\n由此研究人员便提出了TRCA方法,TRCA的方法即通过最大化每个task中神经影像数据的**复现性**(reproducibility),提取任务相关成分(task-related com-ponents)。对于SSVEP这种锁时(time-locked)信号,该方法非常合适,因为在SSVEP中可以最大化多个trial之间的可再现性,提高SNR(Signal-to-Noise),抑制自发脑电活动。\n\n\n[(279条消息) 提取任务相关成分的TRCA算法_Ethan Hunt丶的博客-CSDN博客](https://blog.csdn.net/weixin_43715601/article/details/120575420)\n\n在离线实验中，受试者进行模拟在线实验以记录数据以进行离线分析。实验由12个块组成。在每个块中，要求受试者凝视视觉刺激之一**0.5 s**，并完成对应于**所有40个刺激的40个试验**。每次试验都以刺激程序产生的指示目标刺激的视觉提示 (红色方块) 开始。提示在屏幕上出现了0.5秒。指示每个受试者在提示持续时间内尽快将视线转移到目标上。此后，所有刺激在监视器上同时闪烁0.5 s。为了减少眼球运动伪影，要求受试者在刺激期间避免眨眼。为了避免视觉乏力，在两个连续的block之间休息了几分钟。首先根据事件触发提取包含**九通道**ssvep的数据时期。将所有数据阶段下**采样到250Hz，然后用IIR滤波器从7 hz到90Hz进行带通滤波。**使用MATLAB中的filtfilt() 函数实现了零相位正向和反向滤波。考虑到视觉路径中的潜伏期延迟，**在 [0.14 s] 中提取数据时期**，其中时间0表示刺激开始，并且在离线分析中使用了数据长度。\n\n训练阶段包括12个区块，每个区块包括40个试验。在此阶段获取的数据在测试阶段用作单独的训练数据。提示引导选择任务的测试阶段包括**5个块**，每个块还包括**40个试验**。每个试验**持续0.8 s**，包括0.3 s用于视觉刺激和0.5 s用于视线转移。下一个目标的提示出现在刺激偏移之后。实时向受试者提供视觉和听觉反馈。在线分析程序正确识别目标后，发出一声短促的哔哔声。同时，在屏幕顶部的文本输入字段中键入目标字符。\n\n一个多通道的EEG信号由任务相关性成分si和任务无关的信号ni组成，任务相关部分在trial之间保持着不变性，而任务无关部分在trial之间是变化的。si之间的协方差为一正常数,si与ni之间的协方差为0\n\n我们希望能够提取到任务相关成分s(t)，以增大信噪比。\n\n首先将多通道的EEG信号加权求和，表示为一个线性模型y(t)，为了使得y(t)==s(t)，就必须使每个通道相关成分的加权求和结果为1，无关成分加权求和结果为0。如果我们得到了这样的一个解，那么多通道的**EEG信号经过线性加权求和**后，便能够得到在多个trial之间具有高度相关性的*y*(*t*)。\n\n原本trial(颜色片段)之间变化较大的N通道EEG信号，经过处理后得到的y ( t ) y*(*t*)在trial之间相关性较高。空间滤波器表示为W=[W1,W2,..]，上述这一过程表示为**Y=W<sup>T</sup>X**，X表示原本trials各通道的信号x<sub>i</sub>(t)\n\n![空间滤波器](https://img-blog.csdnimg.cn/20200418225702674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjc2NTcwMw==,size_16,color_FFFFFF,t_70)\n\n于是，问题的重点就来到了如何求解出空间滤波器W，这里给出了两种方法，分别是：\n\n* 协方差最大化(CovMax)\n* 相关性最大化(CorrMax)\n\n**相关性最大化CorrMax**\n\n通过皮尔逊相关系数，求解来自**k-th trial**和来自**I-th trial**的EEG信号xk(t)和xl(t)相关性，然后找到所有trial可能的组合中使相关系数之和最大的解，然而这种结果只是一个相关性成分，不是封闭解，也就是说不能求出问题的解，因此需要用最大化trial之间的协方差\n\n**协方差最大化CovMax**\n\n和CorrMax不同的仅是将trial之间相关系数的求解变为计算**协方差矩阵**\n\n多个trial之间的协方差之和为目标函数\n$$\n\\sum_{k,l=1,k≠l}^K{\\hat{c}_{kl}=}\\sum_{k,l=1,k≠l}^K{Cov\\left( y^{\\left( k \\right)}\\left( t \\right) ,y^{\\left( l \\right)}\\left( t \\right) \\right) =}\\sum_{k,l=1,k≠l}^K{\\sum_{i,j=1}^N{w_iw_jCov\\left( x_{i}^{\\left( k \\right)}\\left( t \\right) ,x_{j}^{\\left( k \\right)}\\left( t \\right) \\right) =w^TSw}}\n$$\n$$\n\\text{其中,对称矩阵}S_{ij}=\\sum_{k,l=1,k≠l}^K{Cov\\left( x_{i}^{\\left( k \\right)}\\left( t \\right) ,x_{j}^{\\left( l \\right)}\\left( t \\right) \\right)}\n$$\n\n为了获得有限解，我们使y(t)的方差进行约束，归一化到1\n$$\nVar\\left( y\\left( t \\right) \\right) =\\sum_{i,j=1}^{N_c}{w_iw_jCov\\left( x_i\\left( t \\right) ,x_j\\left( t \\right) \\right) =w^TQw=1,}\n$$\n$$\n\\text{其中，}Q=Cov\\left( x_i\\left( t \\right) ,x_j\\left( t \\right) \\right)\n$$\n\n这里Q应该是对于每一个y(t)进行的操作,\n\n然后，我们的约束优化问题转变为Rayleigh–Ritz特征值问题最佳的系数向量**W通过求解Q<sup>-1</sup>S的特征向量**得到。其特征向量为一Nc维的向量矩阵，每一维对应一特征值，并且按特征值大小降序排序，特征值的大小表示了按其对应的特征向量对信号进行空间滤波后，*y*(*t*)在trial之间的任务相关性(task consistency)。\n\n**总结**\n\n总结一下，这个分类方法的核心就是TRCA，提取任务相关性分析，如何提取相关性成分成为了关键点。\n\n简化流程就是：**对于多个通道的信号，通过空间滤波器，得到任务相关性成分**\n\n这里我们复习一下线代乘法基础知识\n\n空间滤波器就是各个通道对于权值的一个数组(一维矩阵)，假设为空间滤波器:\n$$\nW=\\left( \\begin{array}{c}\n\tw_1\\\\\n\t\\vdots\\\\\n\tw_{Nc}\\\\\n\\end{array} \\right)\n$$\nW=(w1,w2,...)，而多个通道的信号表示为:\n$$\nX=\\left( \\begin{matrix}\n\t3.1&\t\t...&\t\t7\\\\\n\t\\vdots&\t\t\\vdots&\t\t\\vdots\\\\\n\t5.9&\t\t\\cdots&\t\t8.3\\\\\n\\end{matrix} \\right),每一行表示这一通道的采样点数值\n$$\n用公式表示就是Y=W<sup>T</sup>X。\n\n而求解空间滤波器就利用到协方差矩阵。将每次trials之间(不包括自己)求解一次协方差矩阵\n\n**协方差**\n\n在统计学中，给定 $n$ 个观测样本的 $m$ 个随机变量 $X_1, X_2, \\dots, X_m$，我们可以使用 $n \\times m$ 的数据矩阵 $X$ 来表示这些样本。矩阵 $X$ 的每一行表示一个观测样本，每一列表示一个随机变量。假设 $X$ 的每一列的均值为 $0$，则其协方差矩阵 $C$ 的第 $i,j$ 个元素可以表示为：\n$$\nCi,j\\=1n−1∑k\\=1n(Xk,i−Xiˉ)(Xk,j−Xjˉ)C\\_{i,j} = \\\\frac{1}{n-1}\\\\sum\\_{k=1}^n (X\\_{k,i} - \\\\bar{X\\_i})(X\\_{k,j} - \\\\bar{X\\_j})Ci,j​\\=n−11​∑k\\=1n​(Xk,i​−Xi​ˉ​)(Xk,j​−Xj​ˉ​)\n$$\n\n\n其中，$\\bar{X_i}$ 表示 $X$ 的第 $i$ 列的均值，即第 $i$ 个随机变量的均值。上式可以改写为矩阵形式：\n$$\nC\\=1n−1(X−Xˉ)T(X−Xˉ)C = \\\\frac{1}{n-1} (X - \\\\bar{X})^T (X - \\\\bar{X})C\\=n−11​(X−Xˉ)T(X−Xˉ)\n$$\n\n\n其中，$\\bar{X}$ 是一个 $1 \\times m$ 的向量，表示每个随机变量的均值，$(X - \\bar{X})$ 表示去均值化后的数据矩阵，$(X - \\bar{X})^T$ 表示其转置矩阵。因此，协方差矩阵可以看作是去均值化的数据矩阵的转置矩阵与去均值化的数据矩阵之积的标准化。\n\n当数据矩阵 $X$ 中的每一行表示一个观测样本时，$X$ 的每一列表示一个随机变量的均值可以通过对 $X$ 按列求平均得到。在这种情况下，上式可以改写为：\n$$\nC\\=1n−1(X−xˉ)T(X−xˉ)C = \\\\frac{1}{n-1} (X - \\\\bar{x})^T (X - \\\\bar{x})C\\=n−11​(X−xˉ)T(X−xˉ)\n$$\n\n\n其中，$\\bar{x}$ 是一个 $1 \\times n$ 的向量，表示每个观测样本的均值。在这种情况下，协方差矩阵可以看作是去均值化的观测样本数据矩阵的转置矩阵与去均值化的观测样本数据矩阵之积的标准化。\n\n因此，我们可以得出结论，将去均值化的数据矩阵的转置矩阵与去均值化的数据矩阵之积除以 $n-1$，就可以得到协方差矩阵。这也是为什么可以通过两个矩阵相乘来计算协方差矩阵的原因。\n\n# 深度学习方法\n\n## 深度学习和机器学习\n\n![image-20230401234449494](D:\\Typora\\images\\image-20230401234449494.png)\n\n机器学习特征通常需要手动设计，分类器需要手动选择，随着数据增大而收敛，停滞不前\n\n深度学习，端到端，给一个网络数据和任务，特征提取和建模步骤都是自动完成的，随着数据变大而扩展，越来越好\n\n## 迁移学习\n\n加载预训练的网络，比如一个Alexnet能输出1000个分类，如果我们实际只需要4分类，那么可以替换掉最后几层来加快学习\n\n比从空白开始训练省时省力\n\n![image-20230401234757051](D:\\Typora\\images\\image-20230401234757051.png)\n\n![image-20230401234810906](D:\\Typora\\images\\image-20230401234810906.png)\n\n### 两种方法\n\n#### 时频域\n\n1.将时域信号转换为时频域表示形式，并训练卷积神经网络，直接从这些时频表示中提取模式。\n\n![image-20230401233434429](D:\\Typora\\images\\image-20230401233434429.png)\n\n时频表示，描述了信号中的频谱成分如何随时间的变化而变化，增强了可能不可见的模式\n\n##### 方法\n\n将信号从时频表示保存为图像的技术，有：\n\n* 频谱图，spectrogram\n* 梅尔频谱图\n* 连续小波变换，scalogram或尺度图\n* 常数Q变化，constant Q\n\n#### 直接输入\n\n直接将信号输入神经网络进行训练，如lstm\n\n为了加快速度，一般需要进行降采样，在matlab中可以使用invariant scattering convolutional network不变散射卷积网络来自动提取特征，获得提供低波动表示的特征，而不会丢失关键信息\n\n## 小波变换\n\n### 两个基本概念\n\n#### 缩放\n\n是指及时拉伸或收缩信号的过程\n\n## 利用尺度图处理信号\n\n步骤：将信号进行时频变换，输入神经网络进行训练；对于信号先进行时频表示然后用训练好的模型进行预测\n\n\n\n\n\n## 降采样\n\n[Python脑电数据处理EEG-深度学习建模_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1US4y1g7gC/?spm_id_from=333.337.search-card.all.click&vd_source=8ecff66abb776707f111647a284db8d9)\n\nlstm，提取12个特征，它数据有pos和neg两个阶段，已经标好label\n\n要分析多少赫兹的信号就将采样到它的两倍\n\n![image-20230402005247706](D:\\Typora\\images\\image-20230402005247706.png)\n\n滤了1-100.功率频谱图100之后骤降\n\n![image-20230402005339811](D:\\Typora\\images\\image-20230402005339811.png)\n\n将功率谱密度图转为numpy array格式\n\n![image-20230402005509859](D:\\Typora\\images\\image-20230402005509859.png)\n\n计算面积值\n\n注意换算，比如取300ms的值，采样率对应出来的numpy array是多少到多少\n\n## 预处理\n\n### 滑动时间窗\n\n\n\n## 分类方法\n\n### 原始数据特征算法\n\n原始数据特征的卷积神经网络分类算法由 robin 提出，该算法提取的特征是初始脑电信号中的时空特征。时空特征的提取主要是基于滑动时间窗方法，在每一个 7.5s 的试验中，选用 4s 的运动想象时间，滑动窗口的长度设为 2s，时窗步进为 0.1s，每一次试验产生 21个时间窗，总共产生 6048（288*21）个短时域信号图作为训练样本。该方法的分类器是VGGnet 的卷积神经网络（CNN）\n\n这种原始数据特征算法具有两个优势，第一是数据预处理简单，对时序信号进行裁剪，并且相邻时间窗之间重叠率高，边缘信息对分类精度的影响较低。第二是易与 CNN 分类器结合，裁剪后生成的样本图可以作为二维图片输入 CNN 中进行训练分类。\n\n缺点包含两点，第一点是**时序特征的实质是信号波形**，实验数据采集过程中被试者的脑区状态对于特征的影响较大，算法可靠性较低，不同被试的分类效果差异较大。第二点是网络参数较大，以 2s 的时间窗为例，采样频率为 250Hz，则时间窗的时间点长度为 500（250*2），远大于相同信号的频域长度（脑电信号一般在 50Hz 左右），因此需要多次迭代训练。\n\n### 平行多层感知网络算法\n\n平行多层感知网络（MLP）网络提取的是能量特征，包括静态能量特征和动态能量特征。如下图所示，标准的 MLP 网络用于分类静态能量，结合 MLP 层和 CNN（卷积层+池化层+全连接层）的结构用于分类动态能量，在两个并行网络的输出端是最大池化层，起到筛选识别分类的作用，选取两个网络识别的较大概率，对脑电信号分类作出判别（类似于数学中的 argmax 函数）。\n\n![image-20230402095023714](D:\\Typora\\images\\image-20230402095023714.png)\n\nMLP 算法应用的网络结构相对简单，并没有过多的层数堆积，因此实际的分类时间相对较短，同时并行网络的优点是在保留卷积神经网络权值共享特点的基础上，实现更有针对性的特征提取和分类。\n\n**并行的神经网络处理架构**是新兴的脑电处理思想之一，徐高伟[25]提出的方法是在脑电分类中，设置并行的 RNN 网络，一路为训练完毕网络，一路为训练网络（网络结构相同），在训练过程中完成模型的迁移和修正。而平行多层感知网络虽然具备并行网络并行取优的特点，但是仅把初始信号划分为动态能量和静态能量，缺乏可靠的数据预处理环节，导致数据分类准确率不高。并行网络的结构更适合与**迁移学习或监督学习的方法结合**，搭配合理高效的数据预处理环节，构建学习能力更强的脑电信号分类框架。\n\n### **黎曼几何与支持向量机算法**\n\n黎曼几何与支持向量机算法是目前对于四分类脑电信号识别效果最好的方法之一（M. Hersche, T. Rellstab, P. D. Schiavone, L. Cavigelli, L.Benini, and A. Rahimi. Fastand accurate multiclass inference for mi-bcis using large multiscale temporal and spectralfeatures[C]. in 2018 26th European Signal Processing Conference (EUSIPCO), 2018, 1690-1694）\n\n### **多尺度** **CSP** 算法\n\n多尺度 CSP 算法也是提取的多尺度特征，包括时间，频率和空间特征\n\n## CNN SSVEP\n\n [Using variable natural environment brain-computer interface stimuli for real-time humanoid robot navigation](https://arxiv.org/pdf/1811.10280.pdf).\n\n在离线实验期间，受试者会固定在闪烁的刺激之一上。每个SSVEP类收集来自每个受试者的皮层大脑信号进行40个实验试验，以形成离线先验训练集或训练每个受试者的CNN模型 (离线校准)。\n\n![image-20230402010906679](D:\\Typora\\images\\image-20230402010906679.png)\n\n我们使用离线先验实验数据集训练SSVEP卷积单元 (SCU) CNN架构 [17]，包括一维卷积层、批归一化和最大池化 (如图4所示)。我们首先对9至100Hz之间的输入信号进行带通滤波，以减少在这项工作中不感兴趣的不期望的高频或低频。通过使用大型初始卷积滤波器来捕获由九个输入通道组成的滤波信号，以捕获我们对干EEG数据进行分类感兴趣的频率。SCU CNN模型使用具有随机梯度下降的反向传播进行训练 [24]。对于此训练，最初通过网格搜索在验证集上选择的关键超参数是L2权重衰减缩放0.004，dropout级别0.5，卷积内核大小1 × 10，内核步长4，maxpool内核大小2，分类交叉熵作为优化函数，ADAM梯度下降算法 [25] 和remu作为所有隐藏层上的激活函数。\n\n## MFCNN\n\n[用于稳态视觉诱发电位目标识别的多尺度特征融合卷积神经网络方法 - 中国知网 (cnki.net)](https://kns.cnki.net/kcms2/article/abstract?v=3uoqIhG8C44YLTlOAiTRKibYlV5Vjs7iJTKGjg9uTdeTsOI_ra5_XbpIojxN0lnj9_VcSXrN1CnJ8R3DtVzVZrrHHAbjlqMS&uniplatform=NZKPT)\n\n将SSVEP信号数据转化为二维时频图像作为输入，基于MFCNN模型框架有效提取目标信号多尺度级联特征，实现SSVEP信号目标自适应特征提取及端到端识别。\n\n### 时频化处理\n\n由于SSVEP信号的非平稳、非线性、时变特性[18],传统的时域或者频域分析方法具有信号处理的不确定性，谱分析无法反映各个频段能量随时间的变化情况，也不能完整地表达信号的特征参数。小波变换在传统傅里叶变换基础上，引入尺度和时间变量来分析信号的不同频率成分，同时提供时域和频域的信息特征[19],适合处理短时间内的突变信号。因此，本文利用小波变换对SSVEP信号进行时频化图像处理，将时频域特征生成时频图，以不同颜色分布表征不同类别的信号差异，如下式\n\n### 神经网络构建\n\n小波变换将SSVEP信号转化成频率-时间-小波系数图(时频图),不同颜色分布的图像作为输入，利用CNN进一步提取图像特征进行学习并分类。\n\n### 目标识别\n\n首先，采集受试者在不同闪烁目标刺激下的多通道SSVEP信号，经过预**处理**整合后输入至网络模型中，利用小波变换构造SSVEP信号为二维时频图像样本集\n\n随机选取数据集的70%为训练集对MFCNN模型进行训练，30%为测试集\n\n![image-20230402011721328](D:\\Typora\\images\\image-20230402011721328.png)\n\n### 实验\n\n实验开始时，受试者有２ｓ的\n\n（ａ）实验时序图\n\n（ｂ）实验场景图\n\n图４ 实验时序图与场景图\n\n![image-20230402213147265](D:\\Typora\\images\\image-20230402213147265.png)\n\n2s静息准 备 时 间，当 ＰＣ 机 提 示 音 响 起，正 式 开 始 闪烁，重复２０次为一轮，单次刺激目标的呈现时间为４ｓ，随后提示音响起闪烁停止，受试者间隔休息２ｓ后再次进行下一次闪烁，每个刺激目标呈现３轮，轮与轮之间也给予受试者充足的休息时间。\n\n## 卷积\n\n预处理(滑动时间窗，原数据少，避免过拟合)--功率谱特征提取PSD\n\n我们选用功率谱密度（PSD）**作为网络的输入特征**。选用原因包含以下两点；第一，前文提到了为了降低信号分类中的个体差异影响，在数据预处理阶段首先利用 DWT 分析不同被试关于运动想象任务的频率分布情况，PSD 生成特征图横轴即为频率轴，可以和数据预处理做有效整合。第二，数据预处理部分的滑动时间窗方法，程序实现过程中是基于python 的 epoch 实现的，**PSD 特征图可以伴随 epoch 生成**，与数据准备环节做有效的衔接，没有窗口信号的多余操作，直接进行变换域处理，保证了特征图的有效性和稳定性。\n\n本实验选用的是 Welch 方法[53]生成 PSD 特征图，该方法也是采用了信号的滑窗处理方法，并利用快速傅里叶变换（FFT）计算信号能量分布。\n\n## CNN+LSTM\n\n![image-20230402113108116](D:\\Typora\\images\\image-20230402113108116.png)\n\nEEG系统以2048年Hz的采样率收集。放置八个Ag/AgCl电极PO7，PO3，POZ，PO4，PO8，O1，Oz和O2覆盖枕区。对于每个受试者，他们参加了15个模块的实验。每个块包含12个试验，对应于以随机顺序生成的所有12个刺激。每次试验持续5 s，分别包括1 s的提示期和4 s的目标刺激。总共收集了180个试验。\n\n# 前景\n\n![image-20230423203429043](D:\\Typora\\images\\image-20230423203429043.png)\n"},{"title":"AR开发-空间定位点与SLAM","url":"/2023/03/13/AR开发-空间定位点/","content":"\n在基于单目的摄像头的AR技术中，特征点（Feature）是最通用的一项技术手段，通过匹配不同帧图像之间特征点的对应关系，我们才能够准确计算相机的运动，从而恢复环境三维结构。特征点相关算法很多，在移动端，为了提高计算效率，倾向使用ORB和Freak，比如SLAM中我们就使用了ORB特征，Marker Tracking中我们使用了Freak特征；而类似SIFT这种，匹配精度高，但是运算效率低，一般用于SFM这类技术中。使用特征点的好处在于，特征具有良好的尺度不变形、方向不变形和光照不变形等特性，匹配结果较为鲁棒。光流法（Optical Flow）是相对于特征点的另一类跟踪相机运动的方法，它的基本原理是不去计算特征点以及特征描述子，而是直接使用像素块进行匹配，提高了运算效率，而其缺点是光流法只适合匹配相邻的两帧图像来计算运动变化，它要求光强度守恒（Brightness Consistency），所以无法用于重定位等技术实现。\n\n# 空间定位点\n\n空间定位点表示系统随时间跟踪的世界上的重要点。 每个定位点都有可调整的[坐标系统](https://learn.microsoft.com/zh-cn/windows/mixed-reality/design/coordinate-systems)（基于其他定位点或参照系），以确保锚定的全息影像保持位置精确。 在定位点的坐标系统中渲染全息影像可以在任何给定时间为你提供最准确的全息影像定位。 这是以不断对全息影像的位置进行小的调整为代价的，因为系统不断地将其移回到基于现实世界的位置。\n\nARFoundation中的参考点（Reference Point）与ARCore中的Anchor其实是同一概念，锚点的原意是指不让船舶飘移的固定锚，这里用来指将虚拟物体固定在 AR 空间上的一种技术。由于跟踪使用的陀螺仪传感器的特性，误差会随着时间积累，所以需要通过图像检测等来对误差进行修正，此时，如果已存在于空间上的对象不同步进行校正则会出现偏差，锚点的功能即是绑定虚拟物体与 AR 空间位置。被赋予 Anchor 的对象将被视为固定在空间上的特定位置，并自动进行位置校正，锚点可以 确保物体在空间中看起来保持相同的位置和方向，让虚拟物体在 AR 场景中看起来待在原地不动。\n\n参考点的工作原理如下：AR 应用中，摄像头和虚拟物体在现实世界空间中的位置会在帧与帧之间更新，即虚拟物体在现实世界 空间中的姿态每帧都会更新，由于陀螺仪传感器的误差积累，虚拟物体会出现飘移现象，为解决这个问题， 我们需要使用一个参考点将虚拟对象固定在现实空间中，如前所述，这个参考点姿态信息的偏差必须要能用某种方式消除以确保参考点的姿态不会随着时间而发生变化。消除这个偏差的就是视觉校准技术，通过视觉校准能让参考点保持相同的位置与方向，这样，连接到该参考点的虚拟对象也就不会出现飘移。一个参考点上可以 连接一个或多个虚拟对象，参考点和连接到它上面的物体看起来会待在它们在现实世界中的放置位置，随着参考点姿态在每帧中进行调整以适应现实世界空间更新，参考点也将相应地更新物体的姿态，确保这些物体能 够保持它们的相对位置和方向，即使在参考点姿态调整的情况下也能如此，有了参考点，连接到参考点上的虚拟对象就像是固定在现实世界空间中一样。\n\n# SLAM\n\n摄像头成本低且能获取丰富的环境信息，使用摄像头作为传感器的VSLAM技术一直是学术界与工业界的热门研究方向。我们也是众多VSLAM学习者中的一员，从入门到查找各种资料学习的过程中，踩了不少坑，但也有一些心得。考虑到大多数VSLAM的入门学习者会碰到学习曲线陡峭，内容繁杂的问题，我们开源了**《smoothly-vslam》**教程，并将在**组队学习**中，陪伴学习者成长。\n\n开源地址：https://github.com/datawhalechina/smoothly-vslam\n\n**SLAM** (`simultaneous localization and mapping),也称为CML (Concurrent Mapping and Localization`), 即时定位与地图构建，或并发建图与定位。\n\n![Position_Structure](https://yqfile.alicdn.com/ffc72ae16fbc8af1c9ffedc151547abe47ebd220.png)\n\n## 坐标叠加\n\n我们需要把虚拟坐标和现实世界的坐标进行叠加。我们现在接触虚拟信息的方式，无论是电脑、平板还是手机，都是通过屏幕，这样我们感受到的信息其实是2D的。而真实环境的坐标系是3D的，所以，如果我们要让虚拟信息与真实环境无缝融合，首先要做的就是叠加虚拟坐标系与真实坐标系。\n\n## 几何物理信息交互\n\n真实环境中有高低起伏、有障碍物、有遮挡关系，AR可以让虚拟信息跟这些真实环境中的物理信息进行交互。\n\n## 语义理解\n\n随着机器学习和深度学习的发展，虚拟信息可以“理解”真实世界，让二者的融合更趋于自然。上面两步是我们目前已经实现了的技术。未来我们要做的，是语义理解。语义理解加上之前的坐标叠加和交互，我们就可以实现科幻电影般的效果。\n\n[(265条消息) 一文彻底搞懂SLAM技术_小麦大叔的博客-CSDN博客](https://blog.csdn.net/u010632165/article/details/119426739)\n\n## 平面检测\n\nSLAM构建出了3D点云地图，并估计出了Camera Pose，然而对于AR应用，还无法确定3D模型的摆放位置。比如我们需要在桌面上摆放一个花瓶，我们还需要知道在3D点云地图中，桌面对应的位置，这就需要上面流程图里提到的平面检测。\n转换为一个数学问题描述：在空间中我们有一系列的点**P**，并给出一个方向向量 **D** ，求一个法向量平行于**D** 的平面并使得所有的点距离该平面的距离之和最小。\n这是一个非常典型的最小二乘估计问题，因此可以利用已有的数学工具求解，如高斯牛顿，LM算法，SVD分解等等。如果是检测水平面，其中**D** 是根据重力传感器得到的竖直方向，即平面的法向量方向得以确定；\n\n## Marker+SLAM\n\nSLAM初始化建立的点云世界坐标系是随机的，对于单目SLAM，scale信息是无法确定的，即无法确定点云世界坐标和真实尺寸的比例。在某些情况下，AR应用希望能够和真实的尺寸一一对应，在这种情况下我们提出了利用Marker作为SLAM的初始地图的方法。通过一个事先确定的Marker，建立一个已知scale信息的世界坐标系，在此坐标系的基础上通过SLAM跟踪并扩张地图，那么在叠加3D模型时就可以安装其真实尺寸展示。算法上的区别就在于SLAM首先要去识别Marker，而不是自己去初始化地图，识别Marker的方法也可以借鉴Marker Tracking的相关技术。\n\n[SLAM+AR 技术与应用的一些思考-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/227624)\n\n# EasyAR\n\n## 运动跟踪的工作原理\n\n运动跟踪通过视觉惯性同步定位和建图（VISLAM）技术，计算设备相对于真实空间的位姿关系。在设备移动过程中，通过识别相机图像中显著特征点并跟踪其位置变化，结合设备的IMU数据信息，实时计算当前设备相对于真实世界的位置和姿态。\n\n- 真实尺度\n\n  利用设备的惯导传感器和相机图像数据融合，恢复真实物理尺度，位置的单位是米。\n\n- 鲁棒准确的运动跟踪\n\n  VISLAM算法相比纯视觉SLAM能极大降低长时间跟踪的漂移，且对于光照变化、弱纹理区域和动态物体等更鲁棒。\n\n- 快速初始化\n\n  只需要相机对着应用场景横移1-2次即可实现初始化。初始化完成时的位置定义为世界坐标系的原点，根据重力方向和屏幕朝向，将初始化姿态朝向屏幕。初始化完成后自动开启位姿跟踪。\n\n- 快速重定位\n\n  在设备跟踪丢失后/跟踪不佳后快速准确地恢复设备相对于世界坐标系的位姿，重定位前后世界坐标系原点不变，保证跟踪的持续性和准确性。在初始化区域附近具有位姿校正能力从而消除长距离运动产生的累计误差。\n\n- 点击碰撞\n\n  支持点击当前视野内的点云或者水平面。\n\n- 锚点\n\n  当放置虚拟物体时，可以使用锚点确保虚拟物体锚定在特定的区域内，使设备移动中也能保持虚拟物体的稳定。这意味着，即便位姿出现了偏差，虚拟物体也会看起来位于原始放置的位置。你可以调用接口hitTestAgainstPointCloud实现Anchor的创建,每次调用接口hitTestAgainstPointCloud就会自动创建一个Anchor。当Anchors太多而超出内存限制就会自动把老的Anchors释放掉。 你也可以在调用hitTestAgainstHorizontalPlane后调用hitTestAgainstPointCloud为平面创建Anchor.\n\n## EasyAR 稀疏空间地图\n\n### 功能简介\n\nEasyAR 稀疏空间地图( [Sparse Spatial Map](https://help.easyar.cn/EasyAR Sense/v4_1/ApiReference/SparseSpatialMap.html) )用于扫描用户周围环境，生成环境的三维视觉地图，并提供视觉定位跟踪功能。\n\n建立的视觉地图可以 [保存](https://help.easyar.cn/EasyAR Sense/v4_1/ApiReference/SparseSpatialMap.html#savemap) 或多个设备间实时共享。当其他设备加载相应地图，并在加载地图中通过 [定位](https://help.easyar.cn/EasyAR Sense/v4_1/ApiReference/SparseSpatialMap.html#startlocalization) 确定设备相对于地图的位置和姿态，适用于开发持久化AR应用或多人互动AR应用。\n\nEasyAR 稀疏空间地图支持 [加载](https://help.easyar.cn/EasyAR Sense/v4_1/ApiReference/SparseSpatialMap.html#loadmap) 多个地图，在多个地图中定位并返回对应地图的ID和设备相对于该地图的位置和姿态。\n\n稀疏空间地图目前需要稳定的运动跟踪系统(例如EasyAR Motion Tracking / ARCore / ARKit)提供六自由度的位置和姿态用于建图以及定位成功后的持续跟踪。在建图过程中，稀疏空间地图利用相机图像和对应位姿构建环境1：1的视觉地图。定位过程中，当视觉定位成功后，设备相对地图的位姿通过运动跟踪系统持续更新。\n\n稀疏空间地图建图通过扫描环境并构建三维环境点云，每一个三维点都记录周围的局部视觉信息。定位过程通过将当前相机图像和地图的三维点进行视觉匹配并尝试计算对应位姿来恢复相应的位姿\n\n### 怎么往稀疏空间添加物体？\n\n在ImageTarget下生成物体后，再新建一个物体，赋值这个物体的坐标和欧拉角度，设置父节点为SpatialMap的对象\n","categories":["经验"]},{"title":"数据分析笔记","url":"/2023/02/09/数据分析笔记/","content":"\n# matplotlib\n\n![image.png](https://s2.loli.net/2023/02/09/lSWTAt63Kxah1bw.png)\n\n\n\n# numpy\n\n![数据分析day02总结.png](https://s2.loli.net/2023/02/11/vgQIuRtAxhM6D7d.png)\n\n# pandas\n\n1.Series 一维，带标签数组\n\n2.DataFrame 二维，Series容器\n\n**loc函数**：通过行索引 \"Index\" 中的具体值来取行数据（**如取\"Index\"为\"A\"的行**）\n\n**iloc函数**：通过行号来取行数据（**如取第二行的数据**）\n\n![image.png](https://s2.loli.net/2023/02/11/pTGwLsnYE7emMQV.png)\n\n![day05总结.png](https://s2.loli.net/2023/02/11/ileLTozxIjc4Q7t.png)\n"},{"title":"Linux笔记","url":"/2023/01/02/Linux笔记/","content":"\n# 第一课\n\n## 什么是LInux?\n\n* Linux是一种操作系统\n* 1991年10月，Linux Torvalds发布第一个公开版内核\n\n![image-20220907104545952.png](https://s2.loli.net/2023/01/02/R75fqyE4pDYr21I.png)\n\n\n\n## Linux目录结构\n\n![image-20220907104056459.png](https://s2.loli.net/2023/01/02/iZbAM7HdcDGf3ou.png)\n\n![image-20220907104116027.png](https://s2.loli.net/2023/01/02/ZhoP78ujFqfRr4X.png)**/ linux 文件系统的起点，linux 所有的文件都放在其中。**\n\n/bin 存放二进制可执行文件，常用命令一般都在这里 \n\n/etc 存放系统管理和配置文件 \n\n**/home 存放所有普通用户的家目录**\n\n/usr 存放系统应用程序 \n\n/opt 额外安装的可选应用程序包所放置的位置。比如，我们可以把 tomcat 等都 安装到这里 \n\n/proc 虚拟文件系统目录，是系统内存的映射，相当于是存储内存中的信息 \n\n**/root 管理员的家目录** \n\n/sbin 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用 的系统级别的管理命令和程序。如 ifconfig 等 \n\n**/dev 用于存放硬盘、键盘、鼠标、光驱等各种设备文件** \n\n/mnt 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂 载其他的文件系统 \n\n/boot 存放用于系统引导时使用的各种文件 \n\n/lib 存放跟文件系统中的程序运行所需要的共享库及内核模块 \n\n/tmp 用于存放各种临时文件 \n\n/var 用于存放各种服务的日志文件、系统启动日志等\n\n# 第二课\n\n## 查看及切换目录\n\n### \"三剑客\"高级使用\n\n* pwd — Print Working Directory – 用途:查看当前工作目录 \n\n* cd — Change Directory \n  *  用途:切换工作目录\n  *  格式:cd [目标文件夹位置]\n\n**绝对路径与相对路径**\n\n* 绝对路径：以根目录(/)起始的路径\n\n* 相对路径：以当前路径为参照的路径\n\n```bash\n[root@zrj pki]# cd /etc/pki/CA/ #绝对路径(以根为起始)\n[root@zrj pki]# cd CA/ #相对路径(相对于当前目录/etc/pki)\n```\n\n* . 表示当前目录\n* .. 表示父目录(也就是上一级目录)\n\n```bash\n[root@zrj CA]# cd .. #返回上一级目录\n[root@zrj /]# pwd #当切到根以后无法再返回上一级（linux 系统以根为起始的）\n```\n\n## ls列出目录内容/文件属性\n\n### ls列出目录内容/文件属性\n\n– -l：以长格式显示（显示详细属性） \n\n– -A：包括名称以 . 开头的隐藏文档 \n\n– -d：显示目录本身(而不是内容)的属性 \n\n– -h：提供易读的容量单位(K、M)等 \n\n– -R：递归显示内容\n\n```bash\nls -lh /etc/passwd #显示详细属性并加上易读单位(K) 不加-h就是默认以字节为单位,理解为human给人看的\n```\n\n查详细属性\n\n```bash\nls -lhd 目录或文件\n```\n\n\n\n### 创建/删除/移动目录\n\n#### 别名\n\n```bash\nalias #查看别名列表\nalias hn='hostname' #命名别名,等号左边不要有空格\nunalias hn #删除别名\n```\n\n#### 创建\n\n* mkdir--Make Directory\n\n#### 删除\n\n* rm--Remove\n  * -r：递归删除\n  * -f：强制删除\n\n#### 移动\n\n* mv--Move\n\n```bash\nmv /opt/susu /opt/yiyi #改名 换个地方换个名 cp也可以\nmv /opt/susu/ /opt/ #移动susu文件夹下的内容，/opt/susu则是表示移动文件夹\n```\n\n## 复制与通配符\n\n### cp复制\n\n* cp--Copy\n  * -r：递归复制整个目录\n  * -f：强制覆盖，不提示\n  * -p：保持源文件属性不变\n\n#### 强制覆盖\n\n临时取消别名：在运行命令前，加上 \\\n\n```bash\ncp -r /boot/ /opt/ #递归复制每复制一个就询问一遍，输入y，文件太多时怎么处理呢？\n#alias查看别名是发现 cp='cp -i' 复制时及使用cp -rf也是会询问 因为-i优先级高于-f\n\\cp -r /boot/ /opt/ #用\\临时取消别名\n```\n\n#### 复制多个\n\n永远把最后一个参数作为目标，其他的所有参数都作为源\n\n```bash\ncp -r /boot/ /home/ /etc/passwd /mnt/ #将/boot/ /home/复制到/mnt目录下\n```\n\n### 通配符\n\n* *任意多个字符\n* ？单个字符\n  * '*tab'以tab结尾 'tab\\*'以tab开头\n\n```bash\nls /boot/vm* #显示以vm开头数据\n```\n\n* 特殊字符\n  * [a-z]：多个字符或连续范围中的一个，若无则忽略\n  * {a,min,xy}：多组不同的字符串，全匹配\n\n```bash\n[redhat@localhost ~]$ touch tty3\n[redhat@localhost ~]$ touch tty4 #新创建两个tty3,tty4\n[redhat@localhost ~]$ ls tty[3-8]#连续范围\ntty3  tty4 #只会找到符合的\n[redhat@localhost ~]$ ls tty{3,4,5,6,7,8}#多组条件\nls: 无法访问'tty5': 没有那个文件或目录\nls: 无法访问'tty6': 没有那个文件或目录\nls: 无法访问'tty7': 没有那个文件或目录\nls: 无法访问'tty8': 没有那个文件或目录#找不到符合的会提示\ntty3  tty4\n```\n\n\n\n## 重定向与管道操作\n\n* \\>：覆盖重定向\n* \\>>：追加重定向\n\n### 将屏幕显示信息写入文件\n\n命令 \\> file 覆盖 \n\n命令\\>> file 追加 \n\n```bash\n[redhat@localhost ~]$ touch redhat.txt #创建一个文件\n[redhat@localhost ~]$ echo \"hello, I'm Joel\" > /var/ftp/Joel.txt #写字符串进文本\n[redhat@localhost ~]$ ls\n公共  图片  音乐  redhat.txt  vmlinuz-0-rescue-3f6f17037a7c4806bcc68ce95a0c1d7b\n模板  文档  桌面  tty3        vmlinuz-4.18.0-193.el8.x86_64\n视频  下载  opt   tty4\n[redhat@localhost ~]$ hostname #hostname命令查看本机的hostname\nlocalhost.localdomain\n[redhat@localhost ~]$ hostname > redhat.txt  #将本机hostname写入redhat.txt种\n[redhat@localhost ~]$ cat redhat.txt #查看文件内容\nlocalhost.localdomain\n```\n\n* cat 加-n 添加行标\n\n### 管道\n\n|:只接受一个输入的命令\n\n```bash\n#一个文件12行 显示8-12行内容：\nhead -12 /etc/passwd/ | tail -5 \n或\ncat /etc/passwd/ | head -12 |tail -5\n```\n\n\n\n## find精确查找文件\n\n– 常用条件表示: \n\n* -type 类型(f 文件【黑】、d 目录【蓝】、l 快捷方式【青】) \n\n* -name \"文档名称\" \n\n* -size +|-文件大小(**k**、M、G) k小写\n\n* -user 用户名 -mtime 修改时间\n\n```bash\n#-type 按照类型查找 \n[root@localhost ~]# find /dev/ -type l #查找快捷方式\n#-name '文档名称' 查找文件名\n[root@localhost ~]# find /etc/ -name '*tab'\n-size +或-文件大小(k、M、G)\n[root@localhost ~]# find /boot/ -size +10M #查找大于 10M 的  不支持-1M，-1G，-1k(太小了)\n```\n\n## find高级使用\n\n### wc\n\nwc： word count 统计 \n\n**`wc -l /etc/passwd` 查看这个文件有多少行 也是查看操作系统有多少用户**\n\n```bash\nfind /etc/ -name '*tab' | wc -l #管道给wc表示统计以tab结尾的文件有多少个\n\n-exec拓展find的功能 find /home/ -name '*susu*' -exec cp -r {} /root \\; #{}将前面的结果放进里面作为复制的对象 \\;表示结束\n```\n\n\n\n# 第三节课\n\n* mkdir 只能创建文件夹不管后缀是怎么样，make directory\n\n### 创建文件\n\n```bash\ntouch [文件名]\n```\n\n### 创建硬连接\n\nln\n\n```bash\nln  [选项] 原文件 /路径/快捷方式名字\n```\n\n颜色是青绿色\n\n### 删除目录下所有内容\n\n删除 /root/opt 下的所有内容，利用通配符 *\n\n```bash\nrm -rf /root/opt/*\n#或者\ncd /root/opt\nrm -rf *\n```\n\n## grep 查找文本内容\n\n语法格式：\n\n```bash\ngrep [选项] '匹配模式' 文本文件...\n```\n\n\n\n### 压缩文件\n\n• tar 集成备份工具\n\n红色 用tar就得加f选项，f一定放在最后\n\n*  -c:创建归档 \n\n*  -x:释放归档 \n\n*  -f:指定归档文件名称 \n\n*  -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理 \n\n*  -t:显示归档中的文件清单 \n\n*  -C(大写):指定释放的位置 ，**后面要接释放目标**\n\nf:选项必须放在所有选项的最后\n\n```bash\ntar -zcf /路径/压缩包名字 被压缩归档的源数据 #用gzip压缩，可以压多个\ntar -jcf #bzip2压缩\ntar -Jcf #使用xz压缩\n#cf是一定要加的，c：创建归档 f:指定归档文件名称\n```\n\n例子：\n\n```bash\n[root@localhost ~]# tar -zcf /opt/abc.tar.gz /home/\ntar:从成员名中删除开头的\"/\"\n```\n\n**查看：**\n\n```bash\n tar -tf /opt/bin.tar.bz2\n```\n\n### 解压缩\n\n```bash\n#把压缩的c改成x 不加-z-j-J也可以 直接-xf\ntar -zxf /路径/压缩包名字 -C 解压缩到的位置 #不加-C解压到当前\ntar -jxf\ntar -Jxf\n```\n\n\n\n## win于linux互传\n\nscp方法\n\nwin\n\n```shell\n本地文件->远程文件夹\nscp local_file remote_username@remote_ip:remote_folder \n本地文件->远程文件\nscp local_file remote_username@remote_ip:remote_file \n```\n\n\n\n```shell\nscp get66.pcap root@192.168.1.147:/super\n```\n\nlinux\n\n```shell\nscp /home/zhao/data/test.txt zw@10.150.69.247: /C:/Users/zw/Desktop/summary\n或\nscp /home/zhao/data/test.txt zw@10.150.69.247: /C:/Users/zw/Desktop/summary/tt.txt\n```\n\nssh connection deny 可能是因为没有装Oepnssh[通过ssh协议实现Windows与Linux之间的文件互传_ssh传输文件 windows到linux_奇迹虎虎的博客-CSDN博客](https://blog.csdn.net/qq_17685725/article/details/123501015)\n\n# 第四次课\n\n## grep的查找条件\n\n语法格式：\n\n```bash\ngrep [选项] '匹配模式' 文本文件...\n```\n\n匹配模式：\n\n* ^word：以字符串word开头的\n* word$：以字符串word结尾的\n* ​       ^$：匹配空行\n\n例子：\n\n```bash\n[root@localhost ~]# grep ^root /etc/passwd # 查找/etc/passwd 包含root开头的行\n[root@localhost ~]# grep -v ^$ /etc/default/useradd #查看文件非空行\n[root@localhost ~]# grep -v ^# /etc/login.defs #去除以#开头即去掉注释\n```\n\n```bash\ngrep -E '匹配模式1|匹配模式2' 文本文件 #单引号括住\n```\n\n任意满足一个就将其过滤出来\n\n\n\n## vim文本编辑器\n\n```bash\nvim [[/目录/]文件名]\n[root@localhost ~]# vim /opt/ps.txt #打开此文件进行以下操作\n```\n\n* 若目标不存在，则创建空文件并编辑\n\n**先进入的是命令模式**：\n\n* 在命令模式，i键进入输入模式，Esc键返回\n* 在命令模式，:键进入末行模式，Esc键返回\n\n基本操作：\n\n* 保存并退出 `:wq`\n* 放弃修改并退出`:q!`\n\n命令模式下的操作：\n\n* `gg`或`1G`直接到文件首行，`10gg`或`10G`跳转到第十行\n* `G`到文件末尾\n* `yy`复制，`5yy`往下复制5行，`p`粘贴\n* `dd`删除，`10dd`删除10行\n* `u`撤销，`U`撤销当前行的所有修改，`Ctrl+u`撤销一次撤销操作\n* `/word`向后查找，`?word`向前查找，按回车后按n查找下一个，N查找上一个\n* `ZZ`保存并退出vim\n\n* `:w /root/newfile` 另存为其他文件 `:r /etc/filesystems` 读入其他文件内容\n\n开关设置\n\n* `:set nu`显示行号 `:set nonu`不显示行号\n\n### 与vim相关的配置文件\n\n```bash\nvim ~/.vimrc #~家目录下配置\nset nu # 之后打开文件编辑器都有行标\nset ai # 都有缩进\n#记得:wq保存退出才能生效\n```\n\n### 可视化操作\n\nVim 多行注释\n\n1.  首先按 esc 进入命令行模式下，按下 Ctrl + v ，进入列（也叫区块）模式;\n2.  在行首使用上下键选择需要注释的多行;\n3.  按下键盘（大写） \"I\" 键，进入插入模式；\n4.  然后输入注释符（ \"//\"、\"#\" 等）;\n5.  最后按下 \"Esc\" 键。\n\n## mount挂载\n\n光驱默认在/dev/sr0，它是块设备不能直接读，要挂载才能读\n\n```bash\nmount 设备路径 挂载点目录\numount 挂载点目录 #卸载设备，卸载块设备无效\n```\n\n例子：\n\n```bash\nmount /dev/cdrom /dvd/ # 将光盘挂载到/dvd/目录\n```\n\n\n\n# 第五次课\n\n## RPM包\n\n没法指定安装位置，要会找，拓展名为.rpm\n\n源码包封装-->rpm包\n\n![image.png](https://s2.loli.net/2022/10/11/CtukIKTLz58yrSO.png)\n\n**查询已安装的软件包**\n\n```bash\nrpm -q[子选项] [软件名称]\nrpmquery [子选项] [软件名称]\n```\n\n* -a：列出已安装的所有软件包\n* -i：查看指定软件的详细信息\n* -l：查看指定软件的文件安装清单\n\n**查询某个目录/文件是哪个rpm包带来的**\n\n```bash\nrpm -qf [文件路径]\n```\n\n即使目标文件被删除也可以查询，注意后面接文件路径不是软件名。\n\n\n\n**查询未安装的软件包**\n\n```bash\nrpm -qpi [RPM包文件] #查看指定软件的详细信息\nrpm -qpl [RPM包文件] #查看指定软件的文件安装清单\n```\n\n**卸载**\n\n```bash\nrpm -e\n```\n\n**强制覆盖安装**\n\n```bash\nrpm -ivh --force [] \n```\n\n--force\n\n## yum仓库简介\n\n解决要安装各种依赖包的问题(一次性装)\n\n### yum配置解析\n\n* 基本设置：/etc/yum.conf\n* 仓库配置：**/etc/yum.repos.d/*.repo** 一定以.repo结尾\n* 日志文件：/var/log/yum.log\n\n\n\n```bash\nvim /etc/yum.repos.d/dvd.repo #/dvd.repo根据具体改\n[AppStream]\nname=rhel8.2\nbaseurl=file:///dvd/AppStream #file://代表本地 /dvd从根开始 路径根据具体来改\nenabled=1\ngpgchcek=0\n[BaseOS]\nname=rhel8.2\nbaseurl=file:///dvd/BaseOS\nenabled=1\ngpgcheck=0\n:wq\n```\n\n\n\n\n\n\n\n# 配置网络、源码包的编译和安装\n\n## 配置linux网络\n\n### 配置主机名\n\n在root权限下\n\n```bash\n[root@localhost ~]# vim /etc/hostname #修改配置文件，永久配置主机名\nsvr7.tedu.cn\nreboot #重启生效\n```\n\n### 配置IP\n\n红帽是ens160 centos是ens33\n\n**修改网卡名**\n\n```bash\n[root@svr7 ~]# vim /etc/default/grub\n…\nGRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0\"\t\t#在末尾引号内添加net.ifnames=0 biosdevname=0\n\n[root@svr7 ~]# grub2-mkconfig  -o /boot/grub2/grub.cfg\t\t#重新生成引导文件，使配置文件生效\n[root@svr7 ~]# reboot\t\t#重启\n\n```\n\n**验证，网卡名是否发生变化**\n\n```bash\n[root@svr7 ~]# ifconfig \t\t#有eth0网卡\neth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.71.130  netmask 255.255.255.0  broadcast 192.168.71.255\n\n```\n\n**配置IP地址**\n\n临时配置：\n\n```bash\nifconfig ens160 192.168.147.7/24\n```\n\n永久配置\n\n```bash\n[root@svr7 ~]# nmcli connection show\t\t#查看连接名\nNAME        UUID                                  TYPE      DEVI\nvirbr0      0ace37a8-f7ad-45d6-9088-00b367999c0b  bridge    virb\n有线连接 1  02cc8558-b41e-3bc4-817b-243ca95c0417  ethernet  eth\n\n```\n\n**重新添加网卡**\n\n```bash\n[root@svr7 ~]# nmcli connection add  type ethernet ifname  eth0 con-name eth0\t#添加网卡\n```\n\n**配置IP**\n\n先不要照抄！\n\n```bash\n配置IP\n[root@svr7 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.147.7/24 ipv4.gateway 192.168.147.254 connection.autoconnect yes\t\t#配置IP地址和网关并实现开机自动连接\n```\n\n注意：这里有两个ip地址要根据自己的修改，在虚拟机中选择VMnet8网卡，选NAT模式，查询子网ip和分配的网关；关闭DHCP，再改，因为打开后就是系统分配了\n\n![image.png](https://s2.loli.net/2022/10/25/cNFkhPIa83GA6Rj.png)\n\n第一个ip填子网ip但后面的.0改成.7，加上/24，代码例子子网ip是192.168.147.0于是填入192.148.147.7/24\n\n第二个ip点击NAT设置查询网关ip填入\n\n![image.png](https://s2.loli.net/2022/10/25/mtMBn3CVoWr4EkI.png)\n\n```bash\n[root@svr7 ~]# nmcli connection up eth0 \t#激活eth0\n[root@svr7 ~]# ifconfig\t\t#查看配置的IP\n[root@svr7 ~]# route -n\t\t#查看网关\n```\n\n**为本机指定DNS服务器**\n\n```bash\n[root@svr7 ~]# vim  /etc/resolv.conf\n…\nnameserver 8.8.8.8\n```\n\n添加次要DNS\n\n**ping 本机验证**\n\n```bash\n[root@svr7 ~]#ping 本机ip\n```\n\n本机ip在命令行窗口\n\n```shell\nipconfig /all\n```\n\n以太网适配器...VMnet1下的ipv4地址，后面有(首选)\n\n一般是网关ip的.2改为.1\n\n## SSH\n\n![image.png](https://s2.loli.net/2022/10/25/W8ZraPUs9CeyDbw.png)\n\n克隆主机A后看克隆机B的ip地址\n\n在A中试着用ssh连B\n\n```bash\nssh root@[ip]\n```\n\n例子：\n\n```bash\nssh 命令选项 \n-p  端口：连接到指定的端口\n-X  启用-X转发，在本机运行对方的图形程序\n[root@svr7 ~]# ssh root@192.168.4.207\n…\nAre you sure you want to continue connecting (yes/no)? yes\t#第一次远程会让输入yes\nroot@192.168.4.207's password: \t\t\t\t\t\t\t#输入密码\nLast login: Wed Jul  8 11:24:37 2020\n[root@pc207 ~]# firefox \t\t\t#运行firefox图形程序，失败\nError: GDK_BACKEND does not match available displays\n退出，使用-X选项登陆，成功\n[root@pc207 ~]# exit\n[root@svr7 ~]# ssh -X root@192.168.4.207\nroot@192.168.4.207's password: \n[root@pc207 ~]# firefox\n\n```\n\n**修改默认端口**\n\n默认是22，可以进行修改，再连得关防火墙\n\n修改默认端口，pc207主机操作:\n\n```bash\n[root@pc207 ~]# vim /etc/ssh/sshd_config\nPort 8022          #Port原本是注释掉的 取消注释再把22改为8022\n[root@pc207 ~]# systemctl restart sshd\t\t#重启sshd服务，切记selinux需要是宽松或者禁止状态setenforce 0\n```\n\n测试：svr7主机操作，如果测试失败，出现以下问题，请关闭防火墙\n\n```bash\n[root@svr7 ~]# ssh -p 8022 -X root@192.168.4.207\t\nssh: connect to host 192.168.4.207 port 8022: No route to host\n[root@svr7 ~]# systemctl stop firewalld\n[root@svr7 ~]# getenforce\n[root@svr7 ~]# setenforce 0\n[root@svr7 ~]# ssh -p 8022 -X root@192.168.4.207\t#重新测试\nroot@192.168.4.207's password: \n[root@pc207 ~]#\n[root@pc207 ~]# logout #退出\n```\n\n\n\n# 常用网络工具\n\n![image.png](https://s2.loli.net/2022/10/25/1lHUYFqWTmXznN7.png)\n\n![image.png](https://s2.loli.net/2022/10/25/ilE852Y63wjFrom.png)\n\n```shell\nC:\\Users\\chan>tracert www.baidu.com\n\n通过最多 30 个跃点跟踪\n到 www.a.shifen.com [183.232.231.172] 的路由:\n\n  1     1 ms     1 ms     1 ms  10.253.36.1\n  2     7 ms     3 ms     3 ms  202.116.36.213\n  3    12 ms     2 ms     4 ms  10.10.0.253\n  4     7 ms    10 ms     4 ms  120.236.163.1\n  5     6 ms    41 ms     7 ms  183.233.56.61\n  6     9 ms    10 ms     9 ms  120.196.243.21\n  7     *        *        *     请求超时。\n  8    37 ms    13 ms    13 ms  120.241.49.210\n  9     *        *        *     请求超时。\n 10    15 ms    26 ms    14 ms  183.232.231.172\n\n跟踪完成。\n```\n\n![image.png](https://s2.loli.net/2022/10/25/YJci9s7VKIBHLN8.png)\n\n``` bash\nping -c [数字] -w [限定响应时间] [ip] #限定包数\n```\n\n\n\n# 源码编译安装\n\nRPM软件包： rpm -ivh  yum -y install\n\n源码包----开发工具----->可以执行的程序----->运行安装\n\n优势：\n\n灵活度较高，自定义较高，可以指定安装位置\n\n* 获得软件的最新版,及时修复bug\n\n* 软件功能可按需选择/定制,有更多软件可供选择\n\n* 源码包适用各种平台\n\n#### 准备编译环境，启动yum\n\n步骤一：安装开发工具gcc与make\n\n```bash\n[root@svr7 ~]# yum -y install gcc make\t\t#可能会报错 说明没挂光驱和启用yum.repos.d\n[root@svr7 ~]# mount /dev/cdrom /dvd/\n[root@svr7 ~]# vim /etc/yum.repos.d/dvd.repo \n[BaseOS]\nname=BaseOS\nbaseurl=file:///dvd/BaseOS\ngpgcheck=0\ngpgkey=/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\n[AppStream]\nname=AppStream\nbaseurl=file:///dvd/AppStream\ngpgcheck=0\n[epel]\nname=EPEL\nbaseurl=http://mirrors.aliyun.com/epel/$releasever/Everything/$basearch\ngpgcheck=0\nenabled=1\n[httpAppstream]\nname=aliyun Appstream\nbaseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os\ngpgcheck=0\n[root@svr7 ~]# yum -y install gcc make\t#安装\n```\n\n查看是否安装成功：\n\n\n\n# 自定义仓库\n\n制作仓库索引文件\n\n```bash\ncreaterepos [仓库路径]\nls [仓库路径]\n```\n\n发现多了`repodata` 这就是索引文件\n\n```\nvim /etc/yum.repos.d/dvd.repo \n```\n\n添加，其中这里设置的仓库路径是`/mytools/`\n\n```\n[Mytools]\nname=Mytools\nbaseurl=file:///mytools/\ngpgcheck=0\n```\n\n清空，重新生成\n\n```bash\nyum clean all\nyum repolist -v\n```\n\n\n\n## 安装一些小玩意\n\n小火车\n\n```bash\nyum -y install sl\nsl\n```\n\n字符语\n\n```bash\nyum -y install cmatrix\ncmatrix\n```\n\noneko占用前端\n\n```bash\noneko &  #在后台进行\n```\n\n这是会出现`[1] 数字`\n\n```bash\nkill all 数字  #杀死对应进程\n```\n\n\n\n# 用户组\n\n超级用户id为0,其他从1开始。\n\n每一个用户都会分配一个组，组账号用来区分权限，不用于登录。\n\n* 基本组\n* 附加组\n\n```bash\n/etc/passwd #存放账号\n```\n\n```bash\ncat -n /etc/passwd | less #查看账号目录\n```\n\n添加组\n\n```\ngroupadd stu\nuseradd -u 1111 -d /\n```\n\n## 用户初始配置文件\n\n```bash\n# ls -a /etc/skel/\n```\n\n模板目录，写到这里的东西会作为模板复制到新用户的家目录下。\n\n全局配置文件还有：/etc/bashrc, /etc/profile\n\n* ~/.bash_profile：每次登录时执行\n* ~/.bashrc：每次进入新的Bash环境时执行\n* ~/.bash_logout：每次退出登录时执行\n\n`echo`输出\n\n```bash\n# vim /home/[用户名]/.bashrc\n```\n\n打开用户终端时执行的内容\n\n## 权限与归属\n\n### 解析文件/目录权限\n\n```bash\n# ls -lhd ..\n权限位 硬连接数 属主 属组 大小 最后修改时间 \n```\n\n\n\n### 修改权限\n\n`chmod [-R] [+-=][rwx] 文件 ... `\n\n-R递归修改权限\n\n```\n# chmod u+r /                                       \n```\n\n![image.png](https://s2.loli.net/2022/11/15/c6SOaboFrfuAq7Z.png)j.png)\n\n# 权限管理\n\n目录权限默认为755，文件默认为644，一般文件默认不给x权限\n\n```bash\nmkdir -p /opt/susu/yiyi/ling #递归创建文件夹\nls -R /opt/susu/yiyi  #递归列出 展开/opt/susu以及/opt/susu/yiyi\nls -lhd /opt/susu/yiyi #查看属性\n```\n\n权限位： User--Group--Ohter 各三个字符表示，字符有r(读)/w(写)/x(执行)/-\n\n```bash\nchmod 0=--- /opt/susu #修改Ohter权限为---\n```\n\n递归修改-R\n\n```bash\nchmod o+rx /opt/susu/yiyi #加可读可写权限\n```\n\n文件夹的权限可执行是指它的目录下的文件可执行，如果它的父目录没有可执行权限，那么不可移动等操作这个文件夹。\n\n## 属组\n\n```bash\nmkdir /susu01\nls -lhd /susu01\ngroupadd stugrp #创建新组\nuseradd dc #创建新用户\nid dc #查看用户Id\nchown dc:stugrp /susu01  #修改归属\nls -lhd /susu01 #发现susu的属于的人和属于的组分别变为dc和stugrp\n```\n\n```bash\n[root@localhost ~]# gpasswd -a zhangsan stugrp #加入组\n[root@localhost ~]# su - zhangsan #切换\n[zhangsan@localhost ~]$ exit\n注销\n[root@localhost ~]#\n```\n\n### 权限位\n\n```bash\nmkdir /student/\nchown :stugrp /student/\nchmod g+s /student/\nls -lhs /student/ #发现group变成r-s\nmkdir /student/stu2/ #此时新建的子目录组会和/student/一致为stugrp\n```\n\n### 粘滞位 \n\n避免在同一个文件夹下不同用户互删文件\n\n```bash\n[root@localhost ~]#chmod o+t /public/ #other的x被t覆盖\n#此时如果一个用户想要rm rf 另一个用户创建的文件不可置信\n```\n\n\n\n# 计划任务启动流程\n\n## 查看进程\n\n\n\n进程动态排名\n\n```bash\ntop -d3 #每三秒更新一次进程动态排名\n```\n\n查进程PID号\n\n```bash\npgrep -l crond\n\n#查用户 查lisi的进程 pstree以树形结构展示 比pgrep详细\npstree -apu lisi \n```\n\n## 进程管理\n\n```bash\n# sleep 3 #占用前台终端三秒 暂停功能\n^Z #此时挂起后是停止的\n[1]+ 已暂停             sleep 3\n# jobs\n[1]+ 已暂停             sleep 3\n# bg 1  #激活后台的sleep 3\n# sleep 30 &  #加\"&\"直接在后台进行\n# jobs\n[1]+ 运行中             sleep 3\n[2]+ 运行中             sleep 30\n# fg 2  #把sleep 30恢复到前台\n# jobs -l #多加显示进程的PID号\n```\n\n* Ctrl + z 挂起当前进程\n* jobs 查看后台任务列表\n* fg 将后台任务恢复到前台\n\n**杀死进程**\n\n```bash\n[root@localhost ~]# kill [PID号]\n[root@localhost ~]# killall sleep #杀死所以sleep名的进程\n#假设有一个lisi用户在vim list.txt状态\n[root@localhost ~]# pstree -apu lisi\nbash,4419\n\tvim,5213 list.txt\n[root@localhost ~]# kill [-9] 5213 #此时lisi的vim状态终止 -9是暴力删除的方法\n\n[root@localhost ~]# pkill -9 -U lisi #强制踢出lisi 此时lisi的终端退出了\n```\n\n\n\n## 日志\n\ntail -f 查看\n\n```bash\n# tail -f /opt/1.txt\n```\n\n![image-20221129095411871](D:\\Typora\\images\\image-20221129095411871.png)\n\n# 服务器搭建\n\n## 搭建ftp\n\nFTP：文件传输协议 虚拟机 A（svr7）搭建基本 FTP 服务 \n\n安装 vsftpd 软件\n\n```bash\n[root@JSever ~]# yum -y install vsftpd \n```\n\n重启 vsftpd 服务 \n\n```bash\n[root@JSever ~]# systemctl restart vsftpd\n\n[root@JSever ~]# systemctl enable vsftpd \n```\n\n允许匿名访问\n\n```bash\n[root@JSever ~]# vim /etc/vsftpd/vsftpd.conf\n```\n\nanonymous_enable=NO 改成YES\n\n客户机访问：\n\n```bash\n[root@JClient ~]# firefox ftp://192.168.4.7\n```\n\n默认共享数据的目录：`/var/ftp`\n\n### 上传\n\n```bash\nftp 192.168.4.5\nput 文件\n```\n\n必须要用户登录，匿名登陆会`permission denied`\n\n## 搭建http服务\n\n虚拟机 svr7 作为服务端，搭建 web 服务器 \n\n1、安装软件包\n\n```bash\n[root@svr7 ~]# yum -y install httpd \n```\n\n2、书写页面内容，重启服务 \n\n```bash\n[root@svr7 ~]# echo xixhaha > /var/www/html/index.html \n[root@svr7 ~]# systemctl restart httpd pc207 \n```\n\n作为客户端测试，成功 \n\n```bash\n[root@pc207 ~]# curl 192.168.4.7 3\n```\n\n修改配置文件 /etc/httpd/conf/httpd.conf，改变网页文件存放路径\n\n```bash\n[root@svr7 ~]# vim /etc/httpd/conf/httpd.conf \nDocumentRoot \"/var/www/myweb\" \n\nDirectoryIndex index.html #默认网站起始页\n```\n\n改变网页文件存放路径\n\n```bash\n[root@svr7 ~]# mkdir /var/www/myweb \n[root@svr7 ~]# echo wo shi myweb > /var/www/myweb/index.html \n[root@svr7 ~]# systemctl restart httpd pc207 作为客户端测试，成功\n[root@pc207 ~]# curl 192.168.4.7\n```\n\n### 配置一个虚拟站点 \n\n • 配置文件路径 \n\n– /etc/httpd/conf/httpd.conf #主配置文件\n\n – /etc/httpd/conf.d/*.conf #调用配置文件 \n\n为每个虚拟站点添加配置  \n\n<VirtualHost *:80>\n\nServerName 此站点的 DNS 名称 \n\nDocumentRoot 此站点的网页根目录 \n\n\\</VirtualHost>\n\n虚拟机 svr7 作为服务端操作 \n\n```bash\n[root@svr7 ~]# vim /etc/httpd/conf.d/nsd01.conf \nNameVirtualHost *:80 #请用机器的 IP 代替\\*号 \n#开启虚拟主机，在所有 IP 地址上启用 80 端口 \n<VirtualHost *:80>\nServerName www.qq.com #指定访问的域名 \nDocumentRoot /var/www/qq #指定网页文件路径 \nServerName www.baidu.com \nDocumentRoot /var/www/baidu \n</VirtualHost>\n```\n\n\n\n```bash\n[root@svr7 ~]# mkdir /var/www/qq\n[root@svr7 ~]# mkdir /var/www/baidu \n[root@svr7 ~]# echo wo shi qq > /var/www/qq/index.html\n[root@svr7 ~]# echo wo shi baidu > /var/www/baidu/index.html \n[root@svr7 ~]# systemctl restart httpd\n```\n\n pc207 测试：\n\n```bash\n[root@pc207 ~]# vim /etc/hosts 192.168.4.7 www.qq.com www.baidu.com\n[root@pc207 ~]# curl www.qq.com \nwo shi qq \n[root@pc207 ~]# curl www.baidu.com\n```\n\n\n\n>  第一个虚拟站点被视为默认站点\n\n若想要原有的初始的话，虚拟站点配置上面另外加：\n\n```bash\n<VirtualHost *:80>\n\tDocumentRoot /var/ftp/ \n</VirtualHost>\n```\n\n","tags":["笔记","Linux"],"categories":["本科课程"]},{"title":"软件工程导论学习笔记","url":"/2023/01/01/软件工程导论学习笔记/","content":"\n# 作业题\n\n## 能力成熟度模型\n\n* 软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是\n\n  A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 \n\n  <u>B.使用标准开发过程（或方法论）构建（或集成）系统</u> \n\n  C.管理层寻求更主动地应对系统的开发问题 \n\n  D.连续地监督和改进标准化的系统开发过程\n\n  解析：A基本管理属于2可重复级；C属于已管理级；D改进属于5优化级；B标准属于3已定义级\n\n![image.png](https://s2.loli.net/2022/09/05/QlKeMdZCzwSc4ks.png)\n\n* 软件能力成熟度模型（CMM)的第 4 级（已管理级）的核心是 。 \n\n  A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 \n\n  B.组织具有标准软件过程 \n\n  C.对软件过程和产品都有定量的理解和控制 \n\n  D.先进的新思想和新技术促进过程不断改进\n\n  解析：4已管理级关键词：定量，预测\n\n## 软件过程模型\n\n* 为了有效地捕获系统需求，应采用 .\n\n  A.瀑布模型 B.V 模型 <u>C.原型模型</u> D.螺旋模型\n\n  解析：\n\n  * 瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。该模型适用于项目**开始时需求已确定**的情况。\n\n  * V 模型是**瀑布模型的变种**，它说明测试活动是如何与分析和设计相联系的。\n\n  * 原型模型允许开发人员**快速地构造**整个系统或系统的一部分以理解或澄清问题。原型的用途是**获知用户的真正需求**，因此原型模型可以有效地引发系统需求。\n\n  * 螺旋模型把开发活动和**风险管理**结合起来，以将风险减到最小并控制风险。\n  * 演化模型在获取**一组基本的需求**后，通过快速分析构造出该软件的一个初始可运行版本，然后逐步演化成为最终软件产品。\n  * 增量模型是一种阶段化的软件开发过程模型。在该过程模型中，客户提出系统需求，并指出**哪些需求是最重要的**。开发团队把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成， 并且能完成特定的功能。其优点包括：能**较短时间**内向用户提交可完成一些有用的工作产品；逐步增加产品的功能，使用户有较充裕的时间学习和适应新产品；项目失败的风险较低；优先级最高的服务首先交付，然后依次将其他 构件集成进来，这意味着最重要的服务将接受最多的测试。**快速发布**\n  * 喷泉模型是典型的**面向对象**生命周期模型，是一种以用户需求为动力，以对象作为驱动的模 型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。“喷泉” 一词本 身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程 中不断地完善软件系统；无间隙是指在开发活动之间**不存在明显的边界**。\n\n## 系统工程\n\n* 经济可行性研究的范围包括（ ） \n\n  A、技术有效性 B、管理制度 <u>C、效益分析</u> D、开发风险\n\n  解析：\n\n  * 经济可行性主要进行成本效益分析，从经济角度，确定系统是否值得开发\n  * 技术可行性主要根据系统的功能、性能、约束条件等，分析在现有资源和技术条件下系统能否实现\n  * 法律可行性合同责任、侵犯专利权、版权等问题\n\n* （多选题）在对协同电子商务平台项目进行技术可行性分析的过程中需要注意哪些方面？ （ ） \n\n  <u>A、在限制条件下，功能目标是否能达到</u>\n\n  <u>B、利用现有技术，性能目标是否能够达到</u> \n\n  <u>C、对开发人员数量和质量的要求，并说明能否满足</u> \n\n  <u>D、在规定的期限内，开发是否能够完成</u>\n\n  解析：根据软件设计文档国家标准（GB8567-2006）的要求，技术可行性章节应该主要包含 以下内容： \n\n  1.在当前的限制条件下，该系统的功能目标能否达到 \n\n  2.利用现有的技术，该系统的功能能否实现 \n\n  3.对开发人员的数量和质量的要求，并说明这些要求能否满足 \n\n  4.在规定的期限内，本系统的开发能否完成 除了上述内容之外，技术可行性部分应该对当前开发所使用的主流研发框架和架构做简要的 介绍和说明，不限于图表和文字等方式。\n\n* 为了分析顾客不同情况下的订票习惯，可采用以下哪种需求获取方式（ ）\n\n  A、正式访谈 B、非正式访谈 C、调查表 <u>D、观察实践</u>\n\n  解析：错选C，使用观察实践，情景分析获取用户在不同场景下的不同需求。\n\n## 结构化方法和数据流图\n\n* 面向数据流自顶向下求精过程不包括\n\nA、分析追踪数据流图\n\nB、用户复查\n\nC、细化数据流图\n\nD、实现数据流图\n\n# 软件工程与软件过程\n\n## 软件\n\n**软件=程序+数据+文档**\n\n### 计算机软件\n\n* 计算机软件是指计算机系统中的程序及其文档\n* 程序是计算任务的处理对象和处理规则的描述\n* 文档是为了便于了解程序所需的阐明性资料\n\n### 软件的特点\n\n* 软件是一种逻辑实体，而不是有形的系统元件，其开发成本和进度难以准确地估算\n* 软件是被开发或被设计的，没有明确的制造过程，一旦开发成功，只需复制即可，但其维护的工作量大\n* 软件的使用没有硬件那样的机械磨损和老化问题\n* 软件不能独立存在，需要依附于一定的环境(如硬件、网络以及其他软件等)\n* 软件必须遵从人为的惯例，并适应已有的技术和系统。\n* 软件需要随接口的不同而改变\n\n### 软件的分类\n\n有多种分类方法。\n\n* 基础设施类\n  * 系统软件\n  * 支持软件\n* 应用类\n  * 应用软件\n\n## 软件工程\n\n**软件工程学科出现的主要原因是软件危机的出现**\n\n### 软件危机\n\n* 一个合格的软件开发是按时按量按质实现软件\n* 许多软件项目不能满足客户的要求\n* 许多软件项目超出预算和时间安排\n\n![image.png](https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png)\n\n![image.png](https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png)\n\n\n\n### 软件工程的定义\n\n**1968年NATO(北大西洋公约组织)会议上首次提出**\n\n**计算机科学技术百科全书**：软件工程是应用计算机 科学、数学及管理科学等原理，开发软件的工程。 软件工程借鉴传统工程的原则、方法，以提高质量、 降低成本为目的\n\n\n\n### 软件生存周期\n\n软件有一个孕育、诞生、成长、成熟、衰亡的生存过程。这个过程即为计算机**软件的生存周期**\n\n软件生存周期大体可分为如下几个活动：\n\n```mermaid\ngraph LR\nA(计算机系统工程) ---B(需求分析)\n\n    B --- C(设计)\n    C ---D(编码)\n    D---E(测试)\n    E---F(运行)\n    F---G(维护)\n\n```\n\n\n\n# 软件过程模型(8种)\n\n![image.png](https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png)\n\n![image.png](https://s2.loli.net/2022/09/05/tpu6mjN18L3hBvf.png)\n\n## 能力成熟度模型\n\n### 能力成熟度模型CMM\n\n原本是评估依据，后来用于改进软件管理过程\n\n![image.png](https://s2.loli.net/2022/09/05/QlKeMdZCzwSc4ks.png)\n\n### 能力成熟度模型集成CMMI\n\n#### 阶段式模型 (整体能力的划分)\n\n![image-20220905211312772](https://jjuprising.github.io/images/SE_Note/image-20220905211312772.png)\n\n#### 连续式模型(某方面能力的衡量)\n\n![image-20220905211353252.png](https://s2.loli.net/2023/10/07/NKvxRji3V1G6TPh.png)\n\n![image-20220905211407538](https://jjuprising.github.io/images/SE_Note/image-20220905211407538.png)\n\n\n\n## 软件过程模型\n\n| 软件过程模型 | 瀑布模型                                         | 增量模型                                                     | 原型模型                                                     | 螺旋模型                                                     | 喷泉模型                                                     | 基于构件的开发模型                           | 形式化方法                                                   |\n| ------------ | ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------------------------------------ |\n| 特点         |                                                  | 首先有完成核心基本需求，再逐步确定非核心；多个增量可叠加     | 反映系统性质的一个子集                                       | 风险驱动的软件过程模型，把开发活动和**风险管理**结合起来，以将风险减到最小并控制风险 | 基于面向对象思想、迭代、无间隙。模型各个阶段没有明显界限，开发人员同步进行开发 | 利用预先包装的构件来构造应用系统             | 是建立在 **严格数学基础**上。开发过程重凡是采用严格 的数学语言，具有精确的数学语义的方法，都称为形 式化方法 |\n| 适用场景     | 项目开始前需求和解决方案就很明确，短期或中期项目 | 不完全明确但知道核心需求，急需使用的软件，需求经常变化       | 要从用户身上了解主要需求，周期是一个环型，可废弃上一个原型或在其基础上追加 |                                                              | 适应于面向对象的软件开发过程，以对象为驱动，只用对象和关系实现活动的迭代和无间隙 | 构件化结构，可以尽量重用已有的组件。         | 对安全性、可靠性极高                                         |\n| 优缺点       | 缺：缺乏灵活性、维护代价大                       | 各增量构件均为一个可操作产品。融合了瀑布模 型的基本成分（重复地应用）和演化模型的迭代特征，特别适用于**需求经常发生变化**的软件开发。 | 用户需要方面，重交互。缩短了开发周期，加快了工程进 度，降低成本。 | 将原型实现的**迭代特征**与瀑布模型中**控制的**和**系统化的**方面结合起来， 不仅体现了这两种模型的优点，而且增加了**风险分析** | 可以提高软件 项目开发效率，节省开发时间                      | 减少开发、降低风险和成本、需求妥协、快速交付 | 易于发现需求的歧义性、不完整性和不一致性，易于对分析模型、 设计模型和程序进行验证。 |\n\n\n\n### 瀑布模型\n\n**项目需求方案明确，短期小型工程**\n\n从下到上很难，不适用需求经常换的\n\n![image-20220905211552135](https://jjuprising.github.io/images/SE_Note/image-20220905211552135.png)\n\n![image-20220905211651996](https://jjuprising.github.io/images/SE_Note/image-20220905211651996.png)\n\n![image-20220905211703289](https://jjuprising.github.io/images/SE_Note/image-20220905211703289.png)\n\n\n\n### 演化模型\n\n开发早期对软件需求的认识是模糊的、不确定的，因此软件很难一次开发成功。逐步演化而来\n\n**开发的软件，需求不能一次搞清楚**，且系统需求比较复杂？\n\n答案：用演化模型\n\n```mermaid\ngraph LR\nA{演化模型}-->B(增量模型)\nA-->C(原型模型)\nA-->D(螺旋模型)\n```\n\n#### 增量模型\n\n**每次增量都可用**，有核心需求，急需使用的软件。多个增量可重叠\n\n![image-20220905212334175](https://jjuprising.github.io/images/SE_Note/image-20220905212334175.png)\n\n* 适用于**需求经常发生变化**的软件开发\n* 第一个增量**通常是核心产品**\n\n![image-20220905212549792](https://jjuprising.github.io/images/SE_Note/image-20220905212549792.png)\n\n#### 原型模型\n\n**原型**（prototype）是预期系统的一个可执行版本，反映 了系统性质（如功能、计算结果等）的一个选定的子集。\n\n![image-20220905212656390](https://jjuprising.github.io/images/SE_Note/image-20220905212656390.png)\n\n**特点：**\n\n* 用户不能完全准确表达对未来系统的全面要求\n* 开发者对要解决的问题的应用问题模糊不清\n* 一圈出来一个版本\n\n**类型：**\n\n* 探索型\n* 实验型\n* 演化型\n\n![image-20220905212802183](https://jjuprising.github.io/images/SE_Note/image-20220905212802183.png)\n\n#### 增量模型和原型模型的区别\n\n核心都是迭代，但增量模型强调**各增量构建均是一个可操作产品**。原型模型不断讨论修改完善。\n\n![image-20220905212909013](https://jjuprising.github.io/images/SE_Note/image-20220905212909013.png)\n\n![image-20220905213105101](https://jjuprising.github.io/images/SE_Note/image-20220905213105101.png)\n\n\n\n#### 螺旋模型\n\n* 有风险机制\n\n![image-20220905213228769](https://jjuprising.github.io/images/SE_Note//image-20220905213228769.png)\n\n![image-20220905213239716](https://jjuprising.github.io/images/SE_Note/image-20220905213239716.png)\n\n\n\n![image-20220905213315281.png](https://s2.loli.net/2023/10/07/Y1qzk3BKaL7mCfS.png)\n\n### 喷泉模型\n\n* 像喷泉从下往上，后面的工作在做前面的也没停止\n* **基于面向对象思想**，迭代、无间隙\n\n> 注意，面向对象不是喷泉独有的，其他一些模型也有\n\n### 基于构件的开发模型\n\n![image-20220905213500212.png](https://s2.loli.net/2023/01/01/J6ESlVFpTYn2toH.png)\n\n![image-20220905213513555.png](https://s2.loli.net/2023/01/01/E5jG9oyJmnvCDQP.png)\n\n### 形式化模型\n\n**建立在严格数学基础上**\n\n![image-20220905213521544.png](https://s2.loli.net/2023/01/01/xLlysfnHRP4CeU2.png)\n\n## CASE工具和环境的重要性\n\nCASE 已被证明可以**加快开发速度**,提高应用软件生产率并保证应用软件的可靠品质。计算机专业人员利用计算机使他们的企业提高了**效率**,企业的各个部门通过使用计算机 **提高了生产率和效率**,增强了企业的竞争力并使之**带来了更多的利润**。\n\n# 系统工程\n\n## 系统工程的任务\n\n1. 识别用户的要求\n\n   * 识别基于计算机系统的整体要求\n   * 标识系统的功能和性能范围\n   * 确定系统的功能、性能、约束和接口\n\n2. 系统建模和模拟\n\n   考虑以下模型：\n\n   * 硬件系统模型\n   * 软件系统模型\n   * 人机接口模型\n   * 数据模型\n\n3. 成本估算及进度安排\n\n   需要一定的资金投入和时间约束\n\n   * 进行成本估算\n   * 作出进度安排\n\n4. 可行性分析\n\n   主要从**经济**、**技术**、**法律**等方面分析所给出的解决方案是否科学。\n\n5. 生成系统规格说明\n\n   作为以后开发基于计算机的系统的依据\n\n## 可行性分析的任务\n\n1. 经济可行性：确定系统是否值得开发\n   * 成本\n   * 效益\n   * 货币的时间价值\n   * 投资的回收期\n   * 纯收入\n2. 技术可行性：分析系统在现有资源和条件下能否实现\n   * 风险分析\n   * 资源分析\n   * 技术分析\n3. 法律可行性：是否引起侵权、破坏等责任问题\n4. 方法的选择和折衷\n\n# 需求工程\n\n## 需求工程的具体步骤和任务\n\n1. 需求获取\n\n   * 系统分析人员通过与用户的交流\n\n   * 对现有系统的观察及时对任务进行分析\n\n2. 需求分析与协商：\n\n   * 分析每个需求与其他需求的关系以检查需求的一致性、重叠和遗漏的情况\n   * 并根据用户的需求对需求进行排序\n\n3. 系统建模\n\n   通过合适的工具和符号系统地描述需求\n\n4. 需求规约\n\n   给出对目标软件的各种需求\n\n5. 需求验证\n\n   对功能的正确性、完整性和清晰性以及其他需求给予评价\n\n6. 需求管理\n\n   对需求工程所有相关活动的规约和控制\n\n## 制定需求获取策略主要考虑因素\n\n1. 功能需求\n\n   * 考虑系统要做什么，在何时做\n   * 在合适及如何修改或升级\n\n2. 性能需求\n\n   考虑软件开发的技术性指标\n\n3. 用户或人为因素\n\n   考虑用户的类型\n\n## 需求获取的方法和策略\n\n* 建立顺畅的通信途径\n* 访谈与调查\n* 亲身实践\n* 会议\n* 头脑风暴\n* 概念建模\n* 原型、仿真\n* 自省\n* 用户行为数据在线采集\n\n# 设计工程\n\n## 软件设计原则\n\n![image.png](https://s2.loli.net/2022/10/10/davFu8RwlArpiVI.png)\n\n### 抽象与逐步求精\n\n抽象\n\n* 在最高层用术语概括性描述\n* 在中间层次用面向过程化方法\n* 在最低层用直接实现的方式\n\n抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面\n\n分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止\n\n随着分解层次的增加，抽象的级别越来越低，也越接近问题的解(算法和数据结构)\n\n### 模块化\n\n模块化：就是把程序划分成**独立命名**且**可独立访问**的模块，<u>每个模块完成一个子功能</u>，把这些模块集成起来构成 一个整体，可以完成指定的功能满足用户的需求。\n\n如果一个大型程序仅由一个模块组成，它将很难被人所理解。\n\n“分而治之”\n\n问：程序采用模块化设计，有哪些优点？\n\n答：程序采用模块化设计，有以下优点：\n\n* 将问题**简化**，划分模块可使每一个模块完成单一的功能， 模块之间的联接**关系简单，具有独立性**；\n\n* 可以独立的进行模块的编码测试，**便于**软件开发工作的**组织**； \n\n* 把每一个模块要解决的问题局限在有限的范围，减少出错 机会，易于修改和维护； \n\n* 有助于软件项目的组织管理，一个复杂的大型软件可以由许多程序员分工编写，提高了开发效率；\n\n* 一个模块可被重复使用，以提高软件产品的复用率；\n\n* 利于估计工作量和开发成本。\n\n### 信息隐藏\n\nDavid Parnas在1972年最早提出信息隐藏的观点。 他在其论文中指出：代码模块应该采用定义**良好的接口来封装**，这些模块的内部结构应该是程序员的<u>私有财产</u>，**外部是不可见的**。\n\n![image.png](https://s2.loli.net/2022/10/10/9nd6RIPijVxOTJB.png)\n\n![image.png](https://s2.loli.net/2022/10/10/VrDELpCFW39o8qu.png)\n\n### 功能独立\n\n**功能独立**：功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果。\n\n两个定性标准:\n\n* **内聚**衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高， 每个模块完成一个相对独立的特定子功能。\n* **耦合**衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低， 即每个模块和其他模块之间的关系要简单。\n\n#### 内聚\n\n紧密程度\n\n![image.png](https://s2.loli.net/2022/10/10/jaSGfgXEFWDPJ8c.png)\n\n**逻辑内聚**\n\n![image.png](https://s2.loli.net/2022/10/10/nF8tCzcJSG13lwj.png)\n\n**时间内聚**：初始化\n\n![image.png](https://s2.loli.net/2022/10/10/5FKcoBhSNVbADPi.png)\n\n**过程内聚**：按任务的顺序\n\n![image.png](https://s2.loli.net/2022/10/10/kwQKtarTVlUfO6b.png)\n\n**通信内聚：**模块的功能都要做，但数据集都是同一个(和逻辑内聚区分)\n\n![image.png](https://s2.loli.net/2022/10/10/fFGLyZwlS1DzPH6.png)\n\n**顺序内聚**：既要按任务的顺序，一个的输出要作为另一个的输入\n\n![image.png](https://s2.loli.net/2022/10/10/lqcG8YRELWIj2B6.png)\n\n**功能内聚：**只完成一项工作\n\n![image.png](https://s2.loli.net/2022/10/10/u7xpYin3QfP6vrw.png)\n\n> 通信内聚和逻辑内聚区分：前者数据集都是同一个，但是逻辑内聚也可以同一个数据集，这时看是否有传入参数来决定执行的操作。\n\n#### 耦合\n\n相互依赖程度\n\n![image.png](https://s2.loli.net/2022/10/10/muHznSwG4AUZh9D.png)\n\n![image.png](https://s2.loli.net/2022/10/10/4RskMoqDwX1IZBl.png)\n\n**内容耦合**\n\n\n\n**公共耦合**\n\n![image.png](https://s2.loli.net/2022/10/10/gp8JmvDkSNWCjKt.png)\n\n**外部耦合**\n\n![image.png](https://s2.loli.net/2022/10/10/ihCr2TUudtngO5p.png)\n\n**控制耦合**\n\n![image.png](https://s2.loli.net/2022/10/10/d27ZoUByTLlGgpH.png)\n\n**标记耦合**\n\n![image.png](https://s2.loli.net/2022/10/10/j4zUNOKLHdBc3b8.png)\n\n**数据耦合**\n\n例如中途调用的函数\n\n![image.png](https://s2.loli.net/2022/10/10/7rn6oSjt13lwFNY.png)\n\n**非直接耦合**\n\n![image.png](https://s2.loli.net/2022/10/10/k5Wa8xEfKgqIe4O.png)\n\n> 标记耦合传的是数据结构的一部分，如数组、字符串等，而数据耦合传的是简单数据\n\n**高内聚，低耦合**\n\n# 结构化程序设计方法\n\n详细描述处理过程常用工具：图形、表格和语言\n\n* **图形**：程序流程图、N-S图、PAD图\n* **表格：**判定表\n* **语言：**过程设计语言(PDL)\n\n![image-20221222113658687.png](https://s2.loli.net/2023/01/01/PEJ5udxMpYl3LFQ.png)\n\n## 结构化分析方法\n\n* **结构化方法**：它以**数据流**为中心构建软件的分析模型和设计模型\n* **结构化分析与建模：**主要思想：**抽象**与自顶向下的**逐层分解**（控制复杂性的两个基本手段）\n* **抽象**：<u>忽略</u>一个问题中与当前目标<u>无关</u>的那些方面，以便更<u>充分地关注</u>与当前目标<u>有关</u>的方面。\n* **分解**：将问题<u>不断分解为较小的问题</u>，直到每个最底层的问题都足够简单为止。\n* 结构化系统分析模型组成结构有：\n  * E-R图\n  * 数据流图(DFD)\n  * 状态变迁图(STD图)\n  * 数据字典(DD)\n\n## 数据流图\n\n主要思想：数据流图描述**输入数据流到输出数据流的变换（即加工）**，用于对系统的**功能建模**。\n\n符号：\n\n* ⚪或椭圆 表示加工，也叫数据处理\n* ▭ 矩形表示数据流的源点或终点，统称外部实体\n* ＝ 双杠，文件或数据存储\n* → 箭头表示数据流\n\n使用数据流图进行需求分析的过程： \n\n1. 画出**系统的输入和输出**。 \n\n   A. 确定源和宿 \n\n   B. 确定加工 \n\n   C. 确定数据流 :输入数据流，输出数据流\n\n   D. 顶层图通常没有文件\n\n2. 画出**系统内部**。 \n\n   A. 确定加工 ：确定父图中某加工分解而成的子加工\n\n   B. 确定数据流 ：沿用或新增\n\n   C. 确定文件 \n\n   D. 确定源和宿 \n\n3. 画出**加工内部**。 \n\n4. **重复第 3 步**，直至每个尚未分解的加工都足够简单（即不必再分解）。\n\n![image.png](https://s2.loli.net/2022/10/17/e2A5DEB9hJbNQSd.png)\n\n![1f10dc03d569bb00e848cdecb12578d.jpg](https://s2.loli.net/2022/10/17/iJW7DaF1Vecdp98.jpg)\n\n### 画顶层图\n\n* 顶层图有唯一的**加工**：**椭圆**表示\n* 系统之外的源或宿(**外部实体**)：**矩形**表示\n\n![image.png](https://s2.loli.net/2022/10/17/mbPQCDagNr3YwsA.png)\n\n步骤：\n\n* 确定唯一加工\n* 确定功能需求和外部实体(源或宿)\n* 确定数据流：系统的输入/输出信息\n\n### 画0层图\n\n步骤：\n\n* 确定加工：确定父图中某加工分解而成的子加工\n\n  * 根据功能分解来确定加工：将一个复杂的功能分解成若干个较小的功能，较多应用于高层DFD中的分解\n\n  ![image.png](https://s2.loli.net/2022/10/17/x6VMIClHh4kjSva.png)\n\n* 确定源和宿\n\n  ![image.png](https://s2.loli.net/2022/10/17/pSnGTO9XbVtL7aK.png)\n\n* 确定数据流\n\n  * 沿用父图\n  * 新增数据流\n\n​\t![image.png](https://s2.loli.net/2022/10/17/VDchlKxzmu61bjU.png)\n\n![image.png](https://s2.loli.net/2022/10/17/gYoK9xfAPbw4HBm.png)\n\n* 确定文件\n  * 已有文件则应画在子图中\n  * 分解子图中，若需要保存某些**中间数据**以备后用，则可以讲这些数据**组成一个新的文件**\n  * 新文件**至少**应有**一个加工**为其**写入**记录，同时至少存在**另一个加工**来**读**该文件。\n\n\n![image.png](https://s2.loli.net/2022/10/17/4C1gEOSxVMWvBdw.png)\n\n\n\n### 画1层图(画加工内部)\n\n复杂的加工可以继续分解为一张DFD子图\n\n分解方法：\n\n1. 指定图中的某一个加工看作一个小系统，系统的输入输出流就是这个加工的输入输出流\n2. 然后采用画0层图的方法，画出该加工的子图\n\n* 加工1子图内部，即考试报名内部\n\n  ![image.png](https://s2.loli.net/2022/10/17/QAyS8zXP56MdBFv.png)\n\n* 加工2子图，即统计成绩\n\n  ![image.png](https://s2.loli.net/2022/10/17/LXCn9rv8dRhwF4O.png)\n\n  \n\n### \t总结\n\n画分层数据流图的步骤：\n\n1. 画系统的输入和输出 \n2. 画系统内部 \n3. 画加工内部 \n4. 重复第3步，直至每个尚未分解的加工都足够简单 (即不必再分解)\n\n**注意：**千万不要试图在数据流图中表现分支条件或循环，这样会造 成混乱，画不出正确的数据流图。\n\n检查分层细化时是否保持信息的连续性，即当把一个处理分解成一 系列处理时，**分解前和分解后的一系列输入输出数据流必须相同**， 这条规则也成为数据流图的数据平衡原则。\n\n### 审查\n\n完整性：\n\n* 每个加工至少有一个输入数据流和一个输出数据流\n* 分层数据流图，每个文件应至少有一个加工读取该文件，有另一个加工写该文件\n* 画的是数据流而不是控制流\n\n## 数据字典\n\n### 判定表\n\n确定四个区域的内容\n\n![image.png](https://s2.loli.net/2022/10/24/JSYHGaeViP3xkpq.png)\n\n简化标准：\n\n* 具有相同的操作\n* 有且仅有一个不同的取值，简化后用小横杠表示，如本题简化后第四列第一个\n\n### 判定树\n\n![image.png](https://s2.loli.net/2022/10/24/u4pPRwCJdNif8H2.png)\n\n* 根节点是加工过\n* 最右边是具体的部分\n* 中间的部分都是影响条件\n\n## 模块结构图\n\n![image-20221024114704451.png](https://s2.loli.net/2022/10/24/mUgcPKGrYQ1HZxN.png)\n\n\n\n**注意：**\n\n* 模块之间相连的线段(调用)是没有方向的，有方向的是数据流\n\n### 结构图\n\n基本成分：模块，调用，数据\n\n类树形结构\n\n\n\n![image.png](https://s2.loli.net/2022/10/24/exKtDhSZQsT49EO.png)\n\n* 扇入是别人调用他的个数\n* 扇出是他调用别人的个数\n\n#### 含义\n\n* 深度和宽度在一定程度上反映了程序的规模和复杂程度\n* 一个模块的扇出过大通常意味着该模块**比较复杂**，然而扇出太少可能导致深度增加\n* 一个模块的扇入表示有多少模块可直接调用它，它反映了该模块的**复用程度**，因此模块的扇入越大越好\n\n# 面向数据结构的分析与设计\n\n## 什么是面向数据结构的方法\n\n### 面向数据结构的方法是\n\n·    以数据结构为中心\n\n·    从输入/输出的数据结构导出程序结构的\n\n·    一种软件需求分析与设计的方法\n\n### 特点\n\n·    ①以信息对象及其操作作为核心进行需求分析\n\n·    ②认为复合信息对象具有层次结构，并且可按顺序、选择、重复3种结构分解为成员对象信息\n\n·    ③提供由层次信息结构映射为程序结构的机制，从而为软件设计奠定良好的基础\n\n##  Jackson图的三种结构\n\n###  顺序元素\n\n![clip_image002-16726347926341.jpg](https://s2.loli.net/2023/01/02/1yQb58xAS4MXKJF.jpg)\n\n\n\n### 1.1.1.   选择元素\n\n\n\n![clip_image004.jpg](https://s2.loli.net/2023/01/02/njSyKTiwJHlGs9c.jpg)\n\n### 1.1.2.   重复元素\n\n\n\n![clip_image006.jpg](https://s2.loli.net/2023/01/02/XGRIbx8d6tNSjDa.jpg)\n\n# 面向对象方法基础\n\n## UML\n\n![image.png](https://s2.loli.net/2022/11/07/KW6VSTxIouspc1M.png)\n\n![image.png](https://s2.loli.net/2022/11/07/KW6VSTxIouspc1M.png)\n\n![image.png](https://s2.loli.net/2022/11/07/42SDw59mAWZMY8Q.png)\n\n![image.png](https://s2.loli.net/2022/11/07/mzcuO8wNeVX4Sja.png)\n\n### UML语言中的关系\n\n·    关联\n\n·    依赖\n\n·    泛化\n\n·    实现\n\n·    聚合\n\n·    组合\n\n### UML包含的视图(红色为已学)\n\n####  结构化\n\n##### 静态视图\n\n•  类图(class)\n\n•   展示类与类之间的相互联系，如关联、依赖、泛化等。可以把若干个相关类包装在一起作为一个单元(包)，相当于一个子系统。。\n\n•   一个系统可以有多张类图，一个类也可以出现在几张类图中\n\n•   对象图是类的实例。区分：对象图在对象名下面加了下划线，同时显示对象间的实例连结关系\n\n•   类\n\n•   类间关系\n\n•   四种\n\n•   依赖\n\n•   ---> 被依赖元素的变化会要求或指示依赖元素的改变(例如类A的方法仅仅使用了类B的对象，那么类A依赖于类B)\n\n•   访问\n\n•   绑定\n\n•   调用\n\n•   创建\n\n•   派生\n\n•   实例化\n\n•   允许\n\n•   实现\n\n•   精化\n\n•   发送\n\n•   使用\n\n•   关联(聚集、组合)\n\n•   对象与其他实例的连接\n\n•   聚集 ——♢ “部分”对象可以是任意整体对象的一部分\n\n•   组合 ——◆ 更强形式的关联，具有强的物主身份，即“整体”对象拥有“部分”对象(例如类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系)\n\n•   是一种拥有的关系，它使一个类知道另一個类的属性和方法；如：老师与学生，丈夫与妻子的关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者沒有箭头，单向的关联有一个箭头。\n\n•   泛化 —▷ 继承，由子类指向父类\n\n•   实现 ---▷ 类连接到接口，接口是行为规划而不是结构\n\n•   强度：依赖<关联<聚集<组合<泛化=实现，类间关系依次增强\n\n属性和操作\n\n•   属性中的变量名要小写\n\n主要版型\n\n•   边界类\n\n•   控制类\n\n•   实体类\n\n设计视图\n\n•  内部结构(internal structure)\n\n•  协作图(collaboration)\n\n•  构件图(component)\n\n用况视图\n\n•  用况图(use case)\n\n•   展示各类外部执行者与系统提供的用况之间的连接。用况图给出用户所感受到的系统行为，但不描述系统如何实现该功能\n\n•   用况--系统的功能，执行者--使用功能的人或外部系统\n\n•   主要元素\n\n•   参与者\n\n•   用例\n\n•   关系\n\n•   关联 ———————————\n\n•   包含 ——<<include>>——\n\n•   扩展 ——<<Extend>>——\n\n•   泛化 ——————————▷\n\n动态的\n\n•   状态机视图\n\n* 状态机图(state machine)\n  * 通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。\n  * 状态的改变成为迁移(transition)。一个状态迁移还可以有与之相关的动作，该动作指出状态迁移时应做什么。\n  * 不是所有的类都要画状态，应当满足这些条件才画\n  * 有一些意义明确的状态\n  * 其行为受不同的状态所影响和改变\n\n•  活动视图\n\n* 活动图(activity)\n  * 描述完成一个操作(如用况)所需要的活动\n  * 由动作状态组成\n  * 完成一个动作的活动的规约\n  * 一个动作完成时，离开该动作状态\n  * 消息发送和接收的规约\n\n•   交互视图\n\n* 顺序图(sequence)\n  * 展示几个对象之间的动态交互关系。\n  * 主要显示:对象之间发送消息的顺序，显示对象之间的交互，即系统执行的某一特定点所发生的事\n\n* 通信图(communication)\n\n·    物理的\n\n* 部署视图\n  * 部署图(deployment)\n\n·    模型管理\n\n* 模型管理视图\n  * 包图(package)\n\n* 剖图\n  * 包图(package)\n\n### UML包括哪四种事物？\n\n·    1.结构事物\n\n•   类\n\n•   接口\n\n•   用例\n\n•   主动类\n\n•   构件\n\n•   结点等\n\n·    2.动作事物\n\n•   状态等\n\n·    3.组织事物\n\n•   包\n\n·    4.注释事物\n\n•   给建模者提供信息，提供关于任意信息的文本说明，但没有语义作用\n\n# 面向对象建模\n\n## 用况建模\n\n执行者，用况\n\n用况是执行者想要做的事，执行者执行用况\n\n线段带箭头表示发起的方向\n\n注意扩展关系是扩展指向用况\n\n泛化(归纳)关系是子用况指向父用况，类似继承\n\n**实验****5** **面向对象方法的应用（1）**\n\n**用况建模**\n\n（1） **实验目的**\n\n掌握UML用况图的画法，学习在软件构思和需求分析阶段进行用况建模，学会填写相关文档。\n\n（2） **实验原理**\n\nü **统一建模语言**\n\n统一建模语言（UML）是一种用来对真实世界物体进行建模的标准标记，这个建模的过程是开发面向对象设计方法的第一步。\n\nUML从考虑系统的不同角度出发，定义了**用况****图、类图、对象图、状态图、活动图、序列图**、协作图、构件图、部署图等图形，这些图从不同的侧面对系统进行描述。系统模型将这些不同的侧面综合成一致的整体，便于系统的分析和构造。尽管UML和其它开发工具还会设计出许多派生的视图，但上述这些图和其它辅助性的文档是软件开发人员所见的最基本的构造。\n\nUML适用于系统开发过程中从需求规格描述到系统完成后测试的不同阶段。在需求分析阶段，可以用用况来捕获用户需求。通过用况建模，描述对系统感兴趣的外部角色及其对系统（用况）的功能要求。分析和设计阶段主要关心问题域中的主要概念（如类和对象等）和机制，需要识别这些类以及它们相互间的关系，并用UML类图来描述。为实现用况，类之间需要协作，这可以用UML动态模型来描述。\n\nü **用况模型**\n\n**用况**图定义：由执行者（Actor）、用况（Use Case）以及它们之间的关系构成的用于描述系统功能的静态视图称为用况图。用况图（User Case Diagram）是被称为执行者的外部实体所能观察到的系统功能的模型图，呈现了一些执行者和一些用例，以及它们之间的关系，展示了用况之间以及与执行者之间是怎样相互联系的，主要用于对系统、子系统或类的功能行为进行[建模](http://baike.baidu.com/view/44500.htm)。用况图定义了系统的功能[需求](http://baike.baidu.com/view/195818.htm)，它是从系统的外部看系统功能，并不描述系统内部对功能的具体实现。\n\n用况图由执行者（Actor）、用况（[Use Case](http://baike.baidu.com/view/1299332.htm)）、[系统边界](http://baike.baidu.com/view/3638793.htm)、箭头组成，用画图的方法来完成。 [ ](http://baike.baidu.com/picview/1281729/1281729/0/ae10edde0c56496f95ee3732.html?fr=lemma) \n\n* **执行者**（Actor）\n  * 定义：执行者（Actor）不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此执行者可以是人，可以是事物，也可以是时间或其他系统等等。还有一点要注意的是，参与者不是指人或事物本身，而是表示人或事物当时所扮演的角色。比如小明是图书馆的[管理员](http://baike.baidu.com/view/315045.htm)，他参与[图书馆管理系统](http://baike.baidu.com/view/125121.htm)的交互，这时他既可以作为管理员这个角色参与管理，也可以作为借书者向图书馆借书，在这里小明扮演了两个角色，是两个不同的执行者。\n  * 画法：执行者**在Visio称为“参与者”**，在画图中用简笔人物画来表示，人物下面附上执行者的名称。执行者的命名，通常是一些角色名，或者系统设备名等。\n\n![wps1.png](https://s2.loli.net/2023/01/01/lgSo1nzI4u6krPQ.png)\n\n \n\n* 用况\n  * 定义：是对包括[变量](http://baike.baidu.com/view/296689.htm)在内的一组动作序列的描述，系统执行这些动作，并产生传递特定执行者的价值的可观察结果。这是[UML](http://baike.baidu.com/view/23396.htm)对用况的正式定义，对我们初学者可能有点难懂。我们可以这样去理解，**用况**是执行者想要系统做的事情。\n  * 画法：**用况**在Visio称为“用例”，在画图中用[椭圆](http://baike.baidu.com/view/36981.htm)来表示，椭圆下面附上用况的名称。对于**用况**的命名，我们可以给用况取一个简单、描述性的名称，一般为**带有动作性**的词。\n\n![wps2.png](https://s2.loli.net/2023/01/01/g4etP6vLOEWkNVi.png)\n\n \n\n* **系统边界**\n  * 定义：[系统边界](http://baike.baidu.com/view/3638793.htm)是用来表示正在[建模](http://baike.baidu.com/view/44500.htm)系统的边界。边界内表示系统的组成部分，边界外表示系统外部。\n  * 画法：可使用Visio的“子系统”画系统边界，因为[系统边界](http://baike.baidu.com/view/3638793.htm)的作用有时候不是很明显，所以在画图时可省略。[系统边界](http://baike.baidu.com/view/3638793.htm)在画图中用方框来表示，同时附上系统的名称，执行者画在边界的外面，用况画在边界里面。命名时使用系统或子系统的名称就可以了。\n\n![wps3.png](https://s2.loli.net/2023/01/01/24ZFocTfRMJKGCw.png)\n\n \n\n**用况图中的关系**\n\n 定义：用况图中可表示执行者和用况之间，用况与用况之间，执行者与执行者之间的多种关系。\n\n* **关联关系**：执行者与用况之间的关系，表示用况是这个执行者发起的，执行者可以行使系统中的这个功能。关联关系在Visio中就称为“关联”，为一条**不带箭头**的线段。\n\n![wps4.png](https://s2.loli.net/2023/01/01/q6X1YKl9kTBPcEN.png)\n\n* **包含关系**：用况与用况之间的关系。基用况必须和被包含用况一起使用才够完整，被包含用况也必然被执行。包含关系在Visio中就称为“包含”，使用带箭头的虚线表示（在线上标注《》），箭头从基用况指向被包含用况。\n\n![wps5.png](https://s2.loli.net/2023/01/01/VTmEqrXUxPMGFAo.png)\n\n* **扩展关系**：用况与用况之间的关系。扩展用况是对基用况（被扩展用况）的扩展，**即使没有扩展用况的参与，也可以完成一个完整的功能**。扩展关系在Visio中就称为“扩展”，使用带箭头的虚线表示（在线上标注《》），箭头从扩展用况指向基用况（被扩展用况）。\n\n![wps6.png](https://s2.loli.net/2023/01/01/bsXFLu1EOaGZmUV.png)\n\n* **泛化关系**：同类元素之间的关系，如用况与用况之间，执行者与执行者之间。类似面向对象中的继承关系。泛化关系在Visio中称为“归纳”，用实线+空心三角形表示，空心三角形指向父，**子可以继承父所有的行为**。\n\n\n\n**用况图** \n\n用况图主要的作用有三个：（1）获取[需求](http://baike.baidu.com/view/195818.htm)；（2）指导测试；（3）还可在整个过程中的其它[工作流](http://baike.baidu.com/view/60285.htm)起到指导作用。\n\n### 用况图\n\n用况图是从程序员角度描述系统的功能？错\n\n## 静态建模\n\n### 类图和对象图\n\n* 对象图是类图的实例\n\n* 类之间的关系有**关联、依赖、泛化、实现**等\n* 类图是一种静态模型，是其他图的基础\n* 一个系统可以有多张类图，一个类也可以出现在几张类图中\n\n#### 如何用UML表示一个类\n\n类又名称，属性和操作组成\n\n名称唯一，一般采用双驼峰命名法\n\n属性，操作首字母通常小写，单驼峰\n\n属性的语法：属性名：类型=初始值  例如：maxCount:Interger=0\n\n操作的语法：操作名 (参数表)：返回类型  例如：method1(Object par):void\n\n#### 类之间的关系\n\n— 关联\n\n--> 依赖\n\n—▷泛化 需要协助\n\n--▷ 实现\n\n**重数：**表示这个类的多少个实例对象可以与另一个类的一个实例**关联**\n\n允许一个类与自身关联\n\n# 状态图和活动图\n\n### 什么是状态图？\n\n·    通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。\n\n### 状态图的组成元素\n\n·    状态\n\n·    状态之间的迁移\n\n·    分支\n\n·    状态内的迁移\n\n·    复合状态\n\n## 活动图\n\n### 什么是活动图？\n\n·    描述完成一个操作(如用况)所需要的活动\n\n### 活动图的组成元素\n\n·    活动\n\n·    泳道\n\n·    分支\n\n·    分岔和汇合\n\n·    对象流\n\n## 1.1.    顺序图\n\n### 1.1.1.   什么是顺序图？\n\n展示几个对象之间的动态交互关系\n\n### 1.1.2.   顺序图\n\n1.组成\n\n•   ①对象\n\n•   ②生命线\n\n•   ③激活\n\n•   ④消息(其中描述消息语法不是重点)\n\n•   ⑤组合片段\n\n2.带条件和分支的顺序图\n\n3.带约束的顺序图\n\n4.带循环和自身消息的顺序图\n\n5.创建对象和删除对象的顺序图\n\n### 结构化控制结构\n\n6.带组合片段的顺序图\n\n•   组合片段是矩形的，注意其覆盖的高度和宽度，高度对应时长，宽度对应覆盖的对象\n\n•   框住一个范围，也可以嵌套\n\n7.网上在线订购的顺序图\n\n### 买饮料的顺序图\n\n\n\n# 第九章 基于构件的软件开发\n\n## 什么是构件\n\n软件构件是软件系统中具有相对独立功能，可以明确标识，接口由规约指定，与语境有明显依赖关系，可独立部署，且多由第三方提供的可组装软件实体。\n\n### 可复用构建是指具有可复用价值的构件\n\n## 可变性分析\n\n### 构件应具有较强的通用性和可变性\n\n为了满足不同的复用需求，需要在构件复用时可能发生变化的一个或多个位置上标识变化点，同时为变化点附加一个或多个变体\n\n## 基于构建的软件开发过程\n\n### 领域工程步骤(生产构建)\n\n1领域分析\n\n2建立领域特定的基准体系结构模型\n\n3标识候选构件\n\n4泛化和可变性分析\n\n5构件重构\n\n6构件的测试\n\n7构件的包装\n\n8构件的入库\n\n### 应用系统工程的步骤(使用构件)\n\n1建立应用系统的体系结构模型\n\n2寻找候选构件\n\n3评价和选择合适的构件\n\n4构件的修改和特化\n\n5开发未被复用的部分\n\n6构件的组装\n\n7集成测试\n\n8评价被复用的构件，并推荐可能的新构件\n\n![clip_image002-16726355802722.jpg](https://s2.loli.net/2023/01/02/ickNdgLUse31RTW.jpg)\n\n# 第十章 敏捷软件开发\n\n## 什么是敏捷开发方法\n\n敏捷开发是一种基于更紧密的团队协作、能够有效应对快速变化需求、快速交付高质量软件的迭代和增量的新型软件开发方法\n\n## 代表性的敏捷开发方法\n\n### Scrum(迭代式增量软件开发过程)为基础的方法论\n\n·    Scrum\n\n·    Scrum/XP混合\n\n·    ...\n\n### 看板方法\n\n### 精益创业\n\n### 极限编程(XP)\n\n","tags":["笔记"],"categories":["本科课程"]},{"title":"用ChatGPT写一个刷题软件","url":"/2022/12/12/用ChatGPT写一个刷题软件/","content":"\n\n\n# 起因\n\n昨天下午准备复习毛概，但是想到期末考试都是选择题，我就在想能不能做一个刷题脚本。简单考虑了一下，打算做一个网页，如果自己写需要一些时间。emmm，我可以让ChatGPT帮我做一个！\n\n我在聊天框里大致输入是这样的：“用javascript，写一个做题软件，题库以JSON格式存储，题与题空行间隔，每一题有四个答案，每个答案独立一行，正确答案在题目的最后一行，用户点击选项后有答对或答错的反馈并显示正确答案，还可以点击按钮进入下一题，点击按钮退出程序‘’\n\n结果就有了这个刷题软件，我将它放到了博客上：[接受洗礼吧！ (jjuprising.github.io)](https://jjuprising.github.io/quiz/)\n\n# 主要功能实现\n\n脚本充分利用了dom。\n\n1.程序逻辑大致是首先准备一个题库数组，每个题目是对象的形式，包括题目、选项数组、正确答案，都是字符串的形式。\n\n2.打开页面后会通过伪随机数随机在题库数组中抽取一个元素，通过dom渲染到页面上。每一个选项是一个`<li>`，监听选项点击事件，通过比对点击的`<li>`和正确答案(字符串)判断正误。\n\n3.监听”下一题“点击事件，重复抽取题目和监听选项点击的操作\n\n我在原代码上添加了样式调整了布局，同时修改了一个bug，ChatGPT给的代码中，\"下一题\"事件的选项的变量用错了，用成了旧的。这也说明ChatGPT给出的代码不完全对的，这也是 Stack Overflow ban掉它的原因之一。\n\n# 题库实现\n\n当我手动修改题库数组时，我想到为什么不能将文本转为`json`呢(主要是想到之前舍长在编辑易班题库的时候通过上传txt就能生成题目)，于是，又借用ChatGPT，弄了一个`txt`生成`json`的脚本。\n\n主要利用`FileReader()`和之前提到的`Blob`大致逻辑如下：\n\n1.读入文本，通过`\\r\\n`分割文本，每行作为一个数组元素\n\n2.遍历每行文本，如果当前行不为空，将其作为一道题。读取题目和四个选项，以及最后一行的答案，将题目添加到题库数组\n\n3.将题库数组转换为`JSON`字符串，并保存为文件\n\n# 代码\n\n## 题库\n\n```html\n<!-- turnJson.html -->\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>turnJson</title>\n</head>\n\n<body>\n    <input type=\"file\" id=\"file-input\">\n    <script>\n        // 定义题库数组\n        const quizData = [];\n\n        // 读取题库文件\n        const fileInput = document.getElementById(\"file-input\");\n        fileInput.addEventListener(\"change\", () => {\n            // 获取题库文件\n            const file = fileInput.files[0];\n\n            // 创建文件阅读器\n            const reader = new FileReader();\n\n            // 监听文件阅读完成事件\n            reader.addEventListener(\"load\", () => {\n                // 获取文件内容\n                const txt = reader.result;\n\n                // 按行分割文本\n                const lines = txt.split(\"\\r\\n\");\n\n                // 遍历每一行文本\n                for (let i = 0; i < lines.length; i++) {\n                    const line = lines[i];\n\n                    // 如果当前行不为空，则将其作为一道题目\n                    if (line.trim() !== \"\") {\n                        // 解析题目内容\n                        const question = line;\n\n                        // 读取四个答案\n                        const answers = [];\n                        for (let j = 0; j < 4; j++) {\n                            const answerLine = lines[i + j + 1];\n                            answers.push(answerLine);\n                        }\n                        i += 5;\n                       // 解析题目答案\n                       const correctAnswer = lines[i];\n                        // 读取下一行，如果下一行为空行，则说明当前题目已经读取完成\n                        const nextLine = lines[i + 1];\n                        if (nextLine === \"\") {\n                            i++;\n                        }\n\n                        \n                        // 将题目添加到题库数组\n                        quizData.push({\n                            question,\n                            answers,\n                            correctAnswer,\n                        });\n                    }\n                }\n\n                // 将题库数组转换为 json 字符串\n                const json = JSON.stringify(quizData);\n\n                // 将 json 字符串保存为文件\n                const a = document.createElement(\"a\");\n                const blob = new Blob([json], { type: \"text/json\" });\n                a.href = URL.createObjectURL(blob);\n                a.download = \"quiz.json\";\n                a.click();\n            });\n\n            // 读取文件内容\n            reader.readAsText(file);\n        });\n    </script>\n</body>\n</html>\n```\n\n## 刷题功能\n\n```html\n<!-- quiz.html-->\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <title>接受洗礼吧！</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"quiz.css\">\n</head>\n\n<body>\n    <div class=\"QuizTable\">\n        <h1>单选题</h1>\n        <div id=\"quiz\" class=\"quiz\">\n            <!-- <p>What is the capital of France?</p>\n          <ul>\n            <li>Paris</li>\n            <li>London</li>\n            <li>Madrid</li>\n            <li>Rome</li>\n          </ul> -->\n        </div>\n        <p id=\"result\" class=\"result\"></p>\n        <button id=\"quit\" type=\"button\">Quit</button>\n        <button id=\"next\" type=\"button\">Next</button>\n    </div>\n\n    <script type=\"text/javascript\">\n        //设置题目布局\n        // const body=document.getElementsByName(\"body\");\n        // const width=body.width;\n        // const height=body.height;\n        // const QuizTable=document.getElementById(\"QuizTable\");\n        // QuizTable.style.left=width/2;\n        // QuizTable.style.top=height/2;\n\n        // 获取题库数组\n        const quizData = [\n            {\n                \"question\": \"( )标志着毛泽东思想的初步形成.\",\n                \"answers\": [\n                    \"A.提出并阐述农村包围城市,武装夺取政权思想\",\n                    \"B.《井冈山的斗争》\",\n                    \"C.《星星之火,可以燎原》\",\n                    \"D.《反对本本主义》\"\n                ],\n                \"correctAnswer\": \"A.提出并阐述农村包围城市,武装夺取政权思想\"\n            },\n            //其他题目\n        ];\n\n        // 从题库中随机抽取一道题目\n        const quizIndex = Math.floor(Math.random() * quizData.length);\n        const quiz = quizData[quizIndex];\n        console.log(quizIndex);\n        // 显示题目和选项\n        const quizElement = document.getElementById(\"quiz\");\n        quizElement.innerHTML = `\n          <p>${quiz.question}</p>\n          <ul>\n            ${quiz.answers\n                .map(\n                    (answer) => `<li>${answer}</li>`\n                )\n                .join(\"\")}\n          </ul>\n        `;\n\n        // 监听答案点击事件\n        const answerElements = quizElement.querySelectorAll(\"li\");\n        for (let i = 0; i < answerElements.length; i++) {\n            const answerElement = answerElements[i];\n            answerElement.addEventListener(\"click\", () => {\n                // 检查答案是否正确\n                const isCorrect = quiz.correctAnswer === answerElement.innerText;\n                const resultElement = document.getElementById(\"result\");\n                if (isCorrect) {\n                    resultElement.innerText = \"正确的。 答案是: \" + quiz.correctAnswer;\n                    resultElement.style.color = \"green\";\n                } else {\n                    resultElement.innerText =\n                        \"错误的！ 正确答案是: \" + quiz.correctAnswer;\n                    resultElement.style.color = \"red\";\n                }\n            });\n        }\n\n        // 监听“下一题”按钮点击事件\n\n        const nextButton = document.getElementById(\"next\");\n        nextButton.addEventListener(\"click\", () => {\n            // 随机抽取下一道题目\n            const nextQuizIndex = Math.floor(Math.random() * quizData.length);\n            const nextQuiz = quizData[nextQuizIndex];\n            console.log(nextQuizIndex);\n            // 显示题目和选项\n            const quizElement = document.getElementById(\"quiz\");\n            quizElement.innerHTML = `\n        <p>${nextQuiz.question}</p>\n        <ul>\n          ${nextQuiz.answers\n                    .map(\n                        (answer) => `<li>${answer}</li>`\n                    )\n                    .join(\"\")}\n        </ul>\n      `;\n\n            const answerElements = quizElement.querySelectorAll(\"li\");\n            for (let i = 0; i < answerElements.length; i++) {\n                const answerElement = answerElements[i];\n                answerElement.addEventListener(\"click\", () => {\n                    // 检查答案是否正确\n                    const isCorrect = nextQuiz.correctAnswer === answerElement.innerText;\n                    const resultElement = document.getElementById(\"result\");\n                    if (isCorrect) {\n                        resultElement.innerText = \"正确的。 答案是: \" + nextQuiz.correctAnswer;\n                        resultElement.style.color = \"green\";\n                    } else {\n                        resultElement.innerText =\n                            \"错误的！ 正确答案是: \" + nextQuiz.correctAnswer;\n                        resultElement.style.color = \"red\";\n                    }\n                });\n            }\n\n            // 清空答题结果\n            const resultElement = document.getElementById(\"result\");\n            resultElement.innerText = \"\";\n        });\n\n        // 监听“退出”按钮点击事件\n        const quitButton = document.getElementById(\"quit\");\n        quitButton.addEventListener(\"click\", () => {\n            // 退出程序\n            window.close();\n        });\n    </script>\n</body>\n```\n\n","tags":["html","javascript"]},{"title":"数据结构学习笔记","url":"/2022/11/16/数据结构学习笔记/","content":"\n\n# 错题\n\n* 【栈和队列】栈和队列的共同特点是<u>只允许在端点插入和删除元素</u>。\n* 【循环队列】数组Q[n]用来表示一个循环队列，front为队头元素的前一个位置，rear为队尾元素的位置，计算队列中元素个数的公式为:~~（rear-front)%n~~  （rear-front+n）%n 。\n  * 虽然数学上没错，但负整数求模结果可能因为编译器环境不同而不同。\n* 【KMP】设目标串为s=“abcabababaab”，模式串为p=“babab”，则KMP模式匹配算法的next数组为~~[-1,0,1,2]~~  [-1,0,0,1,2] 。\n  * next数组是看当前元素的前面的子串，如p[0]是b，记-1；p[1]为a，前面是b，无相同前后缀，记0；p[2]是b，前面是ba也记0，以此类推。\n* 算法分析的目的是<u>分析算法的效率以求改进</u>\n\n1.请写出单链表的插入和删除算法。\n\n```c++\n//插入算法 \ntemplate <typename DataType>\nvoid LinkList<DataType>::Insert(int i,DataType x){\n\tNode<T>*p=first->next;\n\tNode<T>*s=nullptr;\n\tint count=0;\n\twhile(p!=nullptr&&count<i-1){\n\t\tp=p->next;\n\t\tcount++; \n\t}\n\tif(p==nullptr) throw \"插入位置错误！\";\n\telse{\n\t\t//插入操作 \n\t\ts=new Node<T>;\n\t\ts->data=x;\n\t\ts->next=p->next;\n\t\tp->next=s;\n\t}\n}\n//删除算法\n template <typename DataType>\nDataType LinkList<DataType>::Delete(int i){\n\tNode<DataType>*p=first;\n\tNode<DataType>*s=nullptr;\n\tDataType x;\n\tint count=0;\n\twhile(p!=nullptr&&count<i-1){\n\t\tp=p->next;\n\t\tcount++; \n\t}\n\tif(p==nullptr||p->next==nullptr) throw \"删除位置错误！\";\n\telse{\n\t\t//删除操作\n\t\ts=p->next;\n\t\tx=p->data;\n\t\tp->next=s->next;\n\t\tdelete s;\n\t\treturn x;\t \n\t}\n}\n\n```\n\n2.请写出单链表的构造算法。（头插法、尾插法）\n\n```c++\n//头插法\ntemplate <typename T>\nLinkList<T>::LinkList(T a[],int n){\n\tfirst=new Node<T>;\n\tfirst->next=nullptr;//初始化\n\tfor(int i=0;i<n;i++){\n\t\tNode<T>* s=nullptr;\n\t\ts=new Node<T>;\n\t\ts->data=a[i];\n\t\ts->next=first->next;\n\t\tfirst->next=s;\n\t}\n}\n\n//尾插法\ntemplate <typename T>\nLinkList<T>::LinkList(T a[],int n){\n\tfirst=new Node<T>;\n\tNode<T>*r=first,*s=nullptr;\n\tfor(int i=0;i<n;i++){\n\t\t//遍历数组赋值\n\t\ts=new Node<T>;\n\t\ts->data=a[i];\n\t\tr->next=s;\n\t\tr=s; \n\t}\n\tr->next=nullptr;\n}\n\n```\n\n3.请写出顺序表的插入和删除算法。\n\n```c++\n//注意元素编号和存储位置的关系\n//插入\ntemplate <typename T>\nvoid Seqlist::Insert(int i,T x){\n\tif(length==MaxSize) throw \"上溢\"; \n\tif(i>length+1||i<1) throw \"插入位置有误！\";\n\tfor(int j=length;j>=i;j++){\n\t\tdata[j]=data[j-1];\n\t}\n\tdata[i-1]=x;\n\tlength++;\n}//删除 \n template <typename T>\nT SeqList<T>::Delete(int n){\n\tif(length==0) throw “下溢”;\n\tif(n>Length||n<1) throw \"删除位置有误\";\n\tT x=data[n];\n\tfor(int i=n;i<Length;i++){\n\t\tdata[i-1]=data[i];\n\t}\n\tLength--;\n\treturn x;\n}\n\n```\n\n4.请写出链队列的入队和出队算法。\n\n```c++\n//入队 从尾入\ntemplate <typename T>\nvoid LinkQueue::EnQueue(T x){\n\tNode<T>*s=nullptr;\n\ts=new Node<T>;\n\ts->data=x;\n\ts->next=nullptr;\n\trear->next=s;\n\trear=s;\n}\n//出队 从头出\ntemplate <typename T>\nT LinkQueue<T>::DeQueue(){\n\tT x;\n\tNode<T>*p=nullptr;\n\tif(rear==front) throw \"下溢\";\n\tp=front->next;\n\tx=p->data;\n\tfront->next=p->next;//摘链\n\tif(p->next==nullptr) rear==front;//判空\n\tdelete p;\n\treturn x;\n}\n\n```\n\n\n\n# 绪论\n\n* **数据元素**是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。\n* **数据项**是<u>数据</u>的最小单位，**数据元素**是讨论<u>数据结构</u>时涉及的最小数据单位。\n* 从<u>逻辑关系</u>上讲，数据结构主要分为**集合**、**线性结构**、**树结构**和**图结构**。\n* 数据的存储结构主要有**顺序存储结构**和**链接存储结构**两种基本方法，所有存储结构都要存储两方面内容：**数据元素**和**数据元素之间的关系**\n* <u>数据元素之间的逻辑关系</u>在**顺序存储结构**中由**存储位置**表示，在**链接存储结构**中由**指针**表示。\n* 算法具有五个特性，分别是①**有零个或多个输入**②**有一个或多个输出**③**有穷性**④**确定性**⑤**可行性**\n* 算法的可行性是描述算法的**每一条**指令可以**转换为**某种程序设计语言**对应的语句**，并在计算机上**可以执行**。\n* 算法的描述方法通常有**自然语言，程序设计语言，流程图和伪代码**四种。**伪代码**被称为**算法语言**。\n\n## 算法\n\n### 什么是算法？\n\n·    算法是对特定问题求解步骤的一种描述，是指令的有限序列\n\n### 算法的三个基本特性\n\n* 有穷性\n  *  一个算法必须总是在执行有穷步后结束，且每一步都在有穷时间内完成\n\n* 确定性\n  * 算法中的每一条指令必须有确切的含义，不存在二义性。并且，在任何条件下，对于相同的输入只能得到相同的输出\n\n* 可行性\n  * 描述算法的每一条指令可以转换为某种程序设计语言对应的语句，并在计算机上可以运行\n\n**算法有零个或多个输入(算法可以没有输入)，但是必须要有输出，而且输入与输出之间有着某种特定的关系**\n\n### 算法分析--算法效率的度量\n\n#### 时间复杂度\n\n•   用算法中基本语句的执行次数来度量算法的工作量\n\n•   基本语句可以理解为整个算法中执行次数最多的语句\n\n•   考察方式：只考察当问题规模充分大，算法中基本语句的执行次数在渐近意义下的阶，称为时间复杂度，用大O表示。关注的是增长趋势\n\n•   O(1)<O(log_2 n)<O(n)<O(nlog_2 n)<O(n^2)<O(n^3)<...<O(2^n)<O(n!)\n\n#### 空间复杂度\n\n•   是指算法在执行过程中需要的辅助空间数量，即除算法本身和输入输出数据所占的空间外，算法临时开辟的存储空间\n\n•   S(n)=O(f(n))\n\n•   如，用到一个临时存储temp，则空间复杂度为O(n);用到一个n个元素的临时存储的数组，则为O(n)\n\n### 算法分析--举例\n\n#### 非递归算法\n\n•   ①直接看循环重数\n\n•   ②多重求和，分析每次循环都是加1的情况\n\n•   ③每次循环为二倍，用等比数列，求多少项，一般是取对数，结果为对数阶\n\n#### 递归算法\n\n•   根据递归过程建立递推关系式并求解（求和表达式）\n\n#### 最好、最坏、平均情况\n\n•   最好情况：不能代表算法的效率，当出现概率较大时分析\n\n•   最坏情况：最坏能坏到什么程序，实时系统需要分析\n\n•   平均情况：已知输入数据分布情况，通常假设等概率分布\n\n举例：一维数组顺序查找\n\n•  最好：一次找到，O(1)\n\n•  最坏：最后才找到，O(n)\n\n•  平均：n/2，O(n)\n\n•   如果算法的时间代价与输入数据有关，则需要分析最好情况、最坏情况、平均情况\n\n## 数据结构\n\n**数据结构是相互之间存在一定关系的数据元素的集合**\n\n### 根据视点(是否基于内存)的不同分为\n\n#### 逻辑结构\n\n•   数据元素之间逻辑关系的整体，如关联方式或邻接关系，取决于实际问题\n\n四类\n\n•  集合 数据元素之间没有关系\n\n•  线性结构 数据元素之间是一对一的线性关系\n\n•  树结构 数据元素之间是一对多的层次关系\n\n•  图结构 数据元素之间多对多的任意关系\n\n#### 存储结构\n\n•   数据及其逻辑结构在计算机(内存)中的表示，包括数据元素及其逻辑关系\n\n两种\n\n•  顺序存储结构 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置(下标)表示\n\n•  链接存储结构 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针(地址)表示\n\n### 抽象数据类型(ADT)\n\n# 线性表\n\n## 线性表的逻辑结构\n\n线性表简称表，是n(n≥0)个数据元素的**有限序列**，线性表中数据元素的个数称为线性表的长度。当n=0时称为空表。\n\n* 一个非空表记为：L=(a<sub>1</sub>,a<sub>2</sub>,...,a<sub>n</sub>) 。a<sub>1</sub>称为表头元素，a<sub>n</sub>称为表尾元素。\n* a<sub>k-1</sub>称为a<sub>k</sub>的前驱，a<sub>k</sub>称为a<sub>k-1</sub>的后继。除了表头元素和表尾元素，其他元素有且仅有一个前驱和一个后继。\n\n## 线性表的顺序存储结构及实现\n\n### 顺序表的顺序存储结构\n\n* 物理位置相邻表示逻辑关系。逻辑上和物理上相邻\n* 任一元素均可随机存取\n\n存储位置的计算：\n\n每个元素占l个存储单元\n\n递推式：\n$$\nLoc(a_{i+1})=Loc(a_i)+l\n$$\n更通用的：\n$$\nLoc(a_i)=Loc(a_1)+(i-1)\\times{l}\n$$\n**注意是i-1**，举例就知道了\n\n### 实现\n\n#### 查找\n\n**按位查找** O(1)\n\n```c++\ntemplate <typename DataType>\nDataType SeqList<DataType>::Get(int i){\n    if(i<1||i>length) throw \"查找位置非法\"; //注意要先判断\n    else return data[i-1];//注意序号是1开始，而存储是从0开始\n}\n```\n\n**按值查找 **O(n)\n\n```c++\ntemplate <typename DataType>\nDataType SeqList<DataType>::Locate(DataType x){\n    for(int i=0;i<length;i++)\n        if(data[i]==x) return i+1;//注意返回序号i+1\n    return 0;//查找失败\n}\n```\n\n#### 插入 O(n)\n\n> 注意先判断满足条件①表是否已满，即length==MaxSize ②未满，则插入位置是否越界\n\n```c++\ntemplate <typename DataType>\nvoid SeqList<DataType>::Insert(int i,DataType x){\n    if(length==MaxSize) throw \"上溢\";\n    if(i<1||i>length+1) throw \"插入位置错误\";//i最大到length，最小到1\n    for(int j=length;j>=i;j--)\n        data[j]=data[j-1];//从第length-1个后移到下一个，第length个数组元素是空的\n    data[i-1]=x;//序号i存在数组下标为i-1的位置\n    length++;//长度加一，别忘了\n}\n```\n\n平均移动 $\\frac{n}{2}$ 次\n\n#### 删除 O(n)\n\n>如插入类似，同样先判定①表是否为空 ②表不空，删除位置是否越界 返回删除元素的值\n\n```c++\ntemplate <typename DataType>\nDataType SeqList<DataType>::Delete(int i){\n    DataType x;\n    if(length==0) throw \"下溢\";\n    if(i<1||i>length+1) throw \"删除位置错误\";\n    x=data[i-1];//i在下标为i-1上，取出位置i的元素\n    for(int j=i;j<length;j++)\n        data[j-1]=data[j];//从第i个位置往前移，覆盖掉i-1的位置，到length-1移动后结束\n    length--;//长度减1\n    return x;\n}\n```\n\n平均移动 $\\frac{n-1}{2}$ 次\n\n## 线性表的链式存储结构及实现\n\n### 链表\n\n#### 实现\n\n```c++\n//成员变量只有一个 头结点\nNode<DataType> * first\n\n//结点结构包含一个数据域和一个指针域\ntemplate <typename DataType>\nstruct Node{\n    DataType data;//数据域\n    Node<DataType> *next;//指针域\n}\n```\n\n\n\n#### 遍历\n\n```c++\ntemplate <typename DataType>\nvoid LinkList<DataType>::PrintList(){\n    Node<DataType>*p=first->next;//工作指针初始化\n    while(p!=nullptr){\n        cout<<p->data<<\"\\t\";\n        p=p->next;//工作指针p后移，注意不能写成p++\n    }\n    cout<<endl;\n}\n```\n\n#### 求长度\n\n> 工作指针从first->next开始，first不算长度\n\n```c++\ntemplate <typename DataType>\nint LinkList<DataType>::Length(){\n    Node *p=first->next;\n    int count=0;\n    while(p!=nullptr){\n        count++;\n        p=p->next;\n    }\n    return count;\n}\n```\n\n\n\n#### 插入\n\n```c++\ntemplate <typename DataType>\nvoid LinkList<DataType>::Insert(int i,DataType x){\n    Node<DataTpe> *p=first,*s=nullptr;//指针初始化\n    int count=0;//记录遍历位置\n    while(p!=nullptr&&count<i-1){//查找i-1位置，插入在其后面就成了第i个元素\n        p=p->next;//工作指针后移\n        count++;\n    }\n    if(p==nullptr) throw \"插入位置错误\";//没有找到第i-1个\n    else{//找到\n        s=new Node<DataType>;//申请结点s，数据域为x\n        s->data=x;\n        s->next=p->next;//将原本第i个插在s后面\n        p->next=s;//将s插入到p之后\n    }\n}\n```\n\n\n\n#### 删除\n\n> 和插入类似，都是找到后对下一个位置进行操作，但是当对象为表尾，此时，可插但不可删，因此判断位置除了`p==nullptr`还多了`p->next==nullptr`\n\n```c++\ntemplate <typename DataType>\nDataType LinkList<DataType>::Delete(int i){\n    DataType x;\n    int count=0;\n    Node<DataType> *p=first,*q=nullptr;//工作指针指向头结点\n    while(p!=nullptr&&count<i-1){\n        p=p->next;\n        count++;\n    }\n    if(p==nullptr||p->next==nullptr) throw \"删除位置错误\";\n    else{\n        q=p->next;//暂存被删结点\n        x=q->data;\n        p->next=q->next;//摘链\n        delete q;\n        return x;\n    }\n}\n```\n\n#### 建立\n\n#### 头插法\n\n> 初始化\n\n```c++\ntemplate <typename DataType>\nLinkList<DataType>::LinkList(DataType a[],int n){\n    first=new Node<DataType>;\n    first->next=nullptr;//初始化一个空链表\n    for(int i=0;i<n;i++){\n        Node<DataType> *s=nullptr;\n        s->data=a[i];\n        s->next=first->next;//插在头结点后\n        first->next=s;\n    }\n}\n  \n```\n\n#### 尾插法\n\n> 初始化；需要一个尾指针；建立完毕，终端指针指针域用空指针收尾\n\n```c++\ntemplate <typename DataType>\nLinkList<DataType>::LinkList(DataType a[],int n){\n    first=new Node<DataType>;\n    Node<DataType> *r=first,*s=nullprt;//尾指针初始化\n    for(int i=0;i<n;i++){\n        s=new Node<DataType>;\n        s->data=a[i];\n        r->next=s;//插在尾指针后\n        r=s;//尾指针后移\n    }\n    r->next=nullptr;//建立完毕，空指针收尾\n}\n```\n\n\n\n#### 单链表实现就地逆序\n\n```c++\ntemplate<class T>\nvoid Reverse(Node<T> *f){\n\t//头插法,再复制 \n\tNode<T> *p=new Node<T>;\n\tNode<T> *u=new Node<T>;\n\tp=f->next;\n\tf->next=nullptr;\n\twhile(p!=NULL){\n\t\tu=p->next;//存放后继结点\n\t\tp->next=f->next;//插入头结点下一个节点之前 \n\t\tf->next=p;//头插\n\t\tp=u;\t\t \n\t}\n}\n```\n\n> 就地逆序，首先将原链表断开，从第一个结点开始重新头插法，每次插入前要保存后继结点，插完后工作指针指向后保存的后继结点\n\n#### 删除有序链表的一个区间上的元素\n\n```c++\ntemplate <typename T>\nvoid deleteBet(Node<T> *first,int mink,int maxk){\n    Node<T> *p=nullptr;\n\tNode<T> *q=nullptr;\n    p=first;\n    while(p->next!nullptr&&p->next->data<=mink)\n        p=p->next;\n    //结束循环时，p的下一个是大于mink的\n    if(p->next!=nullptr){\n        q=p->next;\n        while(q->data<maxk){\n            Node<T> *u=q->next;//记录下一个\n            p->next=q->next;\n            delete q;\n            q=u;//q移到下一个\n        }\n    }\n}\n```\n\n> 首先判断p的下一个是大于的，然后再申请一个指针q来记录接下来的结点，判断q是否小于maxk是的话要删除q；删除结点需要一个指针u来先记录q后面的结点，将q摘链删除后，让q指向保存好的下一个结点\n\n### 循环链表\n\n\n\n## 两种存储结构的选择\n\n按值查找：\n\n* 顺序表是O(1)，随机存取\n* 链表是O(n)，顺序存取\n\n插入和删除\n\n* 顺序表O(n)\n* 链表O(1)\n\n| 存储结构 | 链表                             | 顺序表                                                       |\n| -------- | -------------------------------- | ------------------------------------------------------------ |\n| 空间上   | 元素**个数变化较大**或为止时选择 | **事先知道**线性表的**大致长度**，使用顺序表空间效率更高     |\n| 时间上   | 频繁**插入和删除**时选择         | 频繁**查找**很少插入删除；或**操作和**元素在表中的**位置密切**相关 |\n\n# 栈和队列\n\n## 队列\n\n初始：front=rear=0\n\n入队：base[rear]=x;rear++;\n\n出队：x=base[front];front++\n\n空队标志：front==rear;\n\n数组大小为MAXSIZE时，当rear==MAXSIZE发生溢出：\n\n* 若front=0，rear==MAXSIZE，再入队真溢出\n* 若front≠0，rear==MAXSIZE，再入队假溢出(前面还有位置其实)\n\n## 循环队列\n\n> front处不存值，rear存值\n\n插入元素：\n\n```c++\nif((rear+1)%MAXSIZE==front) throw \"上溢\";\nrear=(rear+1)%MAXSIZE;\ndata[rear]=x;//插入元素\n```\n\n删除元素：\n\n```c++\nif(front==rear) throw \"下溢\";\nfront=(front+1)%MAXSIZE;\nreturn data[front];//返回出队前的队头元素,front本来是不存值的，放到front相当于出队\n```\n\n> 注意是(指针+1)%MAXSIZE，不能指针%MAXSIZE，因为要包括移动到下一位，不能停留在MAXSIZE，直接一步到位\n\n**队满条件**：`(rear+1)%MAXSIZE==front;`\n\n# 字符串\n\n* 字符串简称“串”\n* 任意个**连续**的字符组成的子序列称为该串的**子串**\n* 包含子串的串称为**主串**\n\n## KMP\n\n看子串即可，当在对比模式串和目标串时，通过模式串可以反应目标串的一些信息\n\nnext[j]定义：\n$$\nnext[j]=\n\\begin{cases}\n-1& \\text{j=0}\\\\\n最长公共前后缀的长度& \\text{集合非空}\\\\\n0& \\text{其他情况}\n\\end{cases}\n$$\n\n> 注意找子串前后缀是j之前的，不包括j位置的字符；next[0]=-1\n\n设目标串为s=“abcabababaab”，模式串为p=“babab”，则KMP模式匹配算法的next数组为 **[-1,0,0,1,2]** \n\n## 矩阵的压缩存储\n\n### 特殊矩阵\n\n#### 对称矩阵 \n\n原本需要n×n，现在只用n×(n+1)/2\n\n> 存一半+主对角线\n\n#### 三角矩阵 \n\n上(下)三角，主对角线以下(上)为均为常数c，和对称矩阵类似，但是要多存一个c\n\n现在只有n×(n+1)/2+1\n\n> 存一半+主对角线+一个常数\n\n#### 对角矩阵 \n\n所有非零元素都集中在以对角线为中心的带状区域，除了主对角线和若干条次对角线的元素外，所有其他元素都为零。\n\n> 只存非0\n\n# 树和二叉树\n\n* 注意树的定义，是有且仅有一个根节点且其余结点配分成互不相交的集合(不能构成回路)。\n\n* 某结点拥有的子树的个数称为该结点的**度**；树中<u>各结点度的最大值</u>称为该**树的度**。\n\n* 线性结构：前驱->后继  树的结构：双亲->孩子\n\n![image.png](https://s2.loli.net/2022/10/09/xdKM4TcY7fGpaC6.png)\n\n**重点：**对于一棵n结点的树，其所有结点的度之和为n-1。\n\n> 理解：把结点上面的边与它关联，那么除了根节点上面没有边，总共的边数(即度数和)就等于所有结点数-1，因此所有结点的度数和就是总结点数-1即n-1。因此有结点数**n=分支数+1**\n\n\n\n### 习题\n\n* 已知一颗度为4的树中，度为i(i>=1)的结点个数有i个，问该树中有     个叶子结点。\n\n  A. 19  B. 21    C. 23 D. 25\n\n**解析：**设i度结点数为n<sub>i</sub>个，则本题树的度为4，总结点数n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>+n<sub>3</sub>+n<sub>4</sub>,由公式结点数n=分支数+1,且度为i(i>=1)的结点个数有i个，那么总的分支数为1+n<sub>1</sub>+2n<sub>2</sub>+3n<sub>3</sub>+4n<sub>4</sub>，联立两式可得叶子节点数n<sub>0</sub>=1+n<sub>2</sub>+2n<sub>3</sub>+3n<sub>4</sub>=21\n\n* 已知一棵度为3的数，度为1的结点有2个，度为2的结点有3个，度为3的结点有4个，问有多少叶子结点。\n\n**解析：**同理n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>+n<sub>3</sub>+n<sub>4</sub>=2n<sub>1</sub>+3n<sub>2</sub>+4n<sub>3</sub>+1，解的n<sub>0</sub>=1+n<sub>2</sub>+2n<sub>3</sub>=12\n\n> 此类给度数k和一些结点数，求叶子结点的题一般做法都是\n>\n> 1.设i度结点数为n<sub>i</sub>个，总结点数就是n=n<sub>0</sub>+n<sub>1</sub>+..+n<sub>k</sub>\n>\n> 2.利用结点数=分支数+1，i度结点有i个分支，因此分支数为∑i×n<sub>i</sub>求和，所以得n=∑i×n+1\n>\n> 3.联立12，带入题目给的相应结点数即可得到结点数n<sub>0</sub>\n\n## 二叉树\n\n![image.png](https://s2.loli.net/2022/10/09/6EZuLpRqDhBw8GS.png)\n\n### 二叉树的逻辑结构\n\n> 注意，二叉树和树是两种不同的树结构，二叉树不是度为2的树，也不能说是度小于等于2的树\n\n对于前者，当是一个只有两个结点的斜树时，**度为1**，只有一个结点时**度为0**，它们度都不是2，但都是二叉树。\n\n对于后者，树的孩子还必须**要有左右之分**，及时只有一个结点，也要区分它是左孩子还是右孩子。例如下图，假设是二叉树，则它们是两课不同的二叉树；假设是树，则它们是同一棵树。\n\n![image-20221214165114732]([JJuprising/JJuprising.github.io]([Joel Station (jjuprising.github.io)](https://jjuprising.github.io/images/数据结构学习笔记/image-20221214165114732.png)\n\n#### 满二叉树\n\n在一棵二叉树中，所有分支结点都存在于左子树和右子树，，并且所有叶子结点都在同一层，这样的二叉树称为**满二叉树**。\n\n**特点：**\n\n1. 叶子只出现在最下一层\n2. 只有度为0和度为2的结点\n3. 在同样深度的二叉树中，满二叉树结点最多，叶子节点最多。\n\n#### 完全二叉树\n\n一棵满二叉树必定是一棵完全二叉树。\n\n完全二叉树，是在满二叉树中，从最后一个结点(最右)连续去掉**任意个结点**(全去掉就是满二叉树)，得到的二叉树。\n\n**特点：**\n\n1. 深度为k的完全二叉树**在k-1层是满二叉树**。\n2. 叶子结点只能出现在**最下两层**，且最下层的叶子结点都集中在左侧连续的位置。\n3. 如果有度为1的结点，只**可能有一个**，且该结点**只有左孩子**。\n4. 在结点数相同的情况下，构成的所有二叉树中完全二叉树的深度最小。\n\n### 二叉树的五个性质\n\n#### 对于二叉树\n\n* 在一棵二叉树中，如果叶子结点的个数为n<sub>0</sub>,度为2的结点个数为n<sub>2</sub>，则**n<sub>0</sub>=n<sub>2</sub>+1**，即叶子结点数等于度为2的结点数加一。\n  * 证明：结点数n=分支数+1=n<sub>1</sub>+2*n<sub>2</sub>+1,n=n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>，联立得n<sub>0</sub>=n<sub>2</sub>+1\n\n* 二叉树的第i层上最多有**2<sup>i</sup>-1**个结点(i≥1)\n  \n  * 等比数列，首项为1，公比为2，第i层满则有2<sup>i</sup>-1个\n  \n* 在一棵深度为k的二叉树中，最多有**2<sup>k</sup>-1**个结点。\n  * 由上面结论深度一定时，满二叉树的结点数是最多的，满二叉树每层的结点数为1,2,4,8...是个公比为2的等比数列，到第k层有2<sup>k-1</sup>个结点，求和公式1*(1-2<sup>k</sup>)/1-2得2<sup>k</sup>-1，这也是一个等比数列的性质，即第n项的值减一等于前n-1项的和\n\n  \n\n#### 对于完全二叉树\n\n* 具有n个结点的完全二叉树的深度为**⌊log<sub>2</sub>n⌋+1**。\n\n  * 由完全二叉树的定义，是由满二叉树从最后一个结点连续去掉任意结点得到，因此一个深度为k的完全二叉树结点数最多是当它是深度为k的满二叉树，最少是当它是深度为k-1的满二叉树，结合上求和公式可得\n    $$\n    2^{k-1}≤n<2^k\n    $$\n    （这里假设深度为k，因此它不为k-1的满二叉树，左边取等或者取大于2<sup>k-1</sup>-1，右边就是小于等于2<sup>k</sup>-1）\n  \n* 对于一棵具有n个结点的完全二叉树从1开始按层序编号，则对于编号为i的结点，双亲和孩子编号之间的关系为：\n\n  * 双亲编号为$⌊i/2⌋$\n  * 左孩子编号为$2i$，右孩子编号为$2i+1$\n\n\n##  二叉树的遍历\n\n### 遍历操作\n\n前序：根左右\n\n中序：左根右\n\n后序：左右根\n\n例题：\n\n1.\n\n![image-20221213203357221](https://jjuprising.github.io/images/数据结构学习笔记/image-20221213203357221.png)\n\n**解析：**前序：ABDGCEHF；中序：DGBAEHCF；后序：GDBHEFCA\n\n#### 确定二叉树\n\n先序加中序或中序加后序可以确定一棵二叉树，但是先序加后序不可以。\n\n前序开头确定根，中序确定左右子树\n\n如先序：**A** <u>B C D E F</u> <u>G H I</u>    中序：<u>C D B F E</u> **A** <u>IHGJ</u>\n\n左子树 先序：**B**DFEF    中序：<u>CD</u>**B**<u>FE</u>\n\n再左子树类推，右子树同理\n\n后序尾部确定根，中序确定左右子树\n\n\n\n### 二叉链表\n\n前序、中序、后序、层序遍历，数据类型默认为char，注意初始化的方式，递归构造\n\n```c++\n#include <iostream>\nusing namespace std;\nint count1 = 0;\n\nstruct BiNode   //二叉树的结点结构\n{\n\tchar data;       //数据类型默认为char\n\tBiNode *lchild, *rchild;\n};\n\nclass BiTree\n{\npublic:\n\tBiTree( ){root = Creat(root);}\t\t\t//构造函数，建立一棵二叉树\n\t~BiTree( ){Release(root);}\t\t\t\t//析构函数，释放各结点的存储空间\n\tvoid PreOrder( ){PreOrder(root);}\t\t//前序遍历二叉树\n\tvoid InOrder( ){InOrder(root);}\t\t\t//中序遍历二叉树\n\tvoid PostOrder( ){PostOrder(root);}\t\t//后序遍历二叉树\n\tvoid LeverOrder( );\t\t\t\t\t\t//层序遍历二叉树\n\tvoid CountLeaf1( ){CountLeaf1(root);}\n\tvoid CountLeaf2( ){cout<<CountLeaf2(root)<<endl;}\nprivate:\n\tBiNode *root;                           //指向根结点的头指针\n\tBiNode *Creat(BiNode *bt);\t\t\t\t//构造函数调用\n\tvoid Release(BiNode *bt);\t\t\t\t//析构函数调用\n\tvoid PreOrder(BiNode *bt);              //前序遍历函数调用\n\tvoid InOrder(BiNode *bt);               //中序遍历函数调用\n\tvoid PostOrder(BiNode *bt);             //后序遍历函数调用\n\tvoid CountLeaf1(BiNode *bt);\n\tint CountLeaf2(BiNode *bt);\n};\n```\n\n#### 前序遍历\n\n**递归** O(n)\n\n```c++\nvoid BiTree::PreOrder(BiNode *bt)\n{\n\tif(bt==NULL)  return;\n\telse {\t\t\n\t\tcout<<bt->data<<\" \";\n        PreOrder(bt->lchild);\n\t\tPreOrder(bt->rchild);\n\t}\n}\n```\n\n#### 中序遍历\n\n```c++\nvoid BiTree::InOrder(BiNode *bt)\n{\n\tif (bt==NULL)  return;      //递归调用的结束条件\t          \n    else {\t\n        InOrder(bt->lchild);    //中序递归遍历root的左子树\n        cout<<bt->data<<\" \";    //访问根结点的数据域\n        InOrder(bt->rchild);    //中序递归遍历root的右子树\n\t}\n}\n```\n\n#### 后序遍历\n\n```c++\nvoid BiTree::PostOrder(BiNode *bt)\n{\n\tif (bt==NULL)  return;       //递归调用的结束条件\n    else {\t\n        PostOrder(bt->lchild);    //后序递归遍历root的左子树\n        PostOrder(bt->rchild);    //后序递归遍历root的右子树\n        cout<<bt->data<<\" \";      //访问根结点的数据域\n\t}\n}\n```\n\n#### 层序遍历\n\n```c++\nvoid BiTree::LeverOrder( )\n{\n\tconst int MaxSize=100;\n\tint front=-1, rear=-1;  //采用顺序队列，并假定不会发生上溢\n\tBiNode *Q[MaxSize], *q;\n\tif (root==NULL) return;\n\telse {\n\t\tQ[rear++]=root;\n\t\twhile (front!=rear)\n\t\t{\n\t\t\tq=Q[front++];\n     \t\tcout<<q->data<<\" \"; \t\t\n    \t\tif (q->lchild!=NULL)  Q[rear++]=q->lchild;\t\t\n\t\t\tif (q->rchild!=NULL)  Q[rear++]=q->rchild;\n\t\t}\n\t}\n}\n```\n\n#### 构造函数——建立二叉树\n\n```c++\nBiNode *BiTree::Creat(BiNode *bt)\n{\n\tchar ch;\n\tcout<<\"请输入创建一棵二叉树的结点数据\"<<endl;\n\tcin>>ch;\n    if (ch=='#') return NULL;\n    else{ \n\t     bt = new BiNode;       //生成一个结点\n         bt->data=ch;\n         bt->lchild = Creat(bt->lchild);    //递归建立左子树\n         bt->rchild = Creat(bt->rchild);    //递归建立右子树\n    } \n    return bt;\n\n}    \n```\n\n#### 析构函数——销毁二叉树\n\n```c++\nvoid BiTree::Release(BiNode *bt)\n{\n\tif (bt != NULL){                  \n\t     Release(bt->lchild);   //释放左子树\n         Release(bt->rchild);   //释放右子树\n         delete bt;\n\t}  \n\n}\n```\n\n#### 遍历算法应用\n\n递归调用深入下一层，返回后还要继续执行\n\n##### 复制\n\n* 如果是空树，递归结束；\n* 否则，申请新结点，复制根节点\n  * 递归复制左子树\n  * 递归复制右子树\n\n```c++\nvoid BiTree::Copy(BiTree T,BiTree &NewT){\n    if(T==NULL){\n        NewT=NULL;//置为空\n        return 0;\n    }else{\n        NewT=new BiNode;//申请空间\n        NewT->data=T->data;//数据域\n        Copy(T->lchild,NewT->lchild);//通过传递NewT->lchild将它们连接起来\n        Copy(T->rchild,NewT->rchild);//递归结束后，栈的特点返回上一层\n    }\n        \n}\n```\n\n##### 计算深度\n\n* 如果是空树，则深度为0\n* 否则，递归计算左子树的深度记为m，递归计算右子树深度为n，深度取m和n较大者加1\n\n```c++\nint BiTree::Depth(BiTree T){\n    int m,n;\n    if(T==NULL) return 0;//如果是空树返回0\n    else{\n        m=Depth(T->lchild);//递归计算左子树的深度\n        n=Depth(T->rchild);//递归计算右子树的深度\n        if(m>n)//取左右子树深度大的那一个\n            return (m+1);//加上当前的根节点\n        else\n            return (n+1);\n    }\n}\n```\n\n\n\n##### 计算结点总数\n\n* 如果是空树，则结点个数为0\n* 否则，结点个数为左子树的结点个数+右子树的结点个数再+1\n\n```c++\nint BiTree:NodeCount(BiTree T){\n    if(T==NULL)\n        return 0;\n    else\n        return NodeCount(T->lchild)+NodeCount(T->lchild)+1;//+1即每轮的根结点\n}\n```\n\n> 基本情况：如果是一个叶子结点，左右子树都为空，返回0，那么就是0+0+1就是1，返回到上一层，假设它没有右子树，那么当前的结点数就是1+0+1就是2，正确，返回上一层，再去递归右子树...;这个1加的就是每一轮的根节点\n\n或者\n\n```c++\ntemplate <class T>\nvoid Count(BiNode<T> *br){\n    if(br!=nullptr){\n        Count(br->lchild);\n        count++;\n        Count(br->rchild);\n    }\n}\n```\n\n\n\n##### 计算叶子\n\n**递归**\n\n* 如果是空树，则叶子结点个数为0\n* 否则，为左子树叶子结点+右子树的叶子结点\n\n```c++\nvoid BiTree::CountLeaf1(BiNode *bt)\n{\n\tif (bt!=NULL){\n\t\tif(bt->lchild==NULL && bt->rchild==NULL)//叶子左右孩子都为空\n\t\t\tcount1++;\n\t\tCountLeaf1(bt->lchild);//不是叶子就继续递归左子树\n\t\tCountLeaf1(bt->rchild);//右子树\n\t}\n    return;\n}\n```\n\n```c++\nint BiTree::LeadCount(BiTree *T){\n    if(T==NULL) return 0;\n    else{\n        if(T->lchild==NULL&&T->rchild==NULL)\n            return 1;//是叶子结点返回\n        else return LeafCount(T->lchild)+LeafCount(T->rchild);\n    }\n}\n```\n\n前序顺序打印叶子(根左右)\n\n```c++\nvoid PreOrderPrint(BiNode *br){\n\tif(bt==nullptr) return;\n\telse{\n\t\tif(bt->lchild==nullptr&&bt->rchild==nullptr)\n\t\t\tcout<<br->data;\n\t\tPreOrderPrint(br->lchild);\n\t\tPreOrderPrint(br->rchild);\n\t\t\n\t}\n}\n```\n\n**非递归**\n\n```c++\nint BiTree::CountLeaf2(BiNode *bt)\n{\n\tconst int MaxSize=100;\n\tBiNode *S[MaxSize];//利用队列\n\tint top=-1; int count=0;\n\twhile(bt!=NULL||top!=-1)\n\t{\n\t\twhile(bt!=NULL)\n\t\t{\n\t\t\tif(bt->lchild==NULL && bt->rchild==NULL)\n\t\t\t\tcount++;\n\t\t\tS[++top]=bt;//入队\n\t\t\tbt=bt->lchild;\n\t\t}\n\t\tif(top!=-1) {\n\t\t\tbt=S[top--];//出队\n\t\t\tbt=bt->rchild;\n\t\t}\n\t}\n\treturn count;\n}\n```\n\n##### 找结点x的双亲\n\n```c++\ntemplate<class T>\n void BiNode<T>::Parent(BiNode<T> *root,T x){\n \tif(root!=nullptr){\n \t\tif(root->data==x) return p;\n \t\telse{\n \t\t\tp=root;//存双亲\n\t\t\tParent(root->lchild,x);\n\t\t\tParent(root->rchild,x); \n\t\t }\n\t }\n }\n```\n\n##### 删除以x为根结点的子树\n\n```c++\n template<class T>\n void release(BiNde<T> T){\n \tif(T!=nullptr){\n \t\trelease(T->lchild);\n \t\trelease(T->rchild);\n \t\tdelete T;\n\t }\n } \ntemplate<class T>\nvoid DelBotmTree(BiNde<T> *root,T x){\n\tif(root==nullptr) return;\n\tif(root->data==n){\n\t\t//找到，删除\n\t\trelease(root);\n\t\troot=nullptr;//标记为空，不要了 \n\t}\n\tif(root!=nullptr){\n\t\tDelBotmTree(root->lchild,x);\n\t\tDelBotmTree(root->rchild,x);\n\t}\n}\n```\n\n##### 交换左右子树\n\n后序遍历的方法进行交换\n\n```c++\ntemplate<class T>\nvoid exchange(BiNode<T> *root){\n    BiNode<T> *t;\n    if(root==nullptr) return;\n    else{\n        exchange(root->lchild);\n        exchange(root->rchild);\n        //交换左右子树\n        t=root->lchild;\n        root->lchild=root->rchild;\n        root->rchild=t;\n    }\n}\n```\n\n> 左右根，化简为最基本的情况就是左右结点的交换\n\n## 森林\n\n森林是$m(m≥0)$棵**互不相交**的树的集合。\n\n> 注意区分树和森林。树删去根节点-->森林；森林增加一个根节点，将森林每一棵树的根节点作为这个根节点的子树-->一棵树\n\n### 树与二叉树相互转换\n\n树的**兄弟**关系<-->二叉树的**双亲**与**右孩子**\n\n树的双亲与**长子**<-->二叉树的双亲与**左孩子**\n\n方法：\n\n1. **加“兄弟”线**，所有相邻兄弟之间加一条线(兄弟关系变为双亲和右孩子的关系)；\n2. **去”孩子“线**，去掉结点与其他孩子的线，保留和长子的线(双亲与长子变为双亲与左孩子，和其他兄弟也没“关系”了)；\n3. **调整**，以根节点为轴顺时针旋转调整，使层次分明。\n\n![image-20221214171816832](https://jjuprising.github.io/images/数据结构学习笔记/image-20221214171816832.png)\n\n> 当二叉树根节点的右子树为空，说明树的根节点是单独的，没有兄弟\n>\n> 树的前序遍历就是二叉树的前序遍历\n>\n> 树的**后序**遍历就是二叉树的**中序**遍历\n\n后序是左右根，中序是左根右。原本树的兄弟之间是左右，在二叉树变成了双亲与右孩子，因此是根右\n\n### 森林转换为二叉树\n\n方法：\n\n1. 将森林每棵树转换为二叉树\n2. 每棵树根结点视为兄弟相连\n3. 调整层次关系\n\n其实由森林和树的定义也可推得方法类似，在第一步完成后，将几颗树的根节点作为兄弟，然后调整，将右兄弟作为右孩子。\n\n![image-20221214171747422](https://jjuprising.github.io/images/数据结构学习笔记/image-20221214171747422.png)\n\n### 树、森林与二叉树的转换\n\n方法：\n\n1. **加”孩子“线**，将结点y与他的左孩子的右孩子、右孩子的右孩子。。。用线连起来\n2. **去线**，删去所有双亲与右孩子的连线\n3. 层次调整\n\n![image-20221214180843999](https://jjuprising.github.io/images/数据结构学习笔记/images/image-20221214180843999.png)\n\n## 最优二叉树\n\n哈夫曼树不存在度为1的结点\n\n哈夫曼树度只能为0或2，不存在度为1。至少：考虑每层2个结点（除了根结点），则至少为2h-1个\n\n至多：考虑满二叉树，则至多为 (2^h) -1\n\n# 图\n\n## 图逻辑结构\n\n#### 邻接图\n\n通过边数的多寡可以将图分为稀疏图和稠密图，稀疏图即边数很少的图\n\n#### 邻接、依附\n\n无向图中，两个顶点相连，互为邻接点，称边依附于这两个顶点\n\n有向图中，a指向b，称顶点a邻接到b，顶点b邻接自a，弧依附这两个点。有向边成为弧\n\n#### 完全图\n\n无向完全图，任意两个顶点之间都存在边。\n\n> n个顶点的无向完全图有 $\\frac{n×(n-1)}{2}$ 条边\n>\n> 每个顶点和其他顶点(n-1个)都有边，算多了一遍结果除2\n\n有向完全图，任意两个顶点都存在**方向相反的两条弧**。\n\n> n个顶点的有向完全图有 $n×(n-1)$ 条弧\n>\n> 任意两点有两条，区分方向，不用除2\n\n#### 度、入度、出度\n\n无向图，度\n\n有向图，入度：进入该顶点的弧的数(以该顶点为弧头)；出度，出去的弧的数(以该顶点为弧尾)\n\n**性质：**\n\n>  无向图，各顶点的度数和等于边数之和两倍，度数算了两遍的边\n>\n> 有向图，**各顶点的入度和等于出度和等于边数之和**，有出必有入，有如必有出，一条边提供一个出度一个入度，入度和等于出度和，加和等于边数的2倍，各自就是等于边数和\n\n#### 路径、回路\n\n* 简单路径：序列中顶点不重复出现的路径\n* 简单回路(简单环)：除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路\n\n* 路径长度：\n  * 带权图：路径上边的**权值之和**\n  * 非带权图：路径上**边的个数**\n\n#### 连通图\n\n* 无向图中，如果两顶点之间有路径，则称两顶点是连通的\n* 无向图中，如果任意两顶点都是连通的，则称该无向图是连通图\n\n#### 强连通图\n\n* 强连通顶点，在有向图中，如果a到b和b到a均有路径，则称a和b是强连通的\n* 强连通图，在有向图中，如果任意两个顶点是强连通的，则称有向图是强连通图\n* 强连通分量：非强连通图的极大连通子图**(极大强连通子图就是指一个强连通子图，再加入任何额外的节点都无法保证这个新的图是一个强连通图)**\n\n![image-20221217153730696](https://jjuprising.github.io/images/数据结构学习笔记/image-20221217153730696.png)\n\n### 遍历操作\n\n算法：BFTraverse\n\n输入：顶点的编号 v\n\n输出：无\n\n 1. 队列Q初始化\n\n 2. 访问顶点v；修改标志visti[v]=1;顶点v入队列Q；\n\n 3. while(队列Q非空)\n\n    3.1 v=队列Q的队头元素出队；\n\n    3.2 w=顶点v的第一个邻接点；\n\n    3.3 while(w存在)\n\n    ​\t3.1.1 如果w未被访问，则访问它；修改标志vistied[w]=1;顶点w入队列Q；\n\n    ​\t3.1.2 w=顶点v的下一个邻接点；\n\n## 图的存储结构及实现\n\n### 邻接矩阵\n\n注意到自己是0，主对角线为0\n\n**空间复杂度为O(n<sup>2</sup>)**\n\n![image-20221217164904968](https://jjuprising.github.io/images/数据结构学习笔记/image-20221217164904968.png)\n\n网图的邻接矩阵可定义为：用权值代替1，主对角都是0，不可达是∞\n\n#### **实现**\n\n```c++\nconst int MaxSize=10;\ntemplate <typename DataType>\nclass MGraph{\n    ...\nprivate:\n    DataType vertex[MaxSize];//存放图中顶点的数组\n    int edge[MaxSize][MaxSize];//存放图中边的数组\n    int vertexNum,edgeNum;//图的顶点和边数\n}\n```\n\n##### 构造函数——图的建立\n\n```c++\ntemplate <typename DataType>\nMGraph<DataType>::MGraph(DataType a[],int n,int e){\n    int i,j,k;\n    vertexNum=n;edgeNum=e;\n    for(i=0;i<vertexNum;i++)\n        vertex[i]=a[i];//存储顶点\n    for(i=0;i<vertexNum;i++)//初始化矩阵\n        for(j=0;j<vertexNum;j++)\n            edge[i][j]=0;\n    for(k=0;k<edgeNum;k++){\n        cin>>i>>j;//输入边依附两个顶点的编号\n        edge[i][j]=edge[j][i];//置有边标志\n    }\n}\n```\n\n##### 深度优先遍历\n\n>  递归栈；按行访问\n\n```c++\ntemplate <typename DataType>\nvoid MGraph<DataType>::DFTraverse(int v){\n    cout<<vertex[v]<<\" \";\n    visited[v]=1;//一个全局遍历，访问置为1\n    for(int j=0;j<vertexNum;j++)\n        if(vertex[v][j]==1&&visited[j]==0) DFTraver(j);//满足条件：邻接同时未访问过\n}\n```\n\n##### 广度优先遍历\n\n>  队列；font指向队头元素的前一个位置，rear指向队尾元素的位置\n\n```c++\ntemplate <typename DataType>\nvoid MGraph<DataType>::BFTraverse(int v){\n    int w;//记录出队\n    int j;//序号\n    int Q[MaxSize];//队列\n    int front=-1,rear=-1;//初始化队列\n    cout<<vertex[v];visited[v]=1;//记录已访问\n    Q[++rear]=v;//被访问顶点入队\n    while(font!=rear){//当队列非空\n        w=Q[++font];//将队头元素出队\n        for(j=0;j<vertexNum;j++)\n            if(eage[w][j]==1&&visited[j]==0){\n                Q[++rear]=j;//入队\n                cout<<vertex[j]<<\" \";\n                visited[j]=1;//访问过，记录\n            }\n    }\n}\n```\n\n\n\n### 邻接表\n\n如果采用邻接矩阵存储稀疏图，会出现什么情况？-->稀疏矩阵\n\n![image-20221217170424730](https://jjuprising.github.io/images/数据结构学习笔记/image-20221217170424730.png)\n\n> 边表中的结点表示什么？-->对应图中的一条边(边表)\n>\n> 设图有n个顶点e条边，邻接表的空间复杂度是：O(n+e)\n\n基础准备：\n\n```c++\nstruct EdgeNode{//定义边表结点。一个结点！\n    int adjvex;//邻接点域\n    EdgeNode * next;\n}\ntemplate <typename DataType>\nstruct VertexNode{//定义顶点表结点\n\tDataType vertex;\n    EdgeNode * firstEdge;\n};\n```\n\n#### 实现\n\n```c++\nconst int MaxSize=10;\ntemplate <typename DataType>\nclass ALGraph{\n    ...\nprivate:\n    VertexNode<DataType> adjlist[MaxSize];//存放顶点表的数组\n    int vertexNum,edgeNum;//图的顶点数和边数\n}\n```\n\n##### 构造函数——图的建立\n\n> 头插法\n\n```c++\ntemplate <typename DataType>\nALGraph<DataType>::ALGraph(DataType a[],int n,int e){\n    int i,j,k;\n    EdgeNode * s=nullptr;\n    vertexNum=n;\n    edgeNum=e;\n    for(i=0;i<vertexNum;i++){//输入顶点信息，初始化顶点表\n        adjlist[i].vertex=a[i];\n        adjlist[i].firstEdge=nullptr;\n    }\n    for(k=0;k<edgeNum;k++){\n        cin>>i>>j;//输入边依附的两个顶点的编号\n        s=new EdgeNode;\n        s->adjvex=j;\n        s->next=adjlist[i].firstEdge;//头插法\n        adjlist[i].firstEdge=s;//类似头指针，要指向第一个\n    }\n}\n```\n\n##### 广度优先遍历算法\n\n> 队列，链表，外层是队列判空，内层是工作指针判空\n>\n> 不能理解为把边表一条一条输出，广度有限有顺序规律的，还是要用队列\n\n```c++\ntemplate <typename DataType>\nvoid ALGraph<DataType>::BFTraverse(int v){\n    int w;//存出队元素\n    int j,Q[MaxSize];//顺序队列\n    int font=-1,rear=-1;//初始化队列\n    EdgeNode * p=nullptr;//工作指针\n    cout<<adjlist[v].vertex;visit[v]=1;\n    Q[++rear]=v;//入队\n    while(font!=rear){//当队列非空\n    \tw=Q[++rear];\n        p=adjlist[w].firstEdge;//工作指针p指向顶点v的边表\n        while(p!=nullptr){\n            j=p->adjvex;\n            if(visit[j]==0){\n                cout<<adjlist[j].vertex;\n                visited[j]=1;\n                Q[++rear]=j;\n            }\n            p=p->next;\n        }\n    }\n}\n```\n\n\n\n## 最小生成树\n\n生成树：连通图的生成树是包含全部顶点的一个极小连通子图\n\n生成树的代价：在无向连通网中，生成树上各边的权值之和\n\n最小生成树：在无向连通网中，代价最小的生成树\n\n### Prim算法\n\n重复指向操作：在所有$i∈U$、$j∈V-U$的边中找一条代价最小的边$(i,j)$并入集合$TE$，同时$J$并入$U$，直至$U=V$为止，此时TE中有$n-1$条边，$T$是一棵最小生成树。\n\n> 在已存在生成树集合中所有顶点找集合外边的边，取代价最小的那一条，把对应的那个点加入到生成树集合中，直到所有顶点都加入\n>\n> “把团队成员之外最容易拉到的入伙”\n\n算法：Prim\n输入：无向连通网G=(V，E)\n输出：最小生成树T=(U，TE)\n  1. 初始化：U = {v}； TE={ }； \n 2. 重复下述操作直到U = V： \n           2.1 在E中寻找最短边(i，j)，且满足i∈U，j∈V-U；\n           2.2 U = U + {j}；\n           2.3 TE = TE + {(i，j)}；\n\n核心代码：\n\n```c++\nvoid Prim(int v){\n    int i,j,k;\n    int adjvex[MaxSize];//记录每个成员最短边的邻接点\n    int lowcost[MaxSize];//记录到所有顶点的最短值\n    for(i=0;i<vertexNum;i++){//初始化辅助数组\n        lowcost[i]=edge[v][i];\n        adjvex[i]=v;//邻接\n    }\n    lowcost[v]=0;//已经在团队里的点置为0\n    for(k=1;k<vertexNum;k++){//迭代n-1\n    \tj=MinEdge(lowcost,vertexNum);//这一步就是找到团队外的最短边，即找数组的最小值，注意判0\n        cout<<\"(\"<<j<<\",\"<<adjvex[j]<<\")\"<<lowcost[i]<<endl;\n        lowcost[j]=0;//将顶点j加入集合U\n        for(i=0;i<vertexNum;i++)\n            if(edge[i][j]<lowcost[i]){\n                lowcost[i]=edge[i][j];\n                adjvex[i]=j;//根据新加入的来更新最短的\n            }\n    }\n}\n```\n\n完整代码：\n\n```c++\nint MinEdge(int lowcost[],int num){\n\tint min=100;\n    int minNum;\n\tfor(int i=0;i<num;i++){\n\t\tif(lowcost[i]!=0&&lowcost[i]<min){\n            min=lowcost[i];\n            minNum=i;   \n        }\n\t\t\t\n\t}\n\treturn minNum;\n}\n\nvoid Prim(int v){\n\tint i,j,k;\n\tint adjvex[MaxSize],lowcost[MaxSize];\n\tfor(i=0;i<vertexNum;i++){\n\t\tlowcost[i]=arc[v][i];\n        //在初始化的过程中对于不可达的点如果不做操作，默认是0，这里的0值就有了两种意义，一种表示是自己到自己，一种是不可达，注意区分\n        if(lowcost[i]==0&&i!=v)\n            lowcost[i]=10000;//记为无穷大\n\t\tadjvex[i]=v;\n\t}\n\tlowcost[v]=0;\n\tfor(k=1;k<vertexNum;k++){\n\t\tj=MinEdge(lowcost,vertexNum);//寻找最短边的邻接点j\n\t\tcout<<j<<adjvex[j]<<lowcost[j]<<endl;\n\t\tlowcost[j]=0;\n\t\tfor(i=0;i<vertexNum;i++){\n\t\t\tif(arc[i][j]<lowcost[i]&&arc[i][j]!=0){//说明是不可达的点，此时要判断\n\t\t\t\tlowcost[i]=arc[i][j];\n\t\t\t\tadjvex[i]=j; \n\t\t\t}\n\t\t} \n\t}\n} \n```\n\n1. 首先将adjvex全置为v，lowcost[i]表示编号为i的点到v的距离，不可达为正无穷。\n2. 然后遍历lowcost找到最小的（不包含0，0表示本身），当找到编号j到v的距离最小，那么把编号j的点到其他点的距离和lowcost比较，如果对应的值要小，那么更新lowcost对应值，同时将adjvex改为j。例如设v=0，第一轮lowcost[5]是最小的为19（表示编号v到编号5的权值是目前v到所有的邻接点中最小的），那么看邻接矩阵第五列（邻接矩阵的第五列从上到下表示编号5到编号0、编号5到编号1...的权值）从上到下对应的与lowcost的比较，如邻接\\[1][5]和lowcost[1]比，邻接\\[2][5]和lowcost[2]比等等，更新lowcost和adjvex）\n3. 重复步骤2vertexNum-1次\n\n是一种贪心策略。\n\n![image.png](https://s2.loli.net/2022/11/15/LBWnTVwJQ9CMvug.png)\n\n```c++\n//图完整代码，包含BFD、DFS、Prim，注意默认是6个顶点9条边，且顶点从0-6\n#include <iostream>\nusing namespace std;\n\nconst int MaxSize = 10;           //图中最多顶点个数\nint visited[MaxSize]={0};\n\nstruct element\n{\n\tint lowcost, adjvex;\n};\nint MinEdge(int lowcost[],int num){\n\tint min=100;\n\tint minNum; \n\tfor(int i=0;i<num;i++){\n\t\tif(lowcost[i]!=0&&lowcost[i]<min){\n\t\t\tmin=lowcost[i];\n\t\t\tminNum=i; \n\t\t}\n\t\t\t\n\t}\n\treturn minNum;\n}\ntemplate <class DataType>\nclass MGraph\n{\npublic:\n\tMGraph(DataType a[ ], int n, int e);    //构造函数，建立具有n个顶点e条边的图\n\t~MGraph( ) { }                     //析构函数为空\n\tvoid DFSTraverse(int v);              //深度优先遍历图\n\tvoid BFSTraverse(int v);               //广度优先遍历图\n\ttemplate <class T>\n\tfriend void Prim(MGraph<T> mg);\nprivate:\n    DataType vertex[MaxSize];          //存放图中顶点的数组\n    int arc[MaxSize][MaxSize];          //存放图中边的数组\n    int vertexNum, arcNum;             //图的顶点数和边数\n};\n\ntemplate <class DataType>\nMGraph<DataType>::MGraph(DataType a[ ], int n, int e)\n{\n\tint i, j, w=0;\n\tvertexNum=n; arcNum=e;\n\tfor (i=0; i<vertexNum; i++)\n\t\tvertex[i]=a[i];\n\tfor (i=0; i<vertexNum; i++)\n        for (j=0; j<vertexNum; j++)\n\t\t\tarc[i][j]=0;\n\t\tfor (int k=0; k<arcNum; k++)\n\t\t{\n\t\t\tcout<<\"请输入边的两个顶点的序号：\";\n\t\t\tcin>>i;\n\t\t\tcin>>j;\n\t\t\tcout<<\"请输入边的权值：\";\n\t\t\tcin>>w;\n\t\t\tarc[i][j]=w; arc[j][i]=w;\t\n\t\t}\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::DFSTraverse(int v)\n{\n\tcout << vertex[v]; visited[v] = 1;\n\tfor (int j = 0; j < vertexNum; j++)\n\t\tif (arc[v][j] >=1  && visited[j]==0) \n\t\t\tDFSTraverse(j);\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::BFSTraverse(int v)\n{\n\tint Q[MaxSize];\n\tint front = -1, rear = -1;   //初始化队列,假设队列采用顺序存储且不会发生溢出\n\tcout << vertex[v]; visited[v] = 1;  Q[++rear] = v;   //被访问顶点入队\n\twhile (front != rear)                   //当队列非空时\n\t{\n\t\tv = Q[++front];                   //将队头元素出队并送到v中\n\t\tfor (int j = 0; j < vertexNum; j++)\n\t\t\tif (arc[v][j]  >=1 && visited[j] == 0 ) {\n\t\t\t\tcout << vertex[j]; \n\t\t\t\tvisited[j] = 1; \n\t\t\t\tQ[++rear] = j;\n\t\t\t}\n\t}\n}\ntemplate <class DataType>\nvoid Prim(MGraph<DataType> mg){\n\tint i,j,k;\n\tint adjvex[MaxSize],lowcost[MaxSize];\n\tint v=0;\n\tint vertexNum=mg.vertexNum;\n\tfor(i=0;i<vertexNum;i++){\n\t\tlowcost[i]=mg.arc[v][i];\n\t\tif(lowcost[i]==0&&i!=v)\n            lowcost[i]=10000;//记为无穷大\n\t\tadjvex[i]=v;\n\t}\n\tlowcost[v]=0;\n\tfor(k=1;k<vertexNum;k++){\n\t\tj=MinEdge(lowcost,mg.vertexNum);//寻找最短边的邻接点j\n\t\tcout<<\"(\"<<j<<\",\"<<adjvex[j]<<\")\"<<lowcost[j]<<endl;\n\t\tlowcost[j]=0;\n\t\tfor(i=0;i<vertexNum;i++){\n\t\t\tif(mg.arc[i][j]<lowcost[i]&&mg.arc[i][j]!=0){\n\t\t\t\tlowcost[i]=mg.arc[i][j];\n\t\t\t\tadjvex[i]=j; \n\t\t\t}\n\t\t} \n\t}\n} \nint main()\n{\n\tchar ch[]={'A','B','C','D','E','F'};\n\tMGraph<char> MG(ch, 6, 9);\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n\tcout<<\"深度优先遍历序列是：\";\n\tMG.DFSTraverse(0);\n\tcout<<endl;\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n    cout<<\"广度优先遍历序列是：\";\n\tMG.BFSTraverse(0);\n\tcout<<endl;\n    cout<<\"最小生成树的生成过程为：\"<<endl;\n    Prim(MG);\n\tcout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n\n### Kruskal算法\n\n按边的权值排序\n\n> 初始所有顶点都在集合里，找最短的边加进来，加之前判断是否形成环，是则舍弃选取下一个，直到集合所有顶点都在统一连通分量上(都连通，n-1条边)\n>\n> 最小生成树可能不唯一，比如当有相同的权值边又不至形成环的时候，就可能构造出不同的最小生成树\n\n### 两种算法比较\n\n| 算法名     | 普利姆算法                 | 克鲁斯卡尔算法     |\n| ---------- | -------------------------- | ------------------ |\n| 算法思想   | 选择点                     | 选择边             |\n| 时间复杂度 | O(n<sup>2</sup>) n为顶点数 | O(eloge) (e为边数) |\n| 适应范围   | 稠密图 (边多)              | 稀疏图 (边少)      |\n\n> 时间复杂度：普利姆算法每一个顶点都要找其他顶点判断；克鲁斯卡尔选择边，与顶点数无关，边排序\n\n## 最短路径\n\n### Dijkstra算法\n\n```c++\n//图 DFS BFS Dijkstra 完整代码\n#include <iostream>\nusing namespace std;\n\n#include<string>\n\nconst int MaxSize = 10;           //图中最多顶点个数\nint visited[MaxSize]={0};\n\nstruct element\n{\n\tint lowcost, adjvex;\n};\nint Min(int dist[],int ver){\n\tint min=255,minNum=0;\n\tfor(int i=0;i<ver;i++){\n\t\tif(dist[i]<min&&dist[i]>0){\n\t\t\tmin=dist[i];\n\t\t\tminNum=i;\n\t\t}\n\t}\n\treturn minNum;\n}\ntemplate <class DataType>\nclass MGraph\n{\npublic:\n\tMGraph(DataType a[ ], int n, int e);    //构造函数，建立具有n个顶点e条边的图\n\t~MGraph( ) { }                     //析构函数为空\n\tvoid DFSTraverse(int v);              //深度优先遍历图\n\tvoid BFSTraverse(int v);               //广度优先遍历图\n\ttemplate <class T>\n\tfriend void Dijkstra(MGraph<T> MG,int v);\nprivate:\n    DataType vertex[MaxSize];          //存放图中顶点的数组\n    int arc[MaxSize][MaxSize];          //存放图中边的数组\n    int vertexNum, arcNum;             //图的顶点数和边数\n};\n\ntemplate <class DataType>\nMGraph<DataType>::MGraph(DataType a[ ], int n, int e)\n{\n\tint i, j, w=0;\n\tvertexNum=n; arcNum=e;\n\tfor (i=0; i<vertexNum; i++)\n\t\tvertex[i]=a[i];\n\tfor (i=0; i<vertexNum; i++)\n        for (j=0; j<vertexNum; j++)\n\t\t\tarc[i][j]=255; // 假设极大值为255，表示两个顶点不邻接\n\t\tfor (int k=0; k<arcNum; k++)\n\t\t{\n\t\t\tcout<<\"请输入边的两个顶点的序号：\";\n\t\t\tcin>>i;\n\t\t\tcin>>j;\n//\t\t\tarc[i][j]=1; arc[j][i]=1;\t\n\t\t\tcout<<\"请输入边的权值：\";\n\t\t\tcin>>w;\n\t\t\tarc[i][j]=w; \n\t\t\tarc[j][i]=w;\t\n\t\t}\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::DFSTraverse(int v)\n{\n\tcout << vertex[v]; visited[v] = 1;\n\tfor (int j = 0; j < vertexNum; j++)\n\t\tif (arc[v][j] <255  && visited[j]==0) \n\t\t\tDFSTraverse(j);\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::BFSTraverse(int v)\n{\n\tint Q[MaxSize];\n\tint front = -1, rear = -1;   //初始化队列,假设队列采用顺序存储且不会发生溢出\n\tcout << vertex[v]; visited[v] = 1;  Q[++rear] = v;   //被访问顶点入队\n\twhile (front != rear)                   //当队列非空时\n\t{\n\t\tv = Q[++front];                   //将队头元素出队并送到v中\n\t\tfor (int j = 0; j < vertexNum; j++)\n\t\t\tif (arc[v][j] <255  && visited[j] == 0 ) {\n\t\t\t\tcout << vertex[j]; \n\t\t\t\tvisited[j] = 1; \n\t\t\t\tQ[++rear] = j;\n\t\t\t}\n\t}\n}\ntemplate <class DataType>\nvoid Dijkstra(MGraph<DataType> MG,int v){\n\tint i,k,num,dist[MaxSize];\n\tstring path[MaxSize];\n\tfor(int i=0;i<MG.vertexNum;i++){\n\t\tdist[i]=MG.arc[v][i];\n\t\tif(dist[i]!=255){\n\t\t\t// path[i]=MG.vertex[v]+MG.vertex[i] char直接赋值给string这是不行的\n\t\t\tpath[i].push_back(MG.vertex[v]);//要用push_back\n\t\t\tpath[i].push_back(MG.vertex[i]);\n\t\t}\t\n\t\telse path[i]=\"\";\n\t\tcout<<\"|\"<<i<<\" \"<<path[i]<<\"|\"<<\" \";\n\t}\n\tcout<<endl;\n\tfor(num=1;num<MG.vertexNum;num++){\n\t\tk=Min(dist,MG.vertexNum);\n\t\tcout<<\"path\"<<k<<\" \"<<path[k]<<\",\"<<dist[k]<<\";\";\n\t\tfor(i=0;i<MG.vertexNum;i++){\n\t\t\tif(dist[i]>dist[k]+MG.arc[k][i]&&i!=v){//i!=v不做到达初始点的判断\n\t\t\tdist[i]=dist[k]+MG.arc[k][i];\n\t\t\tpath[i]=path[k]+MG.vertex[i];\n\t\t}\n\t\t}\t\n\t\tdist[k]=0;\n\t\tcout<<endl;\n\t}\n}\nint main()\n{\n\tchar ch[]={'A','B','C','D','E'};\n\tMGraph<char> MG(ch, 5, 7);\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n\tcout<<\"深度优先遍历序列是：\";\n\tMG.DFSTraverse(0);\n\tcout<<endl;\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n    cout<<\"广度优先遍历序列是：\";\n\tMG.BFSTraverse(0);\n\tcout<<endl;\n    cout<<\"从顶点\"<<ch[0]<<\"到各终点的最短路径分别是：\"<<endl;\n    Dijkstra(MG,0);\n\tcout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n\n## 有向无环图及其应用\n\n### 概念\n\n**AOV网（顶点表示活动的网）**：在一个**表示工程**的有向图中，用**顶点**表示**活动**，用**弧**表示活动之间的**优先关系**\n\nAOV网中出现回路意味着活动之间的优先关系是矛盾的\n\n**拓扑序列**：顶点序列包含所有的点，要满足当且仅当有向图中a到b有一条路径，在顶点序列中a必在b**之前**。\n\n> 得AOV网中所有应该存在的前驱和后继关系都能得到满足；拓扑序列不唯一；意义：工程中各个活动必须按照拓扑序列中的顺序进行才是可行的\n\n**拓扑排序**：对一个有向图**构造拓扑序列**的过程\n\n![image-20221218195618867](https://jjuprising.github.io/images/数据结构学习笔记/image-20221218195618867.png)\n\n> 这里注意，拓扑序列需要满足当a到b存在路径时a得在b之前即可，不需要序列所有前边的到后边的都得有路径，如这里v0到v1就没有。是一个充分条件\n\n### 拓扑排序实现\n\n* 图：带入度的邻接图\n* 栈：入度为0的顶点入栈\n\n算法：TopSort\n输入：有向图G=(V，E)\n输出：拓扑序列\n  1. 栈 S 初始化；累加器 count 初始化；\n  2. 扫描顶点表，**将入度为 0 的顶点压栈；**\n        3. 当栈 S 非空时循环\n           3.1 j = 栈顶元素出栈；输出顶点 j；count++；\n           3.2 对顶点 j 的每一个邻接点 k 执行下述操作(扫描链表)：\n                 3.2.1 将顶点 k 的入度减 1；\n                 3.2.2 **如果顶点 k 的入度为 0，则将顶点 k 入栈；**\n       4. if (count<vertexNum) 输出有回路信息；\n\n```c++\n//结点结构\ntemplate <class DataType>\nstruct VertexNode\n{\n     int in;//邻接表增加入度域，方便对入度的操作\n     DataType vertex;//存顶点\n     EdgeNode *firstEdge;\n};\nvoid ALGraph<DataType>::TopSort(){\n    int i,j;\n    int k;//存放邻接点编号\n    int count=0;//累加器，最后判断是否成环\n    int S[MaxSize],top=-1;//采用顺序栈并初始化\n    EdgeNode *p=nullptr;//工作指针\n    for(i=0;i<vertexNum;i++)//扫描顶点表\n        if(adjlist[i].in==0) S[++top]=i;//将入度为0的顶点压栈\n    while(top!=-1){//栈不空\n        j=S[top--];//入度为0出栈\n        cout<<adjlist[j].vertex;\n        count++;\n        p=adjlist[j].firstEdge;//工作指针初始化\n        while(p!=nullptr){\n            k=p->adjvex;//为编号\n            adjlist[k].in--;//邻接点入度都-1\n            if(adjlist[k].in==0) S[top++]=k;//入读为0的顶点入栈\n            p=p->next;//后移\n        }\n        if(count<vertexNum) cout<<\"有回路\";//拓扑排序一定是有所有点的\n    }\n}\n```\n\n> 如果满足拓扑序列，那么不用担心已出栈的会重复进栈，假设重复进栈，那么就会形成环。\n\n时间复杂度O(n+e)\n\n### 关键路径\n\nAOE网**（边表示活动的网）**：在一个表示工程的带权有向图中，用**顶点表示事件**，用**有向边表示活动**，边上的**权值**表示**活动的持续时间**\n\nAOE网的性质(存在的约束条件)：\n\n* 只有在进入某顶点的**各活动都已经结束**，该顶点所代表的**事件才能发生**\n* 只有在某顶点所代表的**事件发生后**，从该顶点出发的**各活动才能开始**\n\n> 注意活动是可以同时进行的！\n\n最晚开始时间-最早开始时间就是时间余量，在时间余量做不相干的事也不影响工程进度\n\n**关键路径**：AOE网中从源点到终点的**最长**路径。**(也可能不唯一)**\n\n**关键活动**：关键路径上的活动，即时间余量为0的活动\n\n> 不按期完成关键活动就会影响整个工程的进度，换言之，要缩短整个工期，必须加快关键活动的进度；\n>\n> 为什么是最长呢？因为最长的都完成了，其他的也肯定完成了，整项工程也就完成了\n\n* 如何求关键路径呢？-->求关键活动\n* 如何求关键活动呢？关键活动为什么是关键的？关键活动的开始时间不能推迟-->其最早开始时间和最晚开始时间相等\n\n#### 事件(顶点)的最早和最迟\n\n如何求ve(j)和vl(j)？\n\n1. 最早发生时间从ve(1)=0开始**向后递推**，相当于找到这个事件的最长路径\n2. 最迟发生时间从vl(n)=ve(n)开始**向前递推**\n\n![image-20221223153541781](https://jjuprising.github.io/images/数据结构学习笔记/image-20221223153541781.png)\n\n> 最早发生时间从前往后推，完成后可以立马开始的那一条。例如左图中Vu到Vj完成了但是下边的还没有完成，Vj不能开始，而当最长的Vx到Vj完成了前面肯定都完成了，可以开始Vj因此最早为88。前边加求最大\n>\n> 最迟发生时间从后往前推，必须开始的时间，晚于这个时间就不能按时完成后边的.如右图，顶点上的数为各事件的最晚发生时间，减去前边活动天数就是允许拖延的事件。Vx的5-2最小为3，说明只允许拖三天就必须要开始了，再晚点开始耗费两天的话就超过Vx的最迟发生时间了，因此Vj最迟时间为3。后边减求最小\n\n#### 活动(边)的最早和最迟\n\n最早发生时间等于弧尾事件的最早发生时间\n\n最迟发生时间等于弧头事件的最晚发生时间减去这条弧的长度\n\n## 问题\n\n1. n个顶点的无向图，采用邻接表存储：\n\n**统计出度为0的顶点个数**\n\n```c++\nint SunZero(MGraph mg){\n\tint count;//统计有多少个\n\tfor(int i=0;i<mg.vertexNum;i++){\n\t\tint tag=0;//标记 \n\t\tfor(int j=0;i<mg.vertexNum;j++){\n\t\t\tif(edge[i][j]!=0){\n\t\t\t\ttag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t} \n\t\tif(tag==0) count++;\n\t} \n\treturn count;\n}\n```\n\n\n\n# 查找技术\n\n**关键码**：可以标识一个记录的某个数据项\n\n如何评价查找算法的效率呢？：和关键码的比较次数\n\n平均查找长度：查找算法进行的关键码比较次数的数学期望值\n\n## 线性表的查找技术\n\n### 顺序查找(线性查找)\n\n思想：从表的一端到另一端，逐个比较\n\n以下代码默认待查表索引0处不存值。\n\n```c++\nint SeqSearch(int r[],int n,int k){\n    int i=n;\n    while(i>0&&r[i]!=k)\n        i--;\n    return i;//若没查到返回值是0\n}\n```\n\n> 从后往前，注意判断是否越界\n\n改进版：尽头设置哨兵，免去判越界\n\n```c++\nint LineSearch::SeqSearch2(int k){\n    int i=n;\n    data[0]=k;//设置哨兵\n    while(data[i]!=k)//免去判越界\n        i--;\n    return i;//同样查不到返回的是0\n}\n```\n\n\n\n| 算法 | 顺序查找                                         |\n| ---- | ------------------------------------------------ |\n| 优点 | 算法简单、使用面广。对存储(线或链)、有序性无要求 |\n| 缺点 | 查找效率低，特别是元素多的时候                   |\n\n### 折半查找(对半查找、二分查找)\n\n思想：如其名\n\n先排好序！\n\n#### 非递归\n\n```c++\nint LineSearch::BinSearch1(int k){\n    int mid,low=1,high=n;//1开始记录的\n    while(low<=high){//如果没找到，low会超过high，结束循环\n        mid=(high+low)/2;\n        if(k<data[mid]) high=mid-1;\n        else if(k>data[mid]) low=mid+1;\n        else return mid;//查找成功，返回元素序号\n    }\n    return 0;//查找失败，返回0\n}\n```\n\n#### 递归\n\n```c++\nint LineSearch::BinSearch2(int low,int high,int k){\n    int mid;\n    if(low>high) return 0;//递归的边界条件\n    else{\n        mid=(low+high)/2;\n        if(k>data[mid]) BinSearch2(mid+1,high,k);\n        else if(k<data[mid]) BinSearch2(low,mid-1,k);\n        else return mid;//查找成功返回序号\n    }\n}\n```\n\n## 树表的查找技术\n\n### 二叉排序树\n\n#### 定义\n\n* 一棵空的二叉树\n* 或者满足：\n  * 若它的左子树不空，则左子树上所有结点的值均小于根结点的值\n  * 若它的右子树不空，则右子树上所有结点的值均小于根结点的值\n  * 它的左右子树都是而二叉排序树\n\n> 二叉排序树的中序序列即是升序序列\n\n**存储：**二叉链表\n\n#### 二叉树排序树的实现\n\n```c++\nclass BiSortTree{\npublic:\n    ...\nprivate:\n    BiNode<int> *InsertBST(BiNode<int> *bt , int x); \n    BiNode<int> *SearchBST(BiNode<int> *bt, int k);   \n    void Release(BiNode<DataType> *bt);     \n    BiNode<int> *root;    \n}\n```\n\n##### 查找\n\n* 找不到的情况\n* 找到的情况\n* 比当前小的情况\n* 比当前大的情况\n\n```c++\nBiNode<int> * BiSortTree::SearchBST(BiNode<int>* bt,int k){//k是查找值\n    if(bt==nullptr) return nullptr;\n    if(bt->data==k) return bt;//找到了\n    if(bt>data>k) return SearchBST(bt->lchild,k);//大于查找值，查左树\n    else return SearchBST(bt->rchild,k);//小于查找值，查右s\n} \n```\n\n\n\n##### 插入\n\n思路：\n\n* 若二叉排序树为空树，则新插入的结点为新的根结点；\n* 否则，新插入的结点必为一个**新的叶子结点**，其插入位置由**查找过程**得到。\n* 比当前结点小，则插入它的左子树；否则插入右子树\n\n核心：\n\n* 递归\n* 链表插入结点\n\n```c++\nBiNode<int>* BiSortTree::InsertBST(BiNode<int> *bt,int x){\n    if(bt==nullptr){\n        //为空插入\n        BiNode<int> *s=new BiNode<int>;\n        s->data=x;\n        s->lchild=s->rchild=nullptr;\n        bt=s;//新结点上树\n        return bt;\n    }else if(bt->data>x) bt->lchild=InsertBST(bt->lchild,x);\n    else bt->rchild=InsertBST(bt->rchild,x);//注意这里不是单纯的递归函数就可以了，需要赋值的，因为会插入结点改变树\n}\n```\n\n> 注意有返回值，返回值为新结点，赋值给传入树的左/右子树\n\n##### 构造\n\n建立在插入的基础上\n\n（1）每次插入的新结点都是二叉排序树上**新的叶子结点**;\n（2）找到插入位置后，不必移动其它结点，仅需修改某个结点的指针；\n（3）在左子树/右子树的查找过程与在整棵树上查找过程相同；\n（4）新插入的结点没有破坏原有结点之间的关系。\n\n```c++\nBiSortTree::BiSortTree(int a[],int n){\n    root=nullptr;\n    for(int i=0;i<n;i++)\n        root=InsertBST(root,a[i]);\n}\n```\n\n\n\n##### 删除\n\n* 删除后仍要保持二叉排序树的特性\n* 当删除分支节点就破坏了原有的链接关系，需要重新修改指针\n\n**分三种情况：**\n\n1. 被删除的结点是叶子结点\n\n   则将它的双亲结点相应的指针域值置为空，比如p是f的左孩子，现在删除p则`f->lchild=nullptr;`\n\n2. 被删除的结点只有左子树或者只有右子树\n\n   把删除结点的左(右)子树代替它的位置即可，比如p是f的左孩子，而p不是叶子，它有右子树，这是删除p，则`f->lchile=p->rchild`\n\n   这里不管是怎么样，有左子树还是右子树，都是代替它的位置，因为由性质可知左子树所有元素都小于根节点，右子树都大于它，因此代替后不会影响它的有序性\n\n3. **被删除的结点既有左子树，又有右子树**\n\n   分两种情况：当p是f的左孩子，删p时则以f的左子树中的最大值结点替换之，最大值就在左子树的最右下；当p是f的有孩子，则以f右子树的最小值替换它，在最左下\n\n   这样保证了我的左子树都小于我，右子树都大于我，因此选左边的最大或右边的最小\n\n   > 注意特殊情况，当最大/最小就是被删除结点的孩子时\n\n```c++\n//注意，下面默认p是f的左孩子，右孩子同理不失一般性，但是要另写\ntemplate <typename DataType>\nvoid BiSortTree::DeleteBST(BiNode<int> *p,BiNode<int> *f){\n    if((p->lchild==nullptr)&&(p-rchild==nullptr)){\n        //p为叶子\n        f->lchild=NULL;//先置为空\n        delete p;//再删除\n        return;\n    }\n    if(p->rchild==nullptr){\n        //p只有左子树\n        f->lchild=p->lchild;\n        delete p;\n        returnl\n    }\n    if(p->lchild==nullptr){\n        //p只有右子树\n        f->lchild=p->rchild;\n        delete p;\n        return;\n    }\n    //找左子树最大的，找最右下\n    BiNode<int> *par=p,*s=p->lchild;\n    while(s->rchild!=nullptr){\n        par=s;//工作指针\n        s=s->rchild;\n    }\n    p->data=s->data;//修改值\n    if(par==p) par->rchild=s->lchild;\n    else par->lchild=s->lchild;//挂到par\n    delete s;\n}\n```\n\n##### 给定结点的深度\n\n```c++\nvoid Level(BiNode *root,BiNode *p){\n    if(root==nullptr) return 0;\n    if(p==root) return 1;\n    else if(p->data<root->data) return Level(root->lchild,p)+1;//每递归一次说明多了一层\n    else return Level(root->rchild,p)+1;\n}\n```\n\n\n\n#### 平均查找长度\n\n查找成功的平均查找长度为：∑（本层高度*本层元素个数）/节点总数\n\n查找不成功的平均查找长度：∑（本层高度*本层补上的叶子个数）/补上的叶子总数\n\n### 平衡二叉树\n\n* **平衡因子：**<u>该结点的左子树的深度减去右子树的深度</u>\n* **平衡二叉树：**\n  * 一棵空的二叉排序树，或者同时满足：\n  * 根结点的左子树和右子树的深度最多相差1\n  * 根结点的左子树和右子树都是平衡二叉树\n\n插入一个结点会影响哪些结点的平衡因子？\n\n* 最小不平衡子树：以距离插入结点最近的、且平衡因子的绝对值大于 1 的结点为根的子树\n\n> 且入且判断，一旦失衡立即调整；只调整最小不平衡子树，并且不影响其他结点；充分利用二叉排序树的性质来作调整\n\n#### LL型\n\n* B结点带左子树一起上升\n* A成为B的右孩子(因为A大于B)\n* B结点原来的右子树作为A的左子树\n\n![image-20221220165706645](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220165706645.png)\n\n#### RR型\n\n* B结点带右子树一起上升\n\n* A结点成为B的左孩子\n\n* 原来B的左子树做A的右子树\n\n![image-20221220165423429](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220165423429.png)\n\n#### LR型\n\n* C结点穿过A、B结点上升\n* B结点成为C的左孩子，A结点成为C的右孩子(因为B是小于C的，而A是大于C的)\n* 原来C结点的左子树作为B的右子树，C结点的右子树作为A的左子树\n\n![image-20221220164736781](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220164736781.png)\n\n#### RL型\n\n![image-20221220165952142](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220165952142.png)\n\n> 一个原则，上升后根据二叉排序树的性质进行调整\n\n## 散列表的查找技术\n\n* **散列表：**采用散列技术存储查找集合的**连续存储空间**。\n\n* **散列函数：**将关键码**映射为**散列表中适当**存储位置**的函数\n\n* 散列地址：由散列函数所得的存储地址\n\n* **散列函数的设计：**\n\n  * 计算简单。不应太大计算量，降低茶轴效率\n  * 函数值(即散列地址)分布均匀，相同概率散列到散列表中，减少冲突\n\n  > 两个方面是矛盾的，根据具体情况选择一个合理的方案\n\n![image-20221220171726174](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220171726174.png)\n\n常见的散列函数\n\n| 散列函数 | 直接定址法                                                   | 平方取中法                                                   | 除留余数法                                 |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |\n| 形式     | H(key)=a×key+b                                               | 对关键码平方后，按散列表大小，取中间的若干位作为散列地址。   | H(key)=key mod p                           |\n| 例子     | 关键码集合为{10, 30, 50, 70, 80, 90}，选取的散列函数为H(key)=key/10，则10存在下标为1，30在2... | 要求散列地址为 2 位，则(1234)<sup>2</sup>＝1522756，(1235)<sup>2</sup>＝1525225，分别取27，52 | 散列表长为15，设计H(key)= key  mod  13     |\n| 适用     | 事先**知道**关键码，关键码**集合**不是很大且连续性较好       | 事先**不知道**关键码的分布且关键码的**位数**不是很大         | 最简单、最常用，不要求事先知道关键码的分布 |\n\n以下关于哈希查找的叙述中错误的是（A ）。\n\nA. 用拉链法解决冲突易引起堆积现象\n\nB. 用线性探测法解决冲突易引起堆积现象\n\nC. 哈希函数选得好可以减少冲突现象\n\nD. 哈希函数H(k)=k MOD p，p通常取小于等于表长的素数\n\n### 处理冲突的方法\n\n#### 开放寻址法\n\n* **闭散列表**：用开放定址法处理冲突得到的散列表\n\n原理：\n\n1）计算散列地址：j = H(key)\n\n2）如果地址 j 的存储单元没有存储记录，则存储key对应的记录；\n\n3）如果在地址 j 发生冲突，则**寻找一个空的散列地址**，存储key对应的记录；\n\n如何寻找一个空的散列地址？\n\n* 线性探测法\n* 二次探测法\n* 随机探测法等\n\n##### 线性探测法\n\n当发生冲突时，寻找空散列表地址的公式为：Hi=(H(key)**＋d<sub>i</sub>**) % m   （d<sub>i</sub>=1，2，…，m-1)\n\n这个di是设定的，比如设定为1，那么当冲突时就往后试探一位，再冲突再试探，直到有空位\n\n**堆积：**非同义词对同一个散列地址争夺的现象\n\n算法：Search\n输入：闭散列表ht[ ]，待查值k\n输出：如果查找成功，则返回记录的存储位置，否则返回查找失败的标志-1\n         1. 计算散列地址 j；\n         2. 探测下标i初始化：i = j；\n      1. 执行下述操作，直到 ht[i] 为空：\n            2.3.1 若 ht[i] 等于 k，则查找成功，返回记录在散列表中的下标；\n      3.2 否则，i 指向下一单元；\n         4. 查找失败，返回失败标志-1；\n\n```c++\nint HashTabel::Search(int k){\n    int i,j=H(k);//计算散列地址\n    i=j;//设置比较的起始位置\n    while(ht[i]!=0){\n        if(ht[i]==k) return i;//查找成功\n        else i=(i+1)%m;//向后探测一个位置\n    }\n    return -1;//查找失败\n}\n```\n\n##### 二次探测法\n\n以冲突位置为中心，**跳跃式**寻找空的散列地址。\n\nHi=(H(key)＋d<sub>i</sub>) % m   （d<sub>i</sub> = 1<sup>2</sup>,-1<sup>2</sup>,,2<sup>2</sup>,,-2<sup>2</sup>,,… , q<sup>2</sup>,,-q<sup>2</sup>,(q≤m/2)）\n\n#### 拉链法\n\n**开散列表**：用拉链法处理冲突得到的散列表\n\n**同义词子表**：所有散列地址**相同的记录**构成的单链表。(拉链一样链起来)\n\n对于给定的关键码key执行下述操作：\n\n（1）计算散列地址：j = H(key)\n\n（2）将key对应的记录插入(头插法)到同义词子表 j 中；\n\n```c++\n//用拉链法处理冲突，散列表的构造过程如下\nj=H(k);\nNode<int> *p=ht[i];\nwhile(p!=nullptr){\n    if(p->data==k) break;\n    else p=p->next;\n}\nif(p==null){\n    q=new Node<int>;\n    q->data=k;\n    q->next=ht[j];\n    ht[j]=q;\n}\n```\n\n![image-20221220195949858](https://jjuprising.github.io/images/数据结构学习笔记/image-20221220195949858.png)\n\n# 排序技术\n\n* 稳定性：原序列中，a=b且a在b之前，排序后a仍在b之前，称排序算法稳定；否则称为不稳定\n* **趟：**排序过程中，将待排序的记录序列**扫描一遍**称为一趟\n\n## 插入排序\n\n### 直接插入排序\n\n#### 代码\n\n```c++\nvoid Sort::InsertSort(){\n    int i,j,temp;\n    for(i=1;i<length;i++){//⭐排序进行length-1趟\n        temp=data[i];//暂存每一轮的目标记录\n        for(j=i-1;j>=0&&temp<data[j];j--){\n            data[j+1]=data[j];\n        }\n        data[j+1]=temp;//每一轮退出上述循环时，j会--，即只有j+1个位置是空的，故插入位置为j+1\n    }\n}\n```\n\n#### 情况分析\n\n**最好情况：**\n\n* 待排序序列都是正序。\n* 每趟只需与有序序列最后一个记录比较一次，移动两次记录。\n\n比较次数：$n-1$ ，移动次数：$2(n-1)$\n\n**最坏情况：**\n\n* 待排序记录为逆序\n* 第i个记录要和前面i-1个记录比较，每次执行一次移动\n\n比较次数：$\\frac{n(n-1)}{2}$ ， 移动次数： $\\frac{(n+4)(n-1)}{2}$\n\n**平均情况：** \n\n* 各种可能\n* 插入第i个记录需要比较有序区中全部记录的一半\n\n比较次数：$\\frac{n(n-1)}{4}$， 移动次数：$\\frac{(n+4)(n-1)}{4}$\n\n### ⭐希尔排序\n\n#### 改进点\n\n①当待排序记录基本有序，直接插入排序的效率很高（怎么使得排序记录基本有序）\n\n②直接插入排序简单，在记录个数少时效率也很高（怎么使得排序的记录少）\n\n③让元素跨度大一些以更早地到达最终位置\n\n####  关键问题 \n\n①如何分割待排序记录，使得基本有序:不能是逐段分割，而是将相距某个增量的记录组成一个子序列\n\n②子序列内怎么进行直接插入排序\n\n```c++\ntemp = r[i];  j = i - d; \t\nwhile (j > 0 && temp < data[j]) \n{\n    data[j + d] = data[j];  j = j - d;\n}\ndata[j + d] = temp;\n```\n\n![image-20221221113526097](https://jjuprising.github.io/images/数据结构学习笔记/image-20221221113526097.png)\n\n#### 代码\n\n```c++\nvoid Sort::ShellSort(){\n    int i,j,temp;//暂存\n    for(d=length/2;d>0;d--){//增量为d进行直接插入排序\n        for(i=d;i<length;i++){//进行一趟希尔排序\n            temp=data[i];\n            for(j=i-d;j>0&&data[j]>temp;j=j-d)//至关重要的\n                data[j+d]=data[j];//记录后移d个单位\n            data[j+d]=temp;\n        }\n        \n    }\n}\n```\n\n> 一趟希尔排序就是在增量d的情况下把所有子序列都拍好的结果\n\n\n\n## 交换排序\n\n### ⭐起泡排序\n\n每轮冒出一个最大(小)的\n\n#### 基本思路\n\n* 两两比较记录，如果反序则交换，直到没有反序的记录为止\n\n#### 关键问题\n\n①在一趟排序中，多个记录位于**最终位置**时如何记载？\n\n•  用exchange标记每次交换的位置，<u>则最终exchange之后所有记录都是有序</u>\n\n②如何确定**有序区的范围**\n\n•  用bound记录，每一轮bound等于上一轮最终的exchange\n\n③如何判别起泡排序**结束**？\n\n•  当exchange为0\n\n④进入循环之前exchange初值为？\n\n•  [0-length-1]时，exchange=length-1\n\n#### 代码\n\n```c++\nvoid Sort::BubbleSort(){\n    int j;//位置\n    int exchange;//记录每次交换的位置\n    int bound;//记录有序区范围\n    int temp;//暂存\n    exchange=length-1;//先记下范围，后面赋值给bound\n    while(exchange!=0){//结束条件exchange=0，全有序了\n        bound=exchange;\n        exchange=0;\n        for(j=0;j<bound;j++)\n            if(data[j]>data[j+1]){\n                temp=data[j];\n                data[j]=data[j+1];\n                data[j+1]=temp;\n                exchange=j;//记录每次交换的位置\n            }\n    }\n}\n```\n\n\n\n### ⭐快速排序\n\n#### 基本思想\n\n选一个**轴值**，将待排序记录划**分成两部**分，左侧记录均小于或等于轴值，右侧记录均大于或等于轴值，然后分别对这两部分重复上述过程，直到整个序列有序。\n\n#### 关键问题\n\n①如何选择轴值？\n\n* 多种，最简单选第一个记录\n\n②在待排序序列中如何进行划分\n\n③如何处理划分得到的两个待排序子序列\n\n④如何判别快排结束\n\n* 对序列进行一次划分，再分别对左右两个子序列进行快排，再对...快排\n\n* 直到每个分区只有一个记录\n\n![image-20221221115949199](https://jjuprising.github.io/images/数据结构学习笔记/image-20221221115949199.png)\n\n```c++\n//一次划分\nint Sort::Parttition(int first,int last){\n    int i=first;//左侧\n    int j=last;//右侧\n    int temp;\n    while(i<j){\n        while(i<j&&data[j]>=data[i]) j--;\n        if(i<j){\n            temp=data[i];\n            data[i]=data[j];\n            data[j]=temp;\n            i++;//注意这里\n        }\n        while(i<j&&data[i]<=data[j]) i++;\n        if(i<j){\n            temp=data[i];\n            data[i]=data[j];\n            data[j]=temp;\n            j--;\n        }\n    }\n    return i;//返回轴值最终位置\n}\n\n//递归\nvoid Sort::QuickSort(int first,int last){\n    if(first>=last) return;//区间长度为1，递归结束\n    else{\n        int pivot=Partition(first,last);//一次划分\n        QuickSort(first,pivot-1);//左侧快排\n        QuickSort(pivot+1,last);//右侧快排\n    }\n}\n```\n\n\n\n## 选择排序\n\n### 简单选择排序\n\n#### 代码\n\n```c++\nvoid Sort::SelectSort(){\n    int index,i,temp;\n    for(int i=0;i<length;i++){//进行length-1趟简单选择排序\n        index=i;\n        for(int j=i+1;j<length){//在无序区中选取最小记录\n            if(data[j]<data[index]) index=j;\n        }\n        if(index!=i){\n            temp=data[i];\n            data[i]=data[index];\n            data[index]=temp;\n        }\n    }\n}\n```\n\n\n\n### ⭐堆排序\n\n堆的实质满是足如下性质的完全二叉树：二**叉树中任一非叶子结点均小于(大于)它的孩子结点**\n\n大根堆：k<sub>i</sub>≥k<sub>2i</sub>且k<sub>i</sub>≥k<sub>2i+1</sub>\n\n从最后一个非叶子结点开始调整，即从 n/2开始，n/2-1...到1\n\n> 堆存储数组是层序遍历形式\n>\n> 堆调整中左孩子是什么表示的$2×i+1$：存储从data[0]开始，所以左孩子是$2×i+1$，右孩子是$2×i+2$\n>\n> 重建堆\n\n```c++\n//堆调整 仅是对一个元素进行调整，堆排序需要反复调用推调整\nvoid Sort::Sift(int k,int last){\n    int i,j,temp;\n    i=k;//i是被调整结点\n    j=2*i+1;//j是i的左孩子\n    while(j<=last){\n        if(j<last&&data[j+1]>data[j]) j++;//j指向左右孩子的较大者\n        if(data[i]>data[j]) break;//说明已经是堆\n        else{\n            temp=data[j];\n            data[j]=data[i];\n            data[i]=temp;\n            i=j;j=2*i+1;//被调整结点位于结点J的位置\n        }\n    }\n}\n//堆排序\nvoid Sort::HeapSort(){\n    int i,temp;\n    for(i=ceil(length/2)-1;i>=0;i--)\n        //从最后一个分支结点(即最后一个非叶子结点)至根结点调整\n        Sift(i,length-1);\n    for(i=1;i<length;i++){\n        temp=data[0];\n        data[0]=data[length-1];\n        data[length-1]=temp;\n        Sift(0,length-i-1);//重建堆\n    }\n}\n```\n\n> 当i从1开始的堆排序，注意有好几处不同\n\n```c++\n//堆排序\n//堆调整\nvoid Sift(int k,int r[],int n){\n\tint i,j,temp;\n\ti=k;j=2*i;//去+1\n\twhile(j<=n){//还没到叶子\n\t\tif(j<n&&r[j]<r[j+1]) j++;//j指向左右孩子的较大者\n\t\tif(r[i]>r[j]) break;//已经是堆\n\t\telse{\n\t\t\ttemp=r[i];\n\t\t\tr[i]=r[j];\n\t\t\tr[j]=temp;\n\t\t\ti=j;j=2*i;//去+1\n\t\t} \n\t}\n} \nvoid HeapSort(int r[],int n){\n\tint i,temp;\n\tfor(i=n/2;i>=1;i--)//去eil\n\t//从最后一个分支结点至根结点调整\n\t\tSift(i,r,n);\n\tfor(i=1;i<n;i++){//1\n\t\ttemp=r[1];r[1]=r[n-i+1];r[n-i+1]=temp;//n-i+1 1\n\t\tSift(1,r,n-i);//重建堆 1 \n\t} \n```\n\n\n\n## 各种排序的比较\n\n![image-20221209142457790](https://jjuprising.github.io/images/数据结构学习笔记/image-20221209142457790.png)\n\n\n\n|   排序方法   |               平均情况                |       最好情况       |       最坏情况       |\n| :----------: | :-----------------------------------: | :------------------: | :------------------: |\n| 直接插入排序 |           O(n<sup>2</sup>)            |         O(n)         |   O(n<sup>2</sup>)   |\n|   希尔排序   | O(nlog<sub>2</sub>n)~O(n<sup>2</sup>) |  O(n<sup>1.3</sup>)  |   O(n<sup>2</sup>)   |\n|   起泡排序   |           O(n<sup>2</sup>)            |         O(n)         |   O(n<sup>2</sup>)   |\n|   快速排序   |         O(nlog<sub>2</sub>n)          | O(nlog<sub>2</sub>n) |   O(n<sup>2</sup>)   |\n| 简单选择排序 |           O(n<sup>2</sup>)            |   O(n<sup>2</sup>)   |   O(n<sup>2</sup>)   |\n|    堆排序    |         O(nlog<sub>2</sub>n)          | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) |\n|   归并排序   |         O(nlog<sub>2</sub>n)          | O(nlog<sub>2</sub>n) | O(nlog<sub>2</sub>n) |\n\n![image-20221221183614599](https://jjuprising.github.io/images/数据结构学习笔记/image-20221221183614599.png)\n\n![image-20221209142555586](https://jjuprising.github.io/images/数据结构学习笔记/image-20221209142555586.png)\n\n\n\n![image-20221209142741177](https://jjuprising.github.io/images/数据结构学习笔记/image-20221209142741177.png)\n\n\n\n![image-20221209142925247](https://jjuprising.github.io/images/数据结构学习笔记/image-20221209142925247.png)\n\n\n\n![image-20221209143059040](https://jjuprising.github.io/images/数据结构学习笔记/image-20221209143059040.png)\n\n\n\n","tags":["笔记"],"categories":["本科课程"]},{"title":"课本Dijkstra算法Cpp实现及改正","url":"/2022/11/16/Dijkstra算法C++实现/","content":"\n01点17分，又是一个与奇怪问题较量的夜晚，这一次，我又成功解决了。\n\n起因是发现数据结构书上关于Dijkstra算法的实现有点错误，想要自己更正一下，通过在不同位置插入输出字符来调试代码，找到了几处错漏。\n\n* 96行的char直接赋值给string出现乱码，两种办法，一是string+=char，另一种是string.puch_back(char)\n\n* 107行，由于是无向图，有可能路径会重复连上两次，我们要让路径不再逆向连接，例如A起始，默认第一轮是已知AB最短为10，在判断最短路径时，没有排除A，到时AB又连上A，变成ABA，而这个ABA是在path[0]上的，虽然每轮输出最短路径时就不需要输出path[起始点]，这样子的错误也是无妨，只需要跳过path[起始点]即可，但是在调试过程中发现这个错漏，还是从根本上修正，可以把它改成有向图，把初始化的arc\\[j][i]=w去掉。\n\n* (自己的问题)输出结果为?，发现原来是经典for循环是其他变量在递增时还是写了i++...导致循环出不来\n\n* 还有一个注意点需要补充，就是可变参数友元函数的声明:\n\n  ```c++\n  template <class DataType>\n  class MGraph\n  {\n      ...\n      template <class T>\n      friend void Dijkstra(MGraph<T> MG,int v);//友元函数声明，注意不可是DataType，会和类冲突，得换掉，这里是T\n  }\n  \n  //函数实现\n  template <class DataType>\n  void Dijkstra(MGraph<DataType> MG,int v){//这里可以是DataType\n      ...\n  }\n  ```\n\n  \n\n```c++\n//图 DFS BFS Dijkstra 完整代码\n#include <iostream>\nusing namespace std;\n\n#include<string>\n\nconst int MaxSize = 10;           //图中最多顶点个数\nint visited[MaxSize]={0};\n\nstruct element\n{\n\tint lowcost, adjvex;\n};\nint Min(int dist[],int ver){\n\tint min=255,minNum=0;\n\tfor(int i=0;i<ver;i++){\n\t\tif(dist[i]<min&&dist[i]>0){\n\t\t\tmin=dist[i];\n\t\t\tminNum=i;\n\t\t}\n\t}\n\treturn minNum;\n}\ntemplate <class DataType>\nclass MGraph\n{\npublic:\n\tMGraph(DataType a[ ], int n, int e);    //构造函数，建立具有n个顶点e条边的图\n\t~MGraph( ) { }                     //析构函数为空\n\tvoid DFSTraverse(int v);              //深度优先遍历图\n\tvoid BFSTraverse(int v);               //广度优先遍历图\n\ttemplate <class T>\n\tfriend void Dijkstra(MGraph<T> MG,int v);\nprivate:\n    DataType vertex[MaxSize];          //存放图中顶点的数组\n    int arc[MaxSize][MaxSize];          //存放图中边的数组\n    int vertexNum, arcNum;             //图的顶点数和边数\n};\n\ntemplate <class DataType>\nMGraph<DataType>::MGraph(DataType a[ ], int n, int e)\n{\n\tint i, j, w=0;\n\tvertexNum=n; arcNum=e;\n\tfor (i=0; i<vertexNum; i++)\n\t\tvertex[i]=a[i];\n\tfor (i=0; i<vertexNum; i++)\n        for (j=0; j<vertexNum; j++)\n\t\t\tarc[i][j]=255; // 假设极大值为255，表示两个顶点不邻接\n\t\tfor (int k=0; k<arcNum; k++)\n\t\t{\n\t\t\tcout<<\"请输入边的两个顶点的序号：\";\n\t\t\tcin>>i;\n\t\t\tcin>>j;\n//\t\t\tarc[i][j]=1; arc[j][i]=1;\t\n\t\t\tcout<<\"请输入边的权值：\";\n\t\t\tcin>>w;\n\t\t\tarc[i][j]=w; \n//\t\t\tarc[j][i]=w;//改成有向图，使得路径不重复\n\t\t}\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::DFSTraverse(int v)\n{\n\tcout << vertex[v]; visited[v] = 1;\n\tfor (int j = 0; j < vertexNum; j++)\n\t\tif (arc[v][j] <255  && visited[j]==0) \n\t\t\tDFSTraverse(j);\n}\n\ntemplate <class DataType>\nvoid MGraph<DataType>::BFSTraverse(int v)\n{\n\tint Q[MaxSize];\n\tint front = -1, rear = -1;   //初始化队列,假设队列采用顺序存储且不会发生溢出\n\tcout << vertex[v]; visited[v] = 1;  Q[++rear] = v;   //被访问顶点入队\n\twhile (front != rear)                   //当队列非空时\n\t{\n\t\tv = Q[++front];                   //将队头元素出队并送到v中\n\t\tfor (int j = 0; j < vertexNum; j++)\n\t\t\tif (arc[v][j] <255  && visited[j] == 0 ) {\n\t\t\t\tcout << vertex[j]; \n\t\t\t\tvisited[j] = 1; \n\t\t\t\tQ[++rear] = j;\n\t\t\t}\n\t}\n}\ntemplate <class DataType>\nvoid Dijkstra(MGraph<DataType> MG,int v){\n\tint i,k,num,dist[MaxSize];\n\tstring path[MaxSize];\n\tfor(int i=0;i<MG.vertexNum;i++){\n\t\tdist[i]=MG.arc[v][i];\n\t\tif(dist[i]!=255){\n\t\t\t// path[i]=MG.vertex[v]+MG.vertex[i] char直接赋值给string这是不行的\n\t\t\tpath[i].push_back(MG.vertex[v]);//要用push_back\n\t\t\tpath[i].push_back(MG.vertex[i]);\n\t\t}\t\n\t\telse path[i]=\"\";\n\t\tcout<<\"|\"<<i<<\" \"<<path[i]<<\"|\"<<\" \";\n\t}\n\tcout<<endl;\n\tfor(num=1;num<MG.vertexNum;num++){\n\t\tk=Min(dist,MG.vertexNum);\n\t\tcout<<\"path\"<<k<<\" \"<<path[k]<<\",\"<<dist[k]<<\";\";\n\t\tfor(i=0;i<MG.vertexNum;i++){\n\t\t\tif(dist[i]>dist[k]+MG.arc[k][i]){\n\t\t\tdist[i]=dist[k]+MG.arc[k][i];\n\t\t\tpath[i]=path[k]+MG.vertex[i];\n\t\t}\n\t\t}\t\n\t\tdist[k]=0;\n\t\tcout<<endl;\n\t}\n}\nint main()\n{\n\tchar ch[]={'A','B','C','D','E'};\n\tMGraph<char> MG(ch, 5, 7);\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n\tcout<<\"深度优先遍历序列是：\";\n\tMG.DFSTraverse(0);\n\tcout<<endl;\n\tfor (int i=0; i<MaxSize; i++)\n\t\tvisited[i]=0;\n    cout<<\"广度优先遍历序列是：\";\n\tMG.BFSTraverse(0);\n\tcout<<endl;\n    cout<<\"从顶点\"<<ch[0]<<\"到各终点的最短路径分别是：\"<<endl;\n    Dijkstra(MG,0);\n\tcout<<endl;\n    system(\"pause\");\n    return 0;\n}\n```\n\n","tags":["C++"],"categories":["经验"]},{"title":"爱心特效","url":"/2022/11/14/爱心特效/","content":"\n原网站是：https://www.manyuan.ltd\n\n在原网站的基础上作了修改，可以添加自定义文字，关键在于和爱心中心的相对位置需要随着界面的大小改变而改变，另外我将它部署到了我的博客上作为展示([github-hexo 如何添加自定义网页 - 简书 (jianshu.com)](https://www.jianshu.com/p/524b073f9b37)）。\n\n自定义的爱心效果：[就这个爱心嘛 (jjuprising.github.io)](https://jjuprising.github.io/love/)\n\n![image.png](https://s2.loli.net/2022/11/14/45gaMUA7YJwsmfB.png)\n\n由于原本的画布是有做根据页面**动态更新大小**的，使得爱心总是位于界面的中央，这个功能非常好，因此我的想法在这个基础上获取画布的长宽，再加入微调值使得文字可以位于爱心的中央，同时能够保持和爱心的相对位置不变。此外，为了解决手机端适配的问题，在head中加上了最后一行META(令人惊讶的是，原网站没有这一句，但是依然可以**适配手机页面**，值得我去研究研究)。再者，我在尝试自己插入bgm时发现了audio设置auto还是无法自动播放的问题，最终参考原网站代码添加了播放检测的脚本解决了问题。\n\n当然，这种方法是比较笨的，需要根据效果手动微整，也是目前我能想到的解决办法。而且，手机适配也做得一般，爱心会显示不全，且设置的字体加载不出来，效果差强人意，有待优化。\n\n自定义修改的位置：\n\n修改文字：在div元素中修改\n\n手动微调：在代码的第299行，修改最后±的数值即可\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n<HTML>\n <HEAD>\n  <TITLE> 就这个爱心嘛 </TITLE>\n  <META NAME=\"Generator\" CONTENT=\"EditPlus\">\n  <META NAME=\"Author\" CONTENT=\"\">\n  <META NAME=\"Keywords\" CONTENT=\"\">\n  <META NAME=\"Description\" CONTENT=\"\">\n  <META name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=3.0, minimum-scale=1.0, user-scalable=yes\"> <!--适配手机 content参数依次 显示大小 初始大小 最大大小 最小大小 是否支持用户缩放 -->\n  <style>\n  html, body {\n  height: 100%;\n  padding: 0;\n  margin: 0;\n  background: #000;\n}\ncanvas {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\ndiv{\n    position: absolute;\n  width: 100%;\n  height: 100%;\n}\naudio{\n  display: none;\n}\n  </style>\n </HEAD>\n\n <BODY>\n  <canvas id=\"pinkboard\" ></canvas>\n  <div id=\"text\" style=\"font-family: \\534E\\6587\\884C\\6977;\">5 2 0</div>\n  <audio id=\"music\" autoplay=\"autoplay\" controls=\"controls\" loop=\"loop\" preload=\"auto\" src=\"http://music.163.com/song/media/outer/url?id=9442015.mp3\">\n  </audio>\n  <script>\n    // music\n    window.onload = function(){\n    setInterval(\"toggleSound()\",1);\n}\nfunction toggleSound() {\n    var music = document.getElementById(\"music\");//获取ID  \n    if (music.paused) { //判读是否播放  \n        music.paused=false;\n        music.play(); //没有就播放 \n    }    \n}\n//--创建页面监听，等待微信端页面加载完毕 触发音频播放\ndocument.addEventListener('DOMContentLoaded', function () {\n    function audioAutoPlay() {\n        var audio = document.getElementById('music');\n            audio.play();\n        document.addEventListener(\"WeixinJSBridgeReady\", function () {\n            audio.play();\n        }, false);\n    }\n    audioAutoPlay();\n});\n//--创建触摸监听，当浏览器打开页面时，触摸屏幕触发事件，进行音频播放\ndocument.addEventListener('touchstart', function () {\n    function audioAutoPlay() {\n        var audio = document.getElementById('music');\n            audio.play();\n    }\n    audioAutoPlay();\n});\n\n  /*\n * Settings\n */\nvar settings = {\n  particles: {\n    length:   500, // maximum amount of particles\n    duration:   2, // particle duration in sec\n    velocity: 100, // particle velocity in pixels/sec\n    effect: -0.75, // play with this for a nice effect\n    size:      30, // particle size in pixels\n  },\n};\n\n/*\n * RequestAnimationFrame polyfill by Erik M?ller\n */\n(function(){var b=0;var c=[\"ms\",\"moz\",\"webkit\",\"o\"];for(var a=0;a<c.length&&!window.requestAnimationFrame;++a){window.requestAnimationFrame=window[c[a]+\"RequestAnimationFrame\"];window.cancelAnimationFrame=window[c[a]+\"CancelAnimationFrame\"]||window[c[a]+\"CancelRequestAnimationFrame\"]}if(!window.requestAnimationFrame){window.requestAnimationFrame=function(h,e){var d=new Date().getTime();var f=Math.max(0,16-(d-b));var g=window.setTimeout(function(){h(d+f)},f);b=d+f;return g}}if(!window.cancelAnimationFrame){window.cancelAnimationFrame=function(d){clearTimeout(d)}}}());\n\n/*\n * Point class\n */\nvar Point = (function() {\n  function Point(x, y) {\n    this.x = (typeof x !== 'undefined') ? x : 0;\n    this.y = (typeof y !== 'undefined') ? y : 0;\n  }\n  Point.prototype.clone = function() {\n    return new Point(this.x, this.y);\n  };\n  Point.prototype.length = function(length) {\n    if (typeof length == 'undefined')\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    this.normalize();\n    this.x *= length;\n    this.y *= length;\n    return this;\n  };\n  Point.prototype.normalize = function() {\n    var length = this.length();\n    this.x /= length;\n    this.y /= length;\n    return this;\n  };\n  return Point;\n})();\n\n/*\n * Particle class\n */\nvar Particle = (function() {\n  function Particle() {\n    this.position = new Point();\n    this.velocity = new Point();\n    this.acceleration = new Point();\n    this.age = 0;\n  }\n  Particle.prototype.initialize = function(x, y, dx, dy) {\n    this.position.x = x;\n    this.position.y = y;\n    this.velocity.x = dx;\n    this.velocity.y = dy;\n    this.acceleration.x = dx * settings.particles.effect;\n    this.acceleration.y = dy * settings.particles.effect;\n    this.age = 0;\n  };\n  Particle.prototype.update = function(deltaTime) {\n    this.position.x += this.velocity.x * deltaTime;\n    this.position.y += this.velocity.y * deltaTime;\n    this.velocity.x += this.acceleration.x * deltaTime;\n    this.velocity.y += this.acceleration.y * deltaTime;\n    this.age += deltaTime;\n  };\n  Particle.prototype.draw = function(context, image) {\n    function ease(t) {\n      return (--t) * t * t + 1;\n    }\n    var size = image.width * ease(this.age / settings.particles.duration);\n    context.globalAlpha = 1 - this.age / settings.particles.duration;\n    context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);\n  };\n  return Particle;\n})();\n\n/*\n * ParticlePool class\n */\nvar ParticlePool = (function() {\n  var particles,\n      firstActive = 0,\n      firstFree   = 0,\n      duration    = settings.particles.duration;\n  \n  function ParticlePool(length) {\n    // create and populate particle pool\n    particles = new Array(length);\n    for (var i = 0; i < particles.length; i++)\n      particles[i] = new Particle();\n  }\n  ParticlePool.prototype.add = function(x, y, dx, dy) {\n    particles[firstFree].initialize(x, y, dx, dy);\n    \n    // handle circular queue\n    firstFree++;\n    if (firstFree   == particles.length) firstFree   = 0;\n    if (firstActive == firstFree       ) firstActive++;\n    if (firstActive == particles.length) firstActive = 0;\n  };\n  ParticlePool.prototype.update = function(deltaTime) {\n    var i;\n    \n    // update active particles\n    if (firstActive < firstFree) {\n      for (i = firstActive; i < firstFree; i++)\n        particles[i].update(deltaTime);\n    }\n    if (firstFree < firstActive) {\n      for (i = firstActive; i < particles.length; i++)\n        particles[i].update(deltaTime);\n      for (i = 0; i < firstFree; i++)\n        particles[i].update(deltaTime);\n    }\n    \n    // remove inactive particles\n    while (particles[firstActive].age >= duration && firstActive != firstFree) {\n      firstActive++;\n      if (firstActive == particles.length) firstActive = 0;\n    }\n    \n    \n  };\n  ParticlePool.prototype.draw = function(context, image) {\n    // draw active particles\n    if (firstActive < firstFree) {\n      for (i = firstActive; i < firstFree; i++)\n        particles[i].draw(context, image);\n    }\n    if (firstFree < firstActive) {\n      for (i = firstActive; i < particles.length; i++)\n        particles[i].draw(context, image);\n      for (i = 0; i < firstFree; i++)\n        particles[i].draw(context, image);\n    }\n  };\n  return ParticlePool;\n})();\n\n/*\n * Putting it all together\n */\n(function(canvas) {\n  var context = canvas.getContext('2d'),\n      particles = new ParticlePool(settings.particles.length),\n      particleRate = settings.particles.length / settings.particles.duration, // particles/sec\n      time;\n  \n  // get point on heart with -PI <= t <= PI\n  function pointOnHeart(t) {\n    return new Point(\n      160 * Math.pow(Math.sin(t), 3),\n      130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25\n    );\n  }\n  \n  // creating the particle image using a dummy canvas\n  var image = (function() {\n    var canvas  = document.createElement('canvas'),\n        context = canvas.getContext('2d');\n    canvas.width  = settings.particles.size;\n    canvas.height = settings.particles.size;\n    // helper function to create the path\n    function to(t) {\n      var point = pointOnHeart(t);\n      point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;\n      point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;\n      \n      return point;\n    }\n    // create the path\n    context.beginPath();\n    var t = -Math.PI;\n    var point = to(t);\n    context.moveTo(point.x, point.y);\n    while (t < Math.PI) {\n      t += 0.01; // baby steps!\n      point = to(t);\n      context.lineTo(point.x, point.y);\n    }\n    context.closePath();\n    // create the fill\n    context.fillStyle = '#ea80b0';\n    context.fill();\n    // create the image\n    var image = new Image();\n    image.src = canvas.toDataURL();\n    return image;\n  })();\n  \n  // render that thing!\n  function render() {\n    // next animation frame\n    requestAnimationFrame(render);\n    \n    // update time\n    var newTime   = new Date().getTime() / 1000,\n        deltaTime = newTime - (time || newTime);\n    time = newTime;\n    \n    // clear canvas\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // create new particles\n    var amount = particleRate * deltaTime;\n    for (var i = 0; i < amount; i++) {\n      var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());\n      var dir = pos.clone().length(settings.particles.velocity);\n      particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);\n    }\n    \n    // update and draw particles\n    particles.update(deltaTime);\n    particles.draw(context, image);\n  }\n  \n  // handle (re-)sizing of the canvas\n  function onResize() {\n    var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());\n    canvas.width  = canvas.clientWidth;\n    canvas.height = canvas.clientHeight;\n    div=document.getElementById('text');\n     div.style.left=canvas.width/2-56;\n     div.style.top=canvas.height/2.3;\n     div.style.fontSize=50;\n     div.style.color=\"white\";\n  }\n  window.onresize = onResize;\n  \n  // delay rendering bootstrap\n  setTimeout(function() {\n    onResize();\n    render();\n  }, 10);\n})(document.getElementById('pinkboard'));\n  </script>\n </BODY>\n</HTML>\n\n```\n\n","tags":["教程","html"],"categories":["编程"]},{"title":"如何写申报书和管理项目","url":"/2022/11/03/如何写申报书和管理项目/","content":"\n# 计划类文档的体例和内容关系\n\n## 简介/摘要\n\n* 研究背景\n* 现存问题\n* 主要研究内容\n* 创新点\n* 实验结果/核心成果\n\n## 项目背景\n\n问题的背景(技术的应用场景？系统的使用环境？)-->对核心问题的凝练表述(一个词组/一句话)-->理论重要性(问题本身在理论上未能完善解决)、社会意义、应用价值(如能完善，可能获得的收益)\n\n## 相关工作调研(角度:研究领域、产业领域；国内、国外；论文、产品、专利；)\n\n* 解决项目拟研究问题的核心技术(不止一个)的发展沿革及现状\n* 应用要素本身如有与核心技术配合构成系统的情况(从系统角度对相关研究发展加以概述)\n  * 核心技术有没有已经做了或用别的技术来解决了这个问题的\n  * 你这么做又可以解决什么其他的问题\n\n## 问题描述/拟研究问题\n\n* 选择合适的套路：(数学模型法、场景描述法、系统构成法(功能需求、性能需求))\n* 严谨、准确、无歧义的描述(独立于解决方案)\n* 留扣子:将问题解决的核心方法要素/需求进行解构分析(-->潜移默化地催眠读者，尽可能使之对后续的研究内容、技术路线有顺理成章的认同感)\n\n## 研究内容(总分总结构)\n\n从技术面对问题解决方案进行结构，逐一分析\n\n## 技术方案(路线、重点、难点)\n\n(与主要研究内容的区别是：研究内容着重讲做什么；技术路线着重讲怎么做)\n\n重点：如果实现了，至少基本解决了提出的问题(保底)\n\n难点：如果实现了，能较好地解决提出的问题(锦上添花)\n\n## 可行性分析\n\n**理论可行性**\n\n(类比：核心技术在其他领域的应用，从功能和性能上，是否与拟研究应用的要求相吻合)\n\n(着重方案合理性/避重就轻)\n\n**条件可行性**\n\n(研究基础、物质条件、非物质条件)\n\n## 研究计划/进度安排\n\n研究内容的逻辑理论、研究路线的细节理清-->每季度的进度规划(+阶段性成果或进度检验标准)\n\n甘特图\n\n## 预期成果\n\n研究生：专利+论文\n\n本科生：软著/专利+比赛作品/论文\n\n## 经费\n\n资料费、软著费、专利费\n\n\n\n申报书印象分加分技巧：\n\n1. 排版有条理(分点罗列、层次清晰) 适当加粗/高亮显示一些关键词句\n\n2. 主次分明、详略得当\n\n3. 图表化展示核心概念、思路、方法、过程、原理\n\n   切记直接挪用CSDN、知乎、百度百科等(带水印)\n\n   风格要统一\n\n4. 参考文献统一国标标准\n\n5. 工作量(字数和内容)\n\n   字数一万多差不多得了，内容要精妙\n\n从申报书到论文/作品：\n\n​\t申报书(体例框架、基本图、表等素材)-->引言、相关工作、问题描述(迭代优化)-->解决方案、实验验证\n\n以上笔记来自杨欢老师的线上课堂，向杨欢老师致谢。\n\n\n\n# 本科申报书格式\n\n是本人参考之前的活动策划案、师兄师姐的申报书自己设定的一个格式。\n\n* 大标题如国内外研究现状：黑体、四号、一倍行距\n* 正文：中文宋体、小四，英文TImes New Roman\n* 标题序号：1.->1.1->(1)->缩进两个，1)->①\n* 行距：正文固定值20磅，段前段后0.5行\n* 图片嵌入性单倍行距，一定要是矢量图如SVG，比PNG清晰很多倍\n  * 如果用draw.io导出svg要在全选在文本栏下取消勾选自动换行和格式化文本否则插入到word会乱\n","tags":["项目","经验分享"],"categories":["经验"]},{"title":"解决rehl8 Unable to read consumer identity的问题","url":"/2022/11/02/解决rehl8-Unable-to-read-consumer-identity的问题/","content":"\n看看现在的时间吧01:00……本来想着今天能早点睡了，结果被这个问题折磨了一个多小时(尝试百度，然后CSDN上各种牛鬼蛇神的答案折磨)\n\n感谢susu老师的录屏，经过几步简单的操作让我今晚能安心入眠。\n\n# 起因\n\n在进行源码编译安装的开头\n\n```shell\n[root@localhost ~]# yum -y install gcc make\nUnable to read consumer identity\nThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.\nError: There are no enabled repos.\n```\n\n哈哈出现了这个问题\"This system is not registered to Red Hat\"\n\n其实就是需要换一下国内源，而用CentOS应该是没有问题的，这里就介绍以下rehl8的解决办法。\n\n# 新解决办法\n\n2023.1.2 好像阿里云的epel被删了，所以如果配置的阿里云的会失效了\n\n挂好光驱之后\n\n配置内容：\n\n```bash\n[AppStream]\nname=rhel8.2\nbaseurl=file:///dvd/AppStream\nenabled=1\ngpgcheck=0\n[BaseOS]\nname=rhel8.2\nbaseurl=file:///dvd/BaseOS\nenabled=1\ngpgcheck=0\n```\n\n应该是可以用yum的了...\n\n# 旧解决办法(！epel失效！)\n\n## 先挂好光驱\n\n**临时挂载**\n\n```shell\n[root@localhost ~]# mkdir /dvd/\n[root@localhost ~]# mount /dev/cdrom /dvd/ #把光驱挂到/dvd下\n```\n\n### 至关重要的一步！！\n\n修改配置文件，这里进行换源\n\n```shell\n[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo\n```\n\n直接复制粘贴以下内容，但是注意如果你的不是挂载/dvd/下的，在注释的地方要作相应变动。\n\n```shell\n[BaseOS]\nname=BaseOS\nbaseurl=file:///dvd/BaseOS #具体路径修改\ngpgcheck=1\ngpgkey=/etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial\n[AppStream]\nname=AppStream\nbaseurl=file:///dvd/AppStream #具体路径修改\ngpgcheck=0\n[epel]\nname=EPEL\nbaseurl=http://mirrors.aliyun.com/epel/$releasever/Everything/$basearch\ngpgcheck=0\nenabled=1\n[httpAppstream]\nname=aliyun Appstream\nbaseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os\ngpgcheck=0\n```\n\n>  记得ESC+:wq保存~\n\n**这一步设置之后就可以解决问题了！**\n\n重启之后都要重新mount，不太方便，接着进行：\n\n**永久挂载**\n\n```shell\n[root@localhost ~]# vim /etc/fstab\n#在末尾添加 空格分隔即可\n/dev/cdrom /dvd/   iso9660 defaults 0 0\n[root@localhost ~]# reboot #重启一下\n```\n\n**检查挂好没**\n\n```shell\n[root@localhost ~]# mount #看最后是否有 /dev/sr0 on /dvd....\n```\n\n## 开始装编译器\n\n```shell\n[root@localhost ~]# yum clean /all  #清一下缓存\n[root@localhost ~]# yum repolist -v #重新加载一下\n[root@localhost ~]# yum -y install gcc gcc-c++ make\nUpdating Subscription Management repositories.\nUnable to read consumer identity\nThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.\n上次元数据过期检查：0:00:37 前，执行于 2022年11月02日 星期三 00时55分25秒。\n错误：\n 问题 1: cannot install the best candidate for the job\n  - nothing provides libgcc >= 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64\n  - nothing provides libgomp = 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64\n 问题 2: cannot install the best candidate for the job\n  - nothing provides libstdc++ = 8.5.0-4.el8_5 needed by gcc-c++-8.5.0-4.el8_5.x86_64\n(尝试添加 '--skip-broken' 来跳过无法安装的软件包 或 '--nobest' 来不只使用最佳选择的软件包)\n\n```\n\n这时候报错了。\n\n确实，又报错了哈哈，应该是版本问题，还好susu也有讲，按照提示加上'--nobest'即可。\n\n```shell\n[root@localhost ~]# yum -y install --nobest gcc gcc-c++ make\n```\n\n>  搞掂！舒服了~ Zzz\n\n对了，这时候别忘了拍张快照，一劳永逸：）\n","tags":["Linux"],"categories":["经验"]},{"title":"Java学习笔记","url":"/2022/09/29/Java学习笔记/","content":"\n# 错题\n\n* 通过super可调用父类构造函数。对\n\n* 构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的\n\n* 一般在创建新对象时，系统会自动调用构造函数。对\n\n* 【单选题】下面赋值语句不合法的是___D___。\n\n  A.Long a=(Long)(long)3;\n\n  B.Long b=3L;\n\n  C. Long c=Long.parseLong(\"3\");\n\n  D.Long d=(Long )3; \n\n  下面赋值语句不合法的是 D。在Java中，\"Long\"类是原始数据类型long的**包装类**，必须使用关键字\"new\"来构造包装类，才能创建有效的对象。从长值3创建Long对象的正确方法如下：\n\n  ```java\n  Long d = new Long(3);\n  ```\n\n  其他三个选项都是从长值3创建Long对象的有效方法。选项A从将整数值3转换为长值，然后再转换为Long的结果创建Long对象。选项B从长值3L创建Long对象。选项C通过调用Long类的parseLong方法，从字符串值\"3\"创建Long对象。\n\n* 【单选题】java语言中，在定义类时不能使用的修饰符是____B______。 A.public  B.private C.abstract D.final\n\n  * 答案是 B：private。在 Java 语言中，private 是一种访问修饰符，它只能在类的内部使用，不能用于定义类。\n  * A 选项：public。public 是一种访问修饰符，它表示在任何地方都能够访问。定义类时可以使用 public 修饰符。\n  * C 选项：abstract。abstract 是一种修饰符，它用于定义抽象类和抽象方法。定义类时可以使用 abstract 修饰符。\n  * D 选项：final。final 是一种修饰符，它表示类不能被继承，方法不能被重写。定义类时可以使用 final 修饰符。\n\n*  在Java语言中，下面关于Math类的常见操作不正确的描述是_____D__B___。\n\n  A.执行Math.ceil(-10.5) 语句的结果是-10.0\n\n  B.执行Math.round(10.5) 语句的结果是11.0 **(答案是11，没有小数点！)**\n\n  C.执行Math.floor(-10.5) 语句的结果是-11.0\n\n  D.执行Math.round(-10.5) 语句的结果是-10\n\n  `Math.round` 不完全是四舍五入，当刚好为负数且刚好0.5，舍入到正无穷方向上的整数。如`Math.round(-20.5)`结果为`-20`\n\n* 【单选题】执行下面程序段后，输出结果是___C______。\n\n  int a=4,b=6,c=8;\n\n  System.out.println(++a*b---c );\n\n  A.11\n\n  B.16\n\n  C.22\n\n  D.23\n\n  注意后面的---前两个应该是b的后缀，而不是后两个是c的前缀，由于是后缀，无影响，而a的前缀加了用，因此是5×6-8结果为22，而且b的值变为5，a为5。\n\n* 下面概念中，不属于面向对象程序设计的是_____A_____。\n\n  A.过程调用 \n\n  B.对象 \n\n  C.类 \n\n  D.继承\n  \n  文本框获得焦点时回车和按钮单击，都属于**ActionEvent**事件，也就是说**文本框和按钮**可以作为ActionEvent事件的事件源。\n  \n  而**选择框**的选中，和**下拉列表**的选中，都是在触发**ItemEvent**事件。\n  \n  不同类型的事件的监听器要实现的接口不同，对于ActionEvent事件，这个接口是  ActionListener，实现其中的actionPerformed方法，方法传入的也是ActionEvent对象。\n  \n  而对于ItemEvent事件，则要实现的是ItemListener接口，实现其中的itemStateChanged方法，方法传入的是ItemEvent对象。\n\n* 下面关于java.sql包中接口和类的描述不正确的是__B__。\n\n  A.Connection 接口：表示数据库连接\n\n  B.DriverManager类：表示驱动器 **(错，JDBC 的管理层，作用于用户和驱动程序之间。)**\n\n  C.ResultSet接口：表示SQL查询语句返回的<u>结果集</u>\n\n  D.Statement接口：负责<u>执行</u>SQL语句\n\n* 在Java语言中，下面用于执行<u>存储过程</u>SQL语句的是___B___。\n\n  A.Statement\n\n  B.CallableStatement\n\n  C.createStatement\n\n  D.PreparedStatement\n\n  Statement 对象有三种:(Statement)对象用于执行不带参数的简单 SQL语句; (PreparedStatement)对象继承Statement，用于执行**带或不带参数**的预编译 SOL语句:**(CallableStatement)** 对象继承PreparedStatement，**用于执行对数据库存储过程的调用**\n\n* 在Java语言中，下面关于Scanner类描述错误的是_____D__C___。\n\n  A.Scanner类可以方便的完成输入流的输入操作\n\n  B.Scanner sc=new Scanner(System.in);//从标准输入中扫描\n\n  C.Scanner类位于javax.util包中，使用时需要import导入**(是java.util)**\n\n  D.Scanner可以**扫描指定的文件**.\n\n  D是对的，C是错的。\n\n* 在Java语言中，下面不属于ComponentEvent的子类是____D______。\n\n  A.InputEvent\n\n  B.FocusEvent\n\n  C.WindowEvent\n\n  D.ItemEvent\n\n  ItemEvent不属于ComponentEvent的子类。\n\n* 在Java语言中，下面关于组件定义错误的是____ D_____。\n\n  A.TextField tf=new TextField(3);//int型指定列宽\n\n  B.Timer tr=new Timer();\n\n  C.JFileChooser jf=new   JFileChooser();\n\n  D.TextArea ta=new TextArea(3);\n\n* 在Java语言中，以下____C____项是**接口**B的正确定义。\n\n  A.interface B{ void print(){ };}\n\n  B.abstract interface B{void print(){}}\n\n  C.interface B {void print();}\n\n  D.interface B extend A { void print(){}}//A为已定义接口\n\n  ```java\n  public interface Paintable{\n      void draw();//没有{}，可省略public abstract关键字\n  }\n  interface intf1{}\n  interface intf2 extends intf1{}//接口继承接口\n  ```\n\n* 下面概念中，不属于面向对象程序设计的是_____A_____。\n\n  A.过程调用 \n\n  B.对象 \n\n  C.类 \n\n  D.继承\n  \n* 在Java语言中，成员变量中被static关键字修饰的变量，叫 B\n\n  A.变量 \n\n  B.类变量 **（静态变量的成员变量）**\n\n  C.实例变量 \n\n  D.整型变量\n\n* 在Java语言中，下面关于String类的常见操作不正确的描述是______B____。\n\n  A.假设 `s =\"class\"`;则执行`char c = s.charAt(1)`语句后变量c的值是`l`\n\n  B.`indexOf`方法是查找特定字符或字符串在当前字符串中的起始位置，如果不存在则返回0 。**（返回-1）**\n\n  C.`concat`方法的作用是进行字符串的连接，将两个字符串连接以后形成一个新的字符串\n\n  D.`equals`方法的作用是判断两个字符串对象的内容是否相同\n\n  `charAt()` 方法用于返回指定索引处的字符。索引范围为从 `0` 到 `length() - 1`。\n\n* 下面关于try catch语句中异常类排列顺序正确的说法是____B______。\n\n  A.父类异常在前，子类异常在后\n\n  **B.父类异常在后，子类异常在前**\n\n  C.父类和子类异常排列顺序前后无影响\n\n  D.只能有子类异常\n\n* 已知Integer.MAX_VALUE 的值为2147483647，在执行“Integer max1=Integer.MAX_VALUE,max2= max1+1;”语句后，max2等于____A______。\n\n  **A.-2147483648**\n\n  B.2147483647\n\n  C.0\n\n  D.2147483648\n\n* 在Java语言中，Person类有一个成员变量age被protected修饰，下面关于age说法不正确的是___C_______。\n\n  A.能被Person的子类访问。\n\n  B.能被Person类所在同一个包中的其它类访问。\n\n  C.能被Person类所在包之外的其它类访问。\n\n  D.不能被Person类所在包之外的其它类访问。\n\n  protected 访问控制符能被用于方法和成员变量\n   声明为protected的方法和成员变量**能被同一个包里的所有类所访问**，就像默认修饰符package一样\n  能被**该类的子类所访问**，子类可以和父类不在一个包中。\n  另一个包中的子类**只能通过子类或其子类的引用来访问**父类中受保护的成员。同一包中的子类没有此限制。这样可以确保来自其他包的类只访问属于其继承层次结构一部分的成员\n\n* 下面哪项不属于Statement接口提供的3个执行SQL语句的方法______A____。\n\n  A.executeDelete(String sql)\n\n  **B.executeUpdate(String sql)**\n\n  **C.executeQuery(String sql)**\n\n  **D.execute(String sql)**\n\n* 在Java语言中，下面关于RandomAccessFile描述错误的是_____D_____。\n\n  A.实现DataInput和DataOutput接口\n\n  B.getFilePointer()方法：返回此文件中的当前偏移量\n\n  C.readFloat()方法：从此文件读取一个 float\n\n  D.writeChar(int v)：按双字节值将char写入该文件，先写低字节(**将一个字符作为一个两个字节的值写入基础输出流，其中高字节在前**。)\n\n* 在Java语言中，下面相关描述错误的是____B______。\n\n  A.File类对象对应于系统中的一个目录或文件\n\n  B.CharArrayReader 是一个把字符数组作为源的输出流的实现.**(输入流)**\n\n  C.FileInputStream：以字节流方式读取\n\n  D.FileReader：把文件转换为字符流读入\n\n* 下面关于Java事件描述错误的是_____A_____。\n\n  A.只有外部操作会产生事件\n\n  **B.可以通过继承EventObject类编写自定义事件类**\n\n  **C.事件处理的三要素包括事件源、事件以及事件监听器**\n\n  **D.要在事件源上注册事件监听器**\n\n* 在Java语言中，下面关于Applet描述错误的是A。\n\n  A.Applet能执行任何本地计算机上的程序(错误)\n\n  B.Applet的生命周期中有四个状态：初始态、运行态、停止态和消亡态\n\n  C.Applet的init()方法在Applet的生存周期中只调用一次\n\n  D.Applet应用程序必须嵌入在HTML页面中，才能得到解释执行\n\n  此外，Applet是Java类，且通常情况下不能进行文件的I/O操作\n\n* 在Java语言中，下面关于List不正确的描述是_______B___。\n\n  A.List是在java.util包中\n\n  B.List是一个类**（是接口）**\n\n  C.List具有get(int index)方法\n\n  D.List是一个接口\n\n  List，Set，Map都是接口\n\n* 在Java语言中，类Double定义在以下的哪个包中_____C_____。\n\n  A.java.io\n\n  B.javax.lang\n\n  C.java.lang\n\n  D.java.util\n\n* 在Java语言中，下面关于接口错误描述的是___A___。\n\n  A.接口不仅包括方法的特征，还有方法的实现。\n\n  **B.接口只允许public 和abstract修饰。**\n\n  **C.接口中的<u>属性</u>只能被public 、final、static修饰。**\n\n  **D.一个类可以实现多个接口。**\n\n  接口中的<u>属性</u>只能被public 、final、static修饰，而且必须赋值，因为是常量，在后面不能改变，否则会报错，不会给默认值的\n\n* 在Java语言中，执行下列程序段后，i的结果是____D______。\n\n  int i;\n\n  for(i=0;i<10;i++)\n\n  {      \n\n   if (i>4){  continue;}// 一直跳过\n\n   if(i>7 ){ System.out.println(i); break;}\n\n  }\n\n  A.6\n\n  B.8\n\n  C.9\n\n  D.10\n\n* 在Java语言中，下面关于颜色定义不合法的是___B_______。\n\n  A.Color c1=new Color(0xffffff) \n\n  B.Color c2=new Color(Color.BLUE) \n\n  C.Color c3=new Color(0,0,255) \n\n  D.Color c4=new Color(0.2f,0.6f,1.0f)\n\n  Color 是 Java 中的一个类，可以用来表示颜色。在 Java 中，可以使用以下几种方法来定义颜色：\n\n  - 使用 16 进制 RGB 值来定义颜色，例如 A.Color c1=new Color(0xffffff)。\n  - 使用 24 位 RGB 值来定义颜色，例如 C.Color c3=new Color(0,0,255)。\n  - 使用浮点型 RGB 值来定义颜色，例如 D.Color c4=new Color(0.2f,0.6f,1.0f)。\n\n  B.Color c2=new Color(Color.BLUE) 中的 Color.BLUE 是预定义的颜色常量，它表示蓝色。这种方式并不能用来定义颜色，因此 B 选项是不合法的。\n\n* 下面**不属于**Java语言中常见事件类型的是____C______。\n\n  **A.KeyEvent** \n\n  **B.MouseEvent** \n\n  C.TouchEvent \n\n  **D.ItemEvent**\n\n* 在Java语言中，下面不符合数组定义格式的是___D_______。\n\n  A.int []a=new int [3]; \n\n  B.int b[]={1,2,3}; \n\n  C.int c[]=new int [3]; \n\n  D.int e[3]=new int [3];\n\n  在 Java 中，数组是用于存储一组相同类型的数据的数据结构。在 Java 中，可以使用以下几种方法来定义数组：\n\n  - 使用 new 运算符来定义数组，例如 A.int []a=new int [3]; 和 C.int c[]=new int [3];。\n  - 使用 {} 来定义数组并初始化数组元素，例如 B.int b[]={1,2,3};。\n  \n* 在Java语言中，下面变量命名不合法的有 C\n\n  A.$fn\n\n  B.p5p\n\n  C.static\n\n  D._user\n\n  必须以字母、下划线、或者美元符$开头；\n\n* 在Java语言中，下面不属于JDBC的主要功能是A\n\n  A.解析SQL语句\n\n  **B.处理数据库的返回结果**\n\n  **C.建立与数据库或者其他数据源的连接**\n\n  **D.向数据库发送SQL命令**\n\n* 在Java语言中，下面用于执行**简单的不带参数的**SQL语句是 A\n\n  A.Statement\n\n  B.PreparedStatement\n\n  C.CallableStatement\n\n  D.createStatement\n\n* 定义int A=5，执行“System.out.println(\"a=\"+((A<5)?5.1:4));” 语句的结果是 B\n\n  A.a=5.1\n\n  B.a=4.0\n\n  C.a=5\n\n  D.a=4\n\n  三目运算符后面类型不同需要类型升级\n\n* 在Java语言中，下面关于包描述不正确的是 C\n\n  **A.包提供了访问权限和命名的管理机制**\n\n  **B.包是Java提供的一种区别类的名字空间的机制**\n\n  C.类只能访问其所在包中的所有类\n\n  **D.包是类的组织方式，是一组相关类和接口的集合**\n\n  (1)具有public权限的类能**被所有包中的类访问**,与所在的包无关(2)具有缺省权限的类只能被所在包中的类访问,不能再其包外访问\n\n* 定义char x='a'，下面赋值语句不合法的有 **B**\n\n  A.float b=x；\n\n  B.byte c=x;\n\n  C.double d=x;\n\n  D.int a=x;\n\n  应该为 byte c=(byte)x;\n\n* 在Java语言中，下面关于异常的错误描述是_____D_____。\n\n  A.异常是java提供的用于处理程序中错误的一种机制\n\n  B.java.lang. Exception类是所有异常的父类\n\n  C.java.lang.NullPointerException是空指针异常类\n\n  D.当异常产生时，程序会自动跳转到异常处理程序\n\n* 在Java语言中，下面关于File类描述错误的是 A\n\n  A.执行File f=new File(\"e:\\\\txx.txt”)语句的结果是在e盘上创建了一个txx.txt文件\n\n  B.File类对象对应于系统中的一个目录和文件\n\n  C.File类对象描述文件名、可否读写等属性，但不读写文件\n\n  D.一旦创建，File对象表示的抽象路径名将不会改变\n\n  File f=new File;创建的是一个对象\n  \n* 在Java语言中，下面关于AWT组件描述错误的是 C\n\n  A.Choice:制作用于单选的下拉列表\n\n  B.与菜单相关的类主要有三个: MenuBar、Menu、Menultem\n\n  C.Panel类可作为容器容纳其它组件，也可以独立存在\n\n  D.Canvas:代表屏幕上一块空白的矩形区域\n\n  Panel类可作为容器容纳其它组件，也可以独立存在必须在窗体容器中使用，无法脱离窗体显示\n\n* `substring()`截取字符串，从索引0开始计数\n\n  ```java\n  String Str = new String(\"This is text\");\n   \n          System.out.print(\"返回值 :\" );\n          System.out.println(Str.substring(4) );//4开始到最后\n   \n          System.out.print(\"返回值 :\" );\n          System.out.println(Str.substring(4, 10) );//含头不含尾\n  //结果\n  返回值 : is text\n  返回值 : is te\n  ```\n\n  `public int index0f(int ch,int fromlndex)`: 返回从 `fromlndex` 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n\n* 编译JavaApplication源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为**D**\n\n  A. .html\n\n  B. .Java\n\n  C. .exe\n\n  **D. .class**\n\n* 字符串比较。Java中，使用\"==\"比较字符串时，判断的是两个字符串是否存放在相同的位置。\n\n  ```java\n  例如：x = \"Hello\"; y = \"Hello\";\n  \n  x == y; //就是True\n  \n  x == \"Hello\"; //也是True\n  \n  如果 String z=new String(x);\n  x==z;//结果就是false\n  ```\n\n* 在Java语言中，关于final修饰符的说法不正确的是 C\n\n  **A.fnal成员变量表示常量，只能被赋值一次，赋值后值不再改变**\n\n  **B.final类不能被继承，没有子类，fnal类中的方法默认是final的**\n\n  C.final能用于修饰构造方法\n\n  **D.final方法不能被子类的方法覆盖，但可以被继承**\n\n   final修饰的类，为最终类，该**类不能被继承**。如String 类；final修饰的**方法可以被继承和重载**，但不能被重写、覆盖；final修饰的变量不能被修改，是个**常量**\n  \n* main是static，所以不能直接调用非静态的方法\n\n* 方法重载就是一个类中有多个同名但有**不同形参和方法体**的方法 对\n\n* Java String类 trim() 方法用于删除字符串的头尾空白符\n\n## 大题模板\n\n### 集合类\n\n#### ArrayList\n\n```java\nList<String> list=new ArrayList<>();\n\t\tlist.add(\"a\");\n\t\t//第一种\n\t\tIterator<String> iterator=list.iterator();\n\t\twhile(iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t\titerator.remove();//移除\n\t\t}\n\t\t//第二种\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i));\n\t\t\tlist.remove(i)//移除\n\t\t}\n```\n\n#### TreeSet\n\n截取部分输出 `it=tree.SubSet(头,尾).iterator();`  `it=tree.headSet(边界).iterator();`\n\n```java\nTreeSet<UpdateStu>tree =new TreeSet<>();\nUpdateStu stu1=new UpdateStu(\"李同学\", 01011);\nUpdateStu stu2=new UpdateStu(\"陈同学\",01021);\n...;\ntree.add(stu1);\ntree.add(stu2);\ntree.add(stu3);\ntree.add(stu4);\nIterator<UpdateStu> it=tree.iterator();\nit=tree.headSet(stu2).iterator();\nSystem.out.println(\"截取前面部分的集合：\");\nwhile(it.hasNext()){\n\tSystem.out.println(it.next());\t\t\t\n}\nit=tree.subSet(stu2, stu3).iterator();\nSystem.out.println(\"截取中间部分的集合\");\nwhile(it.hasNext()){\n\tSystem.out.println(it.next());\n}\n```\n\n### 文件存取\n\n#### 字节流创建--输入--读取\n\n```java\nFile file=new File(\"MyFile.txt\");\n```\n\n写入文件：\n\n```java\n\t\t\tFileOutputStream outputStream=new FileOutputStream(file);//创建输出流\n\t\t\tbyte buy[]=\"Java程序设计\".getBytes();//准备字节数组\n\t\t\toutputStream.write(buy);//写入\n\t\t\toutputStream.close();\n```\n\n> FileOutputStream里放file，准备byte[]是字符串.getBytes()，写入用write\n\n读取\n\n```java\n\t\t\tFileInputStream inputStream=new FileInputStream(file);//准备输入流\n\t\t\tbyte byt[]=new byte[1024];//准备字节数组接收\n\t\t\tint len=inputStream.read(byt);//read读取\n\t\t\tinputStream.close();\n```\n\n> 读取用read，返回值是长度\n\n文件信息\n\n```java\nSystem.out.println(\"文件长度：\"+file.length()+\"字节\");\nSystem.out.println(\"文件路径：\"+file.getAbsolutePath());\nSimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"YYYY-MM-dd HH:mm:ss\");\nSystem.out.println(\"修改时间\"+simpleDateFormat.format(file.lastModified()));\n```\n\n#### (缓存)字符流\n\n写入\n\n```java\nFileWriter fw=new FileWriter(file);\nBufferedWriter bw=new BufferedWriter(fw);\nString str=\"你好\";\nbw.write(str);//写入字符串\nbw.newLine();//写入换行符\n```\n\n> FileWriter里放file，Buffered里放FW，写入用write，换行符newLine()\n\n读取\n\n```java\nFileReader fr=new FileReader(file);\nBufferedReader br=new BufferedReader(fr);\nString tmp=null;//缓存临时字符串\nwhile ((tmp=br.readLine())!=null) {\n\tSystem.out.println(tmp);//输出每一行\n}\n```\n\n> FileReader里放file，BufferedReader里放FR，读取每一行用br.readLine()，字符串存\n\n### Swing\n\n#### 事件监听\n\n```java\nclass MyJDialog extends JDialog{\n\tpublic MyJDialog(MyFrame frame) {//参数是MyFrame\n\t\tsuper(frame,\"这是一个对话框\",flase);//窗体、标题、是否阻塞\n\t\tContainer container=getContentPane();//获取主窗体\n\t\tcontainer.add(new JLabel(\"这是一个对话框\"));//在容器中添加标签\n\t\tsetBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\n\t}\n}\npublic class MyFrame extends JFrame{\n\tpublic MyFrame() {\n\t\tContainer container=getContentPane();//获取窗体主容器\n\t\t\n\t\tbl.addActionListener(new ActionListener() {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tnew MyJDialog(MyFrame.this).setVisible(true);\n\t\t\t}\n\t\t});\n\t\tcontainer.add(bl);\n\t\tsetVisible(true);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew MyFrame();\n\t}\n\n}\n```\n\n> 组件.addAcitonListener里边new Actionlistener\n\n### 多线程\n\n#### 消费生产栈\n\n```java\nclass ms{\n\tprivate Thread consume;\n\tprivate Thread product;\n\tprivate Random random=new Random();\n\tprivate int count=0;\n\tprivate Stack<Integer> st=new Stack<Integer>();\n\tpublic ms() {\n\t\t\n\t\tproduct=new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\twhile(true) {\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(count<10)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint s=random.nextInt(1000);\n\t\t\t\t\t\t\t\tst.push(s);\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tSystem.out.println(\"生产数据\"+s);\n\t\t\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\t}\t\n\t\t\t}\n\t\t}});\n\t\tproduct.start();\n\t\t\n\t\tconsume=new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\twhile(true) {\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(count>0)\n\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint s=st.pop();\n\t\t\t\t\t\t\t\tcount--;\n\t\t\t\t\t\t\t\tSystem.out.println(\"消费数据：\"+s);\n\t\t\t\t\t\t\t\tThread.sleep(1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\tThread.sleep(100);\n\t\t\t\t\t\t} \n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\t}\t\n\t\t\t}\n\t\t}});\n\t\tconsume.start();\n\t}\n}\n\npublic class Lab14_4{\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew ms();\n\t}\n\n}\n\n```\n\n\n\n### 网络通信\n\n#### TCP 双向通信\n\n##### 服务器端\n\n接收用BufferReader\n\n```java\nclass MySever{\n    public ServerSocket sever;//创建热线\n    public Socket socket;//客服\n    private PrintWriter writer;//输出流\n    void start(){\n        //绑定端口\n        server=new ServerSocket(8998);\n        while(true){\n            socket=server.accept();//等待接收，阻塞\n            //套接字客服传信息，用缓存输入流，里边是InputStreamReader，再里边是socket.getInputStream\n            BufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream));\n            writer=new PrintWriter(socket.getOutputStream,true);\n            while(true){//又一个\n                //字符串接数据 readerLine()\n                String message=reader.readerLine();\n                wrter.println(\"收到，谢谢你！\");\n            }\n            reader.close();//先关流\n            socket.close();\n        }\n    }\n}\n```\n\n> socket.getInputStream就是文件存取的file，类比一下，而InputStreamReader就是FileReader\n\n##### 客户端\n\n发出用PrintWriter\n\n```java\nclass MyClient{\n    Socket socket;//套接字\n    private PrintWriter writer;//写数据，用PrintWriter而不是Buffer\n    private BufferedReader reader;//输入流，读取\n    public MyClient(){\n        //一些修饰，如swing之类的\n        \n        //传数据\n        String message=\"hello\";//准备数据\n        writer.println(message);//传输即可\n    }\n    //连接另外写一个函数\n    public void connect(){\n        socket=new Socket(\"127.0.0.1\",8998);//绑定ip和端口\n        writer=new PrintWriter(socket.getOutputStream(),true);//创建流，一层就够了\n \t\t//接收信息\n        reader=new BufferedReader(new InputStreamReader(socket.getInpuString));\n        //准备线程\n        readThread=new Thread(new Runnable() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n                String message=reader.reaLine();\n                syso(message);\n            }\n        }\n    }\n}\n```\n\n> connect里：绑定端口指定ip，准备流\n>\n> 构造里：writer.println传数据\n\n#### UDP\n\n##### 服务器端\n\n```java\n//指定地址\n//实例化，绑定端口\n//加入组\n//构造里配置，run里边接收/发送\n//准备DataPackage，字符转字节数组，发送socket.send()\nclass Notification extends Thread{\n    int port;//端口\n    InetAddress iAddress=null;//ip\n    MulticastSocket socket=null;//MulticastSocket socket\n    String weather=new String();//发送的信息\n    public Receive() {\n    \t//配置\n    \t//指定地址\n    \ttry {\n    \t\tport=9898;\n\t\t\tiAddress=InetAddress.getByName(\"224.255.10.0\");//getByName返回的InetAddress\n\t\t\tMulticastSocket socket=new MulticastSocket(port);\n\t\t\tsocket.setTimeToLive(1);\n\t\t\tsocket.joinGroup(iAddress);\n\t\t} catch (UnknownHostException e) {\n\t\t\t// TODO 自动生成的 catch 块\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    @Override\n    public void run() {\n    \t// 发送信息\n    \t//准备\n    \tDatagramPacket packet=null;\n    \tbyte data[]=weather.getBytes();//字符转字节数组\n    \tpacket=new DatagramPacket(data, data.length, iAddress, port);\n    \tsocket.send(packet);\n    \tsleep(100);\n    }\n}\n```\n\n> 构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组\n>\n> run()里边：准备包，字符转字节数组，实例化DatagramPacket，socket.send(packet)\n\n##### 客户机端\n\n```java\nclass Receive implements Runnable{\n    int port;//端口\n    InetAddress group=null;//ip\n    MulticastSocket socket=null;//MulticastSocket socket\n    \n    public Receive() {\n    \t//配置\n    \t//指定地址\n    \ttry {\n    \t\tport=9898;\n    \t\tgroup=InetAddress.getByName(\"224.255.10.0\");//getByName返回的InetAddress\n\t\t\tMulticastSocket socket=new MulticastSocket(port);\n\t\t\tsocket.joinGroup(group);\n\t\t} catch (UnknownHostException e) {\n\t\t\t// TODO 自动生成的 catch 块\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    @Override\n    public void run() {\n    \tbyte bty[]=new byte[1024];\n    \tDatagramPacket packet=new DatagramPacket(bty, bty.length, group, port);\n    \ttry {\n\t\t\tsocket.receive(packet);\n\t\t} catch (IOException e) {\n\t\t\t// TODO 自动生成的 catch 块\n\t\t\te.printStackTrace();\n\t\t}\n    \tString message=new String(packet.getData(), 0, packet.getLength());\n    \tSystem.out.println(message);\n    }\n}\n```\n\n\n\n> 构造里边：构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组\n>\n> run()里边：准备字节数组，实例化DatagramPacket，socket.receive(packet)，然后new String(packet.getData(), packet.getLength())packet转字符\n\nmain函数当作类外的函数来看待\n\n1、包内访问权限和protected有何不同？(p98)\n\n包内访问权限介于private和protected之间\n\n包外的派生类，可以在派生类内部调用基类的protected成员\n\n包外的派生类，无法在派生类内部调用基类的包内访问成员\n\n* 当两个包在同一个项目之中时，可以通过完整类目继承包外的基类访问\n\n```java\npackage Lab2;\nclass newClass extends Lab1.myClass{//包名.类名\n    \n}\n```\n\n* 当两个包在不同的项目之中时，将基类项目导出为.jar，将该.jar文件复制到派生类所在的项目文件夹中，然后右键点击选择\"add building path\"添加到构建路径，然后代码与上面相同。\n\n\n\n2、所有数组都能排序吗？\n\n错误。排序要有一定依据，没有指定依据无法排序。如类型为类的数组，可比较的属性不止一种（implements比较器)。\n\n3、接口\n\n接口的本质是标准，是设计者、实现者，调用者之间的桥梁\n\n* 类内实现的可比较器Comparable，由被比较的类implements实现，重写`compareTo`函数\n\n* 类外实现的可比较器Comparator，由另外一个类implements实现，重写`compare`函数\n  * 如果是一次性的考虑用**匿名内部类**来实现比较器。否则这个只用一次的有名字的类可能会对代码理解造成困扰。\n\n\n\n# 基本输入输出范例代码\n\n```java\n Scanner sc=new Scanner(System.in);\n int n=sc.nextInt();\n String str1=sc.next();\n System.out.println(\"欢迎\"+n+\"号同学\"+str1);\n```\n\n\n\n# 第四章 流程控制\n\n## 循环语句\n\n### foreach语句\n\n```java\nfor(元素类型x:遍历对象obj){\n    引用了x的java语句;\n}\n```\n\n**例子：**遍历一维数组\n\n```java\npublic class Repetition{\n    public static void main(String args[]){\n        int arr[]={5,13,96};\n        System.out.println(\"一维数组中的元素分别为：\");\n        //x的类型与arr元素的类型相同 。for循环依次取出arr中的值并赋给x\n        for(int x:arr){\n            System.out.println(x);\n        }\n    }\n}\n\n/*输出结果：\n一维数组中的元素分别为：\n5\n13\n96\n*/\n```\n\n\n\n# 第五章 数组\n\n## 数组的基本操作\n\n### 数组排序\n\n* `Arrays.sort(arr);`\n* `Arrays.parallelSort(arr);`多线程排序，数据量大于一百万\n\n### 复制数组\n\n#### copyof()方法\n\n语法：`int a[]=Arrays.copyOf(arr,int newlength);`\n\n* newlength：复制后新数组的长度\n\n> ！注：不能直接`a=b`，数组名是指针常量（常指针）\n\n# 第六章 类和对象\n\n## 面向对象概述\n\n### 封装\n\n* 避免外部操作对内部数据的影响，提高程序的可维护性\n* 提高工作效率，把无需调用者关心的内容隐藏，简化编程，知道面对外部的接口能调用即可\n\n## 类\n\n**对于人来说，**\n\npublic：学历、知识（别人抢不走的）\n\nprotected：身体等\n\npublic：很多\n\n**protected同包其他类或子类(继承)可见，其他包的类或子类不可见；private都不可见，只有本类可见。**\n\n### this 关键字\n\nthis关键字用于表示本类当前的对象，只能在本类中使用。\n\n```java\npublic void setName(String name){//定义一个setName()的方法\n    this.name=name;//将参数值赋予类中的成员变量\n}\n```\n\n\n\n## 类的构造方法\n\n> Java类内的属性值不支持默认值，不能直接定义 `int count=0` \n>\n> 应使用默认构造函数初始化\n\n```java\npublic class eggCake{\n    int eggCount;\n    public EggCake(int eggCount){//有参构造\n        this.eggCount=eggCount;\n    }\n    public EggCake(){\n        //设置鸡蛋灌饼里蛋的个数为1\n        this(1);\n    }\n}\n```\n\n\n\n## 静态\n\n```java\npublic class Lab2_1{\n    \n    public static void main(String[] args){\n        new Lab2_1().show();//临时无名对象\n        //如果是show.()直接调用会报错，除非把show 声明为静态函数，说这是上面的方法，调用类内成员函数\n    }\n    void show(){\n        System.out.println(\"Hello!\")\n    }\n}\n```\n\n类内静态成员共用一份空间\n\n如果函数\n\n\n\n## 对象\n\n### 对象的销毁\n\n```java\npublic class Lab2_1{\n    \n    public static void main(String[] args){\n        Lab2_1 l2=new Lab2_1();\n        //l2=null; 销毁对象 之后如果是l2.show();那么会报错NullPointerException \n    }//超过作用域 对象l2销毁\n    void show(){\n        System.out.println(\"Hello!\")\n    }\n}\n```\n\n\n\n# 第七章 继承、多态、抽象类与接口\n\n## 类的继承\n\n### extends 关键字\n\n语法：`CHild extends Parents`\n\n### super 关键字\n\n\n\n## Object 类\n\n**Object类是一切类的基类**，隐含的继承\n\n* 如果没声明，toString()一定是调用自Object类，输出是字符编号。\n\n* 输出字符串自动会调用toString()函数，应当重写以达到需要的输出目的。\n* 重写只能保持或扩大访问权限，如原本是Public不能改成Private。\n\n```java\npublic class Student{\n    String name;\n    int age;\n    \n    public Student(String name,int age){\n        this.name=name;\n        this.age=age;\n    }\n    \n    @Override//加这个帮助检查重写的函数名是否正确\n    public String toString(){\n        return \"我叫\"+name+\",今年\"+age+\"岁。\";\n    }\n    public static void main(String[] args){\n        Student s1=new Student(\"张三\",16);\n        System.out.println(s1);//就是System.out.println(s1.toString());\n    }\n}\n```\n\n\n\n## 对象的类型转换\n\n**需要基类对象的任何地方，都可以用派生类对象替代**\n\n### 向上转型\n\n\n\n### 向下转型\n\n\n\n## instanceof关键字判断对象类型\n\n## 方法的重载\n\n>  函数的返回值类型不属于重载的依据\n\n\n\n## final 关键字\n\n最终的、终态\n\n## 多态\n\n\n\n## 抽象类与接口\n\n### 抽象类\n\n* 只要类中有一个抽象方法，此类就是抽象类\n* 抽象类不能实例化，抽象类存在的目的就是为了被继承\n* c++中全是抽象方法就叫纯虚类\n\n### 接口\n\n* 只能声明，不能实现\n\n\n\n# 第9章 异常处理\n\n异常与错误：\n\n一个不好的问题发生了，如果对该问题提前有应对措施，就是**异常处理**；\n\n如果没有任何准备，就是**错误**。\n\n```java\ntry{\n    //想要正确执行，但是不可控的语句段\n    //数据输入输出、网络连接、文件读写、数据库连接访问\n}catch(Exception e){\n    //可以有多个catch语句，捕获不同的异常 \n    //必须是小范围异常(异常类)在前，Exception必须放在最后，Exception是所有异常的基类，范围最大\n}\nfinally{\n    //不管是否有捕获异常，都想要执行的代码\n}\n```\n\n\n\n# 第10章 字符串\n\nString类，字符常量存储。\n\n## 创建\n\n```java\nchar a[]={'g','o','o','d'};\nString s = new String(a);//相当于String s = new String(\"good\")\n```\n\n截取\n\n```java\nchar a[]={'g','o','o','d'};\nString s = new String(a,1,2);//相当于String s = new String(\"oo\")\n```\n\n\n\n## 字符串连接\n\n`int+''`把`int`转为`String`类型\n\n\n\n## 获取字符串信息\n\n```java\nSystem.out.println(s[0]);//是错误的\nSystem.out.println(s.charAt[0]);//才对\n```\n\n### 字符串的查找\n\n`indexOf(String s)` 区分大小写\n\n```java\nString str=\"We are students\";\nint size=str.indexOf(\"a\");\nint size2=str.toLowerCase().indexOf(\"a\");//转为小写再查找，这个toLowerCase()或toUpperCase()是生成新的字符串对象，不会修改原来的字符串\n```\n\n\n\n## 字符串操作\n\n### 获取字符串\n\nsubstring(int beginIndex)\n\n```java\nString str=\"Hello World\";\nString substr=str.substring(3);\n```\n\n\n\n### 字符串替换\n\n`replace()`\n\n`replaceAll()`支持正则表达式\n\n### 判断相等\n\n`equals()`而不是用`==`\n\n```java\nString s1=\"abc\";\nString s2=\"abc\";\nString s3=new String(\"abc\");\nString s4=new String(\"abc\");\nSystem.out.println(s1==s2);//结果是true\nSystem.out.println(s3==s4);//结果是false\n```\n\n如果直接等号赋值，就是基本数据类型，用`==`可以判断；当用`new`，把变量当对象来看待，两个对象不可能相等，因此只能用`equals()`来判断相等。\n\nequals在基本数据类型比较的是值，引用数据类型对象、数组、函数比较的是地址，如果要比较值需要重写equals。String是已经重写好equals了的\n\n没重写之前两者都是比较地址，重写之后前者比较地址后者比较值\n\n比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。\n\n```java\n@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof Person) {\n       Person person = (Person) obj;\n       return name.equalsIgnoreCase(person.getName().trim());\n     }\n       return false;\n}\n```\n\n\n\n### 正则表达式\n\n```java\nString regex1=\"[a-zA-Z_$]+[a-zA-Z_$]*\";//\nString regex2=\"[1-9][0-9]{4,10}*\";//qq号码规则\n```\n\n使用：\n\n```java\npackage lesson5;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RegExp {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tString contentString=\"1998,1239,12,144\";\n\t\t//1.\\\\d表示一个任意的数字\n\t\tString regString=\"\\\\d\\\\d\\\\d\\\\d\";//找四个连续的数字,分组的话是(//d)(//d)\n\t\t//2.创建模式对象[即正则表达式对象]\n\t\tPattern pattern=Pattern.compile(regString);\n\t\t//3.创建匹配器\n\t\t//说明：创建匹配器matcher，按照正则表达式的规则去匹配content字符串\n\t\tMatcher matcher=pattern.matcher(contentString);\n\t\t//4.开始匹配\n\t\t/*\n\t\t * match.find()完成的任务 (考虑分组，如(//d//d)(//d//d))\n\t\t * 1. 根据给定的规则，定位满足规则的字符串（如1999,分组即(19)(99))\n\t\t * 2. 找到时，将字符串的开始的索引记录到matcher对象的属性 int[] groups;\n\t\t *    2.1groups[0]=0，把该子字符串的结束的索引+1的值记录到group[1]=35,+1是因为取字符串左闭右开\n\t\t *    2.2 记录第一组()匹配的字符串的区间group[2]=0,group[3]=2\n\t\t *    2.3 记录第二组()匹配的字符串的区间group[4]=2,group[5]=4\n\t\t *    2.4 如果有更多分组以此类推\n\t\t * 3. 同时记录oldLast的值为子字符串的结束的索引+1的值即5，那下一次执行find时，从5开始匹配\n\t\t */\n\t\twhile(matcher.find()) {\n\t\t\tSystem.out.println(\"找到：\"+matcher.group(0));//group(0)记录找到的字符串开头,同时可以找到结尾\n\t\t\tSystem.out.println(\"第一组()的值： \"+matcher.group(1));//19\n\t\t\tSystem.out.println(\"第二组()的值： \"+matcher.group(2));//99\n\t\t}\n\t}\n\n}\n\n```\n\n#### 元字符\n\n检索特殊字符要用转义符号`\\\\`，在java的正则表达式中两个`\\\\`代表其他语言一个`\\`\n\n#### 字符匹配符\n\n\n\n| 符号   | 含义                                                         | 实例           | 说明                                                 | 匹配输入        |\n| ------ | ------------------------------------------------------------ | -------------- | ---------------------------------------------------- | --------------- |\n| `[ ]`  | 匹配任意一个                                                 | `[efgh]`       | e,f,g,h任意一个                                      | e,f,g,h         |\n| `[^ ]` | 排除                                                         | `[^abc]`       | 除了abc之外的任意一个字符包括数字和特殊符号          | d,f,p           |\n| `.`    | 匹配除\\n以外的任何字符                                       | `a..b`         | a开头b结尾中间任意两个字符                           | aaab,a#*b       |\n| `\\\\d`  | 匹配单个数字字符相当于{0-9}                                  | `\\\\d{3}{\\\\d}?` | 包含3个或4个数字的字符串                             | 123,9876        |\n| `\\\\D`  | 匹配单个非数字字符，相当于`[^0-9]`                           | `\\\\D{\\\\d}*`    | 以单个非数字字符开头后接任意个数字的字符串           | a,A342          |\n| `\\\\w`  | 匹配单个数字、大小英文写字母，下划线，相当于`[0-9a-zA-Z_]`   | `\\\\d{3}\\\\w{4}` | 以3个数字字符开头的任意长度为7的数字字母字符串       | 234abcd、1234Pe |\n| `\\\\W`  | 匹配单个非数字、大小写字母和下划线字符，相当于`[^0-9a-zA-Z_]` | `\\\\W+\\\\d{2}`   | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 |                 |\n| `\\\\s`  | 匹配任何空白字符(空格，制表符等)                             |                |                                                      |                 |\n| `\\\\S`  | 匹配任何非空白字符                                           |                |                                                      |                 |\n| `\\\\.`  | 匹配除\\n之外的所有字符                                       |                |                                                      |                 |\n\n**区分大小写**\n\n默认区分大小写，如模式串写`\"abc\"`匹配出来abc而`(?i)abc`表示不区分大小写,`a(?i)bc`是bc不区分大小写\n\n\n\n## 常用类库\n\n### Integer类\n\n能在int类型和String类型之间互相转换。\n\n```java\nint num = Integer.parseInt(\"456\");//返回包含在由str指定的字符串中的数字的等价整数值\nInteger iNum=Integer.valueOf(\"456\");//返回保存指定的String值的Integer对象\niNum.equal(num);//比较，返回值是true\n```\n\n### Double类\n\n是Number类的子类，都是对浮点数进行操作。Double类在对象中包装一个基本类型为double的值，每个Double类的对象都包含一个double类型的字段。可将String和double相互转换。\n\n```java\nDouble dNum=Double.valueOf(\"3.14\");\nDouble.isNaN(dNum.doubleValue());//是否返回非数字(NaN)值\ndNum.intValue();//转为int类型\n```\n\n### Boolean类\n\n当 String 的参数值在不区分大小写的时候等于 \"true\" ，则 Boolean.valueOf(String) 返回值为 true；\n\n```java\nBoolean b1=Boolean.valueOf(\"true\");\nBoolean b2=Boolean.valueOf(\"ok\");\nb1.booleanValue();//将Boolean对象的值以对应的boolean值返回，值为true\nb2.booleanValue();//值为false\n```\n\n### Character类\n\n字符大小转小写\n\n```java\nCharacter mychar1=Character.valueOf('A');//返回保存指定char值的Character对象\nCharacter.isUpperCase(mychar1);//判断是否为大写字母\nCharacter.toUpperCase(mychar1);//转为大写\nCharacter.toLowerCase(mychar1);//转小写，不改变原来字符串\n```\n\n# 第12章 集合类\n\n```mermaid\ngraph LR\nA[集合类]-->集合类概述\nA-->Collection接口\nA-->List集合\nA-->Set集合\nA-->Map集合\n```\n\n## 集合类概述\n\n集合与数组\n\n| 容器       | 数组             | 集合           |\n| ---------- | ---------------- | -------------- |\n| 长度       | 长度固定         | 长度可变       |\n| 存放的东西 | 存放基本数据类型 | 存放对象的引用 |\n\n```mermaid\ngraph LR\nHashMap-->A[Map]\nTreeMap-->A\nHashSet-->B[Set]\nTreeSet-->B\nArrayList-->C[List]\nLinkedList-->C\nC-->D[Collection]\nB-->D\nA-->Java.lang.Object\nD-->Java.lang.Object\n```\n\n## Collection 接口\n\n```java\nCollection<类名> list=new ArrayList<>();//尖括号只能呢是类，比如不能放int要放integer\n```\n\n方法：\n\n* `add(E e)`\n* `remove(Object o)`\n* `isEmpty()`\n* `iterator()`\n* `size()`  返回int型\n\n遍历集合通过迭代器(Iterator)来实现，只读且向前。Collection接口中的iterator()方法可返回在此Collection进行迭代的迭代器。\n\n可以用foreach，可读可写，但是不能break，除非抛出异常。遍历修改迭代器(ListIterator)\n\n```java\nimport java.util.*;\npublic class Muster{\n    public static void main(String args[]){\n        Collection<String> list=new ArrayList();\n        list.add(\"《Java从入门到精通》\");\n        list.add(\"《java实战》\");\n        lteratior<String> it=list.lterator();\n        while(it.hasNext()){\n            String str=(String)it.next();//获取集合中的元素\n            System.out.println(str);\n        }\n    }\n}\n```\n\n## List集合\n\n> List集合中的元素允许重复，各元素的顺序就是对象插入的顺序。类似Java数组，用户通过使用索引(元素在集合中的位置)来访问集合\n\n### List接口\n\n继承Collection接口，包含其所有方法。还定义两个重要的方法：\n\n* `get(int index)`：获取指定索引位置的元素\n* `set(int index,Object obj)`：将集合中指定索引位置`index`的对象修改为指定的对象`obj`\n\n### List接口的实现类\n\n属于有序集合，不是自动排序的意思\n\n* `ArrayList`类 可变的数组，允许重复 允许null\n* `LinkedList`类链表结构保存对象\n\n| 类   | `ArrayList`            | `LinkedList`             |\n| ---- | ---------------------- | ------------------------ |\n| 优点 | 根据索引快速访问       | 便于向集合插入和删除对象 |\n| 缺点 | 插入或删除对象速度较慢 | 随机访问效率较低         |\n\n动态数组，索引存取\n\n链表，存取有序，不是存到链表头就是链表尾\n\n**实例化**\n\n```java\nList<E> list=new ArrayList<>();\nList<E> list2=new LinkedList<>();\n```\n\n> 开头是List，后面别忘了<>\n\n\n\n## Set集合\n\n`Set`集合传入的`Collection`对象**不能有重复值**\n\nSet接口实现的类：\n\n* `HashSet`类，由哈希表(HashMap实例)支持。允许null\n* `TreeSet`类，还实现了Java.util.SortedSet接口\n\n| 类   | `HashSet`                               | `TreeSet`                                |\n| ---- | --------------------------------------- | ---------------------------------------- |\n| 区别 | 不保证Set集合的迭代顺序和顺序的恒久不变 | **按自然顺序递增**，也可按比较器实现排序 |\n\n```java\nSet<类名> set=new TreeSet<>();\n```\n\n必须可比较，传入的对象的类必须是包装类(默认字典顺序)或者实现`comparable`接口的类\n\nHashSet哈希存储，计算哈希值散列导不同位置，存取位置不能保证，效率高\n\nTreeSet树存储，按照树结构对元素进行比较，放到合适位置，这也就说明，元素会按照树的性质去存储，那么也就无法保证存和取元素的顺序。但是元素可以在存储的时候根据自身的大小排好序，从而可以很轻易的找到最大值，最小值，以及给定一个元素，找到比他大和比他小元素等操作。\n\n问：在定义对象类型时，应该定义为基类或接口的类型，还是派生类的类型？\n\n* 创建的时候**类型不确定**，先定义为基类；或如果定义为接口给别人调用就声明为基类。要**专门调用**派生类具有的功能直接声明为派生类。\n\n* 但是定义为基类无法调用子类特有的成员，如`subSet()`是`TresSet`特有的，定义为基类时无法调用，除非强制转型为子类。\n\n  ```java\n  Set<Integer> set=new TreeSet<>();\n  TreeSet set2=((TreeSet<Interger>)set.)subSet(3,10);\n  ```\n\nTreeSet增加的方法:\n\n* first() 返回此Set集合第一个(最低)元素\n* last() 返回当前最后一个(最高)元素\n* comparator() 返回进行排序的比较器，若自然顺序则null\n* headSet(E toElement) 返回一个**新Set集合**是toElement对象(不包含)之前的所有对象\n* subSet(E fromElement,E toElement) 返回Set集合是fromElement对象与toElement之间的所有对象，**含头不含尾**\n* tailSet(E fromElement) 返回包含fromElement之后所有对象\n\n> 含头不含尾\n\n\n\n## Map集合\n\n没有继承Collection接口，每个对象是**键值**(<key,value>)的形式。\n\n>  每个key只能映射一个value；类要可比较；iterator()的next()输出的仅是key值\n\nMap接口除集合方法的特殊方法\n\n* put(K key,V value)\n* containsKey(Object key) 若包含指定key的映射关系返回true\n* containsValue(Object value) 若将一个或多个key映射到指定值，返回true\n* get(Object key) 返回对象对应的值，否则null\n* values() 返回该集合所有值对象形成的Collection对象，用iterator()遍历输出\n\n| 类    | HashMap                   | TreeMap                          |\n| ----- | ------------------------- | -------------------------------- |\n| 特点1 | 允许nul值和null键，键唯一 | 不允许值对象null(要排序的原因)   |\n| 映射  | 通过哈希表                | 具有一定顺序                     |\n| 优缺  | 不保证顺序不变；快速访问  | 添加、删除、定位性能差；顺序排序 |\n\n> 运用的时候使用HashMap类实现Map集合，当需要顺序输出时再创建一个完成相同映射关系的TreeMap类实例\n\n```java\nMap<String,String> map=new HashMap();\nmap.put(\"1001\",\"java从入门到精通\");\n```\n\n如果key传入的是像Integer，String这样本身有序的，就会按字典序排列，而不是按哈希码。\n\n原理：`add()`时用`hashcode`找哈希地址，用`equal()`看是否有存东西。如果是`false`就先并排放；若是`true`说明有了不用重复存。取值的时候找哈希地址，如果存在多个用`equal()`取具体的那一个。以上哈希码相同的情况为**哈希冲突**，同一个哈希地址可以存放多个不同对象。\n\n优点：不用全部遍历，找到哈希地址再判断哪个是需要的取出即可。\n\n# 第13章 枚举类型与泛型\n\n将“填空题”变为“选择题”\n\n```java\n//声明为int/String类型方便switch case用\n//接口\ninterface SeasonInterface{\n    int Spring=1,SUMMER=2,AUTUMN=3,WINTER=4;\n    //开头隐含的public static final\n}\n//枚举\nenum SeasonEnum{\n    SPRING,SUMMER,AUTUMN,WINTER\n}\npublic class SeasonDemo{\n    public static void printSeason1(int season){\n        switch(season){\n            case SeasonInterface.SPRING:\n                System.out.println(\"这是春季\");\n                break;\n            case SeasonInterface.SUMMER:\n                System.out.println(\"这是夏季\");\n                break;\n            case SeasonInterface.AUTUMN:\n                System.out.println(\"这是秋季\");\n                break;\n            case SeasonInterface.WINTER:\n                System.out.println(\"这是冬季\");\n                break;\n        }\n    }\n}\n```\n\n问：接口和枚举如何选择？\n\n* 接口一般是给别人来实现，功能可以更强大，如果不需要实现直接用枚举就行。\n* 枚举优点：简单，运行效率高，类型安全\n\n### 枚举类型中的构造方法\n\n在枚举类型中，可以添加构造方法，但是规定这个构造方法必须被private修饰符所修饰。用于提示枚举值更加详细的含义、\n\n\n\n## 泛型\n\n### 向上向下转型\n\n```java\n父类 a=new 子类();//向上转型\n子类 b=(子类)a;//向下转型\n子类 b=new 父类();//！这是不可行的！\n```\n\n例子：\n\n```java\npublic class Test{\n    private Object b;\n    public Object getB(){\n        return b;\n    }\n    public void setB(Object b){\n        this.b=b;\n    }\n    public static void main(String[] args){\n        Test t=new Test();\n        t.setB(Boolean.valueOf(true));//向上转型\n        System.out.println(t.getB());\n        t.setB(Float.valueOf(\"12.3\"));\n        Float f=(Float)t.getB();//向下转型\n        System.out.println(f);\n    }\n}\n```\n\n\n\n### 定义泛型类\n\n`Object`类为最上层的类，为了通用通常使传入的值与返回的值都以`Object`类型为主(`Object`太大了，不能统统用`Object`类)。当需要使用这些实例时，必须正确地将该实例**转换为原来的类型**，否则运行时将会发生`ClassCaseException`为了预防，`Java`提供泛型机制：\n\n```java\n类型<T>\n```\n\n### 高级用法\n\n#### 泛型限制\n\n对泛型类的实例类型做了限制\n\n```java\npublic class LimitClass<T extends List>{\n    public static void main(Stirng[] args){\n        //可以实例化已经实现List接口的类\n        LimitClass<ArrayList> l1=new LimitClass<ArrayList>();\n        //这句是错误的，因为HashMap类没有实现List()接口\n        LimitClass<HashMap> l3=new LimitClass<HashMap>();\n    }\n}\n```\n\n`<T extends Serializable>` 序列化，泛型必须是`Serializable`的子类，可传`Integer`或`String`\n\n#### 泛型通配符\n\n```java\nA<?> a;\nA<? extends anyClass> a;\nA<?> a= new List<>;//这样是不可以的，实例化需要要具体的类型\n```\n\n\n\n# 第14章 lambda表达式与流处理\n\n将lambda表达式用来**简化**表示匿名函数，也就是没有名字的函数，提高开发**效率**。\n\n例子：\n\n```java\n//函数式接口\ninterface A{\n    void action();\n}\n//使用匿名类创建对象\nA a=new A(){\n    public void action(){\n         System.out.println(\"创建了接口的匿名对象\");\n    }\n};\n//使用lambda表达式创建\nA a=()->{\n    System.out.println(\"创建了接口的匿名对象\");\n};\n```\n\n**lamba表达式：**\n\n```java\n()->结果表达式\n参数->结果表达式\n//多形参\n(参数1,参数2,...,参数n)->结果表达式\n```\n\n例子：\n\n```java\n//函数式接口\ninterface AdditionInterface{\n    int add(int a,int b);\n}\n\npublic class ParamterDemo{\n    public static void main(String[] args){\n        //lamba 表达式实现加法接口，返回参数相加的值(自动加return)\n        AdditionInterface np=(x,y)->x+y;\n        int result=np.add(15,26);//调用接口方法\n        System.out.println(\"相加结果：\"+result);//输出相加结果\n        //而同一个接口可以实现不同的方法,关键在于接口的实现方式\n        AdditionInterface np2=(a,b)->a*b;\n        result=np2.add(a,b);\n        System.out.println(\"相乘结果：\"+result);//输出相乘结果\n    }\n}\n```\n\n注意：\n\n* lamba表达式不能修改局部变量的值，只能使用\n\n\n\n## 方法的引用\n\n引用静态方法(复制一个已有的函数实现接口，甚至可以不需要这个已有函数内部是如何实现的)\n\n`类名::静态方法名`\n\n```java\ninterface StaticMethodInterface{\n\tint method(int a,int b);\n}\npublic class StaticM\n```\n\n### Function接口\n\n`Function<T,R>`,T:被操作的类型，可以理解为方法的参数类型；R：操作结果类型，方法的返回类型。\n\n`Iterator<T>`只读！\n\n`ListIterator<T>`才能修改list的元素\n\n## 流处理\n\nStream流只能被消费一次，之后失效\n\n### 数据过滤\n\n```java\n//数据转化为流\npublic class FilerDemo{\n    public static void main(String[] args){\n        List<Employee> list=Employee.getEmpList();\n        Stream<Employee> stream=list.stream();\n        stream=stream.filter(people->people.getAge()>30);//过滤出符合条件的数据\n        List<Employee> result=stream.collect(Collectors.toList());//将流对象重新封装成一个List集合\n        List<Employee> result2=list.stream().filter(p->p.getDept().equals(\"开发部\")).peek(p->p.setSalary(p.getSalary()*10)).collect(Collect.toList());//过滤得到符合的让其工资翻十倍\n        for(Employee emp:result){\n            System.out.println(emp);//输出员工信息\n        }\n    }\n}\n```\n\n`filter(predicate类)`用lamba表达式不需要管类型，直接放进去\n\n`peek(consumer类型)和map()`一个里面不用返回值，一个需要。\n\n`collect()` 收集重新归类。\n\n# 第15章 I/O(输入与输出)\n\n```mermaid\ngraph LR\nA[I/O]-->输入/输出流\nA-->File类\nA-->文件输入/输出流\nA-->带缓存的输入/输出流\nA-->数据输入/输出流\n```\n\n## 输入/输出流\n\n程序从指向源的输入流中读取源中的数据。\n\n各种数据源通过输入流传递到目的地\n\n源通过数据流传递到各种数据输出目标\n\n> InputStream类用来处理字节，不适合处理字符。而Java字符是Unicode编码，双字节，用Reader类处理。但注意Reader类不是InputStream的替换者，只是在处理字符串时简化了编程。\n\nread(byte[] b);返回值是读取到的字节数\n\n## File类\n\n`File`类是`java.io`包中**唯一代表磁盘文件本身的类**。因为是代表磁盘，操作要用try catch语句\n\n三种构造方式：\n\n```java\nFile(String pathname)\nFile(String parent,String child)\nFile(File f,String child)\n```\n\n```java\nimport java.io.File;\npublic class FileTest{\n    public static void main(String[] args){\n        File file=new File(\"word.txt\");//相对路径，是在项目目录下创建而不是在所在包类,此时是在内存中创建对象\n\t\t//File file2=new File(\"D:\\\\1.txt\");//绝对路径\n        if(file.exists()){//如果存在\n            file.delete();\n            System.out.println(\"文件已删除\");\n        }else{\n            try{\n                file.createNewFile();//这一步才真正在磁盘中创建文件\n                System.out.println(\"文件已创建\");\n            }catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n```\n\n> File类创建的是一个文件对象！说是在磁盘创建是错误的；除了在内存中的操作，其他都是不保证成功的，\n\n* getName() 文件名称\n* length() 文件的长度(以字节为单位)\n* isHidden() 判断是否隐藏文件，返回布尔值\n\n## 文件输入/输出流\n\n### FileInputStream与FileOutputStream类\n\n> 是字节流，读取写入参数得是字节byte，读取汉字容易乱码\n\n* 创建一个FileOutputStream对象时，可以指定不存在的文件，但是不能是已被其他程序打开的文件\n* 文件输入流FileInputStream类实现！读取！，用read(byte[] b)，从磁盘输入到目的地\n* 文件输出流FileOutputStream类实现！写入！，用write(byte[] b)，从程序输出到磁盘\n\n案例：\n\n```java\npublic class FileStreamDemo{\n    public static void main(String[] args){\n        File file=new File(\"D:\\\\word.txt\");//创建文件对象\n        //写入\n        try{\n            FileOutputStream out=new FileOutputStream(File);//创建输出对象\n            byte buy[]=\"我有一只小毛驴\".getBytes();//写入内容的字节数组，字符串转转字节\n            out.write(buy);//将字节写入到文件\n            out.close();//关闭流\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n        try{\n            FileInputStream in=new FileInputStream(file);//创建输入流\n            byte byt[]=new byte[1024];//缓存字节流\n            int len=in.read(byt[]);//字节转字符串要用\n            System.out.println(\"文件的信息是：\"+new String(byt,0,len));//字节转为字符串输出\n            in.close();\n        }catch(IOException e){\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### FileReader和FileWriter\n\n>  是字符流，读取写入参数字符串即可\n\n```java\nFile file=new File(\"D:\\\\word.txt\");//创建文件对象\n//写入\nFileWriter fw=new FileWriter(file);\nString word=\"我有一只小毛驴\";\nfw.write(word);\nfw.close();\n//读取\nFileReader fr=new FileReade(file);\nchar ch[]=new char[1024];//缓存字符数组\nint len=fr.read(ch);\nSystem.out.println(\"文件的信息是：\"+new String(ch,0,len));//字节转为字符串输出\nfr.close();\n```\n\n\n\n## 带缓存的输入/输出流\n\n缓存是I/O的一种性能优化。缓存流增加了内存缓冲区，使得在流上执行`skip()`、`mark()`和`reset()`方法都成为可能。\n\n### BufferedReader与BufferedWriter类\n\n分别继承Reader类和Writer类，以**行为单位**进行输入/输出\n\n读取文件过程：\n\n文件-->`InputStream`-->`InputStreamReader`-->`BufferedReader`-->字符数据\n\nBufferReader类常用的方法：\n\n* read() 读取单个字符\n* readLine() 读取一个文本行，返回字符串型。若无返回null\n\nBufferWriter类的方法都返回void:\n\n* write(String s, int off, int len) 写入字符串的一部分\n* flush() 刷新流的缓存\n* newLine() 写入一个行分隔符\n\n> 在使用`BufferedWriter`类的`Writer()`方法时，数据首先进入缓存区，**没有立刻被写入输出流**。如果想立即将缓存区中的数据写入输出流，一定要调用`flush()`\n\n```java\nBufferedReader br = new BufferedReader(new FileReader(file));//缓存输入流\n```\n\n#### 实例\n\n##### 基本文件操作\n\n```java\npublic class test2 {\n\tpublic static void main(String[] args) {\n\t\tString content[]= {\"好久不见\",\"最近好吗\",\"常联系\"};\n\t\tFile file=new File(\"word.txt\");\n\t\ttry {\n\t\t\tBufferedWriter bWriter=new BufferedWriter(new FileWriter(file));//文件字符输出流转缓冲输出流\n\t\t\tfor (int k = 0; k < content.length; k++) {\n\t\t\t\tbWriter.write(content[k]);//写入字符串\n\t\t\t\tbWriter.newLine();//写入一个换行符\n\t\t\t}\n\t\t\tbWriter.close();//关闭缓冲输出流\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tBufferedReader bReader=new BufferedReader(new FileReader(file));//文件字符输入流转缓冲输入流\n\t\t\tString tmpString=null;//作为缓冲的临时字符串\n\t\t\tint i=1;//行数\n\t\t\t//从文件重读取一行，如果读出内容不为null，则进入循环\n\t\t\twhile ((tmpString=bReader.readLine())!=null) {\n\t\t\t\tSystem.out.println(\"第\"+i+\"行：\"+tmpString);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tbReader.close();\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t}\n}\n\n输出：\n第1行：好久不见\n第2行：最近好吗\n第3行：常联系\n```\n\n\n\n\n\n\n\n### 获取网页源代码\n\n```java\nimport java.io.*;\nimport java.net.*;\n\npublic class GetPageCode{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO 自动生成的方法存根\n\t\tURL page = null;\n\t\ttry {\n\t\t\tpage = new URL(\"https://www.qq.com\");\n\t\t} catch (MalformedURLException e) {\n\t\t\t// TODO 自动生成的 catch 块\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\tHttpURLConnection conn = (HttpURLConnection) page.openConnection();\n\n\t\tInputStreamReader in = new InputStreamReader(conn.getInputStream());\n\n\t\tBufferedReader buff = new BufferedReader(in);\n\t\tString tmp=null;\n\t\tint i=1;\n\t\t//从流中读出一行，如果内容不为null，则进入循环\n\t\twhile ((tmp=buff.readLine())!=null) {\n\t\t\tSystem.out.println(tmp);\n\t\t\ti++;\n\t\t}\n\t\t\n\t}\n\n}\n```\n\n\n\n# 第16章 反射与注释\n\n实现访问、检测和修改描述Java对象本身信息的功能。\n\n`getCLass()`是Object类定义的，任何类都可以用，获取类信息\n\n```java\n\nClass newC=hashSet.getClass();//获取hashSet的描述信息，假设hashSet是一本书，那newC是书的目录，作者等等基本信息但不包括内容\n//查构造方法\nConstructor[] constructors=mewC.getDeclaredConstructor;\nfor(Constructor constructor:constructors){\n    System.out.println(constructor);//找到构造函数foreach遍历显示\n}\ndeclarednewC=newC.getDeclaredConstructors();\n\n\n```\n\n```java\nField[] declaredFields=demClass.getDeclaredFields();\n\t\tfor(Field field:declaredFields) {\n\t\t\tSystem.out.println(field);\n\t\t}\n```\n\n\n\n```java\n//查成员方法 用户输入参数\nMethod[] declaredMethods=demClass.getDeclaredMethods();\n\t\tfor(Method method:declaredMethods) {\n\t\t\tSystem.out.println(method);\n\t\t}\n\t\tScanner scanner=new Scanner(System.in);\n\t\tString key=scanner.next();\n\t\tfor(Method method:declaredMethods) {\n\t\t\tif(key.equals(\"size\")&&key.equals(method.getName())) {\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(method.invoke(hashSet));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (key.equals(\"add\") && key.equals(method.getName())) {//作判断才知道用户要做那个\n\t\t\t\tString addString = scanner.next();\n\t\t\t\ttry {\n\t\t\t\t\tSystem.out.println(method.invoke(hashSet, addString));\n\t\t\t\t\tfor (String hash : hashSet) {\n\t\t\t\t\t\tSystem.out.print(hash+\" \");\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tscanner.close();\n```\n\n\n\n# 第18章 Swing程序设计\n\n## Swing概述\n\n```mermaid\ngraph LR\njavax.swing.JLabel-->D[javax.swing.JComponent]\nJavax.swing.JPanel-->D\njavax.swing.JDialog-->A[java.awt.Dialog]\njavax.swing.JFrame-->B[java.awt.Frame]\nA-->C[java.awt.Window]\nB-->C\nD-->E[java.awt.Container]\nC-->E\nE-->F[java.awt.Component]\nF-->java.lang.Object\n```\n\n由Swing包的层次结构和继承关系可知\n\n* Dialog和Frame都在awt.Window里\n* 而JDialog在awt.Dialog里，JFrame在awt.Frame里\n* JPanel和JLabel在swing.JComponent里\n* 它们都在awt.Container里，最顶层是java.lang.Object\n\n## Swing常用窗体\n\n* `public JFrame(String title);` 默认不可见窗体，可以标题\n\n* 将窗体转为容器\n\n  ```java\n  JFrame jf=new JFrame(\"登录\");\n  Container container=jf.getContentPane();\n  ```\n\n* `container.add();container.remove()` 添加；删除容器中的组件\n\n* `container` 是主容器，组件都在这个范围内\n\n* `JLabel` 内容可以用html标签\n\n* `setBounds(距离左边x,距离上边y,宽度,高度)` 设置窗体左上角的坐标和大小，对于`JFrame`是设置距离屏幕的位置，对于`container`里的就是相对灰色的`container`位置\n* `setLocation(int x,int y);`\n* `setSize(int width, int height);` 设置窗体宽高\n* `setVisibale(boolean b);` 是否可见\n* `setDefaultCloseOperation(int operation);` 设置关闭方式\n  * 默认是`DISPOSE_ON_CLOSE` 窗体关闭释放窗体资源，窗体消失**但程序不停止**\n  * `EXIT_ON_CLOSE` 窗体关闭，释放窗体资源**并关闭程序**\n\n### `Jdialog` 对话框\n\n* `public JDialog(Frame f, Sring title,boolean mode)`设置`model`为`true`时，打开对话框时，阻塞主窗体不可操作。\n\n`JButton`单击事件\n\n```c++\nclass MyJDialog extends JDialog{\n\tpublic MyJDialog(MyFrame frame) {\n\t\tsuper(frame,\"第一个JDialog窗体\",true);//调用父类构造方法，参数：父类窗体,标题，是否阻塞父窗体\n\t\tContainer container=getContentPane();//获取主窗体\n\t\tcontainer.add(new JLabel(\"这是一个对话框\"));//在容器中添加标签\n\t\tsetBounds(120,120,100,100);//设置对话框在桌面显示的坐标和大小\n\t}\n}\npublic class MyFrame extends JFrame{\n\tpublic MyFrame() {\n\t\tContainer container=getContentPane();//获取窗体主容器\n\t\tcontainer.setLayout(null);//窗体使用绝对布局\n\t\tJButton bl=new JButton(\"弹出对话框\");\n\t\tbl.setBounds(10, 10, 100, 21);//按钮坐标大小\n\t\tbl.addActionListener(new ActionListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t// TODO 自动生成的方法存根\n\t\t\t\tMyJDialog dialog=new MyJDialog(MyFrame.this);//创建对话框，传参是当前窗体\n\t\t\t\tdialog.setVisible(true);\n\t\t\t}\n\t\t});\n\t\tcontainer.add(bl);\n\t\tsetSize(200, 200);\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);//关闭窗体停止程序\n\t\tsetVisible(true);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew MyFrame();\n\t}\n\n}\n\n```\n\n## 常用布局管理器\n\n### null 绝对布局\n\n> 硬性指定位置和大小，组件位置通过绝对坐标的方式来指定\n\n* 首先取消布局管理器：`Container.setLayout(null)`\n* 设置每个组件在容器的位置和大小：`Component.setBounds(int x,int y,int width,int height)`\n\n```java\npublic class AbsolutePosition extends JFrame{\n\n\tpublic AbsolutePosition() {\n\t\tsetTitle(\"绝对布局\");\n\t\tsetLayout(null);//取消布局管理器\n\t\tsetBounds(0,0,300,150);\n\t\tContainer container=getContentPane();\n\t\tJButton b1=new JButton(\"按钮1\");\n\t\tJButton b2=new JButton(\"按钮2\");\n\t\tb1.setBounds(10,30,80,30);//设置按钮位置和大小\n\t\tb2.setBounds(60,70,100,20);\n\t\tcontainer.add(b1);\n\t\tcontainer.add(b2);\n\t\tsetVisible(true);\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew AbsolutePosition();\n\t}\n\n}\n```\n\n### FlowLayout 流布局管理器\n\n* 流布局组件**从左到右**摆放。当组件占据了当前行的所有空间时，**溢出的到下一行**\n* 默认情况，行组件排列方式为**居中对齐**，可以通过设置更改\n\nFlowLayout类具有以下常用的构造方法\n\n* `public  FlowLayout()`\n* `public FlowLayout(int alignment)`\n* `public FlowLayout(int alignment,int horizGap,int vertGap)`\n\n`alignment`参数表示排列方式，可以设置为`Flowlayout.LEFT`、`FlowLayout.CENTER`或`FlowLayout.RIGHT`\n\n`horizGap`,`vertGap`这两个参数以像素为单位指定组件之间的水平间隔和垂直间隔\n\n```c++\npublic class FlowLayoutPosition extends JFrame{\n\tpublic FlowLayoutPosition() {\n\t\tsetTitle(\"流布局管理器\");\n\t\tContainer container=getContentPane();\n\t\tsetLayout(new FlowLayout(FlowLayout.RIGHT,10,10));\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tcontainer.add(new Button(\"button\"+i));\n\t\t}\n\t\tsetSize(300,200);\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew FlowLayoutPosition();\n\t}\n\n}\n```\n\n\n\n### BorderLayout 边界布局管理器\n\n* Swing创建窗体默认是边界布局管理器\n\n* 边界布局管理器把容器**分为东、南、西、北、中5个区域**\n\n* 当组件添加时，需要使用BorderLayout类中的成员变量**指定其区域**\n\n  * BorderLayout.NORTH 北\n\n  * BorderLayout.SOUTH 南\n\n  * BorderLayout.EAST 东\n\n  * BorderLayout.WEST 西\n\n  * BorderLayout.CENTER 中\n\n    -----------NORTH-----------\n\n    WEST---CENTER----EAST\n\n    -----------SOUTH-----------\n\n* `add(组件，成员变量)`\n\n```java\npublic class BorderLayoutPosition extends JFrame{\n\tpublic BorderLayoutPosition() {\n\t\tsetTitle(\"边界布局管理器\");\n\t\tContainer container=getContentPane();\n\t\tsetLayout(new BorderLayout());//使用边界布局管理器\n\t\tJButton centerButton=new JButton(\"中\");\n\t\tJButton northButton=new JButton(\"北\");\n\t\tJButton southButton=new JButton(\"南\");\n\t\tJButton westButton=new JButton(\"西\");\n\t\tJButton eastButton=new JButton(\"东\");\n\t\tcontainer.add(centerButton,BorderLayout.CENTER);\n\t\tcontainer.add(eastButton,BorderLayout.EAST);\n\t\tcontainer.add(westButton,BorderLayout.WEST);\n\t\tcontainer.add(southButton,BorderLayout.SOUTH);\n\t\tcontainer.add(northButton,BorderLayout.NORTH);\n\t\tsetSize(350,200);\n\t\tsetVisible(true);\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew BorderLayoutPosition();\n\t}\n\n}\n```\n\n\n\n### GridLayout 网格布局管理器\n\n* 划分为**网格**，组件可以按**行、列**进行排序\n* 网格个数由行数和列数决定，每个网格大小相同\n* 组件从网格左上角开始，**从左到右从上到下**被添加到网格中\n* 每个组件都会**填满**整个网格\n* **改变窗体大小，组件大小也会随之改变**\n\n构造方法\n\n* `public GridLayout(int rows, int columns)`\n* `public GridLayout(int rows, int columns, int horizGap, int vertGap)`\n\n> rows和columns只有一个可以是0，被用于一行或一列排列任意多个组件\n\n```java\npublic class GridLayoutPosition extends JFrame{\n\tpublic GridLayoutPosition() {\n\t\tContainer container=getContentPane();\n\t\tsetLayout(new GridLayout(7,3,5,5));//7行3列网格，组件水平间距5像素，垂直间距5像素\n\t\tfor (int i = 0; i < 20; i++) {\n\t\t\tcontainer.add(new JButton(\"button\"+i));\n\t\t}\n\t\tsetSize(300,300);\n\t\tsetTitle(\"网格布局管理器\");\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\n\t}\n\n}\n```\n\n\n\n## 常用面板\n\n### JPanel 面板\n\n必须在窗体容器中使用，无法脱离窗体显示\n\n```java\nJpanel p1=new JPanel(new GridLayout(1,4,10,10));//初始化面板，使用1行4列的网格布局，组件水平间隔10像素，垂直间隔10像素\n```\n\n### JScrollPane 滚动面板\n\n```c++\nContainer c=getContentPane();\nJTextArea ta=new JTextArea(20,50);//创建文本区域组件，文本域默认大小为20行、50列\nJScrollPane sp=new JScrollPane(ta);//创建滚动面板，并将其文本域放到滚动面板中\nc.add(sp);\n```\n\n#### **图片路径**\n\n```c++\nIcon con=new ImageIcon(\"src/注意.png\");//使用字符串作为路径，是以项目文件夹为根目录\nURL url=MyImageIcon.class.getResourse(\"注意.png\");//getResourse是以类所在文件夹为根目录\nIcon icon=new ImageIcon(url);//创建Icon对象\n```\n\n当用`new File()`时相对路径是相对于项目的路径，例如JavaSE下面有src，src下面有包，包里有类，当在类中用`new File()`相对路径访问src下的文件时应该是\n\n```java\nFile file=new File(\"src/[文件名]\");\n```\n\n## 事件监听器\n\n### ActionEvent动作事件\n\n动作事件监听器\n\n| 相关定义     | 实现方式                               |\n| ------------ | -------------------------------------- |\n| 事件名       | `ActionEvent`                          |\n| 事件源       | `JButton`、`JList`、`JTextField`等组件 |\n| 监听接口     | `ActionListener`                       |\n| 添加监听方法 | `addActionListener()`                  |\n| 删除监听方法 | `removeActionListener()`               |\n\n```java\nJButton b1=new JButton(\"按钮\");\nbl.addActionListener(new ActionListener() {\n\t\t\t\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t// 要触发的动作\n\t\t\t\t\n\t}\n});\n```\n\n或者用类调用接口的方法：\n\n```java\npublic class SimpleEvent extends JFrame{\n    private JButton jb=new JButton(\"我是按钮\");\n    public SimpleEvent(){\n        jb.addActionListener(new jbAction());\n    }\n    class jbAction implements ActionListener{\n        public void actionPerformed(ActionEvent arg0){\n            jb.setText(\"我被点击了\");\n        }\n    }\n}\n```\n\n> `jbAction`实现`ActionListner`接口，同时在该内部类中实现`actionPerform()`方法，这个方法中定义当用户单击该按钮后实现怎样的功能\n\n### KeyEvent键盘事件\n\n`KeyEvent`类负责捕获键盘事件，可以通过为组件添加实现了`KeyListener`接口的监听器类来处理相应的键盘事件。\n\n`KeyListerner`接口3个抽象方法\n\n```java\npublic interface KeyListener extends EventListener{\n    //发生击键事件时触发\n    public void keyTyped(KeyEvent e);\n    //按键被按下时被触发\n    public void ketPressed(KeyEvent e);\n    //案件被释放时被触发\n    public void keyReleased(KeyEvent e);\n}\n```\n\n`KeyEvent`类中的常用方法\n\n* `getKeyChar()` 获得与此事件中的键相关联的字符\n\n```java\ntextField=new JTextField();\ntextField.addKeyListener(new KeyAdapter(){//文本框添加键盘事件的监听\n    public void keyPressed(KeyEvent e){//按键按下时触发\n        //实现的功能\n    }\n})\n```\n\n### MouseEvent鼠标事件\n\n所有组件都能发生鼠标事件。添加`MouseListener`接口监听，有5个抽象对象\n\n```java\npublic interface MouseListener extends EventListener{\n    public void mouseEntered(MouseEvent e);//光标移入组件时触发\n    public void mousePressed(MouseEvent e);//鼠标按键按下\n    public void mouseReleased(MouseEvent e);//鼠标按键释放时被触发\n    public void mouseClicked(MouseEvent e);//发生单击事件被触发\n    public void mouseExited(MouseEvent e);//光标移出组件时被触发\n}\n```\n\n> 注意单击事件如果按键在移除组件之后才被释放，则不会触发单机事件\n\nMouseEvent类中的常用方法\n\n* getSource() 获得触发此次事件的组件对象，返回值为Object类型\n* getButton() 获得按键的int值\n* getClickCount() 获得单击按钮的次数\n\n按键的int值：\n\n| 静态常量 | 常量值 | 代表的键 |\n| -------- | ------ | -------- |\n| BUTTON1  | 1      | 鼠标左键 |\n| BUTTON2  | 2      | 鼠标滚轮 |\n| BUTTON3  | 3      | 鼠标右键 |\n\n```java\nprivate void mouseOper(MouseEvent e){\n    int i=e.getButton();//获得按键的int值\n    if(i==MouseEvent.BUTTON1)\n        System.out.println(\"按下的是鼠标左键\");\n    else if(i==MouseEvent.BUTTON2)\n        System.out.println(\"按下的是鼠标滚轮\");\n    else if(i==MouseEvent.BUTTON3)\n        System.out.println(\"按下的是鼠标右键\");\n}\npublic MouseEvent_Example(){\n    final JLable label=new JLable();\n    label.addMouseListener(new MouseListener(){\n        public void mouseEntered(MouseEvent e){\n            System.out.println(\"光标移入组件\");\n        }\n        public void mousePressed(MouseEvent e){\n            System.out.print(\"鼠标按键被按下\");\n            mouseOper(e);\n        }\n    })\n}\n```\n\n\n\n# 第二十章 多线程\n\n多种活动同时进行的思想称为**并发**，而将完成的每一件事情称为**线程**\n\nCPU在一个时间片中执行某个进程，然后下一个时间片又跳至另一个进程中去执行。由于CPU转换较快，好像同时执行一样\n\n## 创建线程\n\n* Thread类是java.lang包中的一个类\n* 完成线程真正功能的代码放在类的run()方法里\n* start()方法会启动线程，线程自动执行run()方法里的代码。\n* 如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()前，Thread对象只是实例，不是真正的线程\n* 主方法线程由Java虚拟机负责启动\n\n> 如果start()方法调用一个已经启动的线程，抛出IllegalThreadStateException异常\n\n### 实现Runnable()接口\n\n当要继承其他非Thread类，通过Runnable接口来实现多线程\n\n```java\npublic class Threadtest extends Object implements Runnable{\n    @Override\n\tpublic void run() {\n\t\t// TODO 自动生成的方法存根\n\t\tString string=Thread.currentThread().getName();\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(string+\"第\"+i+\"次操作\");\n\t\t}\n\t}\n\tpublic static void main(String[] args)  {\n\t\tThreadtest threadtest=new Threadtest();\n\t\tThread t1=new Thread(threadtest,\"线程1\");//第二个是Thread的名字，一般是Thread(String name)\n\t\tThread t2=new Thread(new Threadtest(),\"线程2\");//匿名方式\n\t\tt1.start();\n\t\tt2.start();\n\t}\n}\n```\n\n> 实现Runnable()接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联\n\n使用Runnable接口启动新的线程步骤如下：\n\n1. 建立Runnable对象\n2. 使用参数为Runnable对象的构造方法创建Thread实例\n3. 调用start()方法启动线程\n\n```java\nThread thread=new Thread(new Runnable(){\n    @Override\n    public void run(){\n        \n    }\n})  \n```\n\n\n\nSwing与Thread结合实例\n\n```java\npublic class SwingAndThread extends JFrame{\n\tint count=0;//图像横坐标\n\tpublic SwingAndThread() {\n\t\tsetBounds(300,200,250,100);\n\t\tContainer container=getContentPane();//主容器\n\t\tcontainer.setLayout(null);\n\t\t\n\t\tIcon icon=new ImageIcon(\"src/1.gif\");\n\t\tJLabel jLabel=new JLabel(icon);\n\t\tjLabel.setBounds(10,10,200,50);\n\t\tThread thread=new Thread() {//匿名线程对象\n\t\t\tpublic void run() {\n\t\t\t\twhile (true) {\n\t\t\t\t\tjLabel.setBounds(count,10,200,50);//将标签的横坐标用变量表示\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(500);//休眠500毫秒\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tcount+=4;//横坐标每次增加4\n\t\t\t\t\tif(count>=200) {\n\t\t\t\t\t\tcount=10;//到达最右边时使其回到最左边\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t\tcontainer.add(jLabel);\n\t\tsetVisible(true);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tnew SwingAndThread();\n\t}\n\n}\n```\n\n\n\n## 线程的生命期\n\n* **出生状态**就是线程被创建时处于的状态，在用户使用该线程实例调用`start()`方法之前线程都是出生状态。\n* 当调用`start()`方法后，线程处于**就绪状态**(可执行状态)\n* 当线程得到系统资源进入**运行状态**。\n* 处于运行状态调用`Thread`类中的`wait()`方法时，进入**等待状态**。进入等待状态<u>必须由其他的线程调用`notify()`唤醒，自己无法唤醒自己</u>，`notifyAll()`方法将所有处于等待状态下的线程唤醒\n* `sleep()`**休眠状态**，时间到了会自动唤醒，区别于等待状态。\n* 线程中运行状态下发出输入/输出请求时，该线程将进入阻塞状态。等待输入输出结束时线程进入**就绪状态**\n* 当线程的`run()`方法执行完毕时，线程进入**死亡状态**。\n\n```mermaid\ngraph TD\n出生-->A[就绪]\nA-->B[运行]\nB-->A\nB-->C[等待]\nB-->D[休眠]\nB-->E[阻塞]\nB-->死亡\nC-->A\nD-->A\nE-->A\n```\n\n\n\n## 操作线程的方法\n\n### 线程的加入\n\njoin()方法加入到另外一个线程。例如存在一个线程A，现在需要插入B要求线程B先执行完毕，然后再执行线程A，调用join()，类似插入队伍。\n\n当某个线程使用join()加入另外一个线程时，另一个线程会等待该线程执行完毕后再继续执行。\n\n使用方法：在某一个线程A的run函数中使用B.join()插入B线程。\n\n插入到主线程：\n\n```java\npublic static void main(Stirng[] args){\n    类 A=new 类();\n}\npublic 类{\n    线程实例化;\n    线程.start;\n    try{\n        线程.join();//这样就插入到主线程\n    }catch(..){\n        e.printStackTrace();\n    }\n}\n```\n\n## 线程的优先级\n\n* 每个线程具有各自的优先级，可以表明在程序中该线程的重要性\n* 系统根据优先级决定首先使哪个线程进入运行状态\n\n```java\npublic class Priority implements Runnable{\n\tString nameString;\n\tpublic Priority(String name) {\n\t\tthis.nameString=name;\n\t}\n\t@Override\n\tpublic void run() {\n\t\t// TODO 自动生成的方法存根\n\t\tString tmpString=\"\";\n\t\tfor (int i = 0; i < 50000; i++) {\n\t\t\ttmpString+=i;//进行50000次字符拼接\n\t\t}\n\t\tSystem.out.println(nameString+\"线程完成任务\");\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tThread aThread=new Thread(new Priority(\"A\"));\n\t\taThread.setPriority(1);\n\t\tThread bThread=new Thread(new Priority(\"B\"));\n\t\tbThread.setPriority(3);\n\t\tThread cThread=new Thread(new Priority(\"C\"));\n\t\tcThread.setPriority(7);\n\t\tThread dThread=new Thread(new Priority(\"D\"));\n\t\tdThread.setPriority(10);\n\t\taThread.start();\n\t\tbThread.start();\n\t\tcThread.start();\n\t\tdThread.start();\n\t}\n\n}\n//结果\nD线程完成任务\nB线程完成任务\nC线程完成任务\nA线程完成任务\n```\n\n> 由输出结果，不一定按优先级，知识作为CPU的参考依据。执行顺序由CPU决定\n\n\n\n## 线程同步\n\n### 线程安全\n\n线程安全问题来源于两个线程同时存取单一对象的数据\n\n### 线程同步机制\n\n>  解决资源共享问题\n\n**同步块**\n\n`synchronized(Object){}`\n\n通常**将共享资源的操作放置**在`synchronized`定义的区域内，当其他线程获取这个锁时，就必须**等待锁被释放后才可以进入该区域**。其中`Object`有标志位，0和1，若为0，表示此同步块内存在其他线程，这是当前线程处于就绪状态，直到同步块中的线程执行完同步块代码后，该对象标志位设置为1，当前线程开始执行同步块。\n\n在run()里边添加同步块：\n\n```java\npublic class SynchronizedTest implements Runnable{\n\tint num=10;\n\t@Override\n\tpublic void run() {\n\t\t// TODO 自动生成的方法存根\n\t\twhile (true) {\n\t\t\tsynchronized (this) {\n\t\t\t\tif (num>0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(100);//使当前线程休眠100毫秒\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t// TODO: handle exception\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(Thread.currentThread().getName()+\"——票数\"+num--);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\t//实例化类对象\n\t\tSynchronizedTest test=new SynchronizedTest();\n\t\t//以该类对象分别实例化4个线程\n\t\tThread tA=new Thread(test,\"线程一\");\n\t\tThread tB=new Thread(test,\"线程二\");\n\t\tThread tC=new Thread(test,\"线程三\");\n\t\ttA.start();\n\t\ttB.start();\n\t\ttC.start();\n\t}\n\n}\n//结果\n线程一——票数10\n线程一——票数9\n线程一——票数8\n线程一——票数7\n线程一——票数6\n线程一——票数5\n线程一——票数4\n线程一——票数3\n线程一——票数2\n线程一——票数1\n```\n\n如果不加同步块结果会出现负数\n\n线程中执行n++结果不一定正确，因为n++不是原子操作，其中包含三步包括取值，加一，赋值，中间可能会被打断，导致结果不一定准确。可以加入锁解决\n\n```java\nsynchronized(Object){\n    try{\n        n++;\n        aomicinteger.incrementAndGet();\n        longAdder.increment();\n    }\n}\n```\n\n**同步方法**\n\n在方法前面用`synchronized`关键字修饰方法：\n\n```c++\nsynchronized void f(){}\n```\n\n同上面的例子实现一样的功能，不过运用同步方法而不是同步块：\n\n```java\npublic class SynchronizedTest implements Runnable{\n\tint num=10;\n\tpublic synchronized void doit() {//定义同步方法\n\t\tif (num>0) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);//使当前线程休眠100毫秒\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(Thread.currentThread().getName()+\"——票数\"+num--);\n\t\t}\n\t}\n\t@Override\n\tpublic void run() {\n\t\t// TODO 自动生成的方法存根\n\t\twhile (true) {\n\t\t\tdoit();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\t//实例化类对象\n\t\tSynchronizedTest test=new SynchronizedTest();\n\t\t//以该类对象分别实例化4个线程\n\t\tThread tA=new Thread(test,\"线程一\");\n\t\tThread tB=new Thread(test,\"线程二\");\n\t\tThread tC=new Thread(test,\"线程三\");\n\t\ttA.start();\n\t\ttB.start();\n\t\ttC.start();\n\t}\n\n}\n```\n\n\n\n# 网络通信\n\n## 网络程序设计基础\n\n在TCP/IP协议栈中，有两个高级协议，即传输控制协议(Transmission Control Protocol，TCP)与用户数据传输报协议(User Datagram Protocol，UDP)\n\n| 高级协议 | TCP                                                          | UDP                                                          |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 特点     | 以固接连线为基础，从一端送至连接的另一端                     | 以发送数据包的方式进行，向若干目标发送数据或接受来自若干源的数据 |\n| 数据顺序 | 数据能够送达，且抵达数据的顺序=送出时的顺序                  | 不保证抵达的顺序=送出时的顺序                                |\n| 类比     | 就像打电话，必须先拨号给对方，等两端确定连接后，互相才能听到对方说法，也知道对方回应的是什么 | 邮递员送信，可以寄出很多信给同一个人，且每封信相对独立。各封信到达的顺序并不重要，收信人接收信件的顺序也不能保证与寄出信件的顺序相同 |\n\n>  TCP是面向**连接**的可靠协议，效率低，保证确实送达。UDP是面向**无连接**的不可靠协议，效率高，不保证数据可靠的传输。\n\n一些防火墙或路由器可能设置不允许UDP数据传输协议\n\n### 端口\n\n类似营业厅的窗口，提供某些服务\n\nHTTP 80\n\nFTP 21\n\nTomcat 8080\n\nMySQL 3306\n\n### 套接字\n\n套接字(Socket)用于将**应用程序与端口**连接起来。\n\n客户端(应用程序<-->Socket<-->Port<-)-(->Port<-->Socket<-->应用程序)服务器\n\n> 类似插座一样连接电器与电线\n\n## TCP程序\n\nTCP协议进行通信的两个应用程序有主次之分，一个称为服务器程序，另一个称为客户机程序，服务端与客户端的交互过程如下：\n\n1. 服务器程序创建一个`SeverSocket`(服务器端套接字)对象，调用`accept()`方法等待客户机来连接\n2. 客户端程序创建一个`Socket`对象，请求与服务器建立连接\n3. 服务器接受客户机的连接请求，同时创建一个新的`Socket`对象与客户建立连接。随后服务器继续等待新的请求\n\n> `SeverSocket`可以理解为售后部门的电话；服务器端运行的`Socket`可以理解为客服人员；客户端运行的`Socket`可以理解为顾客\n\n### IntetAddress类\n\n这是一个与ip地址相关的类，可以获取ip地址，主机地址等信息，常用方法：\n\n* `getByName(String host)` 返回InterAddress 获取Host项对应的InterAddress对象\n* `getHostAddress()` 返回String 获取InterAddress对象所包含的IP地址\n* `getHostName(`) String 获取此ip地址的主机名\n* `getLocalHost()` InterAddress 返回本地主机的InterAddress对象\n\n```java\npublic class Address {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tInetAddress ip;//创建对象\n\t\ttry {\n\t\t\tip=InetAddress.getLocalHost();//实例化对象\n\t\t\tString localname=ip.getHostName();//获取本机名\n\t\t\tString localip=ip.getHostAddress();//获取本机ip地址\n\t\t\tSystem.out.println(\"本机名：\"+localname);\n\t\t\tSystem.out.println(\"本机IP地址：\"+localip);\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n//结果\n本机名：LAPTOP-6G798SAR\n本机IP地址：192.168.4.1\n```\n\n### SeverSocket类\n\n服务器套接字\n\nSeverSocket(int port)：绑定到接口port的服务器套接字\n\n\n\n> 当服务器向输出流写入信息时，客户端通过相应的输入流就能读取，反之亦然\n\n注意accept()方法会阻塞线程的继续指行，直至接收到客户的呼叫\n\n```java\nyu=server.accept();\nSystem.out.println(\"连接中\");\n```\n\n> 如果没有客户呼叫服务机，那么“连接中”语句不会执行\n\n\n\n### TCP网络程序设计\n\n单项通信的例子，客户机通过**输出流**发送数据，服务器通过**输入流**接收数据：\n\n**服务器端：**\n\n```java\npublic class MyServer {\n\tprivate ServerSocket server;//服务器套接字\n\tprivate Socket socket;//客户机套接字\n\tvoid start() {\n\t\ttry {\n\t\t\tserver=new ServerSocket(8998);//服务器启用8998端口\n\t\t\tSystem.out.println(\"服务器套接字已经创建成功\");\n\t\t\twhile (true) {\n\t\t\t\tSystem.out.println(\"等待客户机的连接\");\n\t\t\t\tsocket=server.accept();//服务器监听客户机连接\n\t\t\t\tBufferedReader reader=new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\twhile (true) {\n\t\t\t\t\tString message=reader.readLine();//读取一行文本\n\t\t\t\t\tif(\"exit\".equals(message)) {\n\t\t\t\t\t\tSystem.out.println(\"客户机退出\");\n\t\t\t\t\t\tbreak;//停止接受信息\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"客户机：\"+message);\n\t\t\t\t}\n\t\t\t\treader.close();\n\t\t\t\tsocket.close();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tMyServer tcp=new MyServer();\n\t\ttcp.start();\n\t}\n\n}\n```\n\n**客户机端：**\n\n```java\npublic class MyClient extends JFrame{\n\tprivate PrintWriter writer;//根据套接字字节流创建的字符输出流\n\tSocket socket;\n\tprivate JTextArea area=new JTextArea();//展示信息的文本域\n\tprivate JTextField text=new JTextField();//发送信息的文本框\n\t\n\tpublic MyClient() {\n\t\tsetTitle(\"向服务器送数据\");\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tContainer container=getContentPane();\n\t\tJScrollPane scrollPane=new JScrollPane(area);\n\t\tgetContentPane().add(scrollPane,BorderLayout.CENTER);\n\t\tcontainer.add(text,\"South\");\n\t\ttext.addActionListener(new ActionListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t// TODO 自动生成的方法存根\n\t\t\t\twriter.println(text.getText().trim());//将文本框中的信息写入流\n\t\t\t\tarea.append(text.getText()+'\\n');//将文本框中的信息显示到文本域中\n\t\t\t\ttext.setText(\"\");//清空\n\t\t\t}\n\t\t});\n\t}\n\tprivate void connect() {\n\t\tarea.append(\"尝试连接\\n\");\n\t\ttry {\n\t\t\tsocket=new Socket(\"127.0.0.1\",8998);//连接本地计算机的8998接口\n\t\t\twriter=new PrintWriter(socket.getOutputStream(),true);\n\t\t\tarea.append(\"完成连接\\n\");\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tMyClient client=new MyClient();\n\t\tclient.setSize(200,200);\n\t\tclient.setVisible(true);\n\t\tclient.connect();//连接服务器\n\t}\n\n}\n```\n\n## UDP程序\n\nUDP通信基本模式：\n\n* 将数据打包（数据包），然后将数据包发往目的地\n* 接收别人发来的数据包，然后查看数据包\n\n**发送数据包：**\n\n1. 创建：使用`DatagramSocket()`创建一个数据包套接字。\n2. 打包：使用`DatagramPacker(byte[] buf, int offset, int length, InetAddress address, int port)`创建要发送的数据包。\n3. 发送：使用`DatagramSocket()`类的`send()`方法发送数据包。\n\n**接收数据包：**\n\n1. 创建：使用`DatagramSocket(int port)`创建数据包套接字，绑定到指定的接口。\n2. 准备包：使用`DatagramPacket(byte[] buf, int length)`创建字节数组来接收数据包。\n3. 接收：使用`DatagramPocket`类的`receive()`方法接收UDP包。\n\n### DatagramPacket类\n\n**数据包**，构造方法：\n\n* `DatagramPacket(byte[] buf, int length) `指定包的内存空间和大小\n* `DatagramPacket(byte[] buf, int length,InetAddress address,int port)` 多指定了数据包的目标地址和端口\n\n> 发送数据需指定接收方的Socket地址和端口号\n\n### DatagramSocket类\n\n* DatagramSocket()\n* DatagramSocket(int port)\n* DatagramSocket(int port, InetAddress addr) 适用多块网卡有多个IP地址\n\n> 接收时要指定端口号一般用第二种，发送时不知道用第一种。\n\n### UDP网络程序设计\n\n下面创建一个广播数据报程序，原理类似电台广播。广播电台需要在指定的波段和频率上广播信号，接收者也要将收音机调到指定的波段、频率，才可以收听广播内容。\n\n**广播主机程序不断向外播出信息：**\n\n![image-20221224205156462](https://jjuprising.github.io/images/Ja_Note/image-20221224205156462.png)\n\n```java\npublic class Notification extends Thread{\n\tString weather=\"节目预报：八点有大型晚会，请收听\";//发送的信息\n\tint port=9898;\n\tInetAddress iaddress=null;\n\tMulticastSocket socket=null;//多点广播套接字，是一种DatagramPacket\n\t\n\t@SuppressWarnings(\"deprecation\")\n\tpublic Notification() {\n\t\ttry {\n\t\t\tiaddress=InetAddress.getByName(\"224.255.10.0\");//广播组地址\n\t\t\tsocket=new MulticastSocket(port);//实例化\n\t\t\tsocket.setTimeToLive(1);//指定发送范围是本地网络\n\t\t\tsocket.joinGroup(iaddress);//加入广播组\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tDatagramPacket packet=null;//数据包\n\t\t\tbyte data[]=weather.getBytes();//字符串消息的字节数组\n\t\t\tpacket=new DatagramPacket(data,data.length,iaddress, port);//将数据打包\n\t\t\tSystem.out.println(weather);\n\t\t\ttry {\n\t\t\t\tsocket.send(packet);\n\t\t\t\tsleep(3000);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tNotification w=new Notification();\n\t\tw.start();//启动线程\n\t}\n\n}\n\n```\n\n\n\n**接收广播程序：**\n\n![image-20221224205211236](https://jjuprising.github.io/images/Ja_Note/image-20221224205211236.png)\n\n```java\npublic class Receive extends JFrame implements Runnable,ActionListener{\n\tint port;//端口\n\tInetAddress group=null;//广播组地址\n\tMulticastSocket socket=null;//多点广播套接字对象\n\tJButton inceBtn=new JButton(\"开始接收\");\n\tJButton stopBtn=new JButton(\"停止接收\");\n\tJTextArea inceAr=new JTextArea(10,10);\n\tJTextArea inced=new JTextArea(10,10);\n\tThread thread;\n\tboolean stop=false;//停止接收信息状态\n\t\n\tpublic Receive() {\n\t\t//界面设计\n\t\tsetTitle(\"广播数据报\");\n\t\tsetDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n\t\tthread=new Thread(this);\n\t\tinceBtn.addActionListener(this);//绑定按钮ince的单击事件\n\t\tstopBtn.addActionListener(this);//绑定按钮stop的单击事件\n\t\tinceAr.setForeground(Color.blue);\n\t\tJPanel north=new JPanel();\n\t\tnorth.add(inceBtn);//将按钮添加到north面板\n\t\tnorth.add(stopBtn);\n\t\tadd(north,BorderLayout.NORTH);//将north放置在窗体上部\n\t\tJPanel center=new JPanel();//创建面板对象center\n\t\tcenter.setLayout(new GridLayout(1,2));//设置面板布局\n\t\tcenter.add(inceAr);//将文本域添加到面板上\n\t\tcenter.add(inced);\n\t\tadd(center,BorderLayout.CENTER);//设置面板布局\n\t\tvalidate();//刷新\n\t\t//UDP部分\n\t\tport=9898;\n\t\ttry {\n\t\t\tgroup=InetAddress.getByName(\"224.255.10.0\");//指定接收地址\n\t\t\tsocket=new MulticastSocket(port);//绑定\n\t\t\tsocket.joinGroup(group);//加入广播组\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsetBounds(100,50,360,380);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void run() {\n\t\t// TODO 自动生成的方法存根\n\t\twhile (stop==false) {\n\t\t\tbyte data[]=new byte[1024];//创建缓存字节数组\n\t\t\tDatagramPacket packet=null;\n\t\t\tpacket=new DatagramPacket(data,data.length,group, port);//待接收数据包\n\t\t\ttry {\n\t\t\t\tsocket.receive(packet);//接收数据包\n\t\t\t\t//获取数据包中的内容\n\t\t\t\tString message=new String(packet.getData(),0,packet.getLength());\n\t\t\t\tinceAr.setText(\"正在接收的内容：\\n\"+message);//将接收内容显示在文本域中\n\t\t\t\tinced.append(message+\"\\n\");//每条信息为一行\n\t\t\t} catch (Exception e) {\n\t\t\t\t// TODO: handle exception\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\t// TODO 自动生成的方法存根\n\t\tif (e.getSource()==inceBtn) {//单击inceBtn按钮触发的事件\n\t\t\tinceBtn.setBackground(Color.red);//设置按钮颜色\n\t\t\tstopBtn.setBackground(Color.yellow);\n\t\t\tif (!(thread.isAlive())) {//线程不处于”新建状态”\n\t\t\t\tthread=new Thread(this);\n\t\t\t}\n\t\t\tthread.start();//启动线程\n\t\t\tstop=false;//开始接收信息\n\t\t}\n\t\tif (e.getSource()==stopBtn) {//单击stop按钮触发的事件\n\t\t\tinceBtn.setBackground(Color.yellow);\n\t\t\tstopBtn.setBackground(Color.red);\n\t\t\tstop=true;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\t// TODO 自动生成的方法存根\n\t\tReceive receive=new Receive();\n\t\treceive.setSize(460,200);\n\t}\n\n}\n```\n\n","tags":["编程语言"]},{"title":"pytorch深度学习笔记","url":"/2022/09/27/pytorch深度学习笔记/","content":"\n# 基础知识\n\n## 机器学习\n\n机器学习三大范式\n\n* 监督学习，数据+标签\n* 无监督学习，大数据没法给标签，根据相似性将用户自动分成几类\n  * 同一类人群，产品可以互推\n* 强化学习\n  * 扫地机器人，撞到扣分，没撞到加分\n\n### K邻近\n\n聚类算法\n\n* 簇的个数是超参数，假设是3\n* 随机选三个中心点，计算中心点和其他点的距离，求平均距离\n* 改变中心点，如果距离要小，说明更合适作为中心点\n* 中心点改变有多种策略\n\n如何选取簇，对于多维，两两选择特征画图，多画几个看能分成几个簇，然后直接选最大的那个\n\n如果在报告里，就做主成分分析，找出最具代表性的特征，两两组合判断簇个数，然后开始聚类\n\n随机初始化选簇，然后进行聚类计算。目的就是逐渐逼近一个最优解\n\n\n\n聚类算法\n\n* DBSCAN，在skilearn里有开源代码\n* AP邻近传播算法\n\n## 多层感知机\n\n## 激活函数\n\n## 损失函数\n\n## 梯度下降\n\n### 什么是梯度下降\n\n作用：优化损失函数\n\n找极小值(损失函数要找最小)\n\n梯度：梯度就是函数对它的各个自变量求偏导后，由偏导数组成的一个向量。简单来说就是导数多了**方向**(这个很关键，后面提到)\n\n\n\n在下图情况有可能陷入局部最小值，也就是左边最小值，但他不是全局最小\n\n![img](https://pic3.zhimg.com/80/v2-239bdd1d0c195438ade5ba598a3c5552_720w.webp)\n\n因此，就需要随机初始化几次，多尝试几次\n\n那么如何找呢，以一元二次函数f(x)=(x-1)^2+1为例\n\n![img](https://pic1.zhimg.com/80/v2-0f23b351799a1cb70f9a1f71f743d160_720w.webp)\n\n假设红点处是一个初始值，我们对该点进行求导，导函数fx=2x-2，当x减小，也就是黑色箭头方向，导数是在减小的，代表导数反方向；橙色箭头方向，导数增加，代表导数正向。\n\n为了找到极小值，我们需要让红点x朝着黑色方向移动，这就是梯度下降的目的。实现这一过程，需要提到**学习率eta**\n$$\nx\\leftarrow x-eta*\\frac{df(x)}{dx}\n$$\n让x减去学习率eta乘以函数的导数。学习率eta的目的是控制x更新的幅度，如果eta小，那么x每次更新的幅度就小\n\n进行迭代更新，曲线逐渐平缓，最终会收敛到一个局部的极值点，也就是当导数无限逼近0，最终停留在极值点。\n\n![img](https://pic3.zhimg.com/80/v2-0d352837d300670f0bcf4d6d7de519c2_720w.webp)\n\n> [Gradient-Descent（全世界最通俗易懂的梯度下降法详解-优化函数大法） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/261375491)\n\n### 神经网络与梯度下降\n\n神经网络方面的一个巨大突破是从 **sigmoid** 函数转换到一个 **ReLU** 函数,**Rectified Linear Unit**\n\n![image-20240407202927937](pytorch深度学习笔记.assets/image-20240407202927937.png)\n\n为什么？\n\n使用sigmoid，在x轴负向，梯度会接近0，学习速度变得很慢\n\n而换用ReLU，对于输入的负值，梯度都是0，不会趋向逐渐减少到0，这使得**梯度下降**算法运行得更快。\n\n## 超参数\n\n### 学习率\n\n学习率决定了在每步参数更新中，模型参数有多大程度（或多快、多大步长）的调整\n\n学习率是在梯度下降的过程中更新权重时的超参数，即下面公式中的eta\n$$\nx\\leftarrow x-eta*\\frac{df(x)}{dx}\n$$\n学习率越低，**损失函数的变化速度就越慢**，容易过拟合。虽然使用低学习率可以确保我们不会错过任何局部极小值，但也意味着我们将花费更长的时间来进行收敛，特别是在被困在局部最优点的时候。而学习率过高容易发生梯度爆炸，loss振动幅度较大，模型难以收敛。\n\n学习率的影响：\n\n![img](https://pic3.zhimg.com/80/v2-ed6451ac1a140e12dfd80625ceb15166_720w.webp)\n\n#### 如何设置和调整学习率\n\n调整学习率的套路通常是：\n\n- 先设置一个初始学习率。这个初始学习率应该让损失尽可能快地降低。\n- 然后训练过程中按照一定的schedule降低学习率；或用算法根据实际训练情况，自适应地调整学习率。\n\n另外，在正式开始训练之前， 还应该有一小段热身的过程。热身的原因是一开始模型参数是完全随机的，需要谨慎地更新参数，不能一上来就用初始学习率。\n\n\n\n## 卷积神经网络\n\n简单神经网络和卷积神经网络\n\n![image-20240407202301840](pytorch深度学习笔记.assets/image-20240407202301840.png)\n\n卷积神经网络起到一个分类器的作用\n\n**卷积层负责提取特征，采样层负责特征选择，全连接层负责分类**\n\n![img](https://pic3.zhimg.com/v2-05f7af4e1d59e82412832c01b1144f52_b.jpg)\n\n### 卷积\n\n卷积层如何提取特征呢？\n\n用到卷积核又叫滤波器，(convolution kernel）是可以用来提取特征的\n\n\n\n![img](https://pic4.zhimg.com/v2-c9b00043ba326451979abda5417bfcdf_b.jpg)\n\n**卷积核放在神经网络里，就代表对应的权重（weight)**\n\n**卷积核和图像进行点乘（dot product),** **就代表卷积核里的权重单独对相应位置的Pixel进行作用**\n\n至于为什么要把点乘完所有结果加起来，实际上就是把所有作用效果叠加起来\n\n\n\n我们知道输入，知道神经元的权值（weights）了，根据神经网络公式：\n$$\n\\sum_iw_ix_i+b\n$$\n还需要设置偏置bias，先假设为0\n\n我们分别对三个分量的其中一个3x3的九宫格进行卷积\n\n所以，结果为：\n\nW1output = 1*(-1) +1*1+1*0+0*(-1)+1*0+2*1+0*(-1)+1*1+2*(-1) =1\n\nW2output = 2*1+2*0+1*1+1*1+0*1+0*2+0*1+0*0+1*1=5\n\nW3output = 1*(-1)+1*(-1)+0*(-1)+0*2+0*(1)+0*2+1*0+1*1+0*1 = -1\n\nBias = 0\n\nFinal_output =**W1output + W2output+W3output+bias**= 1+5-1+0 = 5\n\n\n\n三个卷积核的输出为什么要叠加在一起呢\n\n**你可以理解为三个颜色特征分量叠加成RGB特征分量**\n\n但是，不能够对pixels随即找然后进行卷积，除了特征值，还有相对位置需要考虑。\n\n因此，也需要按照正确的顺序去进行卷积。\n\n最经典的就是从左到右，每隔x列Pixel，向右移动一次卷积核进行卷积(x可以自己定义)\n\n![img](https://pic1.zhimg.com/v2-0e86ac3e69a31e47477f658b76842c7c_b.jpg)\n\n到达最右。从上到下，每隔y行pixel,向下移动一次卷积核，移动完成，再继续如上所述，从左到右进行\n\n就这样，我们先从左到右，再从上到下，直到所有pixels都被卷积核过了一遍，完成输入图片的第一层卷积层的特征提取\n\n![img](https://pic2.zhimg.com/v2-8d0c46394cac2f192e236c7cffff2559_b.jpg)\n\n**这里的x我们叫作stride,就是步长的意思，如果我们x = 2, 就是相当每隔两行或者两列进行卷积**\n\n同时我们可以看到，分量的pixel 外面还围了一圈0，称为补0(相当于什么信息都没加)。对比补了0和没补0，同样一行，补0执行了多几次的卷积操作，好处在于：\n\n* 可以获得更多细致特征信息，比如图像的**边缘信息**\n\n* 我们可以控制卷积层输出的特征图的size，从而可以达到**控制网络结构的作用**，还是以上面的例子，如果没有做zero-padding以及第二层卷积层的卷积核仍然是3x3, 那么第二层卷积层输出的特征图就是1x1，CNN的特征提取就这么结束了。\n\n  **同样的情况下加了zero-padding的第二层卷积层输出特征图仍然为5x5,这样我们可以再增加一层卷积层提取更深层次的特征**\n\n[卷积神经网络（CNN）入门讲解 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_141391545)\n\n### 采样层(池化层，pooling)\n\n#### 最大池化\n\n最大池化Maxpooling字面意思就是，直接取最大的\n\n例如下面矩阵图，数值代表特征程度\n\n![img](https://picx.zhimg.com/v2-c03717a0e283578ab302075c1c1fe029_720w.jpg?source=d16d100b)\n\n最大池化选择9，含义就是9代表这个区域，最符合特征的，然后去掉没有的。\n\n为什么要这么做？作者举了个很形象的例子\n\n比如这里四个美女要选一个，每个人的选择都是最符合自己的(也就是四个中最符合的特征)，其他的丢掉\n\n![img](https://picx.zhimg.com/v2-642db2909cdf8230fdcf509b85746556_720w.jpg?source=d16d100b)\n\n那为什么不能都选呢？——不做Maxpooling\n\n首先你娶回4个，她们会各种勾心斗角，让你崩溃**（overfitting）**\n\n然后你会有巨大的经济压力，身体也吃不消**（参数过多导致运算量大）**\n\n最后可能还会难以平衡婆（上一次卷积层）媳或者母子（下一层卷积层）关系**（无法满足模型结构需求）**\n\n#### 如何进行\n\n例如下图 ，可以类比卷积，就是一个2X2的卷积核，stride为2，从左到右从上到下，作用是选取核里最大的值，而不是做卷积运算\n\n![img](https://pic1.zhimg.com/v2-16b276fe8c010af144383da29336c1e9_720w.jpg?source=d16d100b)\n\n#### 池化的性质\n\n**可以一定程度提高空间不变性**，比如说平移不变性，尺度不变性，形变不变性\n\n空间不变性体现在，卷积是对一个区域一个区域进行卷积，CNN关注单独区域的特征以及特征之间的相对位置。\n\n当图像发生细微变化，经过卷积和maxpooling，输出结果和原来差别可能不大甚至很小\n\n平移不变性：图像经过一个小小的平移之后，依然产生相同的池化特征\n\n### 激活函数\n\n在接触到深度学习（Deep Learning）后，特别是神经网络中，我们会发现在**每一层的神经网络输出后都会使用一个函数**（比如sigmoid，tanh，Relu等等）对结果进行运算，这个函数就是激活函数（Activation Function）。\n\n为什么要激活函数？简而言之因为神经网络每层输入输出都是线性求和过程，不管怎么叠加变换，都是线性组合不能解决非线性问题。而通过激活函数可以使神经网络逼近任何非线性函数，应用于复杂的非线性分类问题\n\n我们从最简单的开始讲\n\n#### 线性方程\n\n下图就是一个最简单的神经元，Y=W*X1+1，其实就是一个线性方程\n\n![img](https://pic2.zhimg.com/v2-5fa9312ed3aecb8c3f84c437e4933dd9_b.jpg)\n\n然而，这个神经网络只能够解决普通的线性二分类问题，比如\n\n![img](https://pic4.zhimg.com/v2-825e4434307215b82ee5607512d1695b_b.jpg)\n\n现实中，其实更多的都是复杂的二分类，具有非线性的特点。那么怎么做呢？\n\n首先叠加神经网络行不行？这里我们对神经元进行叠加，列出公式\n\nOutput = w7(input1*w1 +input2*w2)+w8(input1*w3+input2*w4)+w9(input1*w5+input2*w6)\n\nOutput = input1(w1*w7+w3*w8+w9*w5)+input2*(w2*w7+w4*w8+w6*w9)\n\n我们假设Output = 0 \n\n那么input1 = input2*( w2*w7+w4*w8+w6*w9)/(-w2*w7+w4*w8+w6*w9)\n\n这又回到了一个线性方程。由于线性函数具有可加性和其次性，所以仅靠简单的叠加是不能够解决非线性问题的。\n\n![img](https://pic1.zhimg.com/v2-99edcb8c87dbcdc5eb2884cf7076884c_b.jpg)\n\n#### 待解决问题\n\n##### 非线性\n\n那如何将线性神经网络转为非线性呢？我们首先想到二次函数y=wx<sup>2</sup>+B\n\n某一个二次函数经过调整，可以将非线性问题进行分类：\n\n![img](https://pic2.zhimg.com/v2-10f91a9a61f22aea9a46ebaf63c1e3ad_b.jpg)\n\n##### 输出需要进行分类\n\n我们的神经网络（还是最简单的）\n\nY =W*X +B\n\n根据input X的值，我们会得到Y值\n\n所以我们需要一个函数可以对得到的Y值进行分类的\n\n比如Y大于0 ，分类为1\n\n小于0 ，分类为0\n\n##### 输入可能特别大\n\n对于神经网络Y=W*X+B，我们需要算出输出误差error (output Y - target Y) 来更新权值\n\n![img](https://pic3.zhimg.com/v2-b50b34f6c48a49968de2d7b6de79b7e6_b.jpg)\n\n如果输出X绝对值太大甚至无限大，那么输出Y会特别大，直接导致Error非常大，那么更新出来的权值没有意义或无法更新权值\n\n##### 线性方程梯度与输入无关了\n\n线性神经网络导数为常数，那么梯度gradient就与输入X无关了\n\n在反向传播时候，梯度改变也变为常数，和输入的改变关联不上了\n\n#### 激活函数\n\n解决上面的问题，就需要激活函数了\n\n![img](https://pic1.zhimg.com/v2-17708ef17113fc120b045db3de3dbaac_b.jpg)\n\n> [CNN入门讲解：什么是激活函数（Activation Function） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/32824193)\n>\n> \n\n\n\n### 全连接层\n\n全连接层的作用主要就是实现分类（Classification）\n\n训练完到最后一步：\n\n![img](https://pic4.zhimg.com/80/v2-ba7629e4fb2996750f870a1d85bca863_720w.webp)\n\n\n\n猫头猫尾...-->猫\n\n再往前可以做对子特征进行分类：\n\n![img](https://pic2.zhimg.com/80/v2-671995a238e33a1c4e669340fed561f5_720w.webp)\n\n猫眼猫胡须...-->猫头\n\n这些细节特征哪来的呢？就是从前面的卷积层，下采样层来的。\n\n二层全连接\n\n![img](https://pic4.zhimg.com/80/v2-27e053826d9779ef8d8a6faba22a6b7b_720w.webp)\n\n全连接层对模型的影响因素：\n\n1. 全连接层的总层数（长度）\n2. 单个全连接层的神经元数（宽度）\n3. 激活函数(作用：**增加模型的非线性表达能力**)\n\n如果全连接层宽度不变，增加**长度**(总层数)：\n\n**优点**：全连接层数加深，模型非线性表达能力提高。理论上都可以提高模型的学习能力。\n\n如果全连接层长度不变，增加**宽度**(神经元个数)：\n\n**优点**：神经元个数增加，模型复杂度提升。理论上可以提高模型的学习能力。\n\n难度长度和宽度都是越多越好？\n\n肯定不是\n\n（1）**缺点**：学习能力太好容易造成过拟合。\n\n（2）**缺点**：运算时间增加，效率变低。\n\n那么怎么判断模型学习能力如何？看Training Curve 以及 Validation Curve\n\n在其他条件理想的情况下，如果Training Accuracy 高， Validation Accuracy 低，也就是过拟合 了，可以尝试去减少层数或者参数。\n\n如果Training Accuracy 低，说明模型学的不好，可以尝试增加参数或者层数。至于是增加长度和宽度，这个又要根据实际情况来考虑了。\n\n## 编码器解码器\n\nencoder-decoder\n\n表征学习，数据压缩，特征降维\n\n编码器学习数据的特征，逐步压缩输入信息，目的是将所有必要信息编码到一个抽象的表示中\n\n 解码器的任务是将编码器输出的内部表示转换为目标序列。解码器逐步生成输出序列，每一步都可能依赖于前一步的输出以及从编码器传递过来的上下文信息。在生成过程中，解码器逐渐解开编码器压缩的信息，将其转化为有意义的输出\n\n在这个抽象， 可以给一些随机数，如果模型学习的好，应该能够出来一个和x相近的结果\n\n输入数据要洗牌，从不同角度观察，保证多样性\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n \n# 定义编码器\nclass Encoder(nn.Module):\n    def __init__(self, input_dim, emb_dim, hidden_dim, n_layers):\n        super(Encoder, self).__init__()\n        # 输入序列的嵌入层\n        self.embedding = nn.Embedding(input_dim, emb_dim)  \n        # 使用GRU作为循环网络层\n        self.rnn = nn.GRU(emb_dim, hidden_dim, n_layers)   \n \n    def forward(self, src):\n        # src维度是[seq_len, batch_size]\n        # 嵌入层的输出维度是[seq_len, batch_size, emb_dim]\n        embedded = self.embedding(src)  \n        # GRU的输出\n        outputs, hidden = self.rnn(embedded)  \n        return hidden\n \n# 定义解码器\nclass Decoder(nn.Module):\n    def __init__(self, output_dim, emb_dim, hidden_dim, n_layers):\n        super(Decoder, self).__init__()\n        self.embedding = nn.Embedding(output_dim, emb_dim)\n        self.rnn = nn.GRU(emb_dim + hidden_dim, hidden_dim, n_layers)\n        # 线性层，将隐藏状态转换为输出\n        self.fc = nn.Linear(hidden_dim, output_dim)  \n \n    def forward(self, input, hidden):\n        # input维度是[batch_size]，需要增加一个维度成为[1, batch_size]\n        input = input.unsqueeze(0)\n        # 嵌入层的输出维度是[1, batch_size, emb_dim]\n        embedded = self.embedding(input)  \n        # 解码器的RNN同时接收当前输入和上下文向量\n        output, hidden = self.rnn(embedded, hidden)  \n        # 将RNN的输出通过线性层转换为最终的预测结果\n        prediction = self.fc(output.squeeze(0))  \n        return prediction, hidden\n```\n\n\n\n* `dir()`函数，能让我们知道工具箱以及工具箱中的分隔区有什么东西。\n* `help()`函数，能让我们知道每个工具是如何使用的，工具的使用方法。\n  * `help(a)`或者`a??`\n\n三个区域编写代码：\n\n* pycharm的python文件\n  * 整体运行，python文件的块是所有行的代码，适用大型项目\n  * 每次都是整体运行\n* pycharm的python 控制台\n  * 以任意行为块(Shift+Enter)，变量属性在右边查看\n  * 出现错误可阅读性大大降低\n* Jupyter notebook\n  * 同python控制台，Shift+Enter执行块\n  * 可以直接修改块中的错误，阅读性加强\n  * 环境需要配置\n\n## \n\n# 深度学习\n\n## 残差网络Resnet\n\n[(32 封私信 / 2 条消息) 为什么残差连接的网络结构更容易学习？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/306135761/answer/2491142607?utm_campaign=shareopn&utm_content=group3_Answer&utm_medium=social&utm_psn=1764665330822328320&utm_source=wechat_session)\n\n# 注意力机制\n\n#### 组件\n\n- **<u>Q</u>uery（查询）**: 代表需要获取信息的请求。\n- **<u>K</u>ey（键）**: 与Query相关性的衡量标准。\n- **<u>V</u>alue（值）**: 包含需要被提取信息的实际数据。\n- **权重（Attention Weights）**: 通过Query和Key的相似度计算得来，决定了从各个Value中提取多少信息\n\n举例说明\n假设我们有一个简单的句子：“猫喜欢追逐老鼠”。如果我们要对“喜欢”这个词进行编码，一个简单的方法是只看这个词本身，但这样会忽略它的上下文。“喜欢”的对象是“猫”，而被“喜欢”的是“追逐老鼠”。在这里，“猫”和“追逐老鼠”就是“喜欢”的上下文，而注意力机制能够帮助模型更好地捕获这种上下文关系。\n\n```python\n# 使用PyTorch实现简单的点积注意力\nimport torch\nimport torch.nn.functional as F\n\n# 初始化Query, Key, Value\nQ = torch.tensor([[1.0, 0.8]])  # Query 对应于 \"喜欢\" 的编码\nK = torch.tensor([[0.9, 0.1], [0.8, 0.2], [0.7, 0.9]])  # Key 对应于 \"猫\", \"追逐\", \"老鼠\" 的编码\nV = torch.tensor([[1.0, 0.1], [0.9, 0.2], [0.8, 0.3]])  # Value 也对应于 \"猫\", \"追逐\", \"老鼠\" 的编码\n\n# 计算注意力权重\nd_k = K.size(1)\nscores = torch.matmul(Q, K.transpose(0, 1)) / (d_k ** 0.5)\nweights = F.softmax(scores, dim=-1)\n\n# 计算注意力输出\noutput = torch.matmul(weights, V)\n\nprint(\"注意力权重:\", weights)\nprint(\"注意力输出:\", output)\n\n```\n\n\n输出：\n\n```python\n注意力权重: tensor([[0.4761, 0.2678, 0.2561]])\n注意力输出: tensor([[0.9529, 0.1797]])\n```\n\n\n这里，“喜欢”通过注意力权重与“猫”和“追逐老鼠”进行了信息的融合，并得到了一个新的编码，从而更准确地捕获了其在句子中的语义信息。\n\n\n[解码注意力Attention机制：从技术解析到PyTorch实战_attention代码pytorch-CSDN博客](https://blog.csdn.net/magicyangjay111/article/details/132634186)\n\n# Pytorch\n\n## 加载数据\n\n一堆数据-->Dataset(提供一种方式去获取数据及其label)-->Dataloader(为后面的网络提供不同的数据形式)\n\nDataset：\n\n* 如何获取每一个数据及其label\n* 告诉我们总共有多少数据\n\n### 数据的组织形式\n\n* 文件夹名就是一个label\n* ocr\n  * 图片\n  * 对应图片的文字坐标信息\n* 图片名就是label\n\n实战案例：\n\n[image-Snipaste_2022-09-24_23-31-33](http://github.com/JJuprising/upload-img/Snipaste_2022-09-24_23-31-33.png)\n\n```python\nfrom torch.utils.data import Dataset\nfrom PIL import Image\nimport os\n\n\nclass MyData(Dataset):\n\n    def __init__(self, root_dir, label_dir):\n        self.root_dir = root_dir  # 数据集文件夹\n        self.label_dir = label_dir  # 数据集标签\n        self.path = os.path.join(root_dir, label_dir)  # 拼接路径 这里正好文件夹名就是标签名\n        self.img_path = os.listdir(self.path)  # 将文件夹下图片转换成列表\n\n    def __getitem__(self, idx):  # idx是索引\n        img_name = self.img_path[idx]  # 获取单张图片名字\n        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)  # 拼接获得单张图的地址\n        img = Image.open(img_item_path)  # 图片读取\n        label = self.label_dir  # 获取标签\n        return img, label\n\n    def __len__(self):\n        return len(self.img_path)  # 长度即数据集的列表长度\n\n\nroot_dir = \"dataset/train\"  # 大路径\nants_label_dir = \"ants\"  # 蚂蚁标签\nbees_label_dir = \"bees\"  # 蜜蜂标签\nants_dataset = MyData(root_dir, ants_label_dir)  # 实例化蚂蚁\nbees_dataset = MyData(root_dir, bees_label_dir)  # 实例化蜜蜂\n\ntrain_dataset = ants_dataset + bees_dataset  # 拼接数据集\n\n```\n\nhttps://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io\n\n## Tensorboard\n\n看模块的代码：按住Ctrl，点模块\n\n打开窗口，不接`--port`默认打开6006端口的\n\n```shell\ntensorboard --logdir=logs --port=6007\n```\n\n#### add_scalar\n\n```shell\nfrom torch.utils.tensorboard import SummaryWriter\n\nwriter=SummaryWriter(\"logs\")\n\nfor i in range(100):\n    writer.add_scalar(\"标题\",y轴,x轴)\n\nwriter.close()\n```\n\n重新画删掉Logs文件下下的所有文件，在终端Ctrl+c结束后重新打开窗口\n\n#### add_image()\n\nopencv读取到的数据是numpy型\n\n从PIL到numpy，需要在add_image()中指定shape中每一个数字/维表示的含义，默认是CHW即通道-高度-宽度，如果导入图片是HWC就要加入说明，见案例：\n\n```python\nimport numpy as np\nfrom torch.utils.tensorboard import SummaryWriter\nfrom PIL import Image\n\nwriter = SummaryWriter(\"logs\")\nimage_path = \"data/train/ants_image/0013035.jpg\"\nimg_PIL = Image.open(image_path)  # 打开图片\nimg_array = np.array(img_PIL)  # 转成numpy型\nprint(type(img_array))  # 验证时numpy型\nprint(img_array.shape)  # 检查图片的形状，发现是HWC，即高度-宽度-通道\n\nwriter.add_image(\"test\", img_array, dataformats=\"HWC\")  # HWC对应图片的形状\n\nfor i in range(100):\n    writer.add_scalar(\"y=2*x\",3*i,i)\n\nwriter.close()\n```\n\n## Transform\n\ntransform.py工具箱，有toTensor，resize等工具，用于处理图片输出想要的图片结果\n\n* transform的使用\n* tensor数据类型\n\n在括号内Ctrl+P查看要输入的参数\n\n### tensor数据类型\n\n\n\n### ToTensor&Normalize\n\n\n\n```python\nfrom PIL import Image\nfrom  torch.utils.tensorboard import SummaryWriter\nfrom torchvision import transforms\n\nwriter=SummaryWriter(\"logs\")\nimg=Image.open(\"dataset/val/ants/800px-Meat_eater_ant_qeen_excavating_hole.jpg\")\nprint(img)\n\n#ToTensor\ntrans_totensor=transforms.ToTensor()\nimg_tensor=trans_totensor(img) #  转成tensor类型\nwriter.add_image(\"ToTensor\",img_tensor)\n\n#  Normalize\nprint(img_tensor[0][0][0])\ntrans_norm=transforms.Normalize([3,0.5,0.5],[0.5,0.5,0.5]) #  标准差\nimg_norm=trans_norm(img_tensor)\nprint(img_norm[0][0][0])\nwriter.add_image(\"Normalize\",img_norm,1)\n\nwriter.close()\n```\n\n\n\n### resize()\n\n```python\n#接上面代码\n# Resize\nprint(img.size)  # 原图的大小(800, 534)\ntrans_resize = transforms.Resize((512, 512)) # 改大小\n# img PIL -> resize -> img_resize PIL\nimg_resize = trans_resize(img)\n# img_resize PIL -> totensor -> img_resize tensor\nimg_resize=trans_totensor(img_resize)\nwriter.add_image(\"Resize\",img_resize,0)\nprint(img_resize)\n```\n\n\n\n### Compose()\n\n`Compose()`中的参数需要一个列表。Python中，列表的表示形式为[数据1，数据2，...]。在`Compose`中，数据需要是`transforms`类型，所以得到的：\n\n```python\nCompose([transforms参数1,transforms参数2,...])\n```\n\n将几步打包成一步：\n\n```python\n# Compose - resize - 2\ntrans_resize_2 = transforms.Resize(512) # 只改了宽 没改长\n# PIL -> PIL -> tensor\ntran_compose = transforms.Compose([trans_resize_2, trans_totensor])\nimg_resize_2 = tran_compose(img)\nwriter.add_image(\"Resize\", img_resize_2, 1)\nwriter.close()\n```\n\n\n\n### RandomCrop()\n\n随机裁剪出一部分\n\n```python\ntrans_random = transforms.RandomCrop(512) \n# PIL -> PIL -> tensor\ntran_compose_2 = transforms.Compose([trans_random, trans_totensor])\nfor i in range(10): # 设置不同步数\n    img_crop=trans_compose_2(img)\n    writer.add_image(\"RandomCrop\", img_resize_2, 1)\n\nwriter.close()\n```\n\n\n\n### 总结\n\n* 关注输入和输出\n\n* 多看官方文档 [PyTorch](https://pytorch.org/)\n\n* 关注方法需要什么参数\n\n* 不知道返回值的时候：\n\n  * ```python\n    print()\n    print(type())\n    调试\n    ```\n\n    \n\n## torchvision数据集的使用\n\n官网文档的torchvision.datasets下有很多数据集可以使用\n\ntorchvision.models提供训练好的模型\n\ntorchvision.transform上面讲了\n\ntorchvision.utils提供小工具\n\n```python\nimport torchvision\n\ntrain_set=torchvision.datasets.CIFAR10(root=\"./dataset/data1\",train=True,download=True) # 下载训练集\ntest_set=torchvision.datasets.CIFAR10(root=\"./dataset/test1\",train=False,download=True) # 下载测试集\n\nprint(test_set[0]) # ( , )的形式，发现第一个是图片第二个是target\nprint(test_set.classes) # 查看图片有哪些类型(调式看test_set有calsses属性)\n\nimg,target=test_set[0] #接收( , )\nprint(img)\nprint(target)\nprint(test_set.classes[target])\nimg.show()\n\n```\n\n\n\n### 和transform联动\n\n```python\nimport torchvision\nfrom torch.utils.tensorboard import SummaryWriter\n\ndataset_transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) # 设置transforms\ntrain_set=torchvision.datasets.CIFAR10(root=\"./dataset/data1\",train=True,transform=dataset_transform,download=True) # 加入transforms参数\ntest_set=torchvision.datasets.CIFAR10(root=\"./dataset/test1\",train=False,transform=dataset_transform,download=True)\n\nwriter=SummaryWriter('p10')\nfor i in range(10):\n    img,target = test_set[i]\n    writer.add_image(\"test_set\",img,i)\n\nwriter.close()\n\n```\n\n结果：\n\n![image-20220927212823149](https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io@main/images/image-20220927212823149.png)\n\n\n\n## DataLoader\n\n\n\n```python\nimport torchvision\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# 准备测试数据集\ntest_data = torchvision.datasets.CIFAR10(\"./dataset/test1\", train=False, transform=torchvision.transforms.ToTensor())\ntest_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)\n\n# 测试数据集中第一张照片及target\nimg, target = test_data[0]\nprint(img.shape)\nprint(target)\n\nwriter = SummaryWriter(\"dataloader\")\nstep = 0\nfor data in test_loader:\n    imgs, targets = data  # test_loader返回值是batch_size设定的一组图片打包的img和target\n    writer.add_images(\"test_data\", imgs, step)\n    step = step + 1\n\nwriter.close()\n\n```\n\n![image-20220929211159838](https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io@main/images/image-20220929211159838.png)\n\n\n\n## 神经网络\n\n`torch.nn`，Neural Network。\n\n`nn.Module`是所有神经网络的基类\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass Model(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.conv1 = nn.Conv2d(1, 20, 5)\n        self.conv2 = nn.Conv2d(20, 20, 5)\n\n    def forward(self, x): # 隐藏层\n        x = F.relu(self.conv1(x)) #  经过一次卷积然后一次非线性 \n        return F.relu(self.conv2(x)) # 输出\n    \n    \n```\n\n### 卷积操作\n\n\n\n![image.png](https://s2.loli.net/2022/10/04/qbmG4ki3yrdASMo.png)\n\n**各种参数**\n\n![image.png](https://s2.loli.net/2022/10/04/VfBkvFeRrU7QELC.png)\n\n**Stride**\n\nStirde=1表示卷积核在输入图像上移动一格，对应格相乘得到数；从左到右，到边界回到最左向下移动Stride然后重复操作\n\n**padding**\n\n![image.png](https://s2.loli.net/2022/10/04/qaZRfAUQYKLWIpH.png)\n\n```python\nimport torch\nimport torch.nn.functional as F\n\ninput=torch.tensor([[1,2,0,3,1],\n                   [0,1,2,3,1],\n                   [3,2,3,1,1],\n                   [5,2,3,1,1],\n                   [2,1,0,1,1]])\n\nkernel=torch.tensor([[1,2,1],\n                     [0,1,0],\n                     [2,1,0]])\n\nprint(input.shape) # 只有两个参数，不能直接放进卷积，要reshape\n\ninput=torch.reshape(input,(1,1,5,5)) # 5X5矩阵\nkernel=torch.reshape(kernel,(1,1,3,3))\n\nprint(input.shape)\nprint(kernel.shape) # 变成四个参数\n\noutput=F.conv2d(input,kernel,stride=1,padding=1)\nprint(output)\n\n# 输出\n# torch.Size([5, 5])\n# torch.Size([1, 1, 5, 5])\n# torch.Size([1, 1, 3, 3])\n# tensor([[[[ 1,  3,  4, 10,  8],\n#           [ 7, 14, 14, 17,  9],\n#           [ 9, 18, 18, 17,  9],\n#           [15, 17, 14,  8,  7],\n#           [14, 13,  9,  7,  4]]]])\n```\n\n### 卷积层\n\n`nn.Conv1d`一维卷积，`nn.Conv2d`二维卷积层...\n\n彩色图像一般是三通道\n\n```python\nCLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None)\n\n# 参数表 输入通道数，输出通道数，卷积核大小，卷积操作步径大小，边缘填充，卷积核距离...后面都是默认参数\n```\n\n[卷积层示例](https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md#convolution-animations)(动图要梯子才能刷出来)\n\n`out_channels`设置为2时会生成两个卷积核，得到两个叠加的输出。(一般卷积操作会不断增加channels数)\n\n例子：\n\n```python\nimport torch\nimport torchvision.datasets\nfrom torch import nn\nfrom torch.nn import Conv2d\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\ndataset = torchvision.datasets.CIFAR10(\"/dataset/data2\", train=False, transform=torchvision.transforms.ToTensor(),\n                                       download=True)\ndataLoader = DataLoader(dataset, batch_size=64)\n\n\nclass MyModule(nn.Module):\n    def __init__(self):\n        super(Tudui, self).__init__()\n        self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0)\n\n    def forward(self, x):\n        x = self.conv1(x)\n        return x\n\n\nmyModule = MyModule()\nwriter = SummaryWriter(\"logs2\")\nstep = 0\nfor data in dataLoader:\n    imgs, targets = data\n    output = myModule(imgs)\n    print(imgs.shape)\n    print(output.shape)\n    # torch.Size([64,3,32,32])\n    writer.add_images(\"input\", imgs, step)\n    # torch.Size([64,6,30,30]) -> [xxx,3,30,30]\n    output = torch.reshape(output, (-1, 3, 30, 30))  # 原本输出通道数变两倍，这一步相当于切开放到一个\n    writer.add_images(\"output\", output, step)\n    step = step + 1\n\n```\n\n![image.png](https://s2.loli.net/2022/10/05/bMqJYA612urv7FG.png)\n\n### 池化层\n\n**ceil_mode**\n\nfloor向下取整，ceiling向上取整。默认false不够对应不取值\n\n![image.png](https://s2.loli.net/2022/10/05/o5R7AdYrMSk8lwX.png)\n\n实现：\n\n```python\n# 最大池化\n\nimport torch\nfrom torch import nn\nfrom torch.nn import MaxPool2d\n\ninput = torch.tensor([[1, 2, 0, 3, 1],\n                      [0, 1, 2, 3, 1],\n                      [1, 2, 1, 0, 0],\n                      [5, 2, 3, 1, 1],\n                      [2, 1, 0, 1, 1]], dtype=torch.float32)  # 声明一下类型否则报错\ninput = torch.reshape(input, (-1, 1, 5, 5))\nprint(input.shape)\n\n\nclass MyModule(nn.Module):\n    def __init__(self):\n        super(MyModule, self).__init__()\n        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=False) # 注意ceil_mode\n\n    def forward(self,input):\n        output=self.maxpool1(input)\n        return output\n\nmyModule = MyModule()\noutput = myModule(input)\nprint(output)\n\n# 当ceilmode设置为false结果：\n# torch.Size([1, 1, 5, 5])\n# tensor([[[[2.]]]])\n\n# 当ceilmode设置为true结果：\n# torch.Size([1, 1, 5, 5])\n# tensor([[[[2., 3.],\n#           [5., 1.]]]])\n```\n\n\n\n**最大池化目的为了保持原先数据的特征同时减少数据量，加快训练速度。**例如720p也能大致看明白1080p视频内容\n\n例子：\n\n```python\n# 最大池化\n\nimport torch\nimport torchvision\nfrom torch import nn\nfrom torch.nn import MaxPool2d\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\ndataset = torchvision.datasets.CIFAR10(\"/dataset/data2\", train=False, transform=torchvision.transforms.ToTensor(),\n                                       download=True)\ndataLoader = DataLoader(dataset, batch_size=64)\n\n\nclass MyModule(nn.Module):\n    def __init__(self):\n        super(MyModule, self).__init__()\n        self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True)\n\n    def forward(self, input):\n        output = self.maxpool1(input)\n        return output\n\n\nmyModule = MyModule()\nwriter = SummaryWriter(\"Logs_maxpool\")\nstep = 0\n\nfor data in dataLoader:\n    imgs, targets = data\n    writer.add_images(\"input\", imgs, step)\n    output = myModule(imgs)\n    writer.add_images(\"output\", output, step)\n    step = step + 1\n\nwriter.close()\n\n```\n\n![image.png](https://s2.loli.net/2022/10/05/9cvBhXPkQ6GEub3.png)\n\n可以看到输出图片变模糊了\n\n\n\n### 非线性激活 Non-linear\n\n用到`ReLu()`或`Sigmoid()`\n\n```python\nimport torch\nimport torchvision\nfrom torch import nn\nfrom torch.nn import Sigmoid, ReLU\nfrom torch.utils.data import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\ndataset = torchvision.datasets.CIFAR10(\"/dataset/data2\", train=False, transform=torchvision.transforms.ToTensor(),\n                                       download=True)\ndataLoader = DataLoader(dataset, batch_size=64)\n\n\nclass MyModule(nn.Module):\n    def __init__(self):\n        super(MyModule, self).__init__()\n        self.relu = ReLU()\n        self.sigmoid1 = Sigmoid()\n\n    def forward(self, input):\n        output = self.sigmoid1(input)\n        return output\n\n\nMyModule = MyModule()\n\nwriter = SummaryWriter(\"logs_relu\")\nstep = 0\nfor data in dataLoader:\n    imgs, targets = data\n    writer.add_images(\"input\", imgs, global_step=step)\n    output = MyModule(imgs)\n    writer.add_images(\"output\", output, global_step=step)\n    step += 1\n\nwriter.close()\n```\n\n![image.png](https://s2.loli.net/2022/10/07/AkmqnhzTt5SQO4a.png)\n\n**主要目的在网络中引入更多非线性特征，才能训练出符合更多特征的模型。**\n\n\n\n### 线性层及其他层\n\n```python\nCLASS torch.nn.Linear(in_features,out_features,biass=True)\n```\n\n`biass`表示要不要设置偏振b\n\n![image.png](https://s2.loli.net/2022/10/07/IFkEvmwWp1QL23z.png)\n\n`flattten()`展平成一行\n\n\n\n### CRAF10小实战及Sequential()\n\n![image.png](https://s2.loli.net/2022/10/07/Pqjv75cuZ6fQVsU.png)\n\n1、由公式计算第一步卷积得到padding是2(默认设置stride为1)\n\n![image.png](https://s2.loli.net/2022/10/07/HVp1tdsRDFlgBXQ.png)\n\n通过对每一步的解析，我们建立出一个简单的模型，代码如下：\n\n```python\nimport torch\nfrom torch import nn\nfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequential\nfrom torch.utils.tensorboard import SummaryWriter\n\n\nclass MyModule(nn.Module):\n    def __init__(self):\n        super(MyModule, self).__init__()\n        self.model1 = Sequential(\n            Conv2d(3, 32, 5, padding=2),\n            MaxPool2d(2),\n            Conv2d(32, 32, 5, padding=2),\n            MaxPool2d(2),\n            Conv2d(32, 64, 5, padding=2),\n            MaxPool2d(2),\n            Flatten(),\n            Linear(1024, 64),\n            Linear(64, 10)\n        )\n\n    def forward(self, x):\n        x = self.model1(x)\n        return x\n\n\nmyModule = MyModule()\nprint(myModule)\ninput = torch.ones((64, 3, 32, 32))  # torch提供的一个假设的输入\noutput = myModule(input)\nprint(output.shape)\n\nwriter = SummaryWriter(\"logs_seq2\")\nwriter.add_graph(myModule,input)\nwriter.close()\n\n```\n\n![image.png](https://s2.loli.net/2022/10/07/U7kGqmLQAs2tJVo.png)\n","tags":["python","深度学习"],"categories":["深度学习"]},{"title":"python学习笔记","url":"/2022/09/24/python学习笔记/","content":"\n部分来源：[廖雪峰的官方网站](https://www.liaoxuefeng.com/)\n\n# 函数\n\n## 函数的参数\n\n使用默认参数解决调用时缺少实参问题,一定必选参数在前，默认参数在后\n\n```python\ndef power(x, n=2):\n    s = 1\n    while n > 0:\n        n = n - 1\n        s = s * x\n    return s\n```\n\n```python\n>>> power(5)\n25\n```\n\n>  定义默认参数要牢记一点：默认参数必须指向不变对象！\n\n如：\n\n```python\ndef add_end(L=[]):\n    L.append('END')#向list尾插入\n    return L\n```\n\n```python\n>>> add_end()\n['END']\n```\n\n但是，再次调用`add_end()`时，结果就不对了：\n\n```python\n>>> add_end()\n['END', 'END']\n>>> add_end()\n['END', 'END', 'END']\n```\n\n要修改上面的例子，我们可以用`None`这个不变对象来实现：\n\n```python\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n\n## 可变参数\n\n**可变参数就是传入的参数个数是可变的**\n\n我们把函数的参数改为可变参数：\n\n```python\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n\n定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个`*`号。在函数内部，参数`numbers`接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n\n```python\n>>> calc(1, 2)\n5\n>>> calc()\n0\n```\n\n```python\n>>> nums = [1, 2, 3]\n>>> calc(*nums)\n14\n```\n\n`*nums`表示把`nums`这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n\n\n\n# 模块\n\n## 创建模块\n\n* 新建一个.py文件，不要和python自带重名\n\n## 导入模块\n\n```python\nimport 模块名称 [as别名]\nfrom 模块名称 import 函数/变量/类\n```\n\n\n\n例子：\n\n```python\n#导入整个\nimport math\nprint(math.pi)\n\n#导入部分\nfrom math import pi\nprint(pi)\n```\n\n\n\n导入自定义模块要先将自定义模块所在文件下设置为源文件夹（Sources Root）\n\n## 第三方模块\n\n```python\npip install 模块名 #在小黑窗在线安装\n\nimport 模块名 #在python文件使用\n```\n\n例子：\n\n```python\nimport schedule\nimport time\n\ndef job():\n    print(\"hhh\")\n\nschedule.every(3).seconds.do(job)#每三秒执行一次\nwhile True:\n    schedule.run_pending()#启动\n    time.sleep(1)#停一秒\n```\n\n\n\n# 以主程序运行\n\n```python\nif __name__=='__main__':\n\tpass\n```\n\n例子：\n\n```python\n#calc2.py\n\ndef add(a,b)\n\treturn a+b\n\nif __name__=='__main__'\n\tprintf(add(10,20))#只有当运行calc2.py时才会输出，当其作为模块引入到其他文件执行时不输出\n```\n\n# 包\n\npython程序结构：\n\n```mermaid\ngraph LR\nA(Python程序)-->B(包1)\nA-->C(包2)\nA-->D(包3)\nB-->E(模块A)\nB-->F(模块B)\nC-->G(模块A)\nC-->H(模块B)\n```\n\n## 包与目录的区别\n\n* 包(package)包含\\__init\\__.py文件\n* 目录(directory)里通常不包含\\__init\\__.py文件\n\n导入同目录下的包里的模块：\n\n```python\nimport package.module_A as ma #别名\nprint(ma.a)\n```\n\n使用`import`导入时只能跟包名和模块名\n\n想要导入变量用`from`:\n\n```python\nfrom package.moudle_A import a\n```\n\n![image-20220923230121039]( https://jjuprising.github.io/images/image-20220923230121039.png)\n\n\n\n```mermaid\ngraph LR\nA(模块与包)-->B(模块)\nA-->C(包)\nB-->D(避免函数名/变量名重名)\nB-->E(自定义模块)\nB-->F(第三方模块)\nE-->G(一个.py文件称为一个模块)\nF-->H(安装:pip install 模块名)\nF-->I(使用:from ...import 模块名)\nC-->J(避免模块名重名)\nC-->K(包含__init__.py文件)\n```\n\n# 面向对象\n\n## 类和实例\n\n```python\nclass Student(object):\n\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n    \n    def print_score(self):\n        print('%s: %s' % (self.name, self.score))\n```\n\n> 注意：特殊方法“__init__”前后分别有两个下划线！！！\n\n注意到`__init__`方法的第一个参数永远是`self`，表示创建的实例本身，因此，在`__init__`方法内部，就可以把各种属性绑定到`self`，因为`self`就指向创建的实例本身。\n\n有了`__init__`方法，在创建实例的时候，就不能传入空的参数了，必须传入与`__init__`方法匹配的参数，但`self`不需要传，Python解释器自己会把实例变量传进去：\n\n```python\n>>> bart = Student('Bart Simpson', 59)\n>>> bart.name\n'Bart Simpson'\n>>> bart.score\n59\n```\n\n## 继承和多态\n\n### 继承\n\n我们已经编写了一个名为`Animal`的class，有一个`run()`方法可以直接打印：\n\n```python\nclass Animal(object):\n    def run(self):\n        print('Animal is running...')\n```\n\n当我们需要编写`Dog`和`Cat`类时，就可以直接从`Animal`类继承：\n\n```python\nclass Dog(Animal):\n    pass\n\nclass Cat(Animal):\n    pass\n```\n\n**在括号放父类**\n\n### 多态\n\n在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行：\n\n```python\n>>> b = Animal()\n>>> isinstance(b, Dog)\nFalse\n```\n\n例子：\n\n```python\ndef run_twice(animal):\n    animal.run()\n    animal.run()\n    \n>>> run_twice(Animal())\nAnimal is running...\nAnimal is running...\n\n>>> run_twice(Dog())\nDog is running...\nDog is running...\n```\n\n**你会发现，新增一个`Animal`的子类，不必对`run_twice()`做任何修改，实际上，任何依赖`Animal`作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。**\n\n这就是多态的意思：\n\n对于一个变量，我们只需要知道它是`Animal`类型，无需确切地知道它的子类型，就可以放心地调用`run()`方法，而具体调用的`run()`方法是作用在`Animal`、`Dog`、`Cat`对象上，由**运行时该对象的确切类型决定**，这就是多态真正的威力：调用方**只管调用，不管细节**，而当我们新增一种`Animal`的子类时，只要确保`run()`方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：\n\n* 对扩展开放：允许新增`Animal`子类；\n\n* 对修改封闭：不需要修改依赖`Animal`类型的`run_twice()`等函数。\n\n## 获取对象信息\n\n### 使用type()\n\n首先，我们来判断对象类型，使用`type()`函数：\n\n基本类型都可以用`type()`判断：\n\n```python\n>>> type(123)\n<class 'int'>\n>>> type('str')\n<class 'str'>\n>>> type(None)\n<type(None) 'NoneType'>\n```\n\n### 使用isinstance()\n\n对于class的继承关系来说，使用`type()`就很不方便。我们要判断class的类型，可以使用`isinstance()`函数。\n\n我们回顾上次的例子，如果继承关系是：\n\n```python\nobject -> Animal -> Dog -> Husky\n```\n\n那么，`isinstance()`就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象：\n\n```python\n>>> a = Animal()\n>>> h = Husky()\n```\n\n然后，判断：\n\n```python\n>>> isinstance(h, Husky)\nTrue\n>>> isinstance(h, Animal)\nTrue\n```\n\n### 使用dir()\n\n如果要获得一个对象的所有属性和方法，可以使用`dir()`函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法：\n\n```python\n>>> dir('ABC')\n['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']\n```\n\n类似`__xxx__`的属性和方法在Python中都是有特殊用途的，比如`__len__`方法返回长度。在Python中，如果你调用`len()`函数试图获取一个对象的长度，实际上，在`len()`函数内部，它自动去调用该对象的`__len__()`方法，所以，下面的代码是等价的：\n\n```python\n>>> len('ABC')\n3\n>>> 'ABC'.__len__()\n3\n```\n\n我们自己写的类，如果也想用`len(myObj)`的话，就自己写一个`__len__()`方法：\n\n```python\n>>> class MyDog(object):\n...     def __len__(self):\n...         return 100\n...\n>>> dog = MyDog()\n>>> len(dog)\n100\n```\n","tags":["编程语言","python"],"categories":["编程"]},{"title":"js导出json文件","url":"/2022/09/06/js导出json文件/","content":"\n```javascript\nfunction saveJSON(data, filename) {\n    if (!data) {\n        alert(\"保存的数据为空\");\n        return;\n    }\n    if (!filename) filename = \"json.json\";\n    if (typeof data === \"object\") {\n        data = JSON.stringify(data, undefined, 4);\n    }\n    var blob = new Blob([data], { type: \"text/json\" }),\n        e = document.createEvent(\"MouseEvents\"),\n        a = document.createElement(\"a\");\n    a.download = filename;\n    a.href = window.URL.createObjectURL(blob);\n    a.dataset.downloadurl = [\"text/json\", a.download, a.href].join(\":\");\n    e.initMouseEvent(\n        \"click\",\n        true,\n        false,\n        window,\n        0,\n        0,\n        0,\n        0,\n        0,\n        false,\n        false,\n        false,\n        false,\n        0,\n        null\n    );\n    a.dispatchEvent(e);\n}\n```\n\n# Blob\n\nBlob，Binary Large Object的缩写，代表二进制类型的大对象。通俗点说，就是Blob对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作File对象一样操作Blob对象，实际上，File继承自Blob。\n\n## 从字符串创建 Blob\n\n```javascript\nlet myBlobParts = ['<html><h2>Hello Semlinker</h2></html>']; // an array consisting of a single DOMString\nlet myBlob = new Blob(myBlobParts, {type : 'text/html', endings: \"transparent\"}); // the blob\n```\n\n## 从类型化数组和字符串创建 Blob\n\n```javascript\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 \"hello\"\nlet blob = new Blob([hello, ' ', 'semlinker'], {type: 'text/plain'});\n```\n\n\n\n# 鼠标事件\n\n## Document.createEvent()\n\n创建一个指定类型的事件。其返回的对象必须先初始化并可以被传递给`element.dispatchEvent`\n\n### 语法\n\n```javascript\nvar event = document.createEvent(type);\n```\n\n- `event` 就是被创建的 Event 对象。\n- `type` 是一个字符串，表示要创建的事件类型。事件类型可能包括`\"UIEvents\"`, `\"MouseEvents\"`, `\"MutationEvents\"`, 或者 `\"HTMLEvents\"`。\n\n\n\n## MouseEvent.initMouseEvent()\n\n已弃用的特性，建议查阅相关文档改进\n\n[MouseEvent.initMouseEvent() - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/initMouseEvent)\n\n\n\n## EventTarget.dispatchEvent\n\n向一个指定的事件目标派发一个事件, 并以合适的顺序**同步调用**目标元素相关的事件处理函数。标准事件处理规则 (包括事件捕获和可选的冒泡过程) 同样适用于通过手动的使用`dispatchEvent()`方法派发的事件。\n\n### 语法\n\n```javascript\ncancelled = !target.dispatchEvent(event)\n```\n\n### 参数\n\n- `event` 是要被派发的事件对象。\n- `target` 被用来初始化事件和决定将会触发目标。\n","tags":["JavaScript","前端"],"categories":["编程"]},{"title":"微信小程序学习笔记","url":"/2022/08/24/微信小程序学习记录/","content":"\n# Keys\n\n## 云数据库查询\n\n### 获取不到数据\n\n* 云数据库get出来是空数组，一般是因为没有打开权限，修改为\"所有用户可读即可\"。\n\n![image.png](https://s2.loli.net/2022/09/04/TUYPLypO4MNEVhf.png)\n\n* where条件查询要添加查询的索引，如果传入的是`undefined`会获取该数据集合的全部记录\n* **调试！调试！调试！**，如果获取到`undefined`注意多调试，可能是对象属性的问题，例如一般返回`res`，而`res`下还有一层`data`,因此获取想要的字段数据一般是`res.data[0].[字段名]`\n\n## 异步同步问题\n\n特别是数据库的请求是异步的这个千万注意。\n\n解决办法：网上大致用Promise 我也没有自己研究，我的解决办法是涉及到数据库的写成一个函数然后调用函数的时候设置2秒延时执行。\n\n```javascript\nsetTimeout(()=>\n          //调用数据库\n          ,2000)\n```\n\n\n\n## 请求数据限制\n\n云数据库请求记录数据有20段的限制(偶然发现获取到的数据少了一些才查到这个规则)，建议把多的数据打包成数组放在一个字段里。\n\n网上有分页方法还没学会，但是显然是提前打包好数据更为省事。\n\n## 数组值传递的时候变字符串\n\n在查bug的时候发现数组`totalIncomeKeep=[ , , ]`在经过options传值后变成了`totalIncomeKeep= , , ,`，查了一下是字符串类型。刚开始尝试 `JSON.parse()`但是发现他是把将数组字符串转为数组对象。\n\n​\t\t应该使用`totalIncomeKeep.split(\",\")`，传过来的字符串就是按“，”分割的，这是直接用`str.split(\",\")`就成了！\n\n\n\n#  实用组件模板\n\n## 1.返回前页\n\n```javascript\nwx.navigateBack({\n\tdelta:4//delta值就是往前返回几页\n})\n\n```\n\n## 2.输入框+滑动两种输入数值方式\n\n​\t\tinput和text同行,同时滑动块根据输入框动态改变，当输入值小于滑动范围时会提示过小(大)。\n\n![image-20220816220009337](https://s2.loli.net/2022/08/16/2kbSh3ga1K8sPun.png)\n\n#### wxml\n\n```html\n<view wx:if='{{!changeStatus}}' class=\"view-contain-ti\">\n  <!-- 设置面积 -->\n  <!-- <text class=\"text-ti\">设置民宿面积</text> -->\n  <view style=\"display:flex;align-items:center\">\n    <text>设置民宿面积(平方米):</text><input class=\"inputl\" bindinput=\"usernameInput\" placeholder=\"输入5-500的数字\" value=\"{{inputValue}}\"/>\n  </view>\n  <view class=\"intro\">\n    <slider bindchange=\"sliderchange\" min=\"{{minValue}}\" max=\"{{maxValue}}\" block-size=\"20\" value=\"{{areaValue}}\" show-value />\n  </view>\n</view>\n```\n\n#### js\n\n```js\n //实时获取数据\n    usernameInput: function (e) {\n        let value = this.validateNumber(e.detail.value);\n        if(value<=500&&value>=5){\n            this.setData({\n                areaValue: value\n            })\n        }else if(value<5){\n            wx.showToast({\n                title: \"面积设置过小！\", // 提示的内容\n                icon: \"none\", // 图标，默认success\n                image: \"\", // 自定义图标的本地路径，image 的优先级高于 icon\n                duration: 700, // 提示的延迟时间，默认1500\n                mask: false, // 是否显示透明蒙层，防止触摸穿透\n        })\n            this.setData({\n                areaValue: 5\n            })\n        }else if(value>500){\n            wx.showToast({\n                title: \"面积设置过大！\", // 提示的内容\n                icon: \"none\", // 图标，默认success\n                image: \"\", // 自定义图标的本地路径，image 的优先级高于 icon\n                duration: 700, // 提示的延迟时间，默认1500\n                mask: false, // 是否显示透明蒙层，防止触摸穿透\n        })\n            this.setData({\n                areaValue: 500\n            })\n        }else{\n            this.setData({\n                areaValue: 5,\n                inputValue:''\n            })\n        }\n\n    },\n    //数字限制\n    validateNumber(val) {\n        return val.replace(/\\D/g, '')\n    },\n     /**\n     * slider滑动监听事件,滑动选择面积大小\n     */\n    sliderchange: function (e) {\n        this.setData({\n            textValue: '设置民宿面积:' + e.detail.value + ' 平方米',\n            areaValue: e.detail.value,\n            inputValue:e.detail.value\n        })\n        console.log(`当前值`, this.data.areaValue)\n    },\n```\n\n## 3.自定义弹窗\n\n​\t\t通过wx:if控制view的显隐实现弹窗效果，可以关注一下wxss的相关样式\n\n#### wxml\n\n```html\n<view wx:if='{{showModal}}'> \n <view class='mask_layer' bindtap='modal_click_Hidden' />\n <view class='modal_box'>\n  <view class=\"title\">标题</view>\n  <view class='content'>\n<!-- 弹窗内容-->\n   <text class='modalMsg'></text>\n  </view>\n  <view class='btn1'>\n   <view bindtap='modal_click_Hidden' class='cancel'>取消</view>\n   <view bindtap='Sure' class='Sure'>确定</view>\n  </view>\n </view>\n</view>\n```\n\n####  wxss\n\n```css\n.mask_layer {\n width: 100%;\n height: 100%;\n position: fixed;\n z-index: 999;\n left:0;top:0;\n background: #000;\n opacity: 0.5;\n overflow: hidden;\n}\n\n.modal_box {\n width: 76%;\n overflow: hidden;\n position: fixed;\n top: 50%;\n left: 0;\n z-index: 1001;\n background: #fafafa;\n margin: -150px 12% 0 12%;\n border-radius: 3px;\n}\n.title {\n padding: 15px;\n text-align: center;\n background-color: gazure;\n}\n.content {\n overflow-y: scroll; /*超出父盒子高度可滚动*/\n}\n.input_show1{\n  margin: 0 auto;\n  width: 80%;\n  margin-left: 10%;\n  font-size: 32rpx;\n  text-align: center;\n }\n\n.btn1 {\n width: 100%;\n margin-top: 65rpx;\n display: flex;\n flex-direction: row;\n align-items: center;\n justify-content: space-between;\n box-sizing: border-box;\n background-color: white;\n}\n.cancel {\n width: 100%;\n padding: 10px;\n text-align: center;\n color: black;\n}\n.Sure {\n width: 100%;\n padding: 10px;\n color: #44b549;\n background-color: white;\n border-left: 1px solid #d0d0d0;\n text-align: center;\n}\n.modalMsg {\n text-align: center;\n margin-top: 45rpx;\n display: block;\n}\n```\n\n####  js\n\n```js\nshowCancelOrder: function() {\n  this.setData({\n   showModal:true\n  })\n },\n   //取消\n modal_click_Hidden: function () {\n  this.setData({\n   showModal: false,\n  })\n },\n // 确定\n Sure: function () {\n\n },\n```\n\n \n\n## 4.数据可视化\n\n点击后显示坐标点的信息\n\n![image-20220817224609612](https://s2.loli.net/2022/08/17/zpTEDSjcJ4qnH6R.png)\n\n​\t\t下载echarts的微信小程序版本：[echarts-for-weixin](https://github.com/ecomfe/echarts-for-weixin) ，地址在：https://github.com/ecomfe/echarts-for-weixin，下载后解压，只需要其中的ec-canvas文件夹。\n\n​\t\t在需要引用echarts的页面json文件中，添加echarts引用（注意echarts的相对路径）：\n\n```json\n{\n  \"usingComponents\": {\n    \"ec-canvas\": \"../../ec-canvas/ec-canvas\"\n  },\n  \"navigationBarTitleText\": \"详情\"\n}\n```\n\n​\t\t在需要引用echarts的js文件中，引入echars.js：\n\n```js\nimport * as echarts from '../../ec-canvas/echarts';\n```\n\n#### wxml\n\n```html\n<!--wxml-->\n<view class=\"echart_panel\">\n    <ec-canvas id=\"mychart\" canvas-id=\"mychart-line\" ec=\"{{ ec }}\" ></ec-canvas>\n</view>\n\n```\n\n#### js\n\n```js\n<!--js-->\n//在外部\nimport * as echarts from '../../components/ec-canvas/echarts';\nconst app = getApp();\nlet chart;\n\n//在Page\n\nonLoad:function(){\n    this.initChart();\n}\n\n/**设置图表映射 */\n    initChart: function (xData, yData) {\n        this.ecComponent = this.selectComponent('#mychart');\n        var that = this;\n        var option = {\n            grid: {\n                containLabel: true\n            },\n            tooltip: {//重写图表提示内容\n                show: true,\n                trigger: 'axis',\n                position: ['50%', '30%'],\n                formatter: function (params) {\n                    return params[0].axisValue + ': ' + params[0].data + '元'\n                }\n            },\n            xAxis: {\n                type: 'category',\n                name:'时间',\n                data: xData,//异步请求的数据\n                nameTextStyle: {\n                    fontSize: 10\n                },\n                splitLine: {\n                    show: true\n                }\n            },\n            yAxis: {\n                type: 'value',\n                title: '收益',\n                name:'元',\n                axisLabel: {\n                    formatter: function (p) {//重写y坐标数值单位\n                        return p;\n                    }\n                },\n                nameTextStyle: {\n                    fontSize: 15\n                }\n            },\n            series: [{\n                name: '总收益',\n                data: yData,//异步请求的数据\n                type: 'line',\n                label: {\n                    show: true\n                }\n            }],\n            dataPointShape: true, //是否在图标上显示数据点标志\n        };\n        //echarts会继承父元素的宽高,所以我们一定要设置echarts组件父元素的高度。\n        var myChart = that.ecComponent.init((canvas, width, height) => {\n            const chart = echarts.init(canvas, null, {\n                width: width,\n                height: height,\n            });\n            //此处为折线图的点击事件，点击展示折点信息\n            chart.on('click', function (handler, context) {\n                var handlerValue = handler.name + ' :  ' + handler.value+'元'\n                wx.showToast({\n                    title: handlerValue,\n                    icon: 'none',\n                    duration: 1200,\n                    mask: true\n                })\n            });\n            //给echarts 设置数据及配置项（图表类型、数据量等）\n            chart.setOption(option);\n            return chart;\n        });\n\n    },\n```\n\n#### wxss\n\n```css\n<!-- wxss -->\n.echart_panel {\n    width: 100%;\n    height: 700rpx;\n  }\n```\n\n\n\n## 5.循环渲染多选框同时根据条件显示样式\n\n​\t\t设定的样式至少有五种，根据选项设定的权重来显示不同的样式（大于两种）。只在网上查到了运用三目运算符，没有多想，误以为只能设置两种。后来想到可以嵌套。！\n\n![image-20220818131332986](https://s2.loli.net/2022/08/18/D8jxYpvMUdSNlXs.png)\n\n#### wxml\n\n```html\n<view class=\"every_tab\">\n      <checkbox-group bindchange=\"checkboxChange3\" class=\"select\">\n          <!-- 循环时外层是items 内层的单个对象是item-->\n        <label class=\"cell\" wx:for=\"{{items}}\" wx:if=\"{{index>78}}\" wx:key=\"value\">\n            <!-- 三目运算符嵌套 根据items数组内对象的weight属性条件来显示样式-->\n          <view class=\"{{item.weight==1?'weight1':(item.weight==2?'weight2':(item.weight==3?'weight3':(item.weight==4?'weight4':'weight5')))}}\">\n            {{item.name}}\n            <checkbox value=\"{{item.value}}\" checked=\"{{item.checked}}\" />\n          </view>\n        </label>\n      </checkbox-group>\n    </view>\n```\n\n#### wxss\n\n```css\n.weigth1{\n  color: black;\n}\n.weight2{\n  color: green;\n}\n.weight3{\n  color: aqua;\n}\n.weight3{\n  color: blue;\n}\n.weight4{\n  color: blueviolet;\n}\n.weight5{\n  color: purple;\n}\n```\n\n\n\n#### js\n\n```js\ndata:{\n     items: [\n            { value: '1', weight: 1, name: '床品每客一换' },\n            { value: '2', weight: 1, name: '行李寄存' },\n            { value: '3', weight: 2, name: '自助入住' },\n            { value: '4', weight: 2, name: '保安' },\n            { value: '5', weight: 3, name: '管家式服务' },\n            { value: '6', weight: 4, name: '床品一天一换' },\n},\n    /*设施多选框 */\n    checkboxChange(e) {\n        console.log('checkbox发生change事件，携带value值为：', e.detail.value)\n        const items = this.data.items\n        const values = e.detail.value\n        for (let i = 0, lenI = 6; i < lenI; ++i) {\n            items[i].checked = false\n            for (let j = 0, lenJ = values.length; j < lenJ; ++j) {//遍历\n                if (items[i].value === values[j]) {\n                    items[i].checked = true;\n                    break;\n                }\n            }\n        }\n        this.setData({\n            items\n            \n        })\n   },\n```\n\n\n\n## 6.进度条\n\n| 属性      | 类型    | 默认值 | 必填 | 说明                   |\n| :-------- | :------ | :----- | :--- | :--------------------- |\n| percent   | number  |        | 否   | 百分比0~100            |\n| show-info | boolean | false  | 否   | 在进度条右侧显示百分比 |\n\n![image-20220824003057165](https://cdn.jsdelivr.net/gh/JJuprising/upload-img/image-20220824003057165.png)\n\n#### wxml\n\n```html\n<view class=\"progress-box\">\n    <text >进度：</text>\n    <progress percent=\"{{persent}}\" show-info stroke-width=\"3\" />\n</view>\n```\n\n#### wxss\n\n```css\n.progress-box{\n    width:85%;\n    margin-left:70rpx;\n}\n```\n\n## 7.搜索框\n\n首页的搜索框，点击后进入搜索页面\n\n![image-20220824113910534.png](https://s2.loli.net/2022/08/30/1Dj63dzmc4raukU.png)\n\n![image-20220824113842731.png](D:\\Typora\\images\\RGD3SPfkxeZTHu7.png)\n\n### Searchinput组件\n\n首先在components文件下准备一个Searchinput组件\n\n#### Searchinput.wxml\n\n```html\n<view class=\"search_input\">\n    <navigator url=\"/pages/search/index\" open-type=\"navigate\" class=\"Searchinput_navigator\">\n        <text >搜索</text>\n    </navigator>\n</view>\n```\n\n#### Searchinput.wxss\n\n```\n.search_input .Searchinput_navigator {\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: white;\n  border-radius: 50rpx; \n  color: #666;\n}\n```\n\n#### Searchinput.js\n\n不需要修改\n\n\n\n然后再添加一个search界面\n\n### search界面\n\n#### search.wxml\n\n```html\n<view class=\"page\">\n  <view class=\"page__bd\">\n    <view class=\"weui-search-bar\">\n      <view class=\"weui-search-bar__form\">\n        <view class=\"weui-search-bar__box\">\n          <icon class=\"weui-icon-search_in-box\" type=\"search\" size=\"14\"></icon>\n          <input type=\"text\" class=\"weui-search-bar__input\" placeholder=\"搜索\" value=\"{{inputVal}}\" focus=\"{{inputShowed}}\" bindinput=\"inputTyping\" />\n          <view class=\"weui-icon-clear\" wx:if=\"{{inputVal.length > 0}}\" bindtap=\"clearInput\">\n            <icon type=\"clear\" size=\"14\"></icon>\n          </view>\n        </view>\n        <label class=\"weui-search-bar__label\" hidden=\"{{inputShowed}}\" bindtap=\"showInput\">\n          <icon class=\"weui-icon-search\" type=\"search\" size=\"14\"></icon>\n          <view class=\"weui-search-bar__text\">搜索</view>\n        </label>\n      </view>\n      <view class=\"weui-search-bar__cancel-btn\" hidden=\"{{!inputShowed}}\" bindtap=\"hideInput\">取消</view>\n    </view>\n    <view class=\"weui-cells searchbar-result\" wx:if=\"{{inputVal.length > 0}}\" wx:for=\"{{search_list1}}\" wx:key=\"dessay_id\">\n      <navigator url=\"/pages/essays_detail/index?essay_id={{item.dessay_id}}\" class=\"weui-cell\" hover-class=\"weui-cell_active\">\n        <view class=\"weui-cell__bd\">\n          <view>{{item.dessay_title}}</view>\n        </view>\n      </navigator>\n    </view>\n  </view>\n</view>\n```\n\n#### search.wxss\n\n​\t\t这里需要添加weui，可以上网上(或者到仓库里)找然后修改文件路径\n\n```css\n/**\n* Tencent is pleased to support the open source community by making\n* WeUI-WXSS available.\n* \n* Copyright (C) 2017 THL A29 Limited, a Tencent company.\n* All rights reserved.\n* \n* Licensed under the MIT License (the \"License\"); you may not use\n* this file except in compliance with the License. You may obtain a copy of\n* the License at\n* \n*       http://opensource.org/licenses/MIT\n* \n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n@import \"base/reset.wxss\";\n\n@import \"widget/weui-cell/weui-cell.wxss\";\n\n@import \"./widget/weui-searchbar/weui-searchbar.wxss\";\npage {\n  background-color: white;\n  padding: 20rpx;\n}\n.search_row {\n  height: 60rpx;\n  display: flex;\n}\n.search_row input {\n  background-color: #dedede;\n  flex: 1;\n  height: 100%;\n  padding-left: 30rpx;\n}\n.search_row button {\n  background-color: white;\n  width: 100rpx;\n  height: 100%;\n  font-size: 28rpx; \n  padding: 0;\n  margin: 0 10rpx;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.search_content {\n  margin-top: 30rpx;\n}\n.search_content .search_item {\n  background-color: white;\n  font-size: 26rpx;\n  padding: 15rpx 10rpx;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n```\n\n#### search.js\n\n```js\nPage({\n\n    /**\n     * 页面的初始数据\n     */\n    data: {\n      inputVal: '',\n      inputShowed: false,\n      search_list1: [],\n    },\n    showInput: function () {\n      this.setData({\n        inputShowed: true\n      });\n    },\n    hideInput: function () {\n      this.setData({\n        inputVal: \"\",\n        inputShowed: false\n      });\n    },\n    clearInput: function () {\n      this.setData({\n        inputVal: \"\"\n      });\n    },\n    inputTyping: function (e) {\n      this.setData({\n        inputVal: e.detail.value\n      });\n      //连接数据库\n      const db = wx.cloud.database()\n      var that = this\n      db.collection('essays_detail').where({\n        //使用正则查询，实现对搜索的模糊查询\n        dessay_title: db.RegExp({\n          regexp: e.detail.value,\n          //从搜索栏中获取的value作为规则进行匹配。\n          options: 'i',\n          //大小写不区分\n        }),\n        \n      }).limit(10).get({\n        success: res => {\n          that.setData({\n            search_list1: res.data\n          })\n        }\n      })\n    }\n    })\n  \n```\n\n\n\n## 8.分类栏\n\n![image-20220824115856124.png](https://s2.loli.net/2022/08/30/rpV3iWQvRcUIxz7.png)\n\n在component文件夹下准备Cater组件：\n\n#### Cater.wxml\n\n```html\n<view>\n<scroll-view class=\"tab-list\" scroll-x scroll-with-animation>\n<view wx:for=\"{{tabs}}\" wx:key=\"id\" class=\"tab-item {{item.isActive ? 'active':''}}\" \n    data-index=\"{{index}}\" bindtap=\"handleItemTap\">{{item.name}}</view>\n</scroll-view>\n<slot></slot>    \n</view>   \n```\n\n#### Cater.wxss\n\n```css\n.tab-list {\n  width: 100%;\n  height: 88rpx;\n  border-bottom: 1rpx solid #e5e5e5;\n  display: inline-block;\n  white-space: nowrap;\n   \n  }\n   \n  .tab-item {\n  width: 188rpx;\n  height: 85rpx;\n  display: inline-block;\n  line-height: 85rpx;\n  vertical-align: middle;\n  text-align: center;\n  }\n   \n  .active {\n  color: red;\n  border-bottom: 5rpx solid red;\n  }\n```\n\n#### Cater.js\n\n```js\nComponent({\n    properties:{\n      tabs:{\n        type:Array,\n        value:[]\n      }\n    },\n    data: { \n        \n    }, \n    //组件.js存放事件回到函数在methods中\n    methods:{  \n      handleItemTap(e){\n        /* 1  \n        1 绑定点击事件 \n        2 获取被点击的索引\n        3 获取原数组\n        4 对数组循环 \n          1 给每一个循环性 选中属性 改为 false \n          2 给 当前的索引的 项添加激活选中效果就可以了\n        */ \n        // 2 获取索引 \n        const {index}=e.currentTarget.dataset; \n        // 传递事件给父组件\n        this.triggerEvent(\"itemChange\",{index});\n        // 3 获取data中的数组\n        // 解构 对 复杂类型进行结构 复制了一份 变量引用而已\n        let {tabs}=this.data;\n        // 4 循环数组 \n        tabs.forEach((v,i) =>i===index?v.isActive=true:v.isActive=false )\n        this.setData({\n          tabs\n        })\n      },\n    }\n  })\n```\n\n\n\n**然后在需要添加分类栏的界面：**\n\n#### index.json\n\n先引入Cater组件\n\n```json\n{\n  \"usingComponents\": {  \n    \"Cater\":\"../../components/Cater/Cater\"\n  },\n  \"navigationBarTitleText\": \"首页\", \n  \"enablePullDownRefresh\":true, \n  \"onReachBottomDistance\":50, \n  \"backgroundColor\": \"#efefef\", \n  \"backgroundTextStyle\": \"dark\"\n}  \n```\n\n#### index.wxml\n\n```html\n<!-- 分类栏 -->\n        <Cater tabs=\"{{tabs}}\" binditemChange=\"handleItemChange\"></Cater>\n\t\t<!-- 以下根据点击分类呈现相应的内容显示在block中-->\n        \t<block wx:if=\"{{tabs[0].isActive}}\"></block>\n\t\t\t<block wx:if=\"{{tabs[1].isActive}}\"></block>\n```\n\n#### index.js\n\n```js\ndata: {\n    tabs: [{   \n      id: 1,\n      name: \"推荐\",\n      isActive:true\n    }, \n    {\n      id: 2,\n      name: \"文创\", \n      isActive:false\n    },  \n    {\n      id: 3,\n      name: \"时装\",\n      isActive:false\n    }, \n    {\n      id: 4,\n      name: \"节目\",\n      isActive:false\n    }\n  ]\n  },\nhandleItemChange(e){\n        const {index}=e.detail;\n        let {tabs}=this.data;\n        // 4 循环数组\n        tabs.forEach((v,i) =>i===index?v.isActive=true:v.isActive=false )\n        this.setData({\n          tabs\n        })\n  },\n```\n\n## 9.地图颜色块图例\n\n![颜色快图例.png](https://s2.loli.net/2022/08/30/6TvqWsAFekx3fXC.png)\n\n#### wxml\n\n```html\n<!-- 图例 -->\n  <view class=\"btm_tool\"> \n    <view class=\"tool_item\">\n    <view class=\"label1\">111</view><view >1级</view>\n    </view>\n    <view class=\"tool_item\">\n    <view class=\"label2\">111</view><view >2级</view>\n    </view>\n    <view class=\"tool_item\">\n    <view class=\"label3\">111</view><view >3级</view>\n    </view>\n    <view class=\"tool_item\">\n    <view class=\"label4\">111</view><view >4级</view>\n    </view>\n    <view class=\"tool_item\">\n    <view class=\"label5\">111</view><view >5级</view>\n    </view>\n  </view>\n```\n\n#### wxss\n\n```css\n.btm_tool {\n  border-top: 1rpx #ccc;\n  position: fixed;\n  left: 0;\n  bottom: 20rpx;\n  width: 100%;\n  height: 100rpx;\n  background-color: #fff;\n  display: flex;\n  z-index:200;\n}\n.btm_tool .tool_item {\n  flex: 6;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  font-size: 20px;\n}\n```\n\n\n\n## 10.收藏功能\n\n​\t\t在文章详情页点击“收藏”，就会在收藏夹”喜爱“界面出现文章的入口。\n\n![image-20220824115856124.png](https://s2.loli.net/2022/08/30/rpV3iWQvRcUIxz7.png)\n\n![image-20220824115546637.png](https://s2.loli.net/2022/08/30/enzOtbEICqy8cRl.png)\n\n![image-20220824115827795.png](https://s2.loli.net/2022/08/30/PK4QDNB5lkoFCH9.png)\n\n\n\n\n\n在需要添加收藏功能的页面：\n\n#### wxml\n\n```html\n<view class=\"tool_item\">\n            <view class=\"iconfont {{isCollect?'icon-shoucang1':'icon-shoucang'}}\" bindtap=\"handleCollect\"></view>\n            <view>收藏</view>\n</view>\n            \n```\n\n#### wxss\n\n```css\n.tool_item {\n  flex: 2;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n}\n.tool_item .icon-shoucang1 {\n  color: orange;\n}\n```\n\n#### js\n\n```js\n  data: {\n        // 是否被收藏\n        isCollect:false,\n    },\n// 点击收藏图标\n    handleCollect(){\n      let isCollect=false;\n      // 1 获取缓存中的收藏数组\n      let collect=wx.getStorageSync(\"collect\")||[];\n      // 2 判断文章是否被收藏过\n      let index=collect.findIndex(v=>v.dessay_id===this.EssaysInfo.dessay_id)\n      // 3 当index!=-1 表示已经收藏过了\n      if(index!==-1){\n        // 已经收藏过了 在数组中删除\n        collect.splice(index,1);\n        isCollect=false;\n        // 弹窗提示\n        wx.showToast({\n          title: '取消成功',\n          icon: 'success',\n          mask: true\n        });\n      }else{\n        // 没有收藏过 添加\n        collect.push(this.EssaysInfo);\n        isCollect=true;\n        // 弹窗提示\n        wx.showToast({\n          title: '收藏成功',\n          icon: 'success',\n          mask: true\n          \n        });\n      }\n      // 4 把数组存入到缓存中\n      wx.setStorageSync(\"collect\",collect);\n      // 5 修改data中的属性 isCollect\n      this.setData({\n        isCollect\n      })\n    },\n```\n\n\n\n**然后在收藏夹界面：**\n\n#### wxml\n\n```html\n<view>\n    <navigator class=\"essays_item\"\n                wx:for=\"{{collect}}\"\n                wx:key=\"essay_id\"\n                url=\"/pages/essays_detail/index?essay_id={{item.dessay_id}}\">\n                    <!-- 左侧图片 -->\n                    <view class=\"essays_img_wrap\">\n                        <image mode=\"widthFix\" src=\"{{item.dessay_img}}\"/>\n                    </view>\n                    <!-- 右侧标题 -->\n                    <view class=\"essays_info_wrap\">\n                        <view class=\"essays_title\">{{item.dessay_title}}</view>\n                        <view class=\"essays_src\">{{item.dessay_src}}</view>\n                    </view>\n    </navigator>\n</view>\n```\n\n#### wxss\n\n```css\n/* pages/like/index.wxss */\npage {\n  background-color: #f3f4f6;\n}\n.essays_item {\n  display: flex;\n  border-bottom: 1px solid #ccc;\n}\n.essays_item .essays_img_wrap {\n  width: 70%;\n  flex: 2;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 300rpx;\n}\n.essays_item .essays_img_wrap image {\n  width: 70%;\n}\n.essays_item .essays_info_wrap {\n  flex: 3;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-around;\n}\n.essays_item .essays_info_wrap .essays_title {\n  font-family: cursive;\n  font-size: 45rpx;\n  font-weight: bold;\n  color: #000;\n}\n.essays_item .essays_info_wrap .essays_src {\n  color: #dedede;\n}\n\n```\n\n#### js\n\n```js\n// pages/like/index.js\nPage({\n\n    /**\n     * 页面的初始数据\n     */\n    data: {\n        collect:[]\n    },\n    onShow(){\n        const collect= wx.getStorageSync(\"collect\")||[];\n        this.setData({\n            collect\n        });\n    }\n    \n})\n```\n\n图标还需要引入一下\n\n#### app.wxss\n\n```css\n@import \"./styles/iconfont.wxss\";\n```\n\n#### iconfont.wxss\n\n```css\n@font-face {\n  font-family: \"iconfont\"; /* Project id 3280754 */\n  src: url('//at.alicdn.com/t/font_3280754_152au8amv0n.woff2?t=1650717301641') format('woff2'),\n       url('//at.alicdn.com/t/font_3280754_152au8amv0n.woff?t=1650717301641') format('woff'),\n       url('//at.alicdn.com/t/font_3280754_152au8amv0n.ttf?t=1650717301641') format('truetype');\n}\n\n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.icon-shoucang:before {\n  content: \"\\e8b9\";\n}\n\n.icon-shoucang1:before {\n  content: \"\\e8c6\";\n}\n\n```\n\n\n\n## 11.循环渲染板块\n\n![image.png](https://s2.loli.net/2022/10/01/L6uwpDFSWq2fZHy.png)\n\n\n\n```html\n<view class=\"box1\" wx:for=\"{{achievement}}\"  wx:key=\"item\">\n        <view class=\"success_img_wrap\">\n        <image mode=\"widthFix\" src=\"{{item.img}}\"/>\n        </view>\n        <view class=\"success_info_wrap\" >\n            <view class=\"success_title\">\n                 {{item.title}}\n            </view>\n        </view>\n    </view>\n```\n\n\n\n```css\n.box1 {\n    display: flex;\n    border-bottom: 1px solid #ccc;\n}\n\n.success_img_wrap {\n    width: 60%;\n    flex: 2;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 250rpx;\n}\n\n.success_img_wrap image {\n    width: 50%;\n}\n\n.success_info_wrap {\n    flex: 3;\n    display: flex;\n    flex-direction: column;\n    justify-content: space-around;\n}\n\n.success_title {\n    font-family: cursive;\n    font-size: 40rpx;\n    font-weight: bold;\n    color: #000;\n}\n```\n\n\n\n## 地图相关\n\n###  获取中心点坐标\n\n```javascript\n//监听拖动地图，拖动结束根据中心点更新页面\n\n mapChange: function (e) {\n  let self = this;\n  if (e.type == 'end' && (e.causedBy == 'scale' || e.causedBy == 'drag')){\n\tself.mapCtx.getCenterLocation({\n\tsuccess: function (res) {\n\tself.setData({\n\tnearList:[]，\n    latitude: res.latitude,\n\tlongitude: res.longitude,\n\t})\n\tself.nearby_search();\n\t}\n  })\n }\n```\n\n \n\n### 微信小程序——打开地图 选择位置 完整功能实现代码(定位，检索周边，可移动选点，可搜索，腾讯地图API)\n\n源码：\n\nCSDN: [微信小程序——打开地图选择位置信息完整功能实现代码(定位，可移动选点，可搜索，腾讯地图API)_微信小程序打开地图标点收藏-HTML5代码类资源-CSDN下载](https://download.csdn.net/download/yu17310133443/11085028)\n\ngithub: https://github.com/mcky1928/map\n\n**效果：**\n\n<img src=\"https://img-blog.csdnimg.cn/20190403105619349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1MTczMTAxMzM0NDM=,size_16,color_FFFFFF,t_70\" alt=\"img\" style=\"zoom:80%;\" />\n\n#### wxml\n\n```html\n<!--pages/shopMap/shopMap.wxml-->\n<!--绑定点击事件-->\n<!--绑定输入事件-->\n<view wx:if=\"{{addListShow}}\">\n<view class=\"top\">\n  <view class=\"back iconfont icon-fanhui\" bindtap=\"back1\"></view>\n  <view class=\"search-box {{addListShow?'search-box1':''}}\">\n    <view class=\"region\" bindtap=\"chooseCity\">{{currentRegion.district}}</view>\n    <view class=\"shu\"></view>\n    <input bindinput=\"getsuggest\" placeholder=\"请输入您的店铺地址\"></input>\n  </view>\n</view>\n<!--关键词输入提示列表渲染-->\n<view class=\"add-list-box\">\n<scroll-view class=\"add-list\" scroll-y>\n  <view class=\"add-item\" wx:for=\"{{suggestion}}\" wx:key=\"index\">\n    <!--绑定回填事件-->\n    <view bindtap=\"backfill\" id=\"{{index}}\" data-name=\"{{item.title}}\">\n      <!--根据需求渲染相应数据-->\n      <!--渲染地址title-->\n      <view class=\"title\">{{item.title}}</view>\n      <!--渲染详细地址-->\n      <view class=\"add\">{{item.addr}}</view>\n    </view>\n  </view>\n</scroll-view>\n</view>\n</view>\n \n \n<view wx:if=\"{{!addListShow && !chooseCity}}\">\n<!--地图容器-->\n<map id=\"myMap\"\n   style=\"width:100%;height:300px;\"\n   longitude=\"{{longitude}}\"\n   latitude=\"{{latitude}}\" scale=\"17\" bindregionchange=\"mapChange\">\n   <cover-view class=\"top\">\n      <cover-view class=\"back\" bindtap=\"back1\">\n        <cover-image src=\"../../images/back.png\"></cover-image>\n      </cover-view>\n      <cover-view class=\"search-box\">\n        <cover-view class=\"region\" bindtap=\"chooseCity\">{{currentRegion.district}}</cover-view>\n        <cover-view class=\"shu\"></cover-view>\n        <cover-view class=\"placeholder\" bindtap=\"showAddList\">请输入您的店铺地址</cover-view>\n      </cover-view>\n   </cover-view>\n   <cover-view class=\"map-prompt\">您可拖动地图, 标记店铺准确位置</cover-view>\n   <cover-image class=\"current-site-icon\" src=\"../../images/my_marker.png\"></cover-image>\n   <cover-view class=\"reload\" bindtap=\"reload\">\n      <cover-view class=\"center1\">\n        <cover-view class=\"center2\"></cover-view>\n      </cover-view>\n   </cover-view>\n</map>\n \n<scroll-view class=\"near-list\" scroll-y>\n  <!--绑定回填事件-->\n  <view class=\"near-item\" wx:for=\"{{nearList}}\" wx:key=\"index\">\n    <view class=\"current-site iconfont icon-location\" wx:if=\"{{index == selectedId }}\"></view>\n    <!--根据需求渲染相应数据-->\n    <view bindtap=\"chooseCenter\" id=\"{{index}}\" data-name=\"{{item.title}}\">\n      <!--渲染地址title-->\n      <view class=\"title {{ index == selectedId?'title1':'' }}\">{{item.title}}</view>\n      <!--渲染详细地址-->\n      <view class=\"add {{ index == selectedId?'add1':'' }}\">{{item.addr}}</view>\n    </view>\n  </view>\n</scroll-view>\n<view class=\"bottom-box\">\n  <button bindtap=\"selectedOk\">确认地址</button>\n</view>\n</view>\n \n<view class=\"region-box\" wx:if=\"{{chooseCity}}\">\n  <view class=\"region-top\">\n    <view class=\"region-back iconfont icon-fanhui\" bindtap=\"back2\"></view>\n    <view class=\"title\">选择城市</view>\n  </view>\n  <view class=\"region-tabs\">\n    <text class=\"tab\" bindtap=\"showProvince\">{{currentProvince}}</text>\n    <text class=\"tab\" bindtap=\"showCity\" wx:if=\"{{!regionShow.province}}\" bindtap=\"showCity\">{{currentCity}}</text>\n    <text class=\"tab\" bindtap=\"showDistrict\" wx:if=\"{{regionShow.district}}\" bindtap=\"showDistrict\">{{currentDistrict}}</text>\n  </view>\n  <scroll-view scroll-y style=\"height:1050rpx;\">\n    <view class=\"region-list\" wx:if=\"{{regionShow.province}}\">\n      <view class=\"region-item\" wx:for=\"{{regionData.province}}\" wx:key=\"index\">\n        <view data-id=\"{{item.id}}\" data-name=\"{{item.fullname}}\" bindtap=\"selectProvince\">\n          <text>{{item.fullname}}</text>\n        </view>\n      </view>\n    </view>\n    <view class=\"region-list\" wx:if=\"{{regionShow.city}}\">\n      <view class=\"region-item\" wx:for=\"{{regionData.city}}\" wx:key=\"index\">\n        <view data-id=\"{{item.id}}\" data-name=\"{{item.fullname}}\" bindtap=\"selectCity\">\n          <text>{{item.fullname}}</text>\n        </view>\n      </view>\n    </view>\n    <view class=\"region-list\" wx:if=\"{{regionShow.district}}\">\n      <view class=\"region-item\" wx:for=\"{{regionData.district}}\" wx:key=\"index\">\n        <view data-id=\"{{item.id}}\" data-name=\"{{item.fullname}}\" data-latitude=\"{{item.location.lat}}\" data-longitude=\"{{item.location.lng}}\" bindtap=\"selectDistrict\">\n          <text>{{item.fullname}}</text>\n        </view>\n      </view>\n    </view>\n  </scroll-view>\n</view>\n```\n\n#### wxss\n\n```css\n/* pages/shopMap/shopMap.wxss */\n@import \"../../lib/css/iconfont.wxss\";\n \n.top {\n  width: 100%;\n  height: 80rpx;\n  line-height: 80rpx;\n  position: fixed;\n  top: 0;\n  left: 0;\n  padding: 30rpx 20rpx;\n  z-index: 999;\n  overflow: hidden;\n}\n.back {\n  width: 80rpx;\n  height: 80rpx;\n  line-height: 80rpx;\n  color: #666;\n  text-align: center;\n  background: rgb(255,255,255);\n  font-size: 50rpx;\n  border-radius: 50%;\n  float: left;\n}\n.back cover-image{\n  width: 50rpx;\n  height: 50rpx;\n  display: inline-block;\n  margin-top: 15rpx;\n}\n.search-box {\n  width: 610rpx;\n  height: 80rpx;\n  line-height: 80rpx;\n  border-radius: 40rpx;\n  background: rgb(255,255,255);\n  margin-left: 20rpx;\n  float: left;\n  overflow: hidden;\n}\n.search-box1 {\n  border: 1px solid #ccc;\n  border-radius: 10rpx;\n  background: #eee;\n}\n.search-box .region {\n  width: 199rpx;\n  line-height: 80rpx;\n  font-size: 30rpx;\n  color: #282828;\n  text-align: center;\n  float: left;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.search-box .shu {\n  width: 1rpx;\n  height: 80rpx;\n  background:#ccc;\n  float: left;\n}\n.search-box input {\n  width: 380rpx;\n  height: 80rpx;\n  line-height: 80rpx;\n  font-size: 30rpx;\n  color: #282828;\n  padding: 10rpx 20rpx;\n  box-sizing: border-box;\n  float: left;\n}\n.search-box .placeholder{\n  width: 380rpx;\n  height: 80rpx;\n  line-height: 80rpx;\n  font-size: 30rpx;\n  color: #ccc;\n  padding: 0 20rpx;\n  box-sizing: border-box;\n  float: left;\n}\n.add-list-box {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  z-index: 998;\n  padding-top: 150rpx;\n  background: #fff;\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.add-list {\n  width: 100%;\n  height: 1000rpx;\n}\n.add-item {\n  line-height: 40rpx;\n  padding: 30rpx 50rpx;\n  text-align: left;\n  border-top: 1px solid #eee;\n}\n.add-item .title {\n  color: #282828;\n  font-size: 32rpx;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.add-item .add {\n  color: #707070;\n  font-size: 24rpx;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.current-site-icon {\n  width: 50rpx;\n  height: 50rpx;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%,-50%);\n}\n.near-list {\n  height: 650rpx;\n  padding-bottom: 100rpx;\n  box-sizing: border-box;\n}\n.near-item {\n  line-height: 40rpx;\n  padding: 30rpx 50rpx 30rpx 90rpx;\n  text-align: left;\n  border-bottom: 1px solid #eee;\n  position: relative;\n}\n.current-site {\n  font-size: 40rpx;\n  color: #3095F9;\n  position: absolute;\n  top: 40rpx;\n  left: 30rpx;\n}\n.near-item .title {\n  color: #282828;\n  font-size: 32rpx;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.near-item .add {\n  color: #707070;\n  font-size: 24rpx;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.near-item .title1 {\n  color: #3095F9;\n}\n.near-item .add1 {\n  color: #3095F9;\n}\n.bottom-box {\n  width: 100%;\n  padding: 20rpx;\n  background: #fff;\n  box-sizing: border-box;\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  z-index: 88;\n  overflow: hidden;\n}\n.bottom-box button{\n  width: 100%;\n  height: 80rpx;\n  line-height: 80rpx;\n  border: none;\n  background: #3095F9;\n  color: #fff;\n  font-size: 36rpx;\n}\n \n.region-box {\n  width: 100%;\n  height: 100%;\n  background: #FFF;\n  position: fixed;\n  top: 0;\n  left: 0;\n  z-index: 1001;\n}\n.region-box .region-top {\n  position: relative;\n  font-size: 40rpx;\n  color: #282828;\n  font-weight: bold;\n  line-height: 100rpx;\n  text-align: center;\n}\n.region-box .region-back {\n  width: 80rpx;\n  height: 80rpx;\n  font-size: 50rpx;\n  text-align: center;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n.region-box .region-tabs{\n  line-height: 60rpx;\n  font-size: 20rpx;\n}\n.region-tabs .tab {\n  min-width: 100rpx;\n  max-width: 200rpx;\n  line-height: 40rpx;\n  font-size: 20rpx;\n  color: #3095F9;\n  text-align: center;\n  border: 1rpx solid #3095F9;\n  border-radius: 20rpx;\n  display: inline-block;\n  margin: 20rpx 0 20rpx 20rpx;\n  padding: 3rpx 20rpx;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.region-list .region-item{\n  font-size: 30rpx;\n  color: #282828;\n  line-height: 80rpx;\n  padding: 10rpx 30rpx;\n  border-top: 1rpx solid #eee;\n}\n \n.map-prompt {\n  width: 420rpx;\n  height: 60rpx;\n  line-height: 60rpx;\n  font-size: 24rpx;\n  color: #707070;\n  text-align: center;\n  background: #fff;\n  border-radius: 10rpx;\n  box-shadow: 0 0 10rpx rgba(0,0,0,0.1);\n  position: absolute;\n  bottom: 40rpx;\n  left: 50%;\n  transform: translate(-50%,0);\n}\n.reload {\n  width: 80rpx;\n  height: 80rpx;\n  background: #fff;\n  border-radius: 50%;\n  box-shadow: 0 0 10rpx rgba(0,0,0,0.1);\n  position: absolute;\n  bottom: 30rpx;\n  right: 30rpx;\n}\n.reload .center1 {\n  width: 30rpx;\n  height: 30rpx;\n  border: 1rpx solid #3095F9;\n  border-radius: 50%;\n  margin: 24rpx auto;\n}\n.reload .center2 {\n  width: 25rpx;\n  height: 25rpx;\n  background: #3095F9;\n  border-radius: 50%;\n  margin: 3rpx auto;\n}\n```\n\n#### js\n\n```js\nvar QQMapWX = require('../../utils/qqmap-wx-jssdk1.2/qqmap-wx-jssdk.min.js');\nvar qqmapsdk;\nPage({\n  data: {\n    addListShow: false,\n    chooseCity: false,\n    regionShow: {\n      province: false,\n      city: false,\n      district: true\n    },\n    regionData: {}, \n    currentRegion: {\n      province: '选择城市',\n      city: '选择城市',\n      district: '选择城市',\n    },\n    currentProvince: '选择城市',\n    currentCity: '选择城市',\n    currentDistrict: '选择城市',\n    latitude: '',\n    longitude: '',\n    centerData: {},\n    nearList: [],\n    suggestion: [],\n    selectedId: 0,\n    defaultKeyword: '房产小区',\n    keyword: ''\n  },\n  onLoad: function () {\n    let self =this;\n    self.mapCtx = wx.createMapContext('myMap')\n    // 实例化API核心类\n    qqmapsdk = new QQMapWX({\n      key: 'W57BZ-JDB6X-XPA4H-Z76MI-73FF2-24BT4'\n    });\n    wx.showLoading({\n      title: '加载中'\n    });\n    //定位\n    wx.getLocation({\n      type: 'wgs84',\n      success(res) {\n        //console.log(res)\n        const latitude = res.latitude\n        const longitude = res.longitude\n        const speed = res.speed\n        const accuracy = res.accuracy\n        //你地址解析\n        qqmapsdk.reverseGeocoder({\n          location: {\n            latitude: latitude,\n            longitude: longitude\n          },\n          success: function (res) {\n            //console.log(res)\n            self.setData({\n              latitude: latitude,\n              longitude: longitude,\n              currentRegion: res.result.address_component,\n              keyword: self.data.defaultKeyword\n            })\n            // 调用接口\n            self.nearby_search();\n          },\n        });\n      },\n      fail(err) {\n        //console.log(err)\n        wx.hideLoading({});\n        wx.showToast({\n          title: '定位失败',\n          icon: 'none',\n          duration: 1500\n        })\n        setTimeout(function () {\n          wx.navigateBack({\n            delta: 1\n          })\n        }, 1500)\n      }\n    })\n  },\n  onReady: function () {\n    \n  },\n  //监听拖动地图，拖动结束根据中心点更新页面\n  mapChange: function (e) {\n    let self = this;\n    if (e.type == 'end' && (e.causedBy == 'scale' || e.causedBy == 'drag')){\n      self.mapCtx.getCenterLocation({\n        success: function (res) {\n          //console.log(res)\n          self.setData({\n            nearList:[],\n            latitude: res.latitude,\n            longitude: res.longitude,\n          })\n          self.nearby_search();\n        }\n      })\n    }\n    \n  },\n  //重新定位\n  reload: function () {\n    this.onLoad();\n  },\n  //整理目前选择省市区的省市区列表\n  getRegionData: function () {\n    let self = this;\n    //调用获取城市列表接口\n    qqmapsdk.getCityList({\n      success: function (res) {//成功后的回调\n        //console.log(res)\n        let provinceArr = res.result[0];\n        let cityArr = [];\n        let districtArr = [];\n        for (var i = 0; i < provinceArr.length; i++) {\n          var name = provinceArr[i].fullname;\n          if (self.data.currentRegion.province == name) {\n            if (name == '北京市' || name == '天津市' || name == '上海市' || name == '重庆市') {\n              cityArr.push(provinceArr[i])\n            } else {\n              qqmapsdk.getDistrictByCityId({\n                // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推\n                id: provinceArr[i].id,\n                success: function (res) {//成功后的回调\n                  //console.log(res);\n                  cityArr = res.result[0];\n                  self.setData({\n                    regionData: {\n                      province: provinceArr,\n                      city: cityArr,\n                      district: districtArr\n                    }\n                  })\n                },\n                fail: function (error) {\n                  //console.error(error);\n                },\n                complete: function (res) {\n                  //console.log(res);\n                }\n              });\n            }\n          }\n        }\n        for (var i = 0; i < res.result[1].length; i++) {\n          var name = res.result[1][i].fullname;\n          if (self.data.currentRegion.city == name) {\n            qqmapsdk.getDistrictByCityId({\n              // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推\n              id: res.result[1][i].id,\n              success: function (res) {//成功后的回调\n                //console.log(res);\n                districtArr = res.result[0];\n                self.setData({\n                  regionData: {\n                    province: provinceArr,\n                    city: cityArr,\n                    district: districtArr\n                  }\n                })\n              },\n              fail: function (error) {\n                //console.error(error);\n              },\n              complete: function (res) {\n                //console.log(res);\n              }\n            });\n          }\n        }\n      },\n      fail: function (error) {\n        //console.error(error);\n      },\n      complete: function (res) {\n        //console.log(res);\n      }\n    });\n  },\n  onShow: function () {\n    let self = this;\n  },\n  //地图标记点\n  addMarker: function (data) {\n    //console.log(data)\n    //console.log(data.title)\n    var mks = [];\n    mks.push({ // 获取返回结果，放到mks数组中\n      title: data.title,\n      id: data.id, \n      addr: data.addr,\n      province: data.province,\n      city: data.city,\n      district: data.district,\n      latitude: data.latitude,\n      longitude: data.longitude,\n      iconPath: \"/images/my_marker.png\", //图标路径\n      width: 25,\n      height: 25\n    })\n    this.setData({ //设置markers属性，将搜索结果显示在地图中\n      markers: mks,\n      currentRegion: {\n        province: data.province,\n        city: data.city,\n        district: data.district,\n      }\n    })\n    wx.hideLoading({});\n  },\n  //点击选择搜索结果\n  backfill: function (e) {\n    var id = e.currentTarget.id;\n    let name = e.currentTarget.dataset.name;\n    for (var i = 0; i < this.data.suggestion.length; i++) {\n      if (i == id) {\n        //console.log(this.data.suggestion[i])\n        this.setData({\n          centerData: this.data.suggestion[i],\n          addListShow: false,\n          latitude: this.data.suggestion[i].latitude,\n          longitude: this.data.suggestion[i].longitude\n        }); \n        this.nearby_search();\n        return;\n        //console.log(this.data.centerData)\n      }\n    }\n  },\n  //点击选择地图下方列表某项\n  chooseCenter: function (e) {\n    var id = e.currentTarget.id;\n    let name = e.currentTarget.dataset.name;\n    for (var i = 0; i < this.data.nearList.length; i++) {\n      if (i == id) {\n        this.setData({\n          selectedId: id,\n          centerData: this.data.nearList[i],\n          latitude: this.data.nearList[i].latitude,\n          longitude: this.data.nearList[i].longitude,\n        });\n        this.addMarker(this.data.nearList[id]);\n        return;\n        //console.log(this.data.centerData)\n      }\n    }\n  },\n  //显示搜索列表\n  showAddList: function () {\n    this.setData({\n      addListShow: true\n    })\n  },\n  // 根据关键词搜索附近位置\n  nearby_search: function () {\n    var self = this;\n    wx.hideLoading();\n    wx.showLoading({\n      title: '加载中'\n    });\n    // 调用接口\n    qqmapsdk.search({\n      keyword: self.data.keyword,  //搜索关键词\n      //boundary: 'nearby(' + self.data.latitude + ', ' + self.data.longitude + ', 1000, 16)',\n      location: self.data.latitude + ',' + self.data.longitude,\n      page_size: 20,\n      page_index: 1,\n      success: function (res) { //搜索成功后的回调\n        //console.log(res.data)\n        var sug = [];\n        for (var i = 0; i < res.data.length; i++) {\n          sug.push({ // 获取返回结果，放到sug数组中\n            title: res.data[i].title,\n            id: res.data[i].id,\n            addr: res.data[i].address,\n            province: res.data[i].ad_info.province,\n            city: res.data[i].ad_info.city,\n            district: res.data[i].ad_info.district,\n            latitude: res.data[i].location.lat,\n            longitude: res.data[i].location.lng\n          });\n        }\n        self.setData({\n          selectedId: 0,\n          centerData: sug[0],\n          nearList: sug, \n          suggestion: sug\n        })\n        self.addMarker(sug[0]);\n      },\n      fail: function (res) {\n        //console.log(res);\n      },\n      complete: function (res) {\n        //console.log(res);\n      }\n    });\n  },\n  //根据关键词搜索匹配位置\n  getsuggest: function (e) {\n    var _this = this;\n    var keyword = e.detail.value;\n    _this.setData({\n      addListShow: true\n    })\n    //调用关键词提示接口\n    qqmapsdk.getSuggestion({\n      //获取输入框值并设置keyword参数\n      keyword: keyword, //用户输入的关键词，可设置固定值,如keyword:'KFC'\n      location: _this.data.latitude + ',' + _this.data.longitude,\n      page_size: 20,\n      page_index: 1,\n      //region:'北京', //设置城市名，限制关键词所示的地域范围，非必填参数\n      success: function (res) {//搜索成功后的回调\n        //console.log(res);\n        var sug = [];\n        for (var i = 0; i < res.data.length; i++) {\n          sug.push({ // 获取返回结果，放到sug数组中\n            title: res.data[i].title,\n            id: res.data[i].id,\n            addr: res.data[i].address,\n            province: res.data[i].province,\n            city: res.data[i].city,\n            district: res.data[i].district,\n            latitude: res.data[i].location.lat,\n            longitude: res.data[i].location.lng\n          });\n        }\n        _this.setData({ //设置suggestion属性，将关键词搜索结果以列表形式展示\n          suggestion: sug,\n          nearList: sug,\n          keyword: keyword\n        });\n      },\n      fail: function (error) {\n        //console.error(error);\n      },\n      complete: function (res) {\n        //console.log(res);\n      }\n    });\n  },\n  //打开选择省市区页面\n  chooseCity: function () {\n    let self = this;\n    self.getRegionData();\n    self.setData({\n      chooseCity: true,\n      regionShow: {\n        province: false,\n        city: false,\n        district: true\n      },\n      currentProvince: self.data.currentRegion.province,\n      currentCity: self.data.currentRegion.city,\n      currentDistrict: self.data.currentRegion.district,\n    })\n  },\n  //选择省\n  showProvince: function () {\n    this.setData({\n      regionShow: {\n        province: true,\n        city: false,\n        district: false\n      }\n    })\n  },\n  //选择城市\n  showCity: function () {\n    this.setData({\n      regionShow: {\n        province: false,\n        city: true,\n        district: false\n      }\n    })\n  },\n  //选择地区\n  showDistrict: function () {\n    this.setData({\n      regionShow: {\n        province: false,\n        city: false,\n        district: true\n      }\n    })\n  },\n  //选择省之后操作\n  selectProvince: function (e) {\n    //console.log(e)\n    let self = this;\n    let id = e.currentTarget.dataset.id;\n    let name = e.currentTarget.dataset.name;\n    self.setData({\n      currentProvince: name,\n      currentCity: '请选择城市',\n    })\n    if (name == '北京市' || name == '天津市' || name == '上海市' || name == '重庆市'){\n      var provinceArr = self.data.regionData.province;\n      var cityArr = [];\n      for (var i = 0; i < provinceArr.length;i++){\n        if(provinceArr[i].fullname == name){\n          cityArr.push(provinceArr[i])\n          self.setData({\n            regionData: {\n              province: self.data.regionData.province,\n              city: cityArr,\n              district: self.data.regionData.district\n            }\n          })\n          self.showCity();\n          return;\n        }\n      }\n    }else{\n      let bj = self.data.regionShow;\n      self.getById(id, name, bj)\n    }\n  },\n  //选择城市之后操作\n  selectCity: function (e) {\n    let self = this;\n    let id = e.currentTarget.dataset.id;\n    let name = e.currentTarget.dataset.name;\n    self.setData({\n      currentCity: name,\n      currentDistrict: '请选择城市',\n    })\n    let bj = self.data.regionShow;\n    self.getById(id, name, bj)\n  },\n  //选择区县之后操作\n  selectDistrict: function (e) {\n    let self = this;\n    let id = e.currentTarget.dataset.id;\n    let name = e.currentTarget.dataset.name;\n    let latitude = e.currentTarget.dataset.latitude;\n    let longitude = e.currentTarget.dataset.longitude;\n    self.setData({\n      currentDistrict: name,\n      latitude: latitude,\n      longitude: longitude,\n      currentRegion: {\n        province: self.data.currentProvince,\n        city: self.data.currentCity,\n        district: name\n      }, \n      chooseCity: false,\n      keyword: self.data.defaultKeyword\n    })\n    self.nearby_search();\n  },\n  //根据选择省市加载市区列表\n  getById: function (id,name,bj) {\n    let self = this;\n    qqmapsdk.getDistrictByCityId({\n      // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推\n      id: id, //对应接口getCityList返回数据的Id，如：北京是'110000'\n      success: function (res) {//成功后的回调\n        //console.log(res);\n        if(bj.province){\n          self.setData({\n            regionData: {\n              province: self.data.regionData.province,\n              city: res.result[0],\n              district: self.data.regionData.district\n            }\n          })\n          self.showCity();\n        } else if (bj.city) {\n          self.setData({\n            regionData: {\n              province: self.data.regionData.province,\n              city: self.data.regionData.city,\n              district: res.result[0]\n            }\n          })\n          self.showDistrict();\n        } else {\n          self.setData({\n            chooseCity: false,\n          })\n        }\n      },\n      fail: function (error) {\n        //console.error(error);\n      },\n      complete: function (res) {\n        //console.log(res);\n      }\n    });\n  },\n  //返回上一页或关闭搜索页面\n  back1: function () {\n    if (this.data.addListShow) {\n      this.setData({\n        addListShow: false\n      })\n    }else {\n      wx.navigateBack({\n        delta: 1\n      })\n    }\n  },\n  //关闭选择省市区页面\n  back2: function () {\n    this.setData({\n      chooseCity: false\n    })\n  },\n  //确认选择地址\n  selectedOk: function () {\n    let pages = getCurrentPages(); //获取当前页面js里面的pages里的所有信息。\n    let prevPage = pages[pages.length - 2]; \n    //console.log(this.data.centerData)\n    prevPage.setData({\n      storeAddress: this.data.centerData.title\n    })\n    wx.navigateBack({\n      delta: 1\n    })\n  }\n})\n```\n\n\n\n引用的阿里图标 iconfont.wxss \n\n```css\n@font-face {font-family: \"iconfont\";\n  src: url('//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999'); /* IE9 */\n  src: url('//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAgQAAsAAAAADnAAAAfAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCEIAqOMIwEATYCJAMoCxYABCAFhG0HgRsbZQxRlG9SkOzjMG74SoiyxOJKUQ6m+GaJv3j4fr//rb3Puf7FEE2iUTWqZhKe6QwJGo1EowRIJKYTkmfym3/ctJ8wScURvVFxQm2q0AnUsDdqSBIoEnSiYcrKRJQyE0dmdpyI9Ofv92oXzfKu7buc91//yqZV86fheECRDT6QAB0gzH3LdJLMDLxi+q3XExhtJwJdlIxTAERFeQEpT8yEDiA+uZrSGnpRG3NsFe9Bo8+38D0AvDM/H/9AZSCkpqAHXXs8ygiG/hRvpFGdFFUCiPq0uG5EwQFAvQo/xUo+AuDHu51mzK5eAdakI1vxN0iJp8Wz4py4MD4mfjf+qLOTmNFp8bDG9EAZ67+8Kg06rYZoIX8OKl8HBn4CMULhZ8oIPT/TRgh+Zo1Q+ckZIfkpxOsQjAGpDgRqkGpB0Aj4vtAzqmPWAPuBPAqUbajwksmvUtgK2i/nCnlmmenJyRnJKXwkgcNBUhGELiVJqQ6cXSlIMsI/LqELKyMlRRfk4geiUCymjkSUVFhkXItj0KoAi4hB0agqHFZQOkMkHRQOj78WFm6LjLoZy90etVyxCO+qXYEO1u/e0ajmRjRnR0x6PZK9NWwg8PUXe2GrKLrxxIGp26OVXCJVJeb2ssOUklNECiXdrbyjMdxlFfGMRub71Mq1FEcL5dES+gZsFa9sDYs1gDVWSaUKrOWxKG4rBHR6lgcnrT9TAF2PoAqIy1ULOAI2n61i8ZT7wiOhjrM8pbLFKOhmbATEo1gydithAOr5Cn7DBxyISlQgb2ReNX0cXUQfptfoi5Upu4jFslivLqRmoMWy/PzRjFEQYEpWM5ljBjOVTqxm0LJ8a2l7YkGQ5tzq1y1m5DMYvPYzR3ZcvGnH7NpP7TulmWKsKwepVbweuT24OWKuOkLZVc141Ud8CubgC1hK+j4KZYwPRlXp9oUTQf7o1kQoKRArS9GFw6pAlmpfuBkEIuiM+5TMA9HENH9EydBfD35B5a7HazFjHUEs25M69vr2tIeo3cqkLokTV7fTjarVQTp95VqGchVjtbVrfMRiRYXamfhqn29AYDdFN6wsUUn3BjI0UCPZPcXOsZLqHOz4CJnnczRi2qKr51fQGCiw7yFmq+fDbR+FyyETyEVyIXOppB6efqBjFoyAgBn1PZ0yiCAg2SojcAZC3M0gZJLHtXV8gRjw6FJdnYCfATo7rblkCXxaRzvxW8X6aYs/WzxNg2OBtbA1KtI6rba6umtXIaw17wEGjyrvLx21fWyR3UIwCLNlayoYCFHdudbDSwfqr5BuGp2DBseytA/2Ablhl8MNg8v5DnOtxz7YaKfb+jfJRah0SYMSfnzS1uRJNp7+zAPGYGWwKR1UVOb7pyV++93DQzJ061b//AkP69eu2LZMte0enJH38yulMbh6Zf3OHUdc1CztT78iX+1pP/cptEybqSjf3dcC99HL0MdkRtmylTJRc0W/lt2K8kztstCnlt4ytHj4fHkNrNU395oJddSPKOaVVOlDclHf4E0zPydz1PvkRzXwfHnxcBn6prmXPuu2tvzlhHOV0zqjveWi/k2n2yqDvTn45o+maGwQQIc2c/CtnoF8yrwv/QzEsqP8D1JLEdtWzFp/acT8BW98cnTKxTf/rhnZrNVVw2i0HMesIzt21q9cHTQqR/z0USZSga+6/3J5heAH5ck1k/e6GwOVgVDaOK0SXtKASls89/8v5KIfvp3TPXFXj+VytEoXNUZbe5eM23eCU8YVl+SralR+BLaodg7THLQe1LTRJvKBctEy6zLf04u6/gPJ8WCFunQ0d1/i7MQ+Tb0fSh1Ds69ep6m1a4d6oaG55EBd/4utvUtHr1Br49KHTb37vLXadZp6pYJh8yV6M3kbgWvT1qVnrsvIzMgwmeD3kulwqAOewbSh0HQNZ9yN63gaTJ+Yd3r/gXuUe5Xgj/K1XCX4abQb7VPmBdODJguxPzMHrOOuy85ewAGLZ6amfc9Zm3MXRc/lnJPsXdznHri6wc/yv3s3kQ1Yb/SWk1jIJLZ/82Y/K4NFLgBmfgWYXS5NtCEA5ZTFrDNf0boZyaUCeFxHfoPvbk2V3EIBlMwTRP8Zfu43PoFtx5HtfNhPZbSkDfzfJ/23rPhxp/+3xj6jKiiv72WSIThqEDmn1Q9F2fG7YAIv1TPGS8CXphvGlnGsMK94U7dwXW7i8CRc56LU2YaK3o7SWnkANSYHUat3Bo32k548WeVCE3XAPnMJCksOorTgCyqW3AcAqHyNGut9h1pLQUOjO5F1zsmuMCeOcGE6D2YU6icLzQbSjnOVJ9FKrccIr1Xn8lKmU4W53GaXsEJcHgxJMTvmquMA9wSi0uPBhbiLtAkl5GaY1UoKHS6yDTN4xCaPx9G/rAyPO1BsIG0g0QUuGB2PGmwkpDeZ08yAZIcX90gMfX89DMHLSseVMuqbUwXj4mZeu1AFsfIcpVK+Pdeofcl2m4BQyYNanFB4XUg2Wyg5aTFW5icJOeK3aoMx8BAzlfA69FeGs+F5+eL2hbatTf0TjUFvO0ZGiRpNtNFFH0OMMdm4ButMMZmneEm9WUfat/XaK3ojVtKg85hJe3ejbrLXpCOT2hKNHi8SVlZ0Px+LTDFhdsLpxbrhOrvJa94ErOuiQwEAAAAA') format('woff2'),\n  url('//at.alicdn.com/t/font_1120834_hvoztl864h6.woff?t=1554258412999') format('woff'),\n  url('//at.alicdn.com/t/font_1120834_hvoztl864h6.ttf?t=1554258412999') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */\n  url('//at.alicdn.com/t/font_1120834_hvoztl864h6.svg?t=1554258412999#iconfont') format('svg'); /* iOS 4.1- */\n}\n \n.iconfont {\n  font-family: \"iconfont\" !important;\n  font-size: 16px;\n  font-style: normal;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n \n.icon-iconfontzhizuobiaozhun16:before {\n  content: \"\\e60f\";\n}\n \n.icon-location:before {\n  content: \"\\e619\";\n}\n \n.icon-dayuhao:before {\n  content: \"\\e600\";\n}\n \n.icon-jizuobiaotu:before {\n  content: \"\\e613\";\n}\n \n.icon-dayuhao1:before {\n  content: \"\\e65c\";\n}\n \n.icon-zuobiao:before {\n  content: \"\\e657\";\n}\n \n.icon-zhengque:before {\n  content: \"\\e64a\";\n}\n \n.icon-fanhui:before {\n  content: \"\\e60d\";\n}\n \n.icon-iconfront-:before {\n  content: \"\\e620\";\n}\n```\n\n**用到的图片**\n\nback.png(wxml39行)和my_marker.png(wxml48行)\n\n![img](https://img-blog.csdnimg.cn/2019040311084374.png)  ![img](https://img-blog.csdnimg.cn/20190403110857533.png)\n\n可参考 [WebService API | 腾讯位置服务](https://lbs.qq.com/webservice_v1/guide-appendix.html)\n","tags":["编程语言","小程序"],"categories":["编程"]},{"title":"中华文化酷！小程序","url":"/2022/07/01/中华文化酷！小程序/","content":"\n<br>\n\n自从报名了icode比赛之后的几个月就再也没有理过这个东西了（事情多得有点忙乱，中途还要弄团委项目，当然我这个组长肯定要负主要责任）。还有半个月才和@Fire_egg急忙开工，当时也没想那么多就想着既然参加了就起码得完成吧，意外的是最后还获得三等奖（五月份的事了）。这次的经历出现了一些问题也让我获得除了开发小程序以外的收获。\n\n#### **策略方面**\n\n首先就是一定要提前准备，确定好主题，做好长期的规划安排。其次是多和组员交流开会，带动一下整个团队。队长就是整个团队的核心和关键，需要有较强的内驱力和领导力。最后就是要做好调研调查，进度估计。了解好项目的大致框架和可能涉及到的技术栈。\n\n#### **技术方面**\n\n这个小程序也是相当简易的，涉及到的都是一些简单的程序指令，没有高端的算法之类的，这也是我们不愿在答辩时过多呈现技术方面的原因呵呵（因为师兄师姐的技术都太过硬核了）。\n\n#### **总结**\n\n这次作品主要有两点亮点吧，一是主题，二是UI界面。自从发现时间紧迫，在技术上不会有太大的造诣。于是每晚下工后躺在床上我都在想怎么包装这个作品。页面是参考的某学习app。而主题我们本打算就以传统文化为内容，但是后来我突然想起高中语文写的那么多作文都提到创新的中华文化。于是我就想以此为内容会不会更好，并定下了一个具有双关意味的名字。\n\n当然也存在很多缺陷。一是前端基础不牢，运行时存在很多bug，不进行改进是绝对不能上线的。二是选题问题。答辩时师兄提了很好的问题，他说为什么不能用抖音这些平台来宣传呢？意思就是让我们思考这个软件凭什么让别人来使用你，如果只是单纯传播一些帖子，网上有很多流量更大的平台可以利用。师兄还建议我们可以增加一些相关活动信息的发布，来提升实用性。三当然就是技术的硬核程度了，要多注重技术方面才能拿得出手，这也是我在接下来要重点加强学习的。\n\n最后附上我深夜爆肝的花里胡哨说明文档以及答辩ppt。\n\n\n\n<center style=\"font-size:large;font-weight:bold\">中华文化酷！说明文档</center><center>2022/4/24</center>\n\n{% pdf https://jjuprising.github.io/files/sinocool_docu.pdf  %}\n\n\n\n\n\n<center style=\"font-size:large;font-weight:bold\">中华文化酷！答辩ppt</center></center><center>2022/5/15</center>\n\n{% pdf https://jjuprising.github.io/files/sinocool_ppt.pdf  %}\n\n\n\n<center style=\"font-size:large;font-weight:bold\">中华文化酷！演示视频</center></center><center>2022/5/15</center>\n\n[腾讯视频 (qq.com)](https://v.qq.com/s/videoplus/970568183)\n\n**鸣谢：**Fire_egg [szlx560223 (github.com)](https://github.com/szlx560223)\n\n**源码：**[JJuprising/Cool-Chinese-Culture: 一款传播创新型中华文化的知识类小程序 (github.com)](https://github.com/JJuprising/Cool-Chinese-Culture)\n","tags":["编程语言","项目"],"categories":["编程"]},{"title":"2022web大作业","url":"/2022/07/01/2022web大作业/","content":"\n最初想法是copy spsspro 可惜临近期末时间太赶了，而且发现还有好多前端知识还没学懂弄会，比如变量生存期、请求的顺序、解析后数据的存储形式等。\n\n源代码已经放到仓库了：https://github.com/JJuprising/Web_FinalHomework\n\n**大作业要求：**\n\n![大作业要求](https://s2.loli.net/2022/07/01/iZunWXdOw8Yev2D.png)\n\n\n\n<center style=\"font-size: large;font-weight: bold;\">说明文档</center>\n\n{% pdf https://jjuprising.github.io/files/web_homework.pdf  %}\n\n","tags":["编程语言","项目"],"categories":["本科课程"]},{"title":"线性代数","url":"/2022/07/01/线性代数/","content":"\n![线性代数题型归纳](https://s2.loli.net/2022/07/01/p8Jt37wIWuxTvUV.png)\n\n","tags":["数学"],"categories":["本科课程"]},{"title":"Cpp语言程序设计","url":"/2022/07/01/Cpp语言程序设计/","content":"\n# 第一章 绪论\n\n* 机器语言与汇编语言\n\n  * 由计算机硬件系统可以识别的二进制指令组成的语言称为机器语言。\n\n  * 汇编语言将机器指令映射为一些可以被人读懂的助记符，如ADD、SUB等。\n\n* 高级语言\n\n  * 高级语言屏蔽了机器的细节，提高了语言的抽象层次，程序中可以采用具有一定含义的数据命名和容易理解的执行语句。这使得在书写程序时可以联系到程序所描述的具体事物。\n\n* 面向对象的语言\n\n  * 出发点：更直接地描述客观世界中存在的事物(对象)以及它们之间的关系。\n  * 特点：\n    * 是高级语言。\n    * 将客观事物看作具有属性和行为的对象\n    * 通过抽象找出同一类对象的共同属性和行为，形成类。\n    * 通过类的继承与多态实现代码重用\n  * 优点：使程序能够比较直接地反映问题域的本来面目，软件开发人员能够利用人类认识事物所采用的一般思维方法来进行软件开发。\n\n* 面向对象的方法\n\n  * 将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体——对象。\n  * 对同类型对象抽象出其共性，形成类。\n  * 类通过一个简单的外部接口，与外界发生关系。\n  * 对象与对象之间通过消息进行通信。\n\n* 计算机中的信息\n\n  * 数据信息——计算机程序加工的对象\n  * 控制信息——指挥计算机操作\n\n\n![image-20220530234340268.png](https://s2.loli.net/2022/07/01/hXDCJFp12a3NSRu.png)\n\n* 信息的存储单位\n  * 位(bit，b)：度量数据的最小单位，表示一位二进制信息。\n  * 字节(byte，B)：由八位二进制数字组成(1 byte = 8 bit)。\n    * 千字节  1 KB = 1024 B\n    * 兆字节  1 MB = 1024 K\n    * 吉字节  1 GB = 1024 M \n* 进制转换\n\n\n\n# 第二章 C++简单程序设计\n\n## I/O流\n\n* 在C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被建立，使用后要被删除。\n* 从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。\n* 数据的输入与输出是通过I/O流来实现的，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。\n\n\n\n\n\n# 第三章 函数\n\n**static_cast是一个强制类型转换操作符**\n\n```c++\ndouble a = 1.999;\nint b = static_cast<double>(a); //相当于a = b ;\n```\n\n## 函数的声明的实现\n\n```c++\nvoid func(int);//函数的声明，可以没有形参名，没有大括号\n\nvoid func(int){}//函数的实现必须要有{}，类构造函数用初始化列表容易忘加{}\n```\n\n\n\n## 函数的参数传递\n\n* 在函数被调用时才分配形参的存储单元\n* 实参可以是常量、变量或表达式\n* 实参类型必须与形参相符或可隐式转换为形参类型\n* 值传递传递参数值，即单向传递\n* 引用传递可以实现双向传递\n* 常引用作参数可以保障实参数据的安全\n\n\n\n## 内联函数\n\n* 声明时用关键字 `inline`\n* 规模小、功能简单使用频繁的函数。编译时在调用处嵌入函数体，节省了参数传递、控制转移等开销\n* 注意\n  * 内联函数体内不能有**循环语句**和**switch**语句\n  * 内联函数的定义必须出现在内联函数第一次被调用之前\n  * 对内联函数不能进行异常接口声明\n\n\n\n## 函数高级\n\n### 1.默认参数\n\n- 默认参数，如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值。\n\n- 注意事项：\n\n- - 有默认参数的要放在最后面。`int fun(int a,int b,int d=1){};`\n  - 如果函数声明有默认参数，函数实现就不能有默认参数。因为声明时已经定义过了，两个有就冲突了。声明和实现只能有一个有默认参数\n\n### 2.占位参数\n\n返回值参数 函数名(数据类型){}\n\n- void     func(int a, int);后面的int就是占位参数，只有传两个才能正常执行。\n- 占位参数也能有默认默认参数，这时候就可以不传这个占位参数了。\n\n### 3.函数重载\n\n作用：函数名可以相同，提高复用性\n\n满足条件\n\n- 同一作用域下\n- 函数名称相同\n- 函数**参数类型**不同 或者 **个数**不同 或a **顺序**不同\n- 对返回值没有规定\n\n```c++\nint sumOfSquare(int a,int b){\n    return a*a+b*b;\n}\ndouble sumOfSquare(double a,double b){\n    return a*a+b*b;\n}\n```\n\n注意：\n\n* 函数的**返回值**和**形参名**不可以作为函数重载的条件\n\n- 函数重载碰到默认参数会出现二义性，尽量避免这种情况。\n\n引用\n\n- 引用相当于**给变量取别名**。语法：`数据类型 &别名=原名;`\n\n- **引用声明时就必须初始化**，`int &c;`是错误的\n\n- 在声明一个饮用后，不能再使之作为另一变量的引用（指向不可修改）\n\n- 引用作为重载的条件。\n\n  - 通过引用参数产生的效果同按地址传递是一样的，引用的语法更加清楚简单，简化指针修改实参。\n\n  ```c++\n  //指针作参数\n  void swap1(int *a,int *b){\n      int temp=*a;\n      *a=*b;\n      *b=temp;\n  }\n  //引用作参数\n  void swap2(int &a,int &b){\n      int temp=a;\n      a=b;\n      b=temp;\n  }\n  int main(){\n      int a=10;\n      int b=20;\n      swap1(&a,&b);//指针参数函数的调用，地址传递\n      swap2(a,b);//引用传递\n  }\n  ```\n\n  \n\n  - `void func(int & a);void func(const int & a);`当`func(a)`时走第一个，当`func(10)`走第二个。`const`是只读状态，相当于创建块区域，然后引用的指向它。注意`int &a=10;`是不合法的，10是一个常量，故不会走第一个。\n\n```c++\n// 声明简单的变量\n\n int i; double d; \n\n// 声明引用变量 \n\n int& r = i;\n\n double& s = d;\n\n i = 5;\n\n cout << \"Value of i : \" << i << endl;\n\n cout << \"Value of i reference : \" << r << endl;\n\n d = 11.7; \n\ncout << \"Value of d : \" << d << endl; \n\ncout << \"Value of d reference : \" << s << endl;\n\n return 0;\n```\n\n结果：\n\n```c++\nValue of i : 5\nValue of i reference :5\nValue of d : 11.7\nValue of d reference :11.7\n```\n\n* 引用做函数的返回值\n  * 不要返回局部变量的引用\n  * 函数的调用可以作为左值存在\n\n```c++\nint & test02(){\n    static int a=10;//一定要加static关键字，表示静态变量，存放在全局区，全局区上的数据在程序结束后系统释放。\n    //如果是int a;那就是返回局部变量的引用了\n    return a;\n}\nint main(){\n    int &ref=test02();//ref结果为10，ref是a的别名\n    test02=1000;//函数的调用作为左值做赋值操作，看成是a的别名，此时ref的结果变为1000\n    return 0;\n}\n```\n\n\n\n# 第四章 类和对象\n\n## 类和对象\n\nC++面向对象的三大特性为：封装、继承、多态。万事万物都皆为对象，对象上有其属性和行为\n\n具有相同性质的对象，我们可以抽象为类。\n\n### 封装\n\n- class代表设计一个类，类后面紧跟着的是类的名称\n\n```c++\nclass Circle\n\n{\n\n//访问权限\npublic:\n    \n//属性：半径\nint m_r;\n\n//行为：获取圆的周长\n\tdouble caculate(){//这里的行为是个函数\n\n\t\tdouble c=PI*m_r*2;\n\n\t\treturn c;\n\n\t}\n\n}\n```\n\n- 实例化：通过类创建一个具体对象。通过\".\"来访问，可以给属性赋值\n\n```c++\nCircle p1;//和结构体类似\n\np1.m_r=3;//赋值半径\n\ncout<<p1.caculate();//输出周长\n```\n\n* 类中的属性和行为统称为 成员。属性： 成员属性/成员变量。行为： 成员函数/成员方法。\n\n### \n\n- 访问权限:\n\n  - 公共权限       public 成员 类内(class大括号内)可以访问 类外也可以访问\n  - 保护权限       protected 成员 类内可以访问 类外不可以访问 儿子可以访问父亲的保护内容\n  - 私有权限       private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲的私有内容\n\n  - struct和class区别\n    - 唯一区别：默认的访问权限不同。**struct 默认是公共public，class<u>默认是私有</u>private**\n\n- **建议成员属性设置为私有**。\n  - 原因：1.可以自己控制读写权限 2.对于写可以检测数据的有效性\n\n- 可以通过public里的行为对private里的属性进行修改，实现只读、可读可写、只写。\n- 读\n\n```c++\nstring getlover(){\n\nreturn m_lover;\n\n}\n```\n\n- 写：\n\n```c++\nvoid setlover(string lover){\n\nm_lover=lover\n\n}\n```\n\n- 检测有效性:\n\n```c++\n//经过检测才能修改到，不至于直接修改private的属性造成麻烦\n\nvoid setAge(int age){\n\nif(age>=150||age<=0)\n\n{\n\nm_age=0;\n\ncout<<\"年龄有问题\";\n\nreturn;\n\n}\n```\n\n- 在类中可以让另一个类作为 本类中的成员\n- 作用域::成员函数 类的声明.h,需要`#pragma once` 和`#include<iostream>`和`using namepace`,如果这个类中还用到另一个类，需要引用另一类的头文件然后加作用域 。 类的实现.cpp需要`#include \"_.h\"`以及在函数名前加作用域，不需要外部的class和public和private的属性。\n- 对象特性\n  - 构造函数(对象初始化)和析构函数(对象清理)\n\n#### 构造函数和析构函数\n\n\n构造函数语法：`类名(){}`\n\n1. 构造函数，没有返回值也不写void\n2. 函数名称与类名相同\n3. 构造函数可以有参数，因此可以发生重载\n4. 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次\n\n析构函数语法：`~类名(){}`\n\n1. 析构函数，没有返回值也不写void\n2. 函数名称与类名相同，在名称前加符号~\n3. 析构函数**不可以有参数**，因此不可以发生重载\n4. 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次\n\n以上两个都是必须有的实现，如果不提供，编译器会提供，不过是空实现。\n\n- 构造函数的分类及调用\n\n两种分类方法\n\n1. 按照参数分类 无参构造（默认构造，编译器提供的）和有参构造\n2. 按照类型分类 普通构造和复制构造函数\n3. 复制构造函数写法\n\n```c++\nPerson(const Person &p){\n//将传入的人身上的属性复制到我身上；\n}\n```\n\n##### 三种调用方法 \n\n​\t1.括号法\n\n`Person p1; //默认构造函数调用`\n\n`Person p2(10); // 有参构造函数`\n\n`Person p3(p2); //拷贝构造函数`\n\n- 注意事项1：**默认构造函数调用时不要加(),编译器会误认为函数的声明**\n\n​\t2.显示法\n\n`Person p1;//不需要加括号写成Person p1()`\n\n`Person p2 = Person(10); //有参构造`\n\n`Person p3 = Person(p2); //拷贝构造`\n\n- person(10); //是匿名对象 特点:当前行执行结束后，系统会立即回收匿名对象\n- 注意事项2：不要利用拷贝构造函数 初始化匿名对象，如person(p3);编译器会识别出person     p3;\n\n​\t3.隐式转换法，直接写\n\n```c++\nPerson p4 = 10; //相当于写了 Person p4 = Person(10); \n\nPerson p5 = p4; //拷贝构造\n```\n\n\n\n##### 拷贝构造函数的调用时机\n\n1.使用一个已经创建完毕的对象来初始化一个新对象\n\n```c++\nPerson p1;\n\nPerson p2(p1);\n```\n\n​\t\t\n\n2.值传递的方式给函数传值\n\n```c++\nvoid fun1(Person p){}\n```\n\n\n\n3.以值方式返回局部对象\n\n```c++\nPerson doword(){\n\nPerson p1;\n\nreturn p1;\n\n}\n```\n\n\n\n##### 构造函数的调用规则\n\n默认情况下，编译器至少给一个类添加三个函数\n\n1. 默认构造函数（无参，函数体为空）\n2. 默认析构函数（无参，函数体为空）\n3. 默认拷贝构造函数，对属性进行值拷贝 \n\n- **如果写了有参构造函数，编译器就不提供默认构造，但仍提供拷贝构造**\n\n* **如果写了拷贝构造函数，编译器就不提供其他函数**\n\n##### 归纳\n\n```c++\n//构造函数 可分为无参构造（默认构造）和有参构造;或者分成普通构造和拷贝构造\nClass Clock{\npublic:\n  \tClock();//默认构造函数的声明，不用加{}\n    Clock(int newH,int newM,int newS);//构造函数的声明\n    Clock(Clock &c1);//复制构造函数的声明\n    ~Clock(){}//析构函数\nprivate:\n    int hour,minute,second;\n  \n};\nClock::Clock():hour(0),minutes(0),second(0){}//默认构造函数的实现\nClock::Clock(int newH,int newM,int newS):hour(newH),minute(newM),second(newS){}//构造函数的声明\nClock::Clock(Clock &c1){//复制构造函数的实现\n    hour=c1.hour;\n    minute=c1.minute;\n    second=c1.second;\n}\n\nint main(){\n    Clock c;//调用无参数的构造函数即默认构造，且设置初始化为(0,0,0)\n    Clock c1(21,10,10);//调用有参数的构造函数\n    Clock c2(c1);//调用复制构造函数\n    //程序结束前会执行析构函数\n    return 0;\n}\n```\n\n#### 构造与析构顺序\n\n```c++\n#include<iostream>\n#include<string.h>\nusing namespace std;\nclass A{\npublic:\n    A(){\n        cout<<\"A类的构造函数调用\"<<endl;\n    };\n    ~A(){\n        cout<<\"A类的析构函数调用\"<<endl;\n    }\n};\nclass B{\npublic:\n    B(){\n        cout<<\"B类的构造函数调用\"<<endl;\n    }\n    A a;//B类的成员是另一个类的对象，称为对象成员\n    ~B(){\n        cout<<\"B类的析构函数调用\"<<endl;\n    }\n};\nint main(){\n    B b;\n}\n\n//结果\n/*\nA类的构造函数调用\nB类的构造函数调用\nB类的析构函数调用\nA类的析构函数调用\n*/\n```\n\n* B类中有对象A作为成员，A为对象成员\n* 当创建B对象是，会先调用对象成员A的构造函数，再调用B的构造函数\n* 而析构顺序相反，先析构B再析构A，所谓先构造后析构，后构造先析构\n\n#### 深拷贝与浅拷贝\n\n**浅拷贝**：编译器的默认的简单的复制拷贝操作 **深拷贝**：在堆区重新申请空间(new)，进行拷贝操作\n\n- 浅拷贝的问题（类中有指针，释放的时候同一块地方被两个类释放两次，非法）要用深拷贝解决 \n\n```c++\n//拷贝函数\n\nPerson(const Person &p)\n\n{\n\n\tm_Age=age;\n\n\tm_Height=new int(*p.m_Height)\n\n}\n```\n\n- 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n\n- 初始化列表\n\n作用：初始化属性 语法：构造函数():属性1(值1),…{ }\n\n类对象作为类成员\n\n- 暂时用列表传参\n\n\n- C++运算符的重载\n\n运算符重载的概念：对**已有的运算符**重新进行定义，赋予其另一种功能，以适应不同的数据类型\n\n- 加法运算符的重载\n\n\n\n# 第五章 数据的共享与保护\n\n## 作用域\n\n### 局部作用域\n\n![image-20220626232121527](https://s2.loli.net/2022/07/01/yVSwlA2ahUoWgJ5.png)\n\n\n\n## 对象生存期\n\n### 静态生存期\n\n* 这种生存期与程序的运行期相同\n* 在文件作用域中声明的对象具有这种生存期\n* **在函数内部声明静态生存期对象，要冠以关键字`static`**\n\n### 动态生存期\n\n* 在局部作用域中声明的具有动态生存期的对象，习惯上也被称为局部生存期对象\n* 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时\n\n## 常对象\n\n**常对象必须进行初始化，且不能被更新**\n\n语法：`const 类型说明符 对象名;`\n\n```c++\nclass A{\n\t...\n}\nconst A a(3,4);//a是常对象，不能被更新\n\nconst int n=10;//正确，用10对常量n进行初始化\nn=20;//错误，不能对常量赋值\n```\n\n\n\n## 用const修饰的类成员\n\n### 常成员函数\n\n声明格式：`类型说明符 函数名(参数表)const;`\n\n**注意：**\n\n* **函数定义的时候也要加上const**\n* 常成员函数调用期间不**能更新(修改)对象**的数据成员，也不能常成员函数中调用没有用const修饰的成员函数\n\n### 常数据成员\n\n使用const说明的数据成员为常数据成员，初始化后不能修改。**构造函数对该数据成员进行初始化就只能通过初始化列表**\n\n```c++\nclass A{\npublic:\n    A(int i);\nprivate:\n    const int a;//常数据成员\n\tstatic const int b;//静态常数据成员 \n}\nconst int A::b=10;//静态常数据成员在类外说明和初始化\n\n//常数据成员只能通过初始化列表来获得初值\nA::A(int i):a(i){}\n```\n\n### 常引用\n\n```c++\nint &a=b;//相当于int*const a=b，指向不可改变，指针常量\nconst int &a=b;//常引用，相当于const int * const a=b,指向的空间不可修改\n```\n\n使得引用的对象只读，不能通过a来改变b的值\n\n\n\n## 静态变量与静态函数（存在于全局，并不属于特定的哪个对象）\n\n### 静态数据成员\n\n静态数据成员：使得一个类的所有对象具有相同的属性，对于任何对象实例，它的属性值相同，不属于任何一个对象。(具体看例子)\n\n**注意：**\n\n* 由于静态数据成员不属于任何一个对象，因此可以通过类名对他访问，一般用法：`类名::标识符`\n* 静态数据成员需要在类定义之外再加以定义。原因：以此来专门为它们分配空间。非静态数据成员无须，因为他们的空间是与他们所属对象的空间同时分配的\n\n```c++\nclass Point{\npublic:\n    Point(int x=0,int y=0):x(x),y(y){//构造函数\n        //在构造函数中对count累加，所有对象共同维护同一个count\n    }\n    Point(Point &p){\n        x=p.x;\n        y=p.y;\n        count++;\n    }\n    ~Point(){count--;}\n    int getX(){return x;}\n    int getY(){return y;}\n    \n    void showCount(){//输出静态数据成员\n        cout<<\" Object count=\"<<count<<endl;\n    }\nprivate:\n    int x,y;\n    static int count;//静态数据成员声明，用于记录点的个数\n}\nint Point::count=0;//静态数据成员定义和初始化，使用类名限定\n```\n\n创建不同`Point`类对象`a`和`b`可以分别调用`showCount`函数输出同一个`count`在不同时刻的数值，实现了a,b之间直接的数据共享。\n\n### 静态函数成员\n\n* 静态成员函数可以访问静态成员变量 \n\n* 静态成员函数**不可以访问非静态成员变量** ，**无法区分到底是哪个对象的** \n\n访问可以通过成员也可以通过类名`Person::func();`这样就不需要创建一个对象然后通过对象的成员函数来访问成员了。\n\n在静态成员函数中没有this指针，因为它属于整个类而不是具体的哪个对象，this指向的是具体的对象\n\n```c++\n//上面的例子做些修改\nclass Point{\npublic:\n    ...\n    static void showCount(){//金泰成员函数\n        ...\n    }\n}\nint main(){\n    Point a(1,3);\n    Point b(a);\n    Point::showCount();//这是想要输出count直接类名访问，因为当为非静态时，a.showCount()和b.showCount()是一个意思\n}\n```\n\n\n\n- 成员变量 和 成员函数 是分开存储的\n\n- - 空对象占用的内存空间为1字节，为了区分不同的空对象占用的空间\n  - 非静态成员变量 属于类的对象上，而静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上。\n\n```c++\nclass Person{\n\n};\n\nclass Phone{\n\nint price;\n\n//void func();\n\n//static int p;\n\n};\n\nPerson p1;\n\nPhone pp1;\n\nsizeof(p1);----1\n\nsizeof(pp1);---4  //就算里面有func和static，sizeof(pp1)都是int的4\n```\n\n\n\n## this指针\n\n- this指针概念\n\n成员函数和成员变量分开存储，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分是哪个对象调用自己呢？\n\n**this**指针指向被调用的成员函数所属的对象不需要定义，直接用\n\n- 解决名称冲突\n\n```c++\nPerson(int age){\n\n//age=age;编译器不知道哪个是哪个\n\nthis->age=age;\n\n}\n```\n\n \n\n- 返回对象本身用`return *this`\n\n- 空指针调用成员函数.如果要用的话，成员函数里面不能有属性，否则报错，因为传入空指针，this是NULL，或者是成员函数里前面加个\n\n  ```c++\n  if(this==NULL)     \n      return;\n  ```\n\n  \n\n## const修饰成员函数\n\nthis指针本质是一个指针常量，不能修改指向 ：\n\n```c++\nPerson * const this;//指向不能改。\nconst Person * const this;//指向不能改，指向的内容也不能改。\n```\n\n**常函数**\n\n```c++\nvoid showp() const\n\n{\n\n}\n```\n\n* 成员函数后加`const`称为**常函数**\n* 常函数内不可修改成员属性\n\n- 在成员函数后面加`const`修饰的是`this`指针，让指针指向的值也不能改，相当于这个函数加了`const`就是承诺不修改`this`指向的属性。\n- `mutable int m_B;`加上关键字`mutable`就是特殊变量，在常函数中可以修改\n\n**常对象**\n\n```c++\nconst Person p;//在对象前加const，变为常对象，一般的成员变量不能改\n```\n\n\n\n- 同理加了mutable就可以改\n- **常对象只能调用常函数**,防止你用常对象调用普通函数来修改里面的属性\n\n常数据成员\n\n**常数据成员只能通过初始化列表来获得初值**\n\n```c++\nclass A{\n    \npublic:\n\tA(int i);\n\nprivate:\n\tconst a;\n\n}\n\nA::A(int i):a(i){}\n```\n\n常引用：即只读状态\n\n```c++\nvoid dist(const Point &a); \n```\n\n\n\n## const型数据小结\n\n| 形式                       | 含义                                                         |\n| -------------------------- | ------------------------------------------------------------ |\n| `Point const t1`           | `t1`是常对象，其值在任何情况下都不能改变                     |\n| `void Point::func() const` | `func()`是`Point`类中的常成员函数，可以引用，但不能修改成员  |\n| `Point * const p`          | `p`是指向`Point`类对象的常指针，`p`的值不能改变，即指向不能变 |\n| `const Point *p`           | `p`是指向`Point`类常对象的指针，其指向的类对象的值不能通过指针来改变 |\n| `Point &t1=t;`             | `t1`是`Point`类对象`t`的引用，二者指向同一段内存空间         |\n\n\n\n## 友元\n\n让一个函数或者类访问另一个类中**私有成员**和保护成员\n\n**注意:**\n\n* 友元的关系是单向的而不是双向的\n* 友元的关系不能传递\n\n\n\n- 全局函数作右元\n\n```c++\nclass Room{\n\nfriend void visit(Room &room);//相当于把函数声明放到类里头开头加上friend，结尾加\";\"\n\n}\n\nvoid visti(Room &room){//全局函数的实现\n\n\n}\n```\n\n\n\n- 类做友元\n\n```c++\nclass Building;\n\nclass goodgay {//做友元\n\npublic:\n\n\tgoodGay();\n\n\tvoid visit;\n\nprivate:\n\n\tBuilding *building;\n\n};\n\nclass Building {\n\n//告诉编译器 goodgay类是Building类的好朋友，可以访问到Building类中私有内容\n\nfriend class goodGay;\n\npublic:\n\n\tBuilding();\n\npublic:\n\n\tstring m_SittingRoom;//客厅\n\nprivate:\n\n\tstring m_BedRoom;\n\n};\n\nBuilding::Building() {\n\n\tthis->m_SittingRoom = \"客厅\";\n\n\tthis->m_BedRoom = \"卧室\";\n\n}\n\ngoodGay::goodGay() {\n\n\tbuilding = new Building;\n\n}\n\nvoid goodGay::visit() {\n\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\n\tcout << \"好基友正在访问\" << building->m_SittingRoom << endl;\n\n}\n\nvoid test01() {\n\n}\n```\n\n\n\n- 另一个类的成员函数做友元\n\n- - 实操经验：如果是一个A类的成员变量想做B类的友元，那么B类里要声明友元，格式 :`friend 函数类型 A::函数名();` 同时，B类的声明要放在A类之后，否则编译器找不到A::函数名()这个东西\n\n  - friend声明友元函数，友元函数却依旧无法访问该类的私有属性”的解决\n    一次C++作业题, 搞了很久弄明白了, 虽然成功了, 但VS2015依旧有红线提示错误, 不过不影响编译、运行, 这似乎是VS自身的一个BUG。\n    解决：\n    友元类方法小结：\n\n    1. **包含声明”friend”的类，必须在((包含其声明的友元函数)的那个类)之前<u>事先声明下</u>————因为在Employer类中用到”Employee&”,不然无法访问该引用的私有成员。**\n    2. 被声明为友元的函数，必须在类内声明，然后在将其声明为友元函数的类的后面定义。\n    3. 还有一个我个人犯的低级错误——在声明友元函数时，忘记加该函数的作用域了。。。\n\n    作业代码如下：\n\n    ```c++\n     #include < iostream >\n     #include < string >\n    using namespace std;\n    \n    class Employee;//先声明，因为在Employer中会用到，否则不给友元函数访问Employer的私有\n    \n    class Employer\n    {\n    public:\n        Employer(string a) {\n            Name = a;\n        };\n        void editEmployee(Employee & person, double salary, string post);\n    private:\n        string Name;\n    };\n    \n    class Employee {\n    public:Employee(int a, string b, double c, string d) {\n        ID = a;\n        Name = b;\n        Salary = c;\n        Post = d;\n    }\n           friend void Employer::editEmployee(Employee & person, double salary, string post);\n           void printInf() {\n               cout << \"ID:\" << ID << \"\\t\" << \"Name:\" << Name << \"\\t\" << \"Salary:\" << Salary << \"\\t\" << \"Post:\" << Post << endl;\n           }\n    protected:\n    private:\n        int ID;\n        string Name;\n        double Salary;\n        string Post;\n    };\n    \n    void Employer::editEmployee(Employee & person, double salary, string post) {\n        person.Salary = salary;\n        person.Post = post;\n    };\n    ```\n\n\n\n# 第六章 数组 指针与字符串\n\n数组是具有一定**顺序关系**的若干<u>相同类型变量的集合体</u>，组成数组的变量称为该数组的<u>元素</u>。\n\n## 数组\n\n### 二维数组初始化\n\n* 将所有初值写在一个{}内，按顺序初始化\n  * 例如：`static int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};`\n* 分行列出二维数组元素的初值\n  * 例如：`static int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};`\n\n* 可以只对部分元素初始化\n  * 例如：`static int a[3][4]={{1},{0,6},{0,0,11}};`\n* 列出全部初始值时，第1维下标个数可以省略\n  * 例如：`static int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12};或：static int a[][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};`\n\n**注：**\n\n如果不作任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0\n\n如果只对部分元素初始化，剩下的未显式初始化的元素，将自动被初始化为零\n\n### 对象数组初始化\n\n```c++\nPoint a[2]={Point(1,2),Point(3,4)};\n```\n\n* 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象\n* 元素所属的类不声明构造函数，则采用默认构造函数。\n* 当数组中每一个对象被删除时，系统都要调用一次析构函数。\n\n\n\n## 指针\n\n### 内存空间的访问方式\n\n* 通过变量名访问\n* 通过地址访问\n\n### 指针的概念\n\n* 指针：内存地址，用于间接访问内存单元\n* 指针变量：用于存放地址的变量\n\n**指针名=地址**\n\n* C++11使用`nullptr`关键字，是表达更准确，类型安全的空指针\n\n### 指向常量的指针和指针类型的常量\n\n#### 指向常量的指针（常指针）\n\n声明时`const`在最前面。不能通过指针来改变指向对象的值，但是指针本身指向可以改变\n\n```c++\nint a;\nconst int *p1 = &a;\t//p1是指向常量的指针\nint b;\np1 = &b;\t//正确，p1本身的值可以改变\n*p1 = 1;\t//编译时出错，不能通过p1改变所指的对象\n\n```\n\n#### 指针类型的常量（指针常量）\n\n`const`在`*`后，指向不可改变。\n\n```c++\nint a;\nint * const p2 = &a; \nint b;\np2 = &b;\t//错误，p2是指针常量，值不能改变\n```\n\n### 指针类型的算术运算\n\n* 指针p加上或减去n\n  * 其意义是指针当前指向位置的前方或后方第n个数据的起始位置。\n\n* 指针的++、--运算\n  * 意义是指向下一个或前一个完整数据的起始。\n\n* 运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置。\n\n* **当指针指向连续存储的同类型数据时，指针与整数的加减和自增自减算才有意义。**\n\n### 指针与数组\n\n指针名加了整数再用*解引用得到所指对象的值。\n\n#### 定义指向数组元素的指针\n\n* 定义与赋值\n\n  ```c++\n  int a[10], *pa;\n  pa=&a[0]; //或 pa=a;数组名a地址也是数组第一个元素a[0]的地址\n  *pa就是a[0]，*(pa+1)就是a[1]，... ，*(pa+i)就是a[i].\n  a[i], *(pa+i), *(a+i), pa[i]都是等效的。\n  ```\n\n* 注意：不能写 a++，数组名不能自加自减，因为a是数组首地址、是常量。\n\n\n\n## 字符串\n\n### 字符数组\n\n用于存放字符串的数组其元素个数应该不小于字符串的长度(即字符个数)加1，因为要在末尾放置一个'\\0'。\n\n```c++\nchar str[8]={'p','r','o','g','r','a','m'};\nchar str[8]=\"program\";\nchar str[]=\"program\";//这三种写法等价\n\nchar s1[3]=\"xyz\";//错误！\nchar s2[2][3]={\"xyz\",\"mnp\"};//错误！\nchar s3[][3]={'a','x','y'};//正确\n```\n\n\n\n## 动态内存分配\n\n目的：保证程序在运行过程中按照实际需要申请适量的内存，使用结束后还可以释放。\n\n在C++程序中建立和删除堆对象使用两个运算符，`new`和`delete`\n\n**new**\n\n`new`的功能是动态分配内存，语法：`new 数据类型 (初始化参数列表)`\n\n创建一维数组：`new 类型名 [数组长度];`\n\n* 如果内存申请成功，`new`运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针对堆对象进行访问\n* `new T`和`new T()`效果相同，都会调用这个默认构造函数\n\n```c++\nint *point;\npoint=new int(2);//初值设置为\n\nint *point=new int;//不设置初值，直接去括号\n\nint *point=new ();//括号里不写，表示用0初始化\n\nint *p=new int[10]();//用0初始化数组\n```\n\n\n\n**delete**\n\n释放指针所指向的内存空间，语法：`delete 指针名;`\n\n删除数组要在指针名前面加\"[]\"：`delete []指针名;`\n\n* 如果是对象，会调用对象的析构函数\n* 对于用`new`建立的对象只能执行一次`delete`删除操作\n\n```c++\ndelete point;\ndelete []p;//一定是指针名，根据指针，去找对应地址的内存空间\n```\n\n\n\n## 内存四区\n\n**代码区 全局区 栈区 堆区**\n\nc++中在程序运行前分为全局区和代码区\n\n**代码区**\n\n特点是共享和只读。共享目的是对于频繁被执行的程序只需要保存一份代码即可\n\n**全局区**\n\n全局变量、静态变量、字符串常量、const修饰的全局变量存放在全局区\n\n局部修饰的都不在全局区里\n\n常量分为字符串常量和const修饰的变量，const修饰的变量有全局也有局部\n\n**栈区**\n\n有编译器自动分配释放，存放函数的参数值、局部变量等\n\n注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n\n**堆区** \n\n由程序员分配释放，程序结束时由操作系统回收\n\n在c++中用关键字`new`将数据开辟到堆区，返回值是地址，如 `new int(10),`将10放到堆区里，可指针接。在程序运行时，10一直存在。\n\n释放利用`delete`指向该区域的指针。\n\n```c++\nint *p=new int(10);\ndelete p;\n```\n\n常见一个数组用中括号:`int *arr=new int[10];` 上面的()表示只有一个元素\n\n释放 `delete[] arr;`\n\n\n\n# 第七章 类的继承\n\n## 基类和派生类\n\n```mermaid\ngraph TD;\n\t交通工具-->火车\n\t交通工具-->汽车\n\t交通工具-->飞机\n\t交通工具-->轮船\n\t汽车-->卡车\n\t汽车-->旅行车\n\t汽车-->小汽车\n\t小汽车-->工具车\n\t小汽车-->轿车\n\t小汽车-->面包车\n```\n\n* 从已有类产生新类的过程就叫类的派生\n* 派生类(子类)包含了基类(父类)特征，同时可以加入自己所特有的新特征\n* 一个派生类同时有多个基类的情况称为多继承(有多个爹)，只有一个直接基类叫做单继承\n* 在类族中，直接参与派生出某类的基类称为直接基类(爸爸辈)，跨层的基类称为间接基类(爷爷辈及以上)。如图中汽车是卡车、旅行车、小汽车的直接基类，而交通工具是旅行车的间接基类\n\n## 派生类构造函数和析构函数\n\n#### 构造函数\n\n**例题**\n\n```c++\n//例7-4.cpp\n#include<iostream>\nusing namespace std;\nclass Base1 {//基类Base1,构造函数有参数\npublic:\n\tBase1(int i) { cout << \"Constructing Base1 \" << i << endl; }\n};\nclass Base2 {//基类Base2,构造函数有参数\npublic:\n\tBase2(int j) { cout << \"Constructing Base2 \" << j << endl; }\n};\nclass Base3 {//基类Base3,构造函数有参数\npublic:\n\tBase3() { cout << \"Constructing Base3 * \" <<endl; }\n};\nclass Derived :public Base2, public Base1, public Base3 {\n//派生新类Derived，注意基类名的顺序\npublic:\n\tDerived(int a,int b,int c,int d):Base1(a),member2(d),member1(c),Base2(b){}\n//注意基类名的个体与顺序，注意成员对象名的个体与顺序\nprivate://派生类的私有成员对象\n\tBase1 member1;\n\tBase2 member2;\n\tBase3 member3;\n};\nint main() {\n\tDerived obj(1, 2, 3, 4);\n\treturn 0;\n}\n```\n\n**输出结果**\n\n![image-20220331165212833](https://s2.loli.net/2022/03/31/9NIY3fWlE5yag6Q.png)\n\n**构造函数的调用顺序**：<u>先调用基类的构造函数，然后调用内嵌对象的构造函数</u>\n\n①**基类构造函数**的调用顺序是按照派生类定义时**继承的顺序**，如例题\n\n```c++\nclass Derived :public Base2, public Base1, public Base3{\n   ...\n}\n```\n\n因此是先Base2,再Base1,最后Base3.\n\n②而**内嵌对象的构造函数**调用顺序应该是按照成员在类中**声明的顺序**\n\n```c++\nprivate://派生类的私有成员对象\n\tBase1 member1;\n\tBase2 member2;\n\tBase3 member3;\n```\n\n应该是先Base1,再Base2,最后Base3.\n\n因此结果顺序是2-1-3-1-2-3\n\n#### 析构函数\n\n语法：`~类名(){}`\n\n* 析构函数不接受任何参数\n* 如果不显式说明，系统会自动生成\n\n上个例题的析构结果是：\n\n![image-20220331181110050](https://s2.loli.net/2022/03/31/3d8Q6GyagTSvAkV.png)\n\n**析构函数顺序和构造函数是严格相反的**，<u>因此会先对派生类新增的类类型的成员对象进行清理，最后对所有从基类继承来的成员进行清理</u>\n\n\n\n## 三种继承方式\n\n* 公有继承，基类的公有和保护成员的访问属性在派生类中不变，私有的在类外无法直接访问\n* 私有继承，基类中的公有成员和保护成员都以**私有成员**身份出现在派生类中，而基类的私有成员在派生类中不可直接访问。经过多轮私有继承之后，所有的基类成员都成为派生类的私有成员或不可直接访问成员，基类的成员无法发挥作用，相当于终止了派生，使用较少\n* 保护继承，基类中的公有成员和保护成员都以**保护成员**身份出现在派生类中，而基类的私有成员不可直接访问。派生类的其他成员就可以直接访问从基类继承来的公有和保护成员，但在类外部通过派生类无法直接访问它们。与私有继承差别就是基类的保护成员可能被它的派生类访问(不至于无法发挥作用)，同时保证其绝对不可能被其他外部使用者访问。(某些需要被保护起来的成员对子孙有用时可以被用到)\n\n\n\n## 类型兼容规则\n\n* 派生类的对象可以隐含转换为基类对象，即可以用派生类对象赋值给基类对象。\n* 派生类的对象可以初始化基类的引用\n* 派生类的指针可以隐含转换为基类的指针\n\n以上称为向上转型。\n\n**不要重新定义同名的非虚函数**，因为此时派生类调用重新定义的非虚函数时都只能访问到从基类继承来的那个最原始的成员。\n\n\n\n## 不能被继承\n\nC++中，不能被派生类继承的是： **构造函数**\n\n\n\n## 私有继承调用基类\n\n```c++\n//7-8.cpp\n#include<iostream>\nusing namespace std;\nclass Base {\npublic:\n\n\tBase():x(0),y(0){}\n\tvoid initBase(int x,int y){\n\t\tthis->x = x;\n\t\tthis->y = y;//需要加this不然分不清\n\t}\n\tvoid fun1() {\n\t\tcout << x << endl;\n\t}\n\tvoid fun2() {\n\t\tcout << y << endl;\n\t}\nprivate:\n\tint x, y;\n};\nclass Derived :private Base {//私有继承\npublic:\n\tDerived() {}\n\tvoid initDerived(int x, int y) {\n\t\tinitBase(x, y);//通过成员函数调用基类成员\n\t}\n\tvoid getX() {\n\t\tfun1();\n\t}\n\tvoid getY() {\n\t\tfun2();\n\t}\n};\nint main() {\n\tDerived son;\n\tson.initDerived(3, 4);\n\tcout << \"调用基类的fun1()返回的到x值：\";\n\tson.getX();\n\tcout << \"调用基类的fun2()返回的到y值：\";\n\tson.getY();\n\treturn 0;\n}\n```\n\n![image-20220331184719981](https://s2.loli.net/2022/03/31/CYBwHDKfI9GnAuN.png)\n\n\n\n## 派生类成员的标识与访问\n\n### 作用域分辨符\n\n**当某派生类的多个基类拥有同名的成员时，调用同名成员必须通过基类名和作用域分辨符“:\"来标识成员**\n\n```c++\nint main(){\n\tDerived d;\n    Derived *p=&d;\n    \n    d.Base1::var=2;//作用域分辨符在同名成员前加\n    d.Base1::fun();\n    \n    p->Base2::var=1;//作用域分辨符在同名成员前加\n    p->Base2::fun();\n    \n    return 0;\n}\n```\n\n\n\n### 虚基类 virtual\n\n同名的数据成员在内存中拥有多个副本，需要使用作用域分辨符来唯一标识并访问它们。将共同基类设置为虚基类，这时从不同的路径继**承过来的同名数据成员在内存中就只有一个**，同一个函数名也只有一个映射，避免冗余。\n\n语法形式：`class 派生类名：virtual 继承方式 基类名`\n\n上述语句声明基类为派生类的虚基类，一起维护同一个内存数据\n\n![image-20220407111402840](https://s2.loli.net/2022/04/07/TiWVlXMo72Z1b6h.png)\n\n在类Derived中`d.Base1::var0`和`d.Base2::var0`是一个对象，造成冗余\n\n虚继承：\n\n```c++\nclass Base1: virtual public Base0{//类Base1是类Base0的公有派生类，Base0是Base1的虚基类\n    \n};\nclass Base2: virtual public Base0{\n    \n};\n```\n\n因此访问呢只需`d.var0`\n\n\n\n#### 最远派生类\n\n就是最年轻的那个子孙，后面没有再派生了\n\n#### 最远基类\n\n最老的那个基类\n\n#### 虚基类及其派生类构造函数\n\n* 如果最远虚基类中没有默认构造但是有有参构造，那么它的每一个子孙都必须在构造函数的成员初始化列表中为最远虚基类的构造函数列出参数。如果未列出表示调用虚基类默认构造函数，又因为没定义，所以会报错\n\n* 如果最远派生类构造函数调用虚基类的构造函数，那么其他类对虚基类构造函数的调用将被忽略\n\n  例：\n\n  ![image-20220407113108138](https://s2.loli.net/2022/04/07/26KuFaOZwPfnXG9.png)\n\n![image-20220407113305802](https://s2.loli.net/2022/04/07/CTFb1ULzwpKNxGW.png)\n\n**注意**：如果不可预估此基类会派生多少子类，那没必要用虚继承。同时多继承非必要不使用，来避免冗余。\n\n\n\n# 第八章 多态性\n\n多态：指同样的消息被不同类型的对象接收时导致不同的行为，即调用了不同的函数\n\n多态性是指具有**不同功能的函数**可以用**同一个函数名**，这样就可以**用一个函数名调用不同内容的函数**\n\n多态分为两类：\n\n* 静态多态：函数重载和运算符重载属于静态多态，复用函数名\n* 动态多态：派生类和虚函数实现运行时多态\n\n\n\n## 虚函数\n\n**什么是虚函数？**\n\n* 在基类用`virtual`声明成员函数为虚函数\n\n**虚函数的作用：**\n\n* 虚函数的作用是**允许在派生类中重新定义与基类同名的函数**(且能同时存在)，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。\n* 而对于派生类的同名函数来说，它覆盖了继承来的基类的同名函数，发挥自己的功能，解决了在第七章类型兼容规则中的问题\n\n**使用方法：**\n\n* 基类声明成员函数前加关键字`virtual`，实现时不用加`virtual`\n* 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体\n* C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都 自动成为虚函数，可以不加`virtual`\n\n![image-20220407114950788](https://s2.loli.net/2022/07/01/khuqBAHjL4nJ6CO.png) \n\n ![image-20220407114933014](https://s2.loli.net/2022/07/01/HBEKURn8myeoQpk.png)\n\n ![image-20220407114904923](https://s2.loli.net/2022/07/01/Ho3W4NSmE9V6lKX.png)\n\n\n\n上面例题是想通**过基类的指针指向派生类的对象**，并访问某个与基类同名的成员，那么首先在虚类中将这个同名函数说明为虚函数。\n\n**多态满足的条件：**\n\n* 有继承关系\n* 子类重写父类中的虚函数\n\n#### 初识虚函数\n\n* 用`virtual` 关键字说明的函数\n* 动态绑定的函数\n* 不能是内联，要在类外实现，因为对内联函数的处理是静态的\n\n#### 虚表\n\n![image-20220414085124122](https://s2.loli.net/2022/07/01/DA8SGuUpwQblVW1.png)\n\n在`Derived`中新定义了f(),会覆盖`Base::f`,其实就是重新开一个新函数；**没有定义g()来覆盖基类，故在虚表中查找g()会指向基类的g()**。\n\n#### virtual关键字\n\n* 如果基类函数是虚函数，派生类有同名的函数，默认为虚函数可以不用加`virtual`,自动覆盖基类同名函数。\n* 想要覆盖基类同名函数，习惯添加`virtual`，增加可读性\n\n#### 哪些成员函数可以是虚函数\n\n* 一般非静态成员函数可以是\n* 构造函数不具有多态功能，不能是\n* 析构函数可以是\n\n\n\n## 纯虚函数\n\n纯虚函数是在声明虚函数是被“初始化”为0的函数，没有定义具体的操作内容，甚至没有函数体。要求各派生类根据实际需要定义自己的版本。声明格式\n\n```c++\nvirtual 函数类型 函数名(参数表) = 0;\n```\n\n* **纯虚函数没有函数体**，不需要实现，即没有`{}`\n* 最后面的`=0`并不表示函数返回值为0，它只是告诉编译器这是纯虚函数\n* 用途是当基类不知道或者不需要这个函数有具体的意义无法实现但是派生类可以进行实现\n\n\n\n## 抽象类\n\n**带有纯虚函数的类是抽象类**。有函数但是不实现。用于初步设计，信息抽象暂时不实现。\n\n**抽象类只能是基类**\n\n```c++\nclass 类名{\n    virtual 类型 函数名(参数表)=0;\n    //其他成员...\n}\n```\n\n* 凡是包含纯虚函数的类都是抽象类\n* 一个基类如果包含一个或一个以上纯虚函数，就是抽象基类\n* 抽象类不能实例化，即不能定义一个抽象类的对象\n\n\n\n## 运算符重载\n\nc++中有以下五个运算符不能重载\n\n| 成员访问运算符 | 成员指针访问运算符 | 域运算符 | 长度运算符 | 条件运算符 |\n| -------------- | ------------------ | -------- | ---------- | ---------- |\n| .              | .*                 | ::       | sizeof     | ?：        |\n\n**重载运算符规则：**\n\n1. 重载不能改变运算符**运算对象(即操作数)的个数**\n2. 重载不能改变运算符的**优先级别**\n3. 重载不能改变运算符的**结合性**\n4. 重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数，与1矛盾\n5. 重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质\n6. 运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非类的成员函数也不是友元函数的普通函数。\n\n### 单目运算符\n\n![image-20220414105129983](https://s2.loli.net/2022/07/01/1aOmCHLKPGoDSZj.png)\n\n当使用重载运算符`c1+c2`就相当于是`c1.operator+(c2)`,重载+左操作数就是本类。\n\n### 双目\n\n**目标**：经过重载后，相当于`oprd1.operator 运算符(oprd2)`,`oprd1`要是随意的一个类而不像单目那样是本类。\n\n \n\n### 重载++，--\n\n* 前置单目运算符，重载函数没有形参\n* 后置运算符，重载函数需要一个int形参（为了区分，加一个形参） 编译器编译成`oprd.operator ++ (0)`\n\n![image-20220414151336572](https://s2.loli.net/2022/07/01/DdtbucCowSjVPAx.png)\n\n前置运算符重载函数类型是引用，返回的是`*this`\n\n后置运算符重载函数类型是类，返回值是一个局部类变量。如果此时函数类型错写成引用，试想一下引用指向的是一个即将消亡的局部变量……\n\n![image-20220421084529945](https://s2.loli.net/2022/07/01/Y85MPUX4GbE2OJQ.png)\n\n\n\n# 第九章 模板与全体数据\n\n## 模板\n\n### 函数模板\n\n函数体是一样的，定义形式\n\n```c++\ntemplate<模板参数类型>\n类型名 函数名(参数表){\n    函数体的定义\n}\n```\n\n* `template`，声明创建模板\n* `typename`，表明其后面的符号**是一种数据类型**，可以用`class`代替\n* `T`，通用的数据类型，名称可以替换，通常为大写字母\n* 编译器通过实参类型推导函数模板的类型参数，以模板生成一个函数，称为函数的**实例化**\n\n**注意：**\n\n* 一个函数模板并非自动可以处理所有类型的数据，只有能够进行函数模板中运算的类型，可以作为类型实参\n* 函数模板**只适用于函数体相同、函数的参数个数相同而类型不同**的情况，如果参数的个数不同，则不能用函数模板\n* 自定义的类需要为该类重载模板中的运算符，才能作为类型实参\n\n![image-20220421092713829](https://s2.loli.net/2022/04/21/AjDFyG2Og9cxIqP.png)\n\n```c++\n//求绝对值\ntemplate<typename T>\nT abs(T x){\n    return x<0?-x:x;\n}\nint main(){\n    int n=-5;\n    double d=-5.5;\n    cout<<abs(n)<<endl;\n    cout<<abs(d)<<endl;\n}\n/*结果\n5\n5.5\n*/\n```\n\n\n\n### 类模板\n\n![image-20220421094753875](https://s2.loli.net/2022/07/01/fSgEN2DZ8lxe6Ys.png)\n\n![image-20220421095132549](https://s2.loli.net/2022/07/01/QGDqijpEzlK8L5J.png)\n\n把`T`做替换成传入的参数\n\n**注意使用模板要加上尖括号和实参**   <u>**类名<>看作整体类名来用**</u>\n\n\n\n例：\n\n```c++\n//9_2\ntemplate <class T>\nclass Store{\nprivate:\n    T item;//存放任意数据类型的数据\n    bool haveValue;//标记item是否被存入内容\npublic:\n    Store();//缺省形式的构造函数\n    T &getElem();//提取数据函数\n    void putElem(const T &x);//存入数据函数\n}\n//成员函数的实现\ntemplate <class T>//缺省构造函数的实现\nStore<T>::Store():haveValue(false){}\n\ntemplate <class T>//提取数据函数的实现\nT &Store<T>::getElem(){//&看作是类型的一部分，放在前面\n    if(!haveValue){\n        cout<<\"No item present!\"<<endl;\n        exit(1);//异常退出\n    }\n    return item;\n}\n\ntemplate <class T>\nvoid Sotre<T>::putElem(const T &x){\n    haveValue=true;//表示item中已存入数值\n    item=x;//存入x\n}\n```\n\n结构体成员快速初始化 大括号\n\n![image-20220421095911747](https://s2.loli.net/2022/07/01/WICFYjmrbXRMawe.png)\n\n\n\n## 群体\n\n\n\n### 线性群体\n\n直接访问的线性群体——数组\n\n* 动态数组如`vector`元素个数可以在程序运行时改变\n\n顺序访问的线性群体——链表\n\n![image-20220421102517039](https://s2.loli.net/2022/07/01/rdevBP3xVpyCbIs.png)\n\n![image-20220421104449075](D:/Typora/images/image-20220421104449075.png)\n\n![image-20220421104801229](https://s2.loli.net/2022/07/01/U9oytKi7zn8eT1L.png)\n\n上图例子了两个版本的[]运算符重载，const的为了能修改常对象。返回的**常引用对象(函数名前有`const`)只能读不能写**。**不能写参数和返回值**\n\n\n\n类内数组深层复制一般需要重载“=”运算符\n\n* 避免自身复制 `if(&rhs!=this)`\n* 比较数组大小是否相同，new（不相同则删除原有，重新分配\n* 遍历数组一个一个复制\n* `return *this`\n\n### 链表\n\n**概念：**链表是一种动态数据结构，可以用来表示顺序访问的线性群体。链表是由系列结点组成的，结点可以在运行时动态生成。每个结点包括数据域和指向链表中下一个结点的指针(即下一个结点的地址)。如果链表每一个结点中只有一个指向后继结点的指针，则该链表称为单链表。\n\n如果每个结点中有两个用于连接其他结点的指针，一个指向前趋结点(称前趋指针)，另一个指向后继结点(称后继指针)，则构成双向链表。链表中的第一个结点称为头结点，最后一个结点称为尾结点，尾结点的后继指针为空。\n\n![image-20220428092308225](https://s2.loli.net/2022/07/01/8tVFCxcMYgN5EB6.png)\n\n#### 插入结点\n\n![image-20220428092952786](https://s2.loli.net/2022/07/01/tAIiNzesGoUk7rD.png)\n\ndata1的结点存放着data2节点的地址，要先把data2结点的地址给新节点然后再把新结点的地址给data1结点，顺序不能乱。\n\n#### 删除结点\n\n* 要看是不是最后的结点\n* 实现起来还要加一个前驱节点的地址，只有用前一个previous结点才能删除现在遍历到的current结点。\n\n\n\n![image-20220428093716001](https://s2.loli.net/2022/07/01/FaeMxI26AYwn3zS.png)\n\n### 栈\n\n**概念：**生活中的例子，假设餐厅里有一摞盘子，如果我们要从中拿取盘子，只能从上面一个开始拿，当我们要放上一个盘子是也只能放在最上面。栈的结构正是如此，每个盘子相当于栈中的一个数据，**数据只能从栈的一端存入(\"压入栈\")，并且只能从栈的同一端取出(\"弹出栈\")，这一端叫栈顶，而栈的另一端叫作栈底。**栈中的数据的添加和删除操作具有\"**后进先出**\"(LIFO)的特性，也就是说，栈中的所有数据，**越早被压入的(接近栈底的)，就越晚被弹出**。\n\n#### 表达式处理\n\n![image-20220428100015878](https://s2.loli.net/2022/07/01/qjAVNlOva2bzium.png)\n\n读取输入流，左边放数值，右边放运算符，运算符入栈的时候如果优先级低（如a-b加号优先级低于/)，那么不能入栈，这时弹出栈中运算符(如/)同时弹出对应操作数的数值进行运算，结果重新放回数值栈中，重复操作。\n\n#### 栈的基本操作\n\n* 初始化\n* 入栈\n* 出栈\n* 清空栈\n  * 把栈顶top置为-1\n* 访问栈顶元素\n* 检查栈的状态（满、空）\n\n\n\n### 队列\n\n**概念：**柜台前、收款机前排队。队列是**只能向一端添加元素，从另一端删除元素的线性群体**，**在队尾添加元素，在队头删除元素**。在队头位置的标记成为队头指针，对队尾位置的标记称为队尾指针。**向队尾添加元素称为\"入队\"，删除队头元素称为\"出队\"**。\"先进先出\"(FIFO)，**最早入队的最先出队。**\n\n![image-20220428110937794](https://s2.loli.net/2022/07/01/8MF9QxinqWs1hEa.png)\n\n\n\n## 排序与查找\n\n### 插入排序(从后往前检索)\n\n比较的时候如果不满足停止条件，需要给key元素腾出空间，找到之后可以直接插入\n\n![image-20220505085145537](https://s2.loli.net/2022/07/01/YIidmRfqpTu8XtF.png)\n\n```c++\n//用直接插入排序法对数组A中的元素进行升序排列\ntemplate <class T>\nvoid insertionSort(T a[], int n) {\n\tint i, j;\n\tT temp;\n\n\t//将下标为1～n-1的元素逐个插入到已排序序列中适当的位置\n\tfor (int i = 1; i < n; i++) {\n\t\t//从a[i - 1]开始向a[0]方向扫描各元素,寻找适当位置插入a[i]\n\t\tint j = i;\n\t\tT temp = a[i];\n\t\twhile (j > 0 && temp < a[j - 1]) {\n\t\t\t//逐个比较，直到temp >= a[j - 1]时，j便是应插入的位置。\n\t\t\t//若达到j == 0，则0是应插入的位置。\n\t\t\ta[j] = a[j - 1];    //将元素逐个后移，以便找到插入位置时可立即插入。\n\t\t\tj--;\n\t\t}\n\t\t//插入位置已找到，立即插入。\n\t\ta[j] = temp;\n\t}\n}\n```\n\n\n\n### 选择排序\n\n![image-20220505085639585](https://s2.loli.net/2022/07/01/Bzd5opjXuRIfSCL.png)\n\n```c++\n//辅助函数：交换x和y的值\ntemplate <class T>\nvoid mySwap(T &x, T &y) {\n\tT temp = x;\n\tx = y;\n\ty = temp;\n}\n\n//用选择法对数组a的n个元素进行排序\ntemplate <class T>\nvoid selectionSort(T a[], int n) {\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint leastIndex = i;\t//最小元素之下标初值设为i\n\t\tfor (int j = i + 1; j < n; j++)\t//在元素a[i + 1]..a[n - 1]中逐个比较显出最小值\n\t\t\tif (a[j] < a[leastIndex])\t//smallIndex始终记录当前找到的最小值的下标\n\t\t\t\tleastIndex = j;\n\t\tmySwap(a[i], a[leastIndex\t]);\t//将这一趟找到的最小元素与a[i]交换\n\t}\n}\n```\n\n\n\n### 交换排序\n\n每一轮沉底一个最大元素，n个元素最多排序n-1次，即沉底n-1个元素。\n\n![image-20220505090218593](https://s2.loli.net/2022/07/01/SBeKx13hjCfQm5l.png)\n\n**一轮循环结束后`lastExchangeIndex`其实就是沉好底的元素最上面那个还没排的元素的索引**\n\n```c++\n//辅助函数：交换x和y的值\ntemplate <class T>\nvoid mySwap(T &x, T &y) {\n\tT temp = x;\n\tx = y;\n\ty = temp;\n}\n\n//用起泡法对数组A的n个元素进行排序\ntemplate <class T>\nvoid bubbleSort(T a[], int n) {\n\tint i = n - 1;\t// i是下一趟需参与排序交换的元素之最大下标\n\twhile (i > 0) {\t//持续排序过程，直到最后一趟排序没有交换发生，或已达n - 1趟\n\t\tint lastExchangeIndex = 0;\t//每一趟开始时，设置交换标志为0（未交换）\n\t\tfor (int j = 0; j < i; j++)\t//每一趟对元素a[0]..a[i]进行比较和交换\n\t\t\tif (a[j + 1] < a[j]) {\t//如果元素a[j + 1] < a[j]，交换之\n\t\t\t\tmySwap(a[j], a[j + 1]);\n\t\t\t\tlastExchangeIndex = j;\t//记录被交换的一对元素中较小的下标，下一步j++ \n\t\t\t}\n\t\ti = lastExchangeIndex;\t//将i设置为本趟被交换的最后一对元素中较小的下标\n\t}\n    \n    //一般方法\n     for(i=0;i<n-1;i++)\n        for(j=0;j<n-i-1;j++){//注意索引\n            if(a[j]>a[j+1])\n                mySwap(a[j],a[j+1]);\n        }\n}\n```\n\n\n\n### 二分查找\n\n当找不到数，注意结束的条件（左边界要是中间数加一，右边界是中间数减一）\n\n![image-20220505095453135](https://s2.loli.net/2022/07/01/OlY1WjxI9EACcib.png)\n\n```c++\n/用折半查找方法，在元素呈升序排列的数组list中查找值为key的元素\ntemplate <class T>\nint binSearch(const T list[], int n, const T &key) {\n\tint low = 0;\n\tint high = n - 1;\n\twhile (low <= high) {\t//low <= high表示整个数组尚未查找完\n\t\tint mid = (low + high) / 2;\t//求中间元素的下标\n\t\tif (key == list[mid])\n\t\t\treturn mid;\t\t//若找到,返回下标\n\t\telse if (key < list[mid])\n\t\t\thigh = mid - 1;\t//若key < midvalue将查找范围缩小到数组的前一半\n\t\telse\n\t\t\tlow = mid + 1;\t//否则将查找范围缩小到数组的后一半\n\t}\n\treturn -1;\t//没有找到返回-1\n}\n```\n\n\n\n# 第十章 泛型程序设计与C++语言标准模板库\n\n面向对象三个特性：封装、继承、多态\n\nSTL 标准模板库\n\n六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器\n\n**容器**可以嵌套容器，里面的叫元素，分为序列式容器和关联式容器：\n\n​\t序列式容器：强调值的顺序，有固定顺序\n\n​\t关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系\n\n**迭代器**，用来遍历元素的指针。实际上迭代器是一个类，这个类封装了一个指针\n\n![image-20220512085602460](https://s2.loli.net/2022/07/01/wDz3jFJLclXtIPk.png)\n\n**算法**，通过有限的步骤，解决问题。\n\n​\t质变算法：运算过程中改变区间内元素内容，如拷贝替换查找。\n\n​\t非质变算法：不更改内容，如查找、计数、遍历\n\n仿函数，行为类似函数，可作为算法的某种策略。\n\n适配器，一种用来修饰容器或者仿函数活迭代器接口的东西\n\n空间适配器，负责空间的配置与管理\n\n**迭代器是算法和容器的桥梁**，使算法能够作用到容器。理解为提供给算法函数的指针参数。\n\n\n\n## 容器算法迭代器初识\n\n### vector容器存放内置数据类型\n\n创建：\n\n```c++\nvector<int>v;\n```\n\n向容器尾部插入数据：\n\n```c++\nv.push_back(10);\n```\n\n通过迭代器访问容器中的数据：\n\n```c++\nvector<int>::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素\nvector<int>::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置,所以*itEnd是错误的\n```\n\n第一种遍历方式：\n\n```c++\nwhile(itBegin!=itEnd){\n    cout<< *itBegin<<endl;\n    itBegin++;\n}\n```\n\n第二种遍历方式（常用）：\n\n```c++\nfor(vector<int>::iterator it=v.begin();it!=v.end();it++){\n    cout<< *it<< endl;//*it解出来的类型对应vecotr<>尖括号里的类型\n}\n```\n\n第三种用算法库：\n\n```c++\n//需要加\n#include<algorithm>\nvoid myPrint(int val){\n    cout<<val<<\" \";\n}\nfor_each(v.begin(),v.end(),myPrint);//在for_each(,,func())中需要调用到第三个参数，是一个函数，在内部会执行func(*first)传递迭代器的指向的值，这是只需拿到这个数执行回调函数输出即可。\n```\n\n\n\n### vector存放自定义数据\n\n存放指针类型\n\n```c++\nvector<Person*>v;//Person是一个类，存放Person类型的指针\nPerson p1;\nv.push_back(&p1);//注意是取地址，存放指针类型的\n```\n\n遍历\n\n```c++\nfor(vector<Person*)::iterator it=v.begin();it!=v.end();it++){\n    cout<<it->name;//或者是*it.name\n}\n```\n\n存放容器类型，容器嵌套\n\n```c++\nvector<int>v;\nvector< vector<int>>V;\nv.push_back(10);\nV.push_back(v);\n```\n\n遍历，需要两层循环\n\n```c++\nfor(vector< vector<int>::iterator it=V.begin();it!=V.end();it++){\n    //此时it类型指向vector<int>类型的指针\n    for(vector<int>::iterator vit=(*it).begin();vit!=(*it).end();vit++){\n        cout<<*vit;\n    }\n}\n```\n\n\n\n### string容器\n\n#### 基本概念\n\n`string`是一个类，封装了一个`char*`来维护，是一个`char*`容器\n\n```c++\nstring s1;\nstring(const char* s);//使用字符串s初始化\nstring(const string& str);//使用一个string对象初始化另一个string对象\nstring(int n,char c);//使用n个字符c初始化，如string s4(10,'c')，则s4=\"ccccccccc\"\n```\n\n\n\n### vector容器\n\n单端数组，可动态扩展\n\n**动态拓展**：并不是在原空间之后来连续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间\n\n \n\n### set容器\n\n#### 概念\n\n`set`不允许插重复的，`multiset`可以。实现自动升序排序\n\n```c++\n#include<set>\n\nset<int>s1;//构造函数\nset<int>s2(s1);//拷贝构造\ns1.insert();//插入数据只有insert方式，而没有push_back\nprintSet(s1);//遍历输出函数自己写\n\n//遍历输出\nvoid printSet(set<int>&s){\n    for(set<int>::iterator it=s.begin();it!=s.end();it++){\n        cout<<*it<<\" \";\n    }\n    cout<<endl;\n}\n```\n\n#### set大小和交换\n\n##### 函数原型\n\n```c++\nsize();//大小，set没有resize()重新设置大小的操作，因为当扩大时其余未设定的会补0导致重复\ns1.empty();//判断是非为空\ns1.swap(s2);//交换容器s1和s2\n```\n\n#### set插入和删除\n\n##### 函数原型\n\n```c++\ns1.insert();//插入\ns1.erase();//删除，可以放指针如s1.begin(),也可以放数值\ns1.clear();//清空\ns1.insert(st).second;//若插入重复则该返回值为false\n```\n\n#### set查找和统计\n\n\n\n### map容器\n\nmap中所有元素都是pair\n\npair中第一个元素为key（键值），第二个元素为value（实值）\n\n所有元素都会根据元素的键值自动排序\n\n本质属于关联式容器，底层结构二叉树实现\n\n**优点：**可以通过key快速找到value值\n\n#### map容器构造和赋值\n\n```c++\nmap<int,int>m;//创建需要两个参数，对组pair元素\nm.insert(pair<int,int>(1,10));//插入要对组pair\n//输出\nvoid printMap(map<int,int>&m){\n    for(map<int,int>::iterator it=s.begin();it!=begin();it!=m.end();it++){\n        cout<<\"key=\"<<(*it).first<<\"value=\"<<it->second<<endl;\n    }\n    cout<<endl;\n}\nmap<int,int>m2(m1);//拷贝构造\nm2=m1;//赋值\n```\n\n**总结**：map中所有元素都是成对出现，输入数据时需要使用对组\n\n#### map容器大小和交换\n\n```c++\nsize();//大小\nempty();//判断为空\nswap(st);//交换\n```\n\n\n\n\n\n## 函数对象\n\n函数对象（仿函数）本质是个类，而不是一个函数\n\n\n\n## 谓词\n\n仿函数 返回值类型是bool数据类型，称为谓词\n\n#### 一元谓词\n\n如果`operator()`接受一个参数，那么叫做一元谓词，两个参数叫二元谓词\n\n```c++\nfind_if(v.begin(),v.end(),查询条件);//返回值是v相同类型的迭代器，没找到返回的是v.end()\nclass Mycompare{\n    public:\n    \tbool operator()(int val1,int val2){\n            return val1>val2;\n        }\n}//二元谓词的匿名函数\nfind_if(v.begin(),v.end(),Mycompare());//类要加上括号\n```\n\n\n\n# 第十一章 流类库与输入输出\n\n## 输出流概述\n\n最重要的三个输出流`ostream`,`ofstream`,`ostringstream`\n\n预先定义的ostream类对象用来完成向标准设备的输出：\n\n* `cout`是标准输出流\n* `cerr`是标准错误输出流，没有缓冲，发送给它的内容立即被输出\n* `clog`类似`cerr`\n\n`ofstream`类支持磁盘文件输出\n\n### 使用width控制输出宽度\n\n```c++\n#include <iostream>\nusing namespace std;\n \nint main() {\n\tdouble values[] = { 1.23, 35.36, 653.7, 4358.24 };\n\tfor(int i = 0; i < 4; i++) {\n\t\tcout.width(10);\n\t\tcout << values[i] << endl;\n\t}\n\treturn 0;\n}\n\n输出结果:\n      1.23\n     35.36\n     653.7\n   4358.24\n//加上左边的空格正好十个宽度，右对齐\n```\n\n### 使用**setw**操纵符指定宽度\n\n```c++\n//11_2.cpp\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n \nint main() {\n\tdouble values[] = { 1.23, 35.36, 653.7, 4358.24 };\n\tstring names[] = { \"Zoot\", \"Jimmy\", \"Al\", \"Stan\" };\n\tfor (int i = 0; i < 4; i++)\n\t  cout << setw(6) << names[i] \n     << setw(10) << values[i] << endl;\n\treturn 0;\n}\n输出结果:\n  Zoot      1.23\n Jimmy     35.36\n    Al     653.7\n  Stan   4358.24\n//setw(n)指定了后面输出的内容宽度在n个宽度内，右对齐\n```\n\n### 设置对齐方式\n\n```c++\n//11_3.cpp\n#include <iostream>\n#include <iomanip>\n#include <string>\nusing namespace std;\n \nint main() {\n\tdouble values[] = { 1.23, 35.36, 653.7, 4358.24 };\n\tstring names[] = { \"Zoot\", \"Jimmy\", \"Al\", \"Stan\" };\n\tfor (int i=0;i<4;i++)\n\t  cout<<setiosflags(ios_base::left)//左对齐\n        <<setw(6)<<names[i]<<resetiosflags(ios_base::left)<<setw(10)<<values[i]<<endl;\n\treturn 0;\n}//这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。\n\n\n输出结果:\nZoot        1.23\nJimmy      35.36\nAl         653.7\nStan     4358.24\n```\n\n### 向二进制文件输出\n\n```c++\n//11_5.cpp\n#include <fstream>\nusing namespace std;\nstruct Date { \n\tint mon, day, year;  \n};\nint main() {\n\tDate dt = { 6, 10, 92 };\n\tofstream file(\"date.dat\", ios_base::binary);\n\tfile.write(reinterpret_cast<char *>(&dt),sizeof(dt));//write函数是把内存中的一块内容写到一个文件输出流中\n\tfile.close();\n\treturn 0;\n}\n\n```\n\n### 向字符串输出\n\n```c++\n//11_6.cpp\n#include <iostream>\n#include <sstream>\n#include <string>\nusing namespace std;\ntemplate <class T>\ninline string toString(const T &v) {\n\tostringstream os;\t//创建字符串输出流\n\tos << v;\t\t//将变量v的值写入字符串流\n\treturn os.str();\t//返回输出流生成的字符串\n} \nint main() {\n\tstring str1 = toString(5);\n\tcout << str1 << endl;\n\tstring str2 = toString(1.2);\n\tcout << str2 << endl;\n\treturn 0;\n}\n\n```\n\n\n\n## 输入流\n\n重要的输入流类：\n\n* istream类最适合用于顺序文本模式输入。cin是其实例。\n* ifstream类支持磁盘文件输入。\n* istringstream\n\n### 构造输入流对象\n\n* 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。\n\n```c++\nifstream myFile(\"filename\");\n```\n\n* 在调用默认构造函数之后使用open函数来打开文件\n\n```c++\nifstream myFile;//建立一个文件流对象\nmyFile.open(\"filename\");//打开文件“filename”\n```\n\n* 打开文件时可以指定模式\n\n```c++\nifstream myFile(\"filename\",ios_base::in|ios_base::binary);\n```\n\n#### 相关函数\n\nopen函数把该流与一个特定磁盘文件相关联。\nget函数的功能与提取运算符（>>）很相像，主要的不同点是get函数在读入数据时包括空白字符。（第6章介绍过）\ngetline的功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。（第6章介绍过）\nread成员函数从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。\nseekg函数用来设置文件输入流中读取数据位置的指针。\ntellg函数返回当前文件读指针的位置。\nclose函数关闭与一个文件输入流关联的磁盘文件。\n\n### 输入流举例应用\n\n#### 为输入流指定一个终止字符\n\n利用getline函数\n\n```c++\n//11_8.cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main() {\n    string line;\n    cout << \"Type a line terminated by '\\t' \" << endl; \n\t getline(cin, line, '\\t');\n    cout << line << endl;\n\treturn 0;\n}\n\n```\n\n### istringstream将字符串转换为数值\n\n```c++\n//11_12.cpp, 头部分省略\ntemplate <class T>\ninline T fromString(const string &str) {\n\tistringstream is(str);\t//创建字符串输入流\n\tT v;\n\tis >> v;\t//从字符串输入流中读取变量v\n\treturn v;\t//返回变量v\n}\n \nint main() {\n\tint v1 = fromString<int>(\"5\");\n\tcout << v1 << endl;\n\tdouble v2 = fromString<double>(\"1.2\");\n\tcout << v2 << endl;\n\treturn 0;\n}\n输出结果：\n5\n1.2\n\n```\n\n\n\n## 两个重要的输入/输出流\n\n* 一个iostream对象可以是数据的源或目的。\n\n* 两个重要的I/O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。\n\n### fstream类\n\n* fstream类支持磁盘文件输入和输出。\n* 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象。\n* 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出\n\n### stringstream类\n\n* stringstream类支持面向字符串的输入和输出\n* 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成\n\n\n\n# 第十二章 异常处理\n\n## 异常处理的语法\n\n* 若有异常则通过`throw`创建一个异常对象并抛掷\n\n* 将可能抛出异常的程序段嵌在`try`块之中。通过正常的顺序执行到达`try`语句，然后执行`try`块内的保护段\n\n* 如果在保护段执行期间没有引起异常，那么跟在`try`块后的`catch`子句就不执行。程序从`try`块后的最后一个`catch`子句后面的语句继续执行\n* `catch`子句按其在`try`块后出现的顺序被检查。匹配的`catch`子句将捕获并处理异常（或继续抛掷异常）。\n* 如果匹配的处理器未找到，则库函数terminate将被自动调用，其默认是调用abort终止程序。\n","tags":["编程语言","c++"],"categories":["本科课程"]},{"title":"离散数学","url":"/2022/07/01/离散数学/","content":"\n# 第一章 命题逻辑的基本概念\n\n## 1.1 命题与连接词\n\n* 非真即假的陈述句称作**命题**\n\n* 作为命题，是否知道它的真值并不重要，<u>重要的是它有唯一的真值</u>。如*2050年的元旦下大雪*\n\n* 用小写英文(p,q,r,s...至少从p开始往后数)表示命题\n\n* 否定式**“非p”﹁p**是复合命题；**∧合取** **∨析取**\n\n* 相容或和排斥或\n\n  * **相容或**，即它联结的两个命题可以同时为真。如*小明爱打球或跑步*这两个命题可以同时为真，相容或\n  * **排斥或**，只有当一个为真，另一个为假时，才为真。但是这个形式化有两种情况。\n    * ①”只能“，*小芳只能挑选跳舞课或羽毛球课* 这里p:小芳挑选跳舞课 q:小芳挑选羽毛球课,结果并不能单纯用p∨q表示，因为当p，q同真时结果也是真，即小芳既选了跳舞可，又选了羽毛球课，不满足”只能“。此复合命题为真应该时当且仅当p、q其中一个为真，另一个为假时才成立。（这里我们容易联想到”异或“关系）如何用形式化表达呢？不如我们表示得详细一点：小芳挑选跳舞课但不挑选羽毛球课或小芳挑选羽毛球课但不挑选跳舞课。于是用符号化表示：**(p∧﹁q)∨(﹁p∧q)** \n    * ②不能同时为真的。*小芳是江西人或安徽人* 这里既可以用**(p∧﹁q)∨(﹁p∧q)** 表示，又可以用**p∧q**表示，因为小芳不可能既是江西人又是安徽人，即p、q不能同时成立。\n\n* **p→q**称为p**蕴涵**q;规定p→q为假当且仅当p为真q为假。当p为假时无论q真假p→q都是真。\n\n  | p q  | p→q  |\n  | :--: | :--: |\n  | 0 0  |  1   |\n  | 0 1  |  1   |\n  | 1 0  |  0   |\n  | 1 1  |  1   |\n\n* 除非和否则。*除非小王穿毛衣，否则天不冷* 将”否“和”则“断开，否掉除非后的命题，改成*如果小王不穿毛衣，则天不冷* 这样就好判断蕴涵关系了。\n\n  *只有天冷，小王才穿毛衣* 是q→p，只有……才……后面推前面。小王穿了毛衣说明天冷了。\n\n* (p→q)∧(q→p)与p↔q的逻辑关系完全一样，都表示p与q互为充分必要条件。\n\n* **优先顺序**：\"( )\"  >  \"﹁\"  >  \"∧\"  =  \"→\"  =  \"↔\"\n\n* 命题的中文说法与符号化\n\n  * ﹁p “非p” \n  * p∧q “p并且q”   \n  * p∨q \"p或q\"\n  * p→q \"如果p，则q\"\n  * p↔q ”p当且仅当q“\n\n## 1.2 命题公式及其赋值\n\n* 真值可以变化的陈述句叫**命题变项**，命题变项不是命题。命题变项用符号联结起来的符号称为**合式公式**，简称**公式**。命题用符号联结起来就是复合命题。区分：*如果题目只有符号p之类的，就是命题变项；如果是p:简单命题那就是命题常项*\n* 公式的层数。单个命题变项算0层，﹁算1层，其他的就是max(i,j)\n* **解释**或**赋值**：用命题常项代替公式中的命题变项然后各指定一个真值0或1（不关心命题内容，只关心真假）\n* 三种命题公式（设A为任一命题公式）\n  * **重言式**，A在它各种赋值下取值均为真，全为成真赋值。\n  * **矛盾式**，A在它各种赋值中取值均为假，全为成假赋值。\n  * **非重言式的可满足式**,A既有成真赋值又有成假赋值。（可满足式：不是矛盾时就是可满足式，至少有一个成真赋值。）\n\n\n\n\n# 第二章 命题逻辑等值演算\n\n## 2.1等值式\n\n* **等值**：在所有扶植下，A和B的真值都相同，则称A与B是等值的，记作\n\n* 等值式模式\n\n  ![image-20220304214907554](https://s2.loli.net/2022/07/01/DiCNtQRYhwI1XZe.png)\n\n![image-20220304214932944](D:/Typora/images/image-20220304214932944.png)\n\n比较重要的等值式模式：1双重否定律、6德摩根律、8零律、9同一律、10排中律、11矛盾律\n\n**等值演算法做题顺序**：\n\n​\t1.消→，↔   （蕴涵等值式、等价等值式）\n\n​\t2.消﹁( )        （德摩根律）\n\n​\t3.消双重否定（双重否定律）\n\n## 2.2 析取范式与合取范式\n\n* 命题变项及其否定统称作**文字**。仅由<u>有限个文字</u>构成的析取式（合取式）称作**简单析取式**（**简单合取式**）。\n\n  * 注意：p,﹁p,q,﹁q就即是简单析取式又是简单合取式。（单个文字析取0或者合取1，也是本身）\n\n* 由有限个**简单合取式的析取**构成的命题公式称作**析取范式**，由有限个**简单析取式做合取**构成的命题公式称作**合取范式,**统称为范式。\n\n  * 注意有些命题公式名字不唯一：p∧q∧r 即是由三个简单析取式做合取构成的合取范式，<u>又是由一个简单合取式构成的析取范式</u>（理解成 (p∧q∧r)∨1) )。\n  * **析取范式容易求成真赋值，合取范式容易求成假赋值**\n\n* （**范式存在定理**）任一命题公式都存在与之等值的析取范式与合取范式。这就意味着我们可将所有的命题公式运用等值演算法转化为析取范式或合取范式的形式，方便求得赋值。\n\n* 在含有n个命题变项的简单合取式（简单析取式）中，若每个命题变项和它的否定式恰好出现一个且仅出现一次[全部齐全]，而且命题变项或它的否定式按照下标从小到大或按照字典序排列，称这样的简单合取式（简单析取式）为极小项（极大项）\n\n  * 简单合取出极小项，简单析取出极大项。\n  * 由于命题变项还有否定形式，所以n个命题变项可以组成2^n个不同的极小项（极大项同理2<sup>n</sup>个）。**每个极小项都有且仅有一个成真赋值**，**每个极大项也只有一个成假赋值**，且不同的极小项（极大项）有不同的成真（成假）赋值。<u>说明一个极小项可以提供一个成真赋值，一个极大项可以提供一个成假赋值</u>。\n  * 讲极小项的成真赋值对应的二进制数等于十进制i，将这个极小项记作m<sub>i</sub>.例如p∨q∨r这个极小项成真赋值为111，对应十进制7，那么这个极小项记作m<sub>7</sub>;极大项同理，记作M<sub>i</sub>。\n  * ﹁m<sub>i</sub>⇔M<sub>i</sub> , ﹁M<sub>i</sub>⇔m<sub>i</sub>\n\n* 主析取范式（主合取范式）：全部由极小项（极大项）构成的析取范式（合取范式）。\n\n  * 主析取范式是简单合取式的极小项做析取，直接看出所有成真赋值；主合取范式是简单析取式的极大项做合取，直接看出所有成假赋值。\n\n  * 任何命题公式都存在与之等值的主析取范式和主合取范式，并且是唯一的。我将其称之为**主范式存在定理**，这条定理为我们转化范式提供依据。\n\n  * **简单合取式转化为极小项的步骤**，如：\n\n    少了一个命题变项的\n\n    p∧q⇔(p∧q)∧1\t\t\t\t(同一律)\n\n    ⇔(p∧q)∧(r∨﹁r)\t  \t\t(排中律，置换规则)\n\n    ⇔<u>(p∧q∧r)∨(p∧q∧﹁r)</u>    (分配律)\n\n    ⇔m<sub>7</sub>∨m<sub>6</sub>\n\n    这样就变成了两个极小项做析取。\n\n    少了两个命题变项的\n\n    p⇔p∧1\t\t\t\t\t\t\t  (同一律)\n\n    ⇔p∧(q∨﹁q)\t\t\t\t\t (排中律，置换规则)\n\n    ⇔(p∧q)∨(p∧﹁q)\t\t\t (分配律)\n\n    ⇔((p∧q)∨(p∧﹁q))∨1      (同一律)\n\n    ⇔((p∧q)∨(p∧﹁q))∧(r∨﹁r)  (排中律，置换规则)\n\n    ⇔<u>(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r)</u>  (分配律)\n\n  * **简单析取式转化为极大项的步骤**，如：\n\n    少了一个命题变项的：\n\n    p∨q⇔(p∨q)∨0                (同一律)\n\n    ⇔(p∨q)∨(r∧﹁r)\t\t\t  <u>(矛盾律)</u>//这一步和简单合取式变极小项不一样，前后的步骤基本一致,结果符号调换\n\n    ……\n\n    ⇔<u>(p∨q∨r)∧(p∨q∨﹁r)</u>\t(分配律)\n\n    少两个命题变项的\n\n    p⇔p∨0\n\n    ……\n\n    ⇔<u>(p∨q∨r)∧(p∨﹁q∨r)∧(p∨q∨﹁r)∧(p∨﹁q∨﹁r)</u>  (分配律)\n\n  * **<u>总结简单合（析）取式转化为极大（小）项基本步骤</u>**：\n\n    * 缺少哪个变项就添加同时添加那个变项的原形和否定式，缺少多个就做排列组合\n\n      如p∧q最后变成<u>(p∧q∧r)∨(p∧q∧﹁r)</u> ，p变成(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r)，原本是合取式加上后各部分做析取，原本析取的加上后各部分做合取\n\n    * 出现重复的命题变项或极小项或矛盾式应消去，如，p∧p⇔p，m<sub>i</sub>∨m<sub>i</sub>⇔m<sub>i</sub>，用0代替矛盾式\n\n  * A是一个有3个命题变项的公式，假设主析取范式为 m<sub>2</sub>∨m<sub>5</sub>∨m<sub>7</sub>，说明它的成假赋值有三个，010,101,111，那么剩下的2<sup>3</sup>-3=5个就是它的成真赋值了，则它的主合取范式为M<sub>0</sub>∧M<sub>1</sub>∧M<sub>3</sub>∧M<sub>4</sub>∧M<sub>6</sub>，<u>相当于把真值表分为成真和成假，成真赋值压缩到主合取范式，成假赋值压缩到主析取范式，一眼就可以看出来。</u>\n\n\n\n\n\n\n\n# 第三章 命题逻辑的推理理论\n\n## 3.2 自然推理系统\n\n常用的推理定理：\n\n* 假言推理 (A→B)∧A⇒B \n* 拒取式 (A→B)∧﹁B⇒﹁A\n* 析取三段式 (A∨B)∧﹁B⇒A\n* 假言三段式 (A→B)∧(B→C)⇒(A→C)\n\n前提：\n\n结论：\n\n推理证明的两个技巧：\n\n* 附加前提证明法。如结论是A→B，就可以把A作附加前提引入推出B。\n* 归谬法，将结论的否定式作为附加前提引入并推出矛盾式。如结论是﹁q，就把q作结论的否定引入最终推出矛盾式。\n\n# 第六章 集合代数\n\n\n\n## 6.1 集合的基本概念\n\n#### 子集 ⊆\n\n#### 空集 ∅\n\n空集的符号化表示为：∅={x|x≠x}\n\n#### n元集 \n\n含有n个元素的集合简称**n元集**，它的含有m(m≤n)个元素的子集称作它的**m元子集**\n\n对于A={1,2,3},0元子集：∅；1元子集：{1},{2},{3}；2元子集：{1,2},{2,3},{1,3}；3元子集：{1,2,3}\n\n#### 幂集 P(A)\n\n定义：把集合A的**全体子集**（包括空集）构成的集合称为A的幂集\n\n其中，P(∅)={∅}（空集是任何集合的子集），P({∅})={∅,{∅} }（想不通就把{∅}换成一个具体的数如{1}\n\n<u>例：A={1,2,3}</u>\n\n​\t\tP(A)={∅,{1},{2},{3},{1,2},{1,3},{2,3},{1,3},{1,2,3} }；\n\n​\t\tP(A)中有2<sup>n</sup>个元素，表示成|P(A)|=2<sup>n</sup>\n\n<u>例题：设A={ {∅},{ {∅} } },计算 P(A)</u>\n\n​\t✔正确答案：P(A)={∅,**{ {∅} }**,**{ { {∅} } }**,{ {∅},{ {∅} } } }\n\n​\t❌易错答案：P(A)={∅,{∅},{ {∅} },{ {∅},{ {∅} } } }\n\n​\t自己是个集合，因此A中元素外边还要加一层{}\n\n## 6.2 集合的运算\n\n#### 并集 ∪\n\n#### 交集 ∩\n\n#### 相对补集 B-A\n\nB-A={x|x∈B∧x∉A}![查看源图像](https://s2.loli.net/2022/03/30/oOJcR5diSBLE9ly.png)\n\n#### 对称差集 ⊕\n\n**A⊕B=(A—B)∪(B—A)**\n\n或者A⊕B=(A∪B)-(A∩B)\n\n![图1.对称差文氏图表示,红色区域表示对称差](https://bkimg.cdn.bcebos.com/pic/9f510fb30f2442a788b65f74d143ad4bd01302a2?x-bce-process=image/resize,m_lfit,w_1200,limit_1/format,f_auto)\n\n#### 绝对补集 ~\n\n给定了全集A，~A=E-A={x|x∈E∧x∉A}\n\n#### 广义并∪ 广义交∩\n\n![image-20220330210030656](https://s2.loli.net/2022/03/30/cmezXR26vSNT9Et.png)\n\n广义运算可以转化为初级运算：\n\n![image-20220330210109294](https://s2.loli.net/2022/03/30/VoClIgfuzYxSB9i.png)\n\n**实例**：\n\n![image-20220330210143336](https://s2.loli.net/2022/03/30/gCd9QD2pzs6JIEA.png)\n\n**注意：**\n\n∪{ {a} }={a},∩{ {a} }={a}\n\n#### 集合的运算规则\n\n一类运算：广义运算、幂集和~运算，\n\n​          **运算由右向左进行**\n\n二类运算：初级运算∪、∩、—、⊕\n\n​          **优先顺序由括号确定**\n\n**混合运算：一类运算优先于二类运算**\n\n## 6.3有穷集的计数（21年不考）\n\n#### 文氏图/韦恩图\n\n#### 包容排斥原理\n\n![image-20220330210948987](https://s2.loli.net/2022/03/30/6PANIvQVFJaml9Z.png)\n\n**|A<sub>1</sub>∪A<sub>2</sub>|=|A<sub>1</sub>|+|A<sub>2</sub>|-|A<sub>1</sub>∩A<sub>2</sub>|**\n\n**下面这一条不用记，等于|S|-|A<sub>1</sub>∪A<sub>2</sub>∪...∪A<sub>n</sub>|，将上面公式代入即可**\n\n![image-20220330210744599](https://s2.loli.net/2022/03/30/h1vyFSzjmwrkVWo.png)\n\n## 6.4 集合的恒等式\n\nP101\n\n![image-20220330211956188](https://s2.loli.net/2022/03/30/tMAncQSIfaNlkRb.png)\n\n![image-20220330212009534](https://s2.loli.net/2022/03/30/au3leXE5d1J7nML.png)\n\n![image-20220330212024361](https://s2.loli.net/2022/03/30/DdfgRioHGv6xphS.png)\n\n![image-20220330212038788](https://s2.loli.net/2022/03/30/LkfGTZ8p1MymI2C.png)\n\n\n\n# 第七章 二元关系\n\n## 7.1 有序对和笛卡尔积\n\n#### 有序对 <x,y>\n\n<x,y>\n\n#### 笛卡尔积 AXB\n\n定义：A,B为集合，用**A中元素为第一元素**，**B中元素为第二元素**构成的所有有序对组成的集合称为A和B的笛卡尔积\n\nAXB={<x,y>|x∈A∧y∈B}\n\n![image-20220330212640447](https://s2.loli.net/2022/03/30/W2KyahGgdbLt8BX.png)\n\n**特别强调**：\n\n(4)空集中取不出元素\n\nA=B且C=D的必要条件是AXC=BXD，后不能推前。例如A={1},B={2},C=∅,D=∅\n\n## 7.2 二元关系\n\n#### 二元关系\n\n定义：一个集合满足①集合非空，且它的元素都是有序对 或者②集合是空集\n\n**二元关系都可看作是某个笛卡尔集的子集**\n\n#### 定义2 \n\nA,B是集合，AXB的任何子集所定义的二元关系称作**从A到B的二元关系**(表示顺序)，特别当A=B是称作**A上的二元关系**\n\n对于任一集合A定义\n\n#### 空关系 ∅\n\n对于任何集合A，**空集∅是AXA的子集**，称作A上的**空关系**\n\n#### 全域关系E<sub>A</sub>\n\nE<sub>A</sub>={<x,y>|x∈A∧y∈A}=AXA\n\n#### 恒等关系I<sub>A</sub>\n\nI<sub>A</sub>={<x,x>|x∈A}\n\n单位阵（第一元素作行，第二元素作列）\n\n#### 小于等于关系L<sub>A</sub>\n\nL<sub>A</sub>={<x,y>|x,y∈A,x≤y}\n\n上三角矩阵\n\n#### 整除关系D<sub>A</sub>\n\nD<sub>A</sub>={<x,y>|x,y∈A,x|y}\n\nx|y,即x是y的因子\n\n#### 包含关系R<sub>⊆</sub>\n\nR<sub>⊆</sub>={<x,y>|x,y∈A,x⊆y}\n\n例如：A={∅,{a},{a,b} }\n\nR<sub>⊆</sub>={<∅,∅>,<∅,{a}>,<∅, {a,b} >,<{a},{a}>,<{a},{a,b}>,<{a,b},{a,b}>}\n\n#### 关系矩阵\n\n关系矩阵行表示第一元素，列表示第二元素，若x<sub>i</sub>Rx<sub>j</sub>则是1，否则是0\n\n#### 关系图\n\n<x<sub>i</sub>,x<sub>j</sub>>，从x<sub>i</sub>到x<sub>j</sub>的有向边\n\n## 7.3关系的运算\n\n#### 定义域 domR\n\n第一元素的集合\n\n#### 值域 ranR\n\n第二元素的集合\n\n#### 域 fldR\n\n定义域和值域的并集，即第一元素和第二元素的集合\n\n#### 逆关系 R<sup>-1</sup>\n\nR<sup>-1</sup>={<x,y>|<y,x>∈R}\n\n#### 合成运算 \n\n**看作矩阵的乘法**\n\n![image-20220330214148187](https://s2.loli.net/2022/03/30/Ofj96JnIpW8otFC.png)\n\n#### 限制\n\n取第一元素在A中的有序对。\n\n![image-20220330214257948](https://s2.loli.net/2022/03/30/gnKhVDX5JrwCbec.png)\n\nxRy: 如果<x,y>∈R，记作xRy\n\n#### 像\n\n**取限制的值域**（第二元素的集合）\n\n![image-20220330214319792](https://s2.loli.net/2022/03/30/KxTS1nF8WrONsBk.png)\n\n![image-20220330214340462](https://s2.loli.net/2022/03/30/CSvMx14cVYE2mW9.png)\n\n#### 定理\n\n合成满足结合律；第二条看作矩阵的逆\n\n![image-20220330214516993](https://s2.loli.net/2022/03/30/LZa8NVjqO3zvkP5.png)\n\nI<sub>A</sub>看作单位阵\n\n![image-20220330214607904](https://s2.loli.net/2022/03/30/TiUSxIVC4MYAnvO.png)\n\n#### 定理 7.4\n\n![image-20220406205316304](https://s2.loli.net/2022/04/06/njqN41yQowW6zfR.png)\n\n**合成运算与并满足分配律，但是和交运算不满足分配律，用包含于连接**\n\n#### 定理 7.5\n\n![image-20220406205448393](https://s2.loli.net/2022/04/06/8wfZBguKCcSqs3N.png)\n\n**限制与交、并满足分配律；像与并满足分配律，与交不满足分配律**\n\n\n\n#### n次幂R<sup>n</sup>的定义\n\n##### 定义\n\n设R为A上的关系，n为自然数，则R的n次幂R<sup>n</sup>定义为\n\n1）R<sup>0</sup>={<x,x>|x∈A}=I<sub>A</sub>}\n\n2）R<sup>n+1</sup>=R<sup>n</sup>∘R\n\n**注意**：由定义1)我们可知∅<sup>0</sup>结果也是I<sub>A</sub>\n\n\n\n##### 关系矩阵\n\n有：\n\n1）M<sub>R<sub>1</sub>∘R<sub>2</sub></sub>=M<sub>R<sub>1</sub></sub>M<sub>R<sub>2</sub></sub>\n\n2）M<sub>R<sup>n</sup></sub>=M<sub>R</sub><sup>n</sup>\n\n**注意**：这里M带角标R表示的是R的关系矩阵\n\n\n\n#### R<sup>n</sup>重复性定理\n\n**定理：**\n\n设A为n元集，R是A上的关系，则存在自然数s和t，使得R<sup>s</sup>=R<sup>t</sup>\n\n**理解** 因为R是A上的关系，对于任何自然数k，R<sup>k</sup>都是AXA的子集（二元关系都可以看作是某个笛卡尔积的子集）.又|AXA|=n<sup>2</sup>（A是n元集），所以其子集总数为2<sup>n<sup>2</sup></sup>个。因此可知，R<sup>k</sup>的取值情况是有限的，最多也就2<sup>n<sup>2</sup></sup>个不同的值，然而R的幂是无穷多的，因此必有重复的\n\n#### R<sup>n</sup>关系图的规律\n\n![image-20220406211644948](https://s2.loli.net/2022/04/06/6BCpUZt7aQ4ymsV.png)\n\n由定义可知R<sup>2</sup>=R∘R,这里假设等号右边取<a,b>,<b,c>,结果是<a,c>。此时在R和R<sup>2</sup>的关系图中我们可以看到R这边从第一个元素a走到b走了一步，b到c又走了一步一共**走了两步**对应到了**R<sup>2</sup>**中的a→c。而R上所有第一元素能**走三步**到另外一个元素的情况就构成了**R<sup>3</sup>**的关系图。\n\n\n\n### 7.4 关系的性质\n\n#### 自反与反自反\n\n![image-20220406212613972](https://s2.loli.net/2022/04/06/ry9sLtaxVpnNqjO.png)\n\n例题：\n\n![image-20220406212640736](https://s2.loli.net/2022/04/06/PAbF3LIhuj9kdom.png)\n\n![image-20220406212651743](https://s2.loli.net/2022/04/06/fS359prnqDMJkyH.png)\n\n这里注意R<sub>2</sub>既不是自反，也不是反自反。因为定义中要求是**对于任意的x**而当x取1、2的时候在R<sub>2</sub>中都有对应的<x,x>。两个条件都不满足，故既不是自反，也不是反自反。\n\n一个关系不可以既是自反又是反自反。\n\n![image-20220406212952970](https://s2.loli.net/2022/04/06/eKI6aXNwqpkAWgs.png)\n\n#### 对称与反对称\n\n![image-20220406213117022](https://s2.loli.net/2022/04/06/Evgb3YkWPcNI9l5.png)\n\n例题：\n\n![image-20220406213134339](https://s2.loli.net/2022/04/06/9zkvCMAljLXT3G5.png)\n\n**这里R<sub>3</sub>是反对称因为前件为假，蕴含式结果为真**而空集即是对称也是反对称也是前件为假的原因。\n\n对称也就是说如果我R里面的有序对的元素是A的元素那么这些有序对的一二元素交换也得是我R里的元素\n\n**判断反对称只需要找x≠y的关系，如果有<x,y>那么<y,x>必不能在，对于所有的都满足那么就有是反对称的**\n\n#### 传递\n\n![image-20220406214546687](https://s2.loli.net/2022/04/06/KnwZhSOA5EG24Qu.png)\n\n**也就是说若R中有能合成的有序对，那么其结果也在R内。**\n\n\n\n#### 关系性质的充分必要条件\n\n设R为A上的关系，则\n\n![image-20220406214736110](https://s2.loli.net/2022/04/06/ovDQp8JUL2XbBIN.png)\n\n五种性质：自反性、反自反性、对称性、反对称性、传递性\n\n**注意：**\n\n* 自反性是对于任意的x而言的，也就是说**所有的<x,x>都应该在R里**！反自反同理，即不能够出现<x,x>！\n* 一个关系不能既是自反的又是反自反的\n* **一个关系可以既是对称的也是反对称的**\n\n例: A={1,2,3},R是A上的关系，R1={<1,1>,<2,2>}，R2={<1,1>,<2,2>,<3,3>,<1,2>}，R3={<1,3>}\n\n答：R1具有对称性、反对称性，**既不是自反也不是反自反**；R2具有自反性；R3是反自反的。\n\n\n\n用关系矩阵记忆：自反性则主对角线全是1，反自反性则主对角线上全是0，对称性矩阵是对称矩阵，反对称性若r<sub>ij</sub>为1则r<sub>ij</sub>为0，传递性，M<sup>2</sup>中1所在的位置对应M上也是1.\n\n### 7.5 关系的闭包\n\n**闭包就是最少的添加**\n\n#### 闭包的关系图\n\n设关系*R*, *r*(*R*), *s*(*R*), *t*(*R*)的关系图分别记为 *G* ，*G<sub>r</sub>* ， *G<sub>s </sub>*，G<sub>t</sub> ,，则 G<sub>r</sub> ，G<sub>s</sub> ，*G<sub>t</sub>* 的顶点集与 *G* 的顶点集相等. 除了 *G* 的边以外, 以下述方法添加新的边： \n\n(1) 考察*G* 的每个顶点, 若没环就加一个环，得到 *G<sub>r</sub>*  \n\n(2) 考察 *G* 的每条边, 若有一条*x<sub>i</sub>* 到 *x<sub>j</sub>* 的单向边, *i*≠*j*, 则在 *G* 中加一条*x<sub>j</sub>* 到 *x<sub>i</sub>* 的反向边, 得到 *G<sub>s</sub>*\n\n(3) 考察 *G* 的每个顶点 *x<sub>i</sub>* , 找 *x<sub>i</sub>* 可达的所有顶点 *x<sub>j</sub>*  (允许*i=j* )*，* 如果没有从 *x<sub>i</sub>* 到 *x<sub>j</sub>* 的边, 就加上这条边, 得到图 *G<sub>t</sub>*\n\ntsr(R)=t(s(r(R)))，表示R的自反、对称、传递闭包，从里到外。\n\n### 7.6 等价关系与划分\n\n#### 等价关系\n\n设R为非空集合A上的关系。如果R是**自反的、对称的和传递的**，则称R为A上的等价关系。（对角线全为1，且是对称矩阵，M<sup>2</sup>的1对应M也是1）\n\n#### 等价类\n\nx的等价类 [x]<sub>R</sub>={y|y∈A∧xRy}\n\n通俗来说就是**R中哪些第一元素是x就把第二元素拿出来**\n\n#### 商集\n\n设R为非空集合A上的等价关系，以R的**所有等价类作为元素**（不同块的集合）的集合成为A关于R的商集，记作A/R，即 A/R={[*x*]<sub>R</sub>|*x*∈*A*}\n\n例如：\n\n![image-20220618193029669](https://s2.loli.net/2022/06/18/dBY9OeNqj3Tm8zU.png)\n\n其中的等价类有：[1]=[4]=[7]={1,4,7}，[2]=[5]=[8]={2,5,8}，[2]=[6]={3，6}\n\n商集为：{ {1,4,7}，{2,5,8}，{3,6} }\n\n#### 划分\n\n满足条件：\n\n1. 是A子集的构成的集合\n2. 空集不存在里面 \n3. 子集的交集是空集\n4. 这个子集族*π*(A的子集构成的集合，*π*⊆P(A))的并集就是A \n\n则称*π*是A的一个划分，称*π*中的元素为A的划分块。\n\n例：A={a,b,c,d}，给定*π<sub>1</sub>*={ {a}，{a,b,c,d} }，*π<sub>2</sub>*={∅，{a,b}，{c,d} }，*π<sub>3</sub>*={ {a,b}，{c}，{d} }，则*π<sub>1</sub>*和*π<sub>2</sub>*都不是A的划分，*π<sub>3</sub>*是A的划分（可以不止一个划分）。\n\n**在等价关系中，划分就是商集，划分块就是等价类。**\n\n### 7.7 偏序关系\n\n#### 小于等于\n\n设R为非空集合A上的关系。如果R是自反的、**反对称的**和传递的，则称R为A上的偏序关系，记为**≼**。设**≼**为偏序关系，如果<x,y>∈**≼**，则记作x**≼**y，读作x”小于等于“y。\n\n**注意：**这里的”小于等于“（也可理解为大于等于）不是指数的大小，而是指在偏序关系中的顺序性。依照不同定义的序，x排在y的前边或者x就是y。\n\n三种符号：\n\n* xRy：<x,y>∈R\n* x~y：<x,y>∈R且R是等价关系\n* x**≼**y：<x,y>∈R且R是偏序关系\n\n例如，恒等关系I<sub>A</sub>，小于等于关系L<sub>A</sub>、整除关系D<sub>A</sub>和包含关系R<sub>⊆</sub>都是相应集合上的偏序关系。一般全域关系E<sub>A</sub>不是A上的偏序关系\n\n定义：\n\n* 若x**≼**y ∧ x ≠ y **,** 则记作x≺y,读作x小于y。 （x≺y说明<x,y>∈R∧x≠y）\n* x与y可比有三种情况：x=y，x≺y，y≺x\n\n例如，A={1,2,3}，**≼**是A上的整除关系，则有1≺2，1≺3；1=1，2=2，3=3；2和3不可比（不满足整除）\n\n#### 全序关系\n\n设R为非空集合A上的偏序关系，如果∀x,y∈A，**x与y都是可比的**，则称R为A上的全序关系\n\n#### 偏序集\n\n集合A和A上的偏序关系一起叫做偏序集≼，记作<A,≼>。\n\n#### 覆盖\n\n*x*≺*y*且 *x*，*y* 之间没别的元素，则称 *y* 覆盖 *x*。\n\n#### 哈斯图\n\n只连覆盖关系，y覆盖x则把y画在x上方\n\n例：偏序集<{1,2,3,4,5,6,7,8,9}，整除关系>和<P({a,b,c},R<sub>⊆</sub>)的哈斯图\n\n![image-20220619085448843](https://s2.loli.net/2022/07/01/QDY1jig5BVlvt9k.png)\n\n#### 最小元、最大元、极小元、极大元\n\n<A,≼>为偏序集，B⊆A，**y∈B**\n\n* 最小(大)元：y小于(大于)等于B中的**任何一个元素**\n* 极小(大)元：B中没有其他元素小于(大于)我\n\n例：A={1,2,...,36}上的整除关系，B={2,3,4,12}\n\n最小元：无（不会是2，因为2没办法整除3，不满足y小于等于B中的任何一个元素） \n\n最大元：12（12可以大于等于2,3,4） \n\n极小元：2，3（没有再可以整除2和3的了，有两个）\n\n极大元：12（没有12能整除的数了）\n\n#### 上界、下界\n\n<A,≼>为偏序集，B⊆A，**y∈A**（y不同于上面的定义，这个范围更大）\n\n* 上界和下界**定义和最大元和最小元相同**，不同的是y的范围。\n\n* C={y|y为B的上界}，则称C的**最小元**为B的**最小上界或上确界**。（上界中的最小）\n* D={y|y为B的下界}，则称D的**最大元**为B的**最大下界或下确界**。（下界中的最大）\n\n**注意：**\n\n1. B的上界、下界、最小上界、最大下界都可能不存在\n2. 如果存在，最小上界与最大下界是唯一的，而上下界不一定唯一\n3. **集合中如果存在最小元，那么这个最小元就是其最大下确界；最大元是上确界**\n4. 画出哈斯图一般会有利于判断\n\n例：A={1,2,...,36}整除关系，B={6,12,18}，C={4,6,12}\n\nB的最小元是6，下界是1,2,3,6。下确界即为最小元6\n\nB的最大元没有，上界是36，上确界为36\n\nC的最小元没有，下界是1,2，下确界为2\n\nC的最大元为12，上界为12,24,36，上确界为最大元12\n\n# 第十四章 图的基本概念\n\n## 14.1 图\n\n无序积：{ {a,b}|a∈A∧b∈B}，记作A&B\n\n无序积中的无序对记作(a,b)\n\n### 二元组\n\n一个无向图*G*是一个有序的二元组<V,E>，其中\n\n* V是一个非空有穷集，称作**顶点集**，其元素称作**顶点**或**结点**\n* E是一个无序积V&V的有穷多重子集(可重复)，称为**边集**，其元素称作**无向边**，简称为**边**\n\n而有向图的二元组中的E的元素为**有向边**\n\n### 图\n\n* **图**，有向图和无向图的统称\n* **阶**，顶点数称作图的阶，n个顶点的图称作**n阶图**\n* **零图**，一条边也没有的图；**平凡图**，1阶零图称作平凡图，只有一个顶点，没有边\n* 定义中V要是非空的，但是运算中可能会出现顶点集为空集的情况，规定<u>顶点集为空集</u>的图为**空图**，记作∅\n* 如果给每一个顶点和每一条边指定一个符号，称这样的图为**标定图**，否则非标定图\n\n### 相邻\n\n对于无向图，若两个顶点 *v<sub>i</sub>* 与 *v<sub>j</sub>* 之间有一条边连接，则称这两个**顶点相邻**。若两条边至少有一个公共端点，则称这两条**边相邻**\n\n对于有向图，顶点之间有一条有向边则相邻，两条边一条的终点是另一条的起点，则两条边相邻\n\n没有边关联的顶点称作孤立点\n\n\n\n* 无向图G=<V,E>中，\n  * 邻域是所有与我相邻的点，不包括我自己\n  * 闭领域是邻域并上子集\n  * 关联集是所有与我关联的无向边(环那条也算)\n* 有向图D=<V,E>中，\n  * 有向图的先驱元集和后继元集的定义中<u,v>,u不等于v，即不能是自己(环的情况)\n  * 邻域是先驱元集和后继元集的并\n  * 闭邻域即邻域加上自己\n\n### 平行边\n\n无向图中，关联一对顶点的两条或以上的边为平行边\n\n有向图中，关联一对顶点的有向边多于1条，称为平行边\n\n### 简单图\n\n含平行边的图称作**多重图**(存在相同的无序对)\n\n既<u>不含平行边</u>也<u>不含环</u>的图称作**简单图**\n\n### 度数\n\n无向图中，v作为边的端点的次数称为度数，记为d(v)\n\n有向图中，v作为边的始点的次数为v的**出度**，记为**d<sup>+</sup>(v)**；作为边的终点的次数为v的**入度**，记为**d<sup>-</sup>(v)**\n\n#### **度数列**\n\n就是把各个顶点的度数列出来d(v1)= ,d(v2)=,...\n\n#### 最大度Δ(G)\n\n#### 最小度![img](D:/Typora/images/clip_image002.png)(G)\n\n### 握手定理\n\n在任何无向图中，所有顶点的度数之和等于边数的2倍\n\n### 可图化\n\n* 给定的非负整数列d=(d1,d2,..,dn)，若存在以V={v1,v2,...,vn}为顶点集的n阶无向图G，使得d(vi)=di，则称d是可图化的（即每个顶点度数要够）\n* 可简单图化：若得到的图是简单图，则d是可简单图化的\n\n判断方法：非负整数列d=(d1,d2,..,dn)是可图化的当且仅当奇数度顶点个数为偶数\n\n例：(3,3,2,1)和(3,2,2,1,1)奇数度顶点个数为3，不是偶数，不是可图画的。而(3,3,2,2)和(3,2,2,2,1)画一下图发现满足，是可图化的\n\n### 完全图\n\n* n阶完全图，G中每个顶点均与其余的n-1个顶点相邻称为n阶无向完全图，简称n阶完全图\n* n阶有向完全图，有向图D中每个顶点都邻接到其余的n-1个顶点\n* n阶竞赛图，基图为K<sub>n</sub>的有向简单图\n\n## 14.2 通路与回路\n\nG为无项标定图，，G中顶点与边交替的序列Г=v<sub>i<sub>0</sub></sub>e<sub>j<sub>1</sub></sub>v<sub>i<sub>1</sub></sub>e<sub>j<sub>2</sub></sub>...e<sub>j<sub>l</sub></sub>v<sub>i<sub>l</sub></sub>称为从起点v<sub>i<sub>0</sub></sub>到终点v<sub>i<sub>l</sub></sub>的通路，Г中边的条数称为它的长度。\n\n### 回路\n\n若起点和终点相同，则称Г为**回路**。\n\n### 简单通路、简单回路\n\n若Г所有边各异，则称Г为简单通路；若简单回路的起点和终点相同，则称为简单回路。\n\n### 初级通路、初级回路（圈）\n\n若所有顶点各异（除起点和终点可能相同外），所有边也各异，则称Г为初级通路；若又有起点和终点相同，则称为初级回路或**圈**\n\n### 注意\n\n* 初级包含于简单，简单回路包含于简单通路，但是初级回路和初级通路在应用中完全分开。\n* 长为1的圈（初级回路）只能由环生成，长为2的圈只能由平行边生成；而在简单无向图中，圈的长度至少为3，因为简单无向图中没有环和平行边。\n\n\n\n## 14.3 图的连通性\n\n### 距离d(u,v)\n\n无向图G中u,v之间长度最短的通路为u,v之间的短程线，短程线的长度成为u,v之间的距离，记作d(u,v)。\n\n### 点割集、边割集\n\n**全部拿掉后，连通分支数增加**、只拿掉其中一部分不影响。\n\n#### 割点、桥\n\n点割集{v}，则v是割点，同理的边成为桥（割边）。\n\n\n\n无向连通图不一定有点割集（如K<sub>n</sub>），但一定有边割集（只要去掉足够多的边，一定会有点连不上）\n\n### 点连通度k(G)、边连通度λ(G)\n\n**想把我从连通图变为非连通图，则至少删去k个顶点/边**\n\n### 短程线、距离d<vi,vj>\n\n![image-20220531205953526](https://s2.loli.net/2022/07/01/3oyhEsNbURWPaBd.png)\n\n短程线，最短的通路；短程线的长度称为距离\n\n### 连通图、单向连通图、强连通图\n\n#### 定义\n\n若有向图D的基图是连通图，则称D为**弱连通图**，简称为**连通图**。（一眼看上去是一个整体）\n\n若∀v<sub>i</sub>,v<sub>j</sub>∈V,v<sub>i</sub>→v<sub>j</sub>与v<sub>j</sub>→v<sub>i</sub>至少成立其一，则称D为**单向连通图**。\n\n若∀v<sub>i</sub>,v<sub>j</sub>∈V,均有v<sub>i</sub>↔v<sub>j</sub>，则称D为**强连通图**。（任意两点相互可达）\n\n连通图⇒单向连通图⇒强连通图，条件要求越来越高\n\n#### 判别定理\n\n定理 14.8 有向图D=<V,E>是强连通图当且仅当D中存在**经过每个顶点至少一次的回路**。\n\n定理 14.9 有向图D是单向连通图当且仅当D中存在经过每个顶点至少一次的**通路**。（只需证v<sub>i</sub>可达v<sub>j</sub>或v<sub>j</sub>可达v<sub>i</sub>）\n\n### 二部图\n\n将无向图划分成两部分V1和V2，使得每条边的两个端点都是一个属于V1，一个属于V2，则称无向图G为**二部图**。（环一定不是）\n\n若G是简单二部图且V1中的每个顶点与V2中所有顶点相邻（有一条边相连），则称G为完全二部图，记为K<sub>r,s</sub>,其中r=|V1|,s=|V2|。\n\n**注意**：n(n≥2)阶零图为二部图\n\n将图按如下方式尝试分成两部分，判断(a)为二部图\n\n![image-20220531211814859](https://s2.loli.net/2022/05/31/RqcJILXosA17Faw.png)\n\n（e)为完全二部图，上面r个点，下面s个点，共有rxs条边，点连通度为min{r,s}，即拿掉少的部分的所有点；边连通度也为min{r,s}，即拿掉一个点的所有边。\n\n\n\n![image-20220531212002901](https://s2.loli.net/2022/05/31/kTAwNU6YtSbms93.png)\n\n## 14.4 图的矩阵表示\n\n### 关联矩阵M(G)\n\n关联矩阵表示的是顶点和边的关系，行是各点，列是各边，记录**关联次数**（注意无向图中环的点边关联次数为2）\n\n有向图中无环的关联矩阵中，用1表示这个点是这条边的始点，0表示不关联，-1表示这个点是这条边的终点\n\n### 邻接矩阵A(D) (有向图)\n\n有向图，表示从顶点vi邻接到顶点vj有多少条边，行和列都是点。\n\n**vi指向vj才加1，环自身加1**\n\n邻接矩阵A和A<sup>*l*</sup>反应的几个信息：\n\n* a<sub>ij</sub><sup>(*l*)</sup>为D中v<sub>i</sub>到v<sub>j</sub>长度为 *l* 的**通路数**\n* 对角线上的a<sub>ii</sub><sup>(*l*)</sup>表示到自身长度为 *l*的**回路数**\n* 矩阵**所有元素之和**表示D中长度为 *l* 的**通路（含回路）总数**\n* 其中**对角线元素之和**表示长度为 *l* 的**回路总数**\n\n### 可达矩阵P(D) (有向图)\n\n**首先首先，对角线先全标上1，自己可达自己**\n\nvi**可达**vj则标上1，否则为0\n\n**注意：**什么叫可达？不是说一步走到是可达，而是存在通路即可，走多少步没关系，只要能走到就是可达！\n\nD为强连通当且仅当P(D)为全1矩阵\n\n# 第十五章 欧拉图与哈密顿图\n\n## 15.1 欧拉图\n\n### 欧拉通路\n\n通过图（无向图或有向图）中<u>**所有边**一次且仅一次行**遍所有顶点**</u>的通路称作**欧拉通路**。\n\n### 欧拉回路\n\n通过图中所有边一次且仅一次行遍所有顶点的回路称作**欧拉回路**。\n\n### 欧拉图\n\n具**有欧拉回路**的图称作欧拉图。\n\n### 半欧拉图\n\n具有欧拉通路**而无欧拉回路**的图称作半欧拉图。\n\n### 注意1\n\n* 规定平凡图是欧拉图。(平凡图是只有一个孤立点组成的图)\n* 欧拉通(回)路是简单通(回)路，但不一定是初级通(回)路。因为欧拉可以走环，而走了环就不满足所有点各异的条件，也就不是初级。\n\n\n\n### 无向欧拉图的判别方法\n\n定理15.1 无向图G是欧拉图当且仅当G是连通图且**没有奇度顶点**。\n\n​\t即顶点的度数为偶数。理解：因为经过一个点需要走进来再走出去，而度数是由边提供的，故顶点度数为偶数。\n\n定理 15.2 无向图G是半欧拉图当且仅当G是连通的且**恰有两个奇度顶点**。\n\n\n\n### 有向欧拉图的判别方法\n\n定理 15.3 有向图D是欧拉图当且仅当D是**强连通**的且每个顶点的**入度等于出度**（度数为偶）。\n\n​\t一个图要是欧拉图它得首先是个强连通图。\n\n定理 15.4 有向图D是半欧拉图当且仅当D是**单向连通**的且恰**有两个奇度顶点**，其中一个顶点的入读比出度大1，另一个顶点的出度比入度大1，而其余顶点的入度等于出度。\n\n​\t一个图是半欧拉图它得首先是个单向连通图\n\n### 定理15.5 \n\nG是非平凡的欧拉图当且仅当G是连通的且是**若干个边不重的圈（无向）的并**。\n\n很好理解，如果是若干个边不重的圈的并，那么每个点度数都为偶\n\n\n\n## 15.2 哈密顿图\n\n* 经过图（有向图或无向图）中所有**顶点**一次且仅一次的<u>初级通路</u>称为**哈密顿通路**。\n\n* 经过图中所有顶点一次且仅一次的<u>初级回路</u>称为**哈密顿回路**。\n* 具有哈密顿回路的图称为**哈密顿图**。\n* 具有哈密顿通路但不具有哈密顿回路的图称为**半哈密顿图**。\n\n首先哈密顿通路一定是初级通路。但是对于哈密顿回路，如果加是初级回路的前提，那么哈密顿回路可以不是初级回路，例如v<sub>1</sub>ev<sub>2</sub>ev<sub>1</sub>，出现了重复的边，不是初级回路，但它确实是经过所有顶点一次且仅一次的回路。\n\n### 哈密顿图的必要条件\n\n定理15.6 无向图G<V,E>是哈密顿图，则对于任意V<sub>1</sub>⊂V,且 V<sub>1</sub>≠∅，均有**p(G-V<sub>1</sub>)≤|V<sub>1</sub>|**。\n\n​\tp是连通分支数，理解:分两种情况，一种v1,v2不相邻，去掉三个点，连通分支数为3；一种v1,v2相邻，与v3不相邻，去掉后两部分；当然如果都相邻去掉后为1，都满足p≤3\n\n![image-20220601214204395](https://s2.loli.net/2022/06/01/B1ZOlvX5JsitxDe.png)\n\n是半哈密顿图，则有**p(G-V<sub>1</sub>)≤|V<sub>1</sub>|+1**\n\n**作为必要条件，用来初步判断其不是哈密顿图/半哈密顿图**\n\n\n\n\n\n看看完全二部图什么时候是哈密顿图，用必要条件初步判别\n\n![image-20220601215140909](https://s2.loli.net/2022/06/01/Kdf9GhsgUN8lorq.png)\n\n### 哈密顿图的充分条件\n\nG为n阶无向简单图，若对于G中任意不相邻的顶点u,v,均有度数和**d(u)+d(v)≥n-1**，则G中存在哈密顿通路。\n\n（存在哈密顿通路说明其可能是哈密顿图也可能是半哈密顿图\n\n**推论：**设G为n(n≥3)阶无向简单图，若对于G中**任意两个不相邻的顶点**u*,*v*均有 **d(u)+d(v)≥n***则 *G* 中存在哈密顿图\n\n### 哈密顿图解决实际问题\n","tags":["数学"],"categories":["本科课程"]},{"title":"云服务器搭建mc服务器经验总结","url":"/2022/03/04/云服务器搭建mc服务器经验总结/","content":"\n## 首先\n\n​\t我的云服务器是轻量化服务器2核4G，ubuntu，指令不同就是`yum`要改成`apt` hhh\n\n刚开始照这网上做就是因为这个导致一开始就失败哈啊哈哈哈。\n\n温馨提示：以下只是很粗糙的总结，如果真要动手的话建议还是直接到文章最下面去看看一些大佬的教程\n\n## 配置一下服务器叭\n\n1.密钥、密码设置好\n\n2.添加一个端口25565（阿里云是没有开这个的）\n\n3.重启\n\n## 下几个软件连接服务器\n\n​\t我这边用的是Xshell 6和FlashFXP 5。通过服务器公网ip和账号密码连接上就可以了\n\n## 安装JAVA 17.0.1\n\n这里千万注意！\n\n1.装的是linux的，不要把自己电脑windows的放上去啊\n\n2.版本！Linux x64 Compressed Archive\n\n否则：unable to access jarfile\n\n3.我是在电脑下载好安装包，用flashxp放上去根目录然后在Xshell解压\n\n​\t`tar -zxvf [文件名加.gz]`\n\n## 直接把自己原来的整个服务端文件打包上传上去\n\n如果你用过自己的电脑开过服的就很方便了，因为启动脚本全部已经都写好了（ 比如start.sh ）！利用FlashFXP上传文件到服务器里。（但是要开放执行权限！！！）上传后--文件右键--属性 权限全部勾上简单粗暴\n\n## 开搞！\n\n装screen,后台运行用\n\n`apt install screen`\n\n然后开窗口\n\n`screen -S [自定义窗口名]`\n\ncd到start.sh的文件夹下\n\n`./start.sh`\n\n这里有可能会遇到打不开的问题：bad interpreter\n\n这就需要把start.sh的doc改成unix。怎么改网上都有\n\n然后重新\n\n`./start.sh`\n\n看到Done!就搞定了！\n\n在mc多人游戏里直接连接-输入ip就能成功连接了！\n\n这里screen还是有一些其他指令的，比如\n\n`screen -ls`\n\n可以查看现在在运行的指令。\n\n连接screen\n\n\n\n其他的上网查查看吧\n\n【参考资料】\n\n1.[零基础！使用云服务器搭建Minecraft服务器 - 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv12182680)\n\n2.[【MC开服教程】十分钟手把手教你怎么用白嫖来的阿里云ECS搭建一台mc服务器|Linux搭建mc服务器_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1PE411c7t9?from=search&seid=16777632017936702084&spm_id_from=333.337.0.0)\n\n3.[我的世界百分百成功搭建 阿里云 百度云 腾讯云服务器教程，超简单！！！！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV13N411o7TU?from=search&seid=16777632017936702084&spm_id_from=333.337.0.0)\n\n这里上几张和舍友联机的截图吧，取名就是我们的宿舍号G318。其中大部分建筑都是FireEgg搭建的，他是MC骨灰级玩家了。\n\n![image.png](https://s2.loli.net/2022/11/14/M4THJ3EGXKFuBQ7.png)\n\n![image.png](https://s2.loli.net/2022/11/14/h6iJoU3CX1PyTOS.png)\n\n![image.png](https://s2.loli.net/2022/11/14/hTa8FjprsiPbwYD.png)\n\n![image.png](https://s2.loli.net/2022/11/14/jWkLn4vxqa9DXyS.png)\n","tags":["教程","服务器","云服务器","minecraft"],"categories":["经验"]},{"title":"my-first-blog","url":"/2022/03/03/my-first-blog/","content":"\n这是我的第一个博客文章\n"},{"title":"Hello World","url":"/2022/03/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n```bash\n$ hexo clean  //清除缓存\n$ hexo g  //生成静态文件\n$ hexo s  //启动本地服务\n$ hexo d //上传\n```\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]