<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JJ的算法之旅 | yjchen</title><meta name="author" content="JJuprising"><meta name="copyright" content="JJuprising"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JJ的算法之旅"><meta name="application-name" content="JJ的算法之旅"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JJ的算法之旅"><meta property="og:url" content="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/index.html"><meta property="og:site_name" content="yjchen"><meta property="og:description" content="kk&amp;#x3D;kk&amp;amp;(kk-1)，可以消除kk二进制的最后一个1 1#include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;  参考https:&amp;#x2F;&amp;#x2F;labuladong.gitee.io&amp;#x2F;algo&amp;#x2F;home&amp;#x2F; 123# 找到数组中的最大值及其索引 速度更快    max_num &amp;#x3D; ma"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://jjuprising.github.io/img/default_cover.jpg"><meta property="article:author" content="JJuprising"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jjuprising.github.io/img/default_cover.jpg"><meta name="description" content="kk&amp;#x3D;kk&amp;amp;(kk-1)，可以消除kk二进制的最后一个1 1#include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;  参考https:&amp;#x2F;&amp;#x2F;labuladong.gitee.io&amp;#x2F;algo&amp;#x2F;home&amp;#x2F; 123# 找到数组中的最大值及其索引 速度更快    max_num &amp;#x3D; ma"><link rel="shortcut icon" href="/images/sta_logo.jpg"><link rel="canonical" href="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: JJuprising","link":"链接: ","source":"来源: yjchen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'yjchen',
  title: 'JJ的算法之旅',
  postAI: '',
  pageFillDescription: '参考, 基础知识, 模板, 输入输出, 构造, 字符串, 二进制与位运算, 基础运算, 位运算, STL C++, 注意, python, c++, 数据结构及基本操作, 括号匹配, 哈夫曼树, 链表, 合并k个有序链表, 单链表的倒数第k个节点, 单链表的中点, 链表是否有环, 两个链表是否相交, 数组, 普通数组, 哈希表, 快慢指针技巧, 二分法, 双指针, 子串, 前缀和, 二叉树, 前中序构造, 中序后序, 前序后序, 搜索, 广度优先BFS, 递归, Hanoi塔, DFS, 图论, 存储, 邻接矩阵, 邻接表, 区别, 并查集(Disjoint Set Union), 最小生成树, Kruskal 加边法, Prim, 最短路径, floyd, 拓扑排序, 回溯算法, 组合和排列, 排序算法, 堆排序, 动态规划, 跳楼梯, 最大子段和, 最大序列和, 字符串区间翻转 题意转换, 最长递增子序列, 最长公共子序列 二维dp, 最少编辑长度, 乘积最大子数组, 完全平方, 背包问题, 简化版背包, 常规01背包, 状态压缩, 数论, 质数, 素数筛选, 背住最大公约数最小公倍数Floyd 算法！！！, 完全平方数, 高精度, SCNUOJ, P01 最大二叉树, ！P02. [算法课分治] 寻找多数, P03. [算法课分治] 找到最大子序和, P04. [算法课分治] 找到 k 个最小数, P05. [算法课分治] 寻找第 k 个最大元素, P06. [算法课动态规划]走网格, P07. [算法课动态规划]爬楼梯, P08. [算法课动态规划]背包问题, P09 最长回文子串, P10 连续数组最大, ⭐P11 最长公共子序列, P12 贪婪 6和9组成的最大数字, P13 贪婪 三角形的最大周长, P14 蛮力 种花问题, ❗P15 贪婪 移掉K位数字(有一步没搞懂), P16 贪婪 盛最多的水, P17 回溯 括号生成 void backTracking(int left int right string curstr), P18 回溯 目标和 void check(int nums[] int tar int n), P19 回溯 电话号码的字母组合 void backtracking(const stringamp sint indexstring curStr) 输入序列 序列号 可能组合, P20 回溯 优美的排列 void backtracking(int pos int n) 位置数 长度, P21 组合 void backTracking(int nint kint startIndex) 长度 个数 遍历位置, P22 回溯 大礼包, P23 计数排序, P24 贪心 跳跃游戏, P25 动规 整数拆分, P26 动态规划 打家劫舍, P27 动态规划 戳气球, P28 贪心 跳跃游戏, P29 指针 颜色分类可以消除二进制的最后一个参考找到数组中的最大值及其索引速度更快背包问题天平称手写数据结构代码链表二叉树蓝桥杯省左孩子右兄弟前缀和二分差分刷动态规划时间复杂度控制在基础知识模板输入输出输入样例输入样例第一行输入两个整数第一个代表数组的长度第二个代表数字与数字之间用空格间开第二行输入一行数字代表数组数字与数字之间用空格间开输入样例注意这个输入是按行的分割构造构建二维数组大坑引用方式修改每一列的第都会跟着字符串大小写转换函数法函数将所有字母都转换成大写函数将所有字母都转换成小写函数将首字母都转换成大写其余小写函数将每个单词的首字母都转换成大写其余小写码用转码用转字符注意没有字符概念小写字母大小写字母之前差了函数可以将编码数值转为字符没有字符的概念不是小写字符原样输出转二进制与位运算基础运算整数除法返回商的整数部分忽略余数输出取模运算符返回除法的余数输出幂运算符计算第一个操作数的第二个操作数次方输出逻辑运算逻辑运算符处理布尔值包括逻辑与只有两边的操作数都为时结果才为逻辑或只要有一个操作数为结果就为逻辑非对一个布尔值进行否定输出输出输出身份运算符比较两个对象是否为同一对象而非仅看其值是否相等判断两个对象是否引用同一个内存地址即它们是否是同一个实例输出因为和指向同一列表对象输出尽管和的元素相同但它们是不同的列表实例与相反用于检查两个对象是否引用不同的内存地址输出对字符串采用机制所以相同的字符串字面量会指向同一内存地址输出因为和是的不同实例位运算位运算符处理整数的二进制表示包括按位与对于两个对应位如果都是则结果为否则为按位或只要有一个对应位为则结果为否则为按位异或当两个对应位不同时结果为否则为按位取反对一个数的所有位进行翻转即将变为变为左移运算符将数字的所有二进制位向左移动指定的位数右移运算符将数字的所有二进制位向右移动指定的位数例如输出二进制下和按位与的结果是输出二进制下和按位或的结果是初始化入栈判空栈顶元素出栈最后一个元素删除元素删除指定元素输出构造生成空字符串生成的复制品结果为从的第开始复制个结果为以前个作为粗值结果为生成个字符结果为将字符串中从下标开始到字符串结束的位置作为字符串初值读取读数组整行读插入在原串下标为的字符前插入字符串在原串下标为的字符前插入个字符将字符串从下标为的开始数个字符分别是插入原串的下标为的字符前长度移除查找返回值为功能将所指向的某一块内存中的每个字节的内容全部设置为指定的值块的大小由第三个参数指定这个函数通常为新申请的内存做初始化工作用法对比用来做内存拷贝你可以拿它拷贝任何数据类型的对象可以指定拷贝的数据长度例注意如用会造成的内存地址溢出就只能拷贝字符串了它遇到就结束拷贝例如用要注意中的字符串长度第一个之前是否超过位如超过则会造成的内存地址溢出插入查找一个元素返回的映射的迭代器在容器中寻找值为为的元素返回该元素的迭代器否则返回取值对应对应清空删除一个元素迭代器刪除关键字删除如果刪除了返回否则返回用迭代器范围刪除把整个清空等同于返回指向头部的迭代器返回指向末尾的迭代器判空注意这里是引用变变或者计时超时之诺很多然而在百度之星一直超时最后发现是的问题当数组很大时比较费时害我罚了几次时超时之二维数组开大了在诺前个达到重量的可行度狠狠超时然后改成前个达到重量的可行度运行出错数组开小了和答案不对的一个重要原因没有说明是的就得换一种方式读取如果保持的方式就会错读取方式有可能会造成运行超时超时版不超时版数据结构及基本操作数组遍历迭代访问链表迭代递归基本的单链表节点是类型注释的一部分用于说明函数的返回类型迭代访问递归访问二叉树递归基本的二叉树节点递归遍历左子树递归遍历右子树前序位置中序位置后序位置括号匹配括号匹配栈这种可不对应该先配对好才能再配对如果为空入栈栈空才成哈夫曼树合并果子诺计算机考研在一个果园里多多已经将所有的果子打了下来而且按果子的不同种类分成了不同的堆多多决定把所有的果子合成一堆每一次合并多多可以把两堆果子合并到一起消耗的体力等于两堆果子的重量之和可以看出所有的果子经过次合并之后就只剩下一堆了多多在合并果子时总共消耗的体力等于每次合并所耗体力之和因为还要花大力气把这些果子搬回家所以多多在合并果子时要尽可能地节省体力假定每个果子重量都为并且已知果子的种类数和每种果子的数目你的任务是设计出合并的次序方案使多多耗费的体力最少并输出这个最小的体力耗费值例如有种果子数目依次为可以先将堆合并新堆数目为耗费体力为接着将新堆与原先的第三堆合并又得到新的堆数目为耗费体力为所以多多总共耗费体力可以证明为最小的体力耗费值误区将从小到大排序后依次合并错误的例如这里合完为再合为最后合和因此应当每次挑最小的两个合并用到优先队列注意这个运算符的重载为什么符号相反升序则相反降序则相同在此处定义一个优先队列如果要按照以进行从小到大排列操作如上进行重载操作符意思是如果成立那么结构体成立由于优先队列是按照从大到小排列所以结构体会排列到之前然而是最小的所以实现了按照的从小到大排序其实用一句话说就是要想更大那么优先队列及重载运算符优先队列重载运算符博客构造方法重载关系运算符定义优先队列比较关系继续合并类型是插入链表快慢指针找中点链表排序思想拆分完后各自排序再每部分合并从新排序快慢指针找中点链表节点放最前后面继续成链找链表中间中点断开左右子链归并排序找到链表的中点读取构造链表记录头结点工作指针从之后开始赋值第个已经在头结点了合并个有序链表小根堆面试常考题合并个升序列表思想因为每个链表都是有序的因此对他们进行排序每次取最小的放进去就好了建立小根堆虚拟头结点优先级队列往内建立小根堆获取最小节点接到结果链表中是从堆中弹出并返回最小的值取指头节点前进单链表的倒数第个节点巧妙思想如何一次遍历链表就到倒数第个节点呢用先走然后设置一个新的指向头节点和一起走当走到末尾也就到倒数第个了预防删除头结点的虚拟节点的重要性如果是直接从开始应对不了规模为删除为的或者是删除的是头结点的情况开始遍历直至到尾删除第个即下一个单链表的中点快慢指针法快慢指针初始化指向快指针走向末尾判断下一轮直接走出界的情况走一步走两步慢指针指向中点链表是否有环力扣第题环形链表两个链表是否相交太巧妙了长度可能不同但是让走完然后走走完走就能同时达到公共区域第一次相等的那一刻就是连接点数组普通数组合并区间力扣以数组表示若干个区间的集合其中单个区间为请你合并所有重叠的区间并返回一个不重叠的区间数组该数组需恰好覆盖输入中的所有区间排序时间复杂度简化思路简化返回一个空排序一下根据第一个元素最终结果如何降低复杂度就是排序后一个一个存到结果数组显然结果数组最后一个一定是那个临近的合并元素如果合不了就直接加入只有当为空或者新元素左值大于最后一个右值无法合并才添加直接合并取最大哈希表两数之和力扣给定一个整数数组和一个整数目标值请你在该数组中找出和为目标值的那两个整数并返回它们的数组下标你可以假设每种输入只会对应一个答案但是数组中同一个元素在答案里不能重复出现你可以按任意顺序返回答案从找的到满足的对应索引快慢指针技巧删除重复项巧妙利用快慢指针扫到一个新的直接赋值给直是在最开始多速度是同步的二分法两数组之和输入有序数组给你一个下标从开始的整数数组该数组已按非递减顺序排列请你从数组中找出满足相加之和等于目标数的两个数如果设这两个数分别是和则以长度为的整数数组的形式返回这两个整数的下标和你可以假设每个输入只对应唯一的答案而且你不可以重复使用相同的元素非递减排序就可以用类似二分法最长回文子串核心对每个字符向两边扩散注意区分奇偶数情况以为中心的最长回文子串以和为中心的最长回文子串调用内置函数从数组的位置到位置二分查找第一个大于或等于的数字找到返回该数字的地址不存在则返回通过返回的地址减去起始地址得到找到数字在数组中的下标从数组的位置到位置二分查找第一个大于的数字找到返回该数字的地址不存在则返回通过返回的地址减去起始地址得到找到数字在数组中的下标例如求最长上升子序列长度可以利用升序特点把遍历查找改成二分查找双指针三数之和力扣给你一个整数数组判断是否存在三元组满足且同时还满足请你返回所有和为且不重复的三元组注意答案中不可以包含重复的三元组这题不难但是很值得思考各种条件限制逻辑排序和上一次不一样这个很重要也难想因为和相同则二三都可能有两组满足三指向最后一个来递减达到这个目标为什么是大于排完序之后后面是大数越减值越小大于就是为了提前结束后面的没必要再比了而不至于造成跳出后直接的递增被了重合满足条件子串前缀和和为的子数组力扣给你一个整数数组和一个整数请你统计并返回该数组中和为的子数组的个数子数组是数组中元素的连续非空序列初始化前缀和为遍历找不到返回有值对应满足个数不会计重因为在此时有多少个满足的就有多少个子数组了都得算上记得插入二叉树动归回溯算法都可以看做二叉树问题的扩展只是它们的关注点不同动态规划算法属于分解问题的思路它的关注点在整棵子树回溯算法属于遍历的思路它的关注点在节点间的树枝算法属于遍历的思路它的关注点在单个节点层序遍历从上到下遍历二叉树的每一层从左到右遍历每一层的每个节点将下一层节点放入队列前中序构造理解前中序数组的结构存索引这里和对应构造头中序后序这里和对应前序后序直接折半搜索广度优先迷宫诺计算机考研队列访问记录一个所有邻接的并且要标记当前为访问的代表上下左右四个动作对应的变化调用就行迷宫记录访问使用队列来维护一层层发散的优先级起点已访问出队找到终点记录步数上下左右四个方向都试一遍判断可走同时未被访问标记访问填充记录起点递归塔注意移动要借助才行前个从第一个经过第三个移动到第二个最后一个经过第二个移动到第三个从第二个经过第一个移动到第三个汉诺塔不是简单的一步移动而是要借助其他的移动步数表示要将经过移动到输出格式要求不能特指而是通过变量的形式前个从第一个经过第三个移动到第二个最后一个经过第二个移动到第三个从第二个经过第一个移动到第三个实现方式递归递归流程递归树多叉树简单来说和到底有什么区别呢对于一棵二义树就是二叉树的层次遍历一层一层的扩展下去就是二义树的中序遍历一条路走到底然后回溯走第二条直到所有路都走完需要注意的是一般情沉下效率不如比如求中的迷宫的最短路径使用就会超时迷宫上下左右要标记不然就是死循环可以走递归访问过记得回溯你退出来要留给其他路径走记录出入口注意每轮都要重新设置图论存储邻接矩阵邻接矩阵是用两个数组来表示图一个一维数组存储图中顶点信息一个二维数组邻接矩阵存储图中的边或弧的信息若或反之特点要判断任意两顶点是否有边无边就很容易了要知道某个顶点的度其实就是这个顶点在邻接矩阵中第行或第列的元素之和求顶点的所有邻接点就是将矩阵中第行元素扫描一遍为就是邻接点而有向图讲究入度和出度顶点的入度为正好是第列各数之和顶点的出度为即第行的各数之和邻接表对于边数相对顶点较少的图邻接矩阵对空间浪费邻接表是数组和链表相结合的方法更加适合即顶点表一位数组和边表链表从图中可以看出顶点表的各个结点由和两个域表示是数据域存储顶点的信息是指针域指向边表的第一个结点即此顶点的第一个邻接点边表结点由和两个域组成是邻接点域存储某顶点的邻接点在顶点表中的下标则存储指向边表中下一个结点的指针对于带权的网图在边表结点定义下加一个的数据域存储权值信息即可区别个顶点条边的无向图邻接表表示有个顶点表节点个边表结点个顶点条边的有向图邻接表表示有个顶点表节点个边表结点如果图中边的数目远远小于称作稀疏图这时用邻接表表示比用邻接矩阵表示节省空间如果图中边的数目接近于对于无向图接近于称作稠密图考虑到邻接表中要附加链域采用邻接矩阵表示法为宜并查集不相交集合并集解决集合类问题核心是树形结构路径压缩思想加快区分集合效率远高于并查集还有一个英文名字从这里可以看出并查集就是合并查找的集合代码实现初始化假设有编号的个元素用数组来存储每个元素的父节点初始化查询查找的祖先代表元素递归出口到达祖先不断往上查找祖先合并找到的祖先找到的祖先的祖先指向的祖先然而每次从根开始查都要查个结点直至到最上面的祖先大大增加时间开销因此出现路径压缩方法也就是直接指向最大的祖先变为查询语句变成进行路径压缩更新最返回父节点例题畅通工程诺计算机考研每个城镇都要可达最小添加多少其实可以发现只要是有共同祖先的都是可以连通的那么如何判断需要加多少条呢判断已经连通的城镇数在查找合并的时候如果发现祖先不同合并的时候联通的城镇数就加最后在判定完后遍历如果等于本身最后输出这里表示有多少个独立的集合连接这个独立集合只需要条边记录祖先祖先压缩我要祖先的祖先返回上一级祖先初始化城市读取道路本身不连通现在联通了把对方看作一个单位那就是多加一个连通的了很奇怪的是上面代码在诺如果用反而超时最小生成树最小生成树详解模板例题博客一个图中可能存在多条相连的边我们一定可以从一个图中挑出一些边生成一棵树这仅仅是生成一棵树还未满足最小当图中每条边都存在权重时这时候我们从图中生成一棵树条边时生成这棵树的总代价就是每条边的权重相加之和找最小带权图加边法克鲁斯卡尔算法是一种巧妙利用并查集来求最小生成树的算法算法将一个连通块当做一个集合首先将所有的边按从小到大顺序排序一般使用快排并认为每一个点都是孤立的分属于个独立的集合然后按顺序枚举每一条边如果这条边连接着两个不同的集合那么就把这条边加入最小生成树这两个不同的集合就合并成了一个集合如果这条边连接的两个点属于同一集合就跳过直到选取了条边为止最短路径邻接矩阵最大初始化三种全遍历循环在外头邻接矩阵在之间初始化赋最大值注意重边对称起点到终点的最短路径拓扑排序记录图记录个结点的入度表示被进入的邻居最小堆优先队列存放入度为的优先队列最小堆优先队列存放入度为统计出队元素个数踢出修改邻居的入度入度变了这个图有环并没有拓扑排序回溯算法递归和回溯相辅相成递归函数下面就是回溯内容回溯搜索纯暴力搜索算法组合问题切割问题子集问题排列问题棋盘问题王后解数独抽象为叉数问题横向节点用循环表示纵向深度用递归参数终止条件在叶子节点搜集结果集合元素处理结点递归回溯撤销处理节点结果回溯三部曲递归函数参数返回值确定终止条件单层递归逻辑最后一步回溯组合和排列回溯用递归模拟了嵌套层循环的方式回溯递归嵌套循环组合不区分顺序排列区分叶子结点收割结果也就是数组大小等于数的个数排序算法堆排序堆是一个完全二叉树只有最后一层不满且只能没有右子节点堆序性大根堆小根堆存储用一位数组从上到下从左到右给每个节点编号这个就是在数组的存储序号这样存储有一个规律设节点下标为左子节点下标为右子节点下标为上滤和下滤当根节点不满足堆序性子树都满足时以大根堆为例把该节点和最有子树最大值比较然后换位直到没有小于或者到达最后一层这就是下滤同理上滤就是和根比较小于就换直到遇到比他小的或到根节点建堆自顶向下建堆法将新元素放到堆的最后一位然后进行上滤操作自下而上建堆法首先将下面的调整成堆然后对父节点进行下滤直到根节点操作完毕应用优先队列小根堆是插入队列后弹出最小元素直接弹出排好序的堆的根节点弹出后将最后一个元素放到根节点重新进行下滤就有序了插入操作插入到尾部然后进行上滤堆排序就是将优先队列的所有元素依次弹出即可然而实际为了考虑空间复杂度会利用原来堆的空余位置建立有序区如何做先调整为最大堆最大元素在顶上将根节点和最后一个元素不一定最小交换此时最后一个位置就是有序区的开始然后将新的根节点进行下滤完成后根节点又是最大的把它的倒数第二个交换倒数第一个位置已经是有序区了这时有序区延伸到倒数第二个位置重复扩大有序区直到全部有序这是会发现大的在最后小的在最前也就是递增序列因此形成递增则构造最大堆递减则构造最小堆从堆的定义到优先队列堆排序分钟看懂必考的数据结构堆哔哩哔哩动态规划核心是最优子结构不都是如乘积最大子数组根据题意适当变动动规基础背包问题打家劫舍股票问题子序列问题重要点数组以及下界的含义递推公式数组如何初始化遍历顺序打印数组看看输出结果是否正确斐波那契数组降到维动态变化三个值即可跳楼梯照动态规划思想我们可以先分析下问题每次都有两种跳法分别是一阶或者两阶那么如果当前是第个台阶那么跳法是不是是台阶的跳法数加上台阶的跳法数如果划算成公式是这里容易有误区为什么不是加一步然后加两步跳一个和两个首先到此时只有唯一的一种操作那么到的步数就是而跳一步的情况已经被包括了此时只有跳两步的操作同上只有的情况因此如果测试样例一直过不了考虑数据类型要开开才够最大子段和最大序列和可能自己就已经大于加上前面的了前面时负数并且子序列是连续的对于输出表示到第的最大序列和可能是前一个加上自己或者仅是自己然而最长的不一定是最大的如果前面已经达到最大的了呢那么我们需要维护一个最大值如果大于他更新维护一个最大值每个都要找子序列然后跟新最大的字符串区间翻转题意转换字符串区间翻转诺计算机考研我们把字符串的变成变成然后构成一个和的字符串对这样一个字符串去求它的最大子段和即可最后再把的个数加上就是最终的答案为什么可以这样本质是求和最大数量差的区间最大序列和就意味着反转后这里会在反转互相抵消之下又多出多少个因此和原本的加上就是翻转后的个数读取字符串遍历构建构建新数组最大序列和最长递增子序列既然是递增子序列我们只要找到前面那些结尾比小的子序列然后把接到这些子序列末尾就可以形成一个新的递增子序列而且这个新的子序列长度加一利用函数从数组的位置到位置二分查找第一个大于或等于的数字找到返回该数字的地址不存在则返回通过返回的地址减去起始地址得到找到数字在数组中的下标求和清空上一个样例满足升序最长公共子序列二维代表字符串前个字符组成的子串和字符串前个字符组成的子串的那么至少一个满足注意这里留空了数组从开始因此对比是要比较和最后输出是输出最少编辑长度字符串动规递归超时编辑距离力扣乘积最大子数组乘积最大子数组力扣给你一个整数数组请你找出数组中乘积最大的非空连续子数组该子数组中至少包含一个数字并返回该子数组所对应的乘积测试用例的答案是一个位整数关键当前位置的最优解未必是由前一个位置的最优解转移得到的根据正负性进行分类讨论负得更多即尽可能小完全平方完全平方数力扣完全平方数是一个整数其值等于另一个整数的平方换句话说其值等于一个整数自乘的积例如和都是完全平方数而和不是数学拆分为就是一个子问题遍历枚举超分成的子集的情况这个就是代表背包问题第一步要明确两点状态和选择只要给几个物品和一个背包的容量限制就形成了一个背包问题呀所以状态有两个就是背包的容量和可选择的物品对于每件物品你能选择什么选择就是装进背包或者不装进背包嘛第二步要明确数组的定义两个状态一个二维数组的定义如下对于前个物品当前背包的容量为这种情况下可以装的最大价值是前个任取放到容量的背包比如说如果其含义为对于给定的一系列物品中若只对前个物品进行选择当背包容量为时最多可以装下的价值为根据这个定义我们想求的最终答案就是就是因为没有物品或者背包没有空间的时候能装的最大价值就是第三步根据选择思考状态转移的逻辑如果你没有把这第个物品装入背包那么很显然最大价值应该等于继承之前的结果如果你把这第个物品装入了背包那么应该等于定义从开始所以和表示第个物品的价值和重量注意代码由根据我的代码翻译旨在帮助不同背景的读者理解算法逻辑本代码不保证正确性仅供参考如有疑惑可以参照我写的代码对比查看初始化一个二维数组用于存储状态表示将前个物品装入容量为的背包中所获得的最大价值开始进行递推当前商品的重量已经超过了无法被放入当前容量为的背包中只能选择不装入背包当前商品的重量小于等于当前容量可以尝试将其放入背包中取最大值考虑是将其放入之前的最优方案中还是选择不放放第个物品那么就要从个物品中加上第个注意重要要从当前的减去第个物品的开始加同时因为从开始放所以第个重量是啥都不放返回最大价值简化版背包值得思考的简化版背包设有一个背包可以放入的物品重量为现有件物品重量分别是问能否从这件物品中选择若干件放入背包中使得放入的重量之和正好为如果有满足条件的选择则此背包有解否则此背包问题无解代表前个物品背包容量最大为最多能装的物品总重量必要清空前件物品凑成重量可行性为这一步初始化关键前已经可以满足能够凑成常规背包诺计算机考研表示前个到达费用的受欢迎指数钱数种类记录方案从块开始放与不放如果大于当前的追加不够买当前的输出受欢迎状态压缩数论质数判断素数注意的情况它本身如果是直接输出否则它开始找输出大于整数的素数判断素数是素数输出不是的话就从开始找分解质因素质因素个数最后跳出循环的结果如果大于就是一个素数分解质因素或者用于统计质因数指数为什么一般到根号就足够了呢我们想想如果两个数相乘等于那么这两个数只有两种情况要么都等于根号要么一个大于根号一个小于根号素数筛选我们要知道一个合数一定是某个质因素的倍数埃式筛法埃式筛一个合数一定是某个质因素的倍数因此找出一个质数把他所有倍数筛掉不包括自己这里到即可如果没被筛掉说明是质数如它不可能被前面的筛掉从倍开始不包括自己统计个数欧拉筛法埃式筛法有个问题公倍数会被重复筛好几次比如会被筛也会被筛加一个数组如果没被筛说明是素数存到数组接下来遍历来筛筛素数倍数这一步关键防止重复筛比如假设当到这是会筛掉但是有了这一步当是的时候已经了这就保证了不会被重复筛而是留到当为时被掉了最后直接用这个素数数组即可应该时没比埃式筛快多少的背住最大公约数最小公倍数算法最小公倍数最大公约数两数乘积即而最大公约数可以使用辗转相除法辗转相除法又名欧几里得算法目的是求出两个正整数的最大公约数它是已知最古老的算法其可追溯至公元前年前这条算法基于一个定理两个正整数和它们的最大公约数等于除以的余数和之间的最大公约数求解最大公倍数最小公约数最大公约数和最小公倍数请输入第一个数请输入第二个数最大公约数为最小公倍数为辗转相除法基于原理两个整数的最大公约数等于其中较小值与两数相除余数的最大公约数请输入第一个数请输入第二个数如果结果为说明二者是最简真分数结束辗转相除算法原理很简单一个点到另一个点的最短路径无非有两种直接到达通过走其他点一个或多个点到达完全平方数数论问题一个整数是一个完全平方数是指它是某一个整数的平方即存在一个整数使得给定一个正整数请找到最小的正整数使得它们的乘积是一个完全平方数一个完全平方数他的质因数的指数都是偶数所以要凑的话就得分解质因数不是偶数的补上一直乘留意未分尽的情况高精度输出反而代表数字的高位计算进位设置较短的字符补最大二叉树读取构造二叉树构造最大二叉树特殊情况只有一个元素找最大值判左右是否空左右递归返回根节点前序遍历函数终止情况为空结点返回排除叶子结点情况其他输出结点递归左右最大二叉树定义二叉树无参有参前序遍历叶子节点的两个子空节点要去掉不输出否则会多输出一对递归左子树递归右子树只有一个元素直接返回中间找最大找最大值左边还有元素左闭右开左子树的构造就是对左边递归右边递归读取算法课分治寻找多数寻找多数返回特定元素在特定数组中出现的次数规模为直接求解分解当前数组的解为两个数组解在当前数组出现次数较大的解读取算法课分治找到最大子序和如果当前序列只有一个元素计算当前序列的分裂点计算左边界最大子序列和计算右边界最大子序列和返回当前序列最大子序列和读入算法课分治找到个最小数就是一个快速排序这里是就要从开始要从开始就得是交换后后移交换后前移返回最终划分完成后基准元素所在的位置分治算法课分治寻找第个最大元素交换后后移返回最终划分完成后基准元素所在的位置数据读取快速排序算法课动态规划走网格棋盘初始化算法课动态规划爬楼梯零一阶都是只有一种方法达到算法课动态规划背包问题不放物品由推出即背包容量为里面不放物品的最大价值此时就是其实就是当物品的重量大于背包的重量时物品无法放进背包中所以背包内的价值依然和前面相同放物品由推出为背包容量为的时候不放物品的最大价值那么物品的价值就是背包放物品得到的最大价值背包问题能放物品的进行初始化遍历物品遍历背包容量放不进就是不妨上一个物品放的进就是比较上一个和放进这个的大小最长回文子串算法课动态规划最长回文子串对角线为少了一个判断是两个字符的情况两个字符找最长的记录下来连续数组最大算法课动态规划连续数组最大和加端点最长公共子序列空出一个外围非则会越界注意都要退一个如果当前字母想都就是左上角加上如果不同找左边或者上边的最大值贪婪和组成的最大数字简单跳过贪婪三角形的最大周长给定由一些正数代表长度组成的数组返回由其中三个长度组成的面积不为零的三角形的最大周长如果不能形成任何面积不为零的三角形返回算法课贪婪三角形的最大周长对进行排序冒泡排序降序用蛮力种花问题假设有一个很长的花坛一部分地块种植了花另一部分却没有可是花不能种植在相邻的地块上它们会争夺水源两者都会死去给你一个整数数组表示花坛由若干和组成其中表示没种植花表示种植了花另有一个数能否在不打破种植规则的情况下种入朵花能则返回不能则返回提示为或中不存在相邻的两朵花算法课蛮力法种花问题最后一个就是插入总数去掉最后一个总数的只有一个花坛第一个和最后一个特殊情况先种最左和最右开始从左往右有位置就种种上后要赋值最后一个数真的猪啊在前面经历过操作你在这里调试输出肯定对应不上原始值啊转换到的最后一个总数贪婪移掉位数字有一步没搞懂给你一个以字符串表示的非负整数和一个整数移除这个数中的位数字使得剩下的数字最小请你以字符串形式返回这个最小的数字仅由若干位数字组成除了本身之外不含任何前导零开始遍历前一个大于后一个去除前导贪婪盛最多的水给你个非负整数每个数代表坐标中的一个点在坐标内画条垂直线垂直线的两个端点分别为和找出其中的两条线使得它们与轴共同构成的容器可以容纳最多的水说明你不能倾斜容器算法课贪婪盛最多的水思路从最远两边往里收缩不是同时收缩是一边一边收缩记录最大找第一长和所有其他的算再找第一二长和所有其他的算面积小的一边收缩回溯括号生成算法课回溯括号生成放的数组递归结束条件当剩余左边括号小于或等于右边时才满足放左放右回溯目标和给你一个整数数组和一个整数向数组中的每个整数前添加或然后串联起所有整数可以构造一个表达式例如可以在之前添加在之前添加然后串联起来得到表达式返回可以通过上述方法构造的运算结果等于的不同表达式的数目提示算法课回溯目标和数组目标和参与个数不满足但是退出回溯电话号码的字母组合输入序列序列号可能组合给定一个仅包含数字的字符串返回所有它能表示的字母组合答案按字母顺序返回给出数字到字母的映射如下与电话按键相同注意不对应任何字母标记当前是遍历到第几个记录遍历到第几个记录第个位置当这个满足时说明前面的坑都填完了三个位置都放好了转为数值取序号递归回溯长度是其他都是回溯优美的排列位置数长度假设有从到的个整数用这些整数构造一个数组下标从开始只要满足下述条件之一该数组就是一个优美的排列能够被整除能够被整除给你一个整数返回可以构造的优美排列的数量提示算法课回溯优美的排列标记作用访问回溯所有排列的组合边凑数进行判断如果不满足置标记为直接排除当前情况组合长度个数遍历位置是氛围是个数记录遍历到那个数了到叶子了收割结果递归回溯回溯大礼包商品即对应价格存放大礼包需要的各个商品数量礼包种类数为此层决策要花多少钱先不考虑买礼包遍历礼包复制一遍需求暂存礼包的大小存入礼包价格是否能买当前礼包遍历礼包的物品列表有一个不满足能买的话更新能买礼包当前礼包加上剩下需求所需的钱不能买礼包换下一个读取假设有个大礼包最基本的一个大礼包都不买遍历所有大礼包包括自己递归终止条件它加下一个礼包超出了数量首先大礼包的物品数要都小于目标数据不满足则跳过递归满足则加入算出总价递归检查是否到最后一个大礼包是判断还剩多少用则用基本物品价格去补充问题这里的你不知道即礼包的个数不定前都是商品计数排序计数排序这里按序号赋值本身就已经有序了不用排序了重复的进行排序的话自动跳过了巧妙贪心跳跃游戏给定一个非负整数数组你最初位于数组的第一个下标数组中的每个元素代表你在该位置可以跳跃的最大长度判断你是否能够到达最后一个下标上一个标记当前出现的位置能到最后的标记查到判断前面有没有能够跳过的法维护一个可达到的最远位置通过遍历当前可跳跃范围内的所有位置计算每个位置能够达到的最远位置并更新如果超过数组长度的最后一个位置则表示可以到达末尾返回否则根据当前位置调整下一次可跳跃范围的起点和终点直到无法继续跳跃返回动规整数拆分给定一个正整数将其拆分为个正整数的和并使这些整数的乘积最大化返回你可以获得的最大乘积我们用来表示分拆数字可以得到的最大乘积对于每个来说都可以通过前面已知的拆分结果来求遍历前面的每个数字假设拆分成两个数和这是一种情况另外又可以继续拆分拆分的最大值就是同理也是一样的我们在所有情况里取最大值就是的结果动态规划打家劫舍你是一个专业的小偷计划偷窃沿街的房屋每间房内都藏有一定的现金影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统如果两间相邻的房屋在同一晚上被小偷闯入系统会自动报警给定一个代表每个房屋存放金额的非负整数数组计算你不触动警报装置的情况下一夜之内能够偷窃到的最高金额提示算法课动态规划打家劫舍占着第个初始化遍历不偷本间偷本间加前面的第二间动态规划戳气球算法课动态规划戳气球添加两侧的虚拟气球从开始已经都被初始化为开始状态转移应该从下往上应该从左往右最后戳破的气球是哪个择优做选择贪心跳跃游戏有一个非负整数数组最初位于数组的第一个位置数组中的每个元素代表你在该位置可以跳跃的最大长度假设你总是可以到达数组的最后一个位置你的目标是使用最少的跳跃次数到达数组的最后一个位置输入基本思想每次在当前能跳跃范围内选择可以使得接下来能跳跃最远的位置记录跳到最远的当前的位置首先初始化一个最远跳得超越了之前的指针颜色分类给定一个包含红色白色和蓝色共个元素的数组原地对它们进行排序使得相同颜色的元素相邻并按照红色白色蓝色顺序排列我们使用整数和分别表示红色白色和蓝色输入第一行输入一个整数代表数组的长度第二行输入一行数字代表数组为数字与数字之间用空格间开输出输出排序后的数组算法课指针颜色分类检查三种颜色工作指针检查找到颜色头一个头部解决建议记录头部索引存储颜色族头进入一个聚类的循环找到一个替换直到越界',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-16 21:03:13',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/./images/ava.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">yjchen</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cv/cyj_CV.pdf"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> CV</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 1.05rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 1.05rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 1.05rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 1.05rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>6</sup></a><a href="/tags/%E8%84%91%E7%94%B5/" style="font-size: 1.05rem;">脑电<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">JJ的算法之旅</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-16T17:39:06.000Z" title="发表于 2023-09-17 01:39:06">2023-09-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-06-16T13:03:13.192Z" title="更新于 2024-06-16 21:03:13">2024-06-16</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为广州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"><header><h1 id="CrawlerTitle" itemprop="name headline">JJ的算法之旅</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">JJuprising</span><time itemprop="dateCreated datePublished" datetime="2023-09-16T17:39:06.000Z" title="发表于 2023-09-17 01:39:06">2023-09-17</time><time itemprop="dateCreated datePublished" datetime="2024-06-16T13:03:13.192Z" title="更新于 2024-06-16 21:03:13">2024-06-16</time></header><p>kk&#x3D;kk&amp;(kk-1)，可以消除kk二进制的最后一个1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://labuladong.gitee.io/algo/home/">https://labuladong.gitee.io/algo/home/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到数组中的最大值及其索引 速度更快</span></span><br><span class="line">    max_num = <span class="built_in">max</span>(nums)</span><br><span class="line">    max_idx = nums.index(max_num) </span><br></pre></td></tr></table></figure>

<ul>
<li>Floyd</li>
<li>背包问题 天平称0</li>
<li>手写数据结构代码，链表、二叉树  P8744 [蓝桥杯 2021 省 A] 左孩子右兄弟</li>
<li>dfs,bfs</li>
<li>前缀和、二分、差分</li>
<li>刷动态规划</li>
<li>时间复杂度控制在10^7</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20240412104816902.png" alt="image-20240412104816902"></p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入样例</span></span><br><span class="line"><span class="comment"># 3 2 1 6 0 5</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入样例</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 1 2 4 </span></span><br><span class="line">Len = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行输入两个整数，第一个代表数组的长度，第二个代表k，数字与数字之间用空格间开</span></span><br><span class="line"><span class="comment"># 第二行输入一行数字代表数组arr。数字与数字之间用空格间开</span></span><br><span class="line"><span class="comment"># 输入样例</span></span><br><span class="line"><span class="comment"># 3 2</span></span><br><span class="line"><span class="comment"># 3 2 1</span></span><br><span class="line">n, k = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())  <span class="comment"># 注意这个输入是按行的，分割</span></span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br></pre></td></tr></table></figure>

<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><strong>构建二维数组大坑！</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.zeros((m, n)) √</span><br><span class="line">dp=[([<span class="number">0</span>]*(n+<span class="number">1</span>))]*(n+<span class="number">1</span>) × 引用方式修改，每一列的第i都会跟着bian</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大小写转换</span></span><br><span class="line"><span class="comment">## 函数法</span></span><br><span class="line">msg=<span class="string">&#x27;www.BAIDU.com.123&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(msg.upper())  <span class="comment">#upper()函数，将所有字母都转换成大写 WWW.BAIDU.COM.123</span></span><br><span class="line"><span class="built_in">print</span>(msg.lower())  <span class="comment">#lower()函数，将所有字母都转换成小写 www.baidu.com.123</span></span><br><span class="line"><span class="built_in">print</span>(msg.capitalize())  <span class="comment">#capitalize()函数，将首字母都转换成大写，其余小写 Www.baidu.com.123</span></span><br><span class="line"><span class="built_in">print</span>(msg.title())  <span class="comment">#title()函数，将每个单词的首字母都转换成大写，其余小写 Www.Baidu.Com.123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Ascll码，用ord()转码，用chr转字符,注意python没有字符概念</span></span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;www.BAIDU.com.123&#x27;</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> msg:</span><br><span class="line">    <span class="keyword">if</span> <span class="number">97</span> &lt;= <span class="built_in">ord</span>(num) &lt;= <span class="number">122</span>: <span class="comment">#小写字母</span></span><br><span class="line">        upper_num = <span class="built_in">ord</span>(num)-<span class="number">32</span> <span class="comment">#大小写字母之前差了32</span></span><br><span class="line">        <span class="comment">#chr()函数可以将编码数值转为字符（python没有字符的概念）</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">chr</span>(upper_num),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(num,end=<span class="string">&#x27;&#x27;</span>)  <span class="comment">#不是小写字符，原样输出</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment"># int转string</span></span><br><span class="line">a=<span class="number">100</span></span><br><span class="line">a_=<span class="built_in">str</span>(a)</span><br><span class="line">a*=<span class="built_in">int</span>(a_)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二进制与位运算"><a href="#二进制与位运算" class="headerlink" title="二进制与位运算"></a>二进制与位运算</h3><h4 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h4><ul>
<li><code>//</code>：整数除法，返回商的整数部分，忽略余数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> // <span class="number">3</span>)    <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>%</code>：取模运算符，返回除法的余数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> % <span class="number">3</span>)    <span class="comment"># 输出：1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>**</code>：幂运算符，计算第一个操作数的第二个操作数次方。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ** <span class="number">3</span>)    <span class="comment"># 输出：8</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>逻辑运算</strong></li>
</ul>
<p>逻辑运算符处理布尔值，包括：</p>
<ul>
<li><code>and</code>：逻辑与，只有两边的操作数都为True时结果才为True。</li>
<li><code>or</code>：逻辑或，只要有一个操作数为True，结果就为True。</li>
<li><code>not</code>：逻辑非，对一个布尔值进行否定。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>)    <span class="comment"># 输出：False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>)    <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">True</span>)    <span class="comment"># 输出：False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>身份运算符</strong>，比较两个对象是否为同一对象，而非仅看其值是否相等<ul>
<li><code>is</code>：判断两个对象是否引用同一个内存地址，即它们是否是同一个实例。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)    <span class="comment"># 输出：True，因为a和b指向同一列表对象</span></span><br><span class="line"></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> c)    <span class="comment"># 输出：False，尽管a和c的元素相同，但它们是不同的列表实例</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>is not</code>：与is相反，用于检查两个对象是否引用不同的内存地址。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">b = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> <span class="keyword">not</span> b)    <span class="comment"># 输出：False，Python对字符串采用intern机制，所以相同的字符串字面量会指向同一内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">x = MyClass()</span><br><span class="line">y = MyClass()</span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> <span class="keyword">not</span> y)    <span class="comment"># 输出：True，因为x和y是MyClass的不同实例</span></span><br></pre></td></tr></table></figure>

<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>位运算符处理整数的二进制表示，包括：</p>
<ul>
<li><code>&amp;</code>：按位与，对于两个对应位，如果都是1，则结果为1，否则为0。</li>
<li><code>|</code>：按位或，只要有一个对应位为1，则结果为1，否则为0。</li>
<li><code>^</code>：按位异或，当两个对应位不同时，结果为1，否则为0。</li>
<li><code>~</code>：按位取反，对一个数的所有位进行翻转，即将1变为0，0变为1。</li>
<li><code>&lt;&lt;</code>：左移运算符，将数字的所有二进制位向左移动指定的位数。</li>
<li><code>&gt;&gt;</code>：右移运算符，将数字的所有二进制位向右移动指定的位数。</li>
</ul>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">5</span> &amp; <span class="number">3</span>)    <span class="comment"># 输出：1，二进制下 5（101）和 3（011）按位与的结果是 1（001）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> | <span class="number">3</span>)    <span class="comment"># 输出：7，二进制下 5（101）和 3（011）按位或的结果是 7（111）</span></span><br></pre></td></tr></table></figure>

<h3 id="STL-C"><a href="#STL-C" class="headerlink" title="STL C++"></a>STL C++</h3><p><strong>stack</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stark&lt;<span class="type">int</span>&gt; S;<span class="comment">//初始化</span></span><br><span class="line">S.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//入栈</span></span><br><span class="line">S.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(!S.<span class="built_in">empty</span>())&#123;<span class="comment">//判空</span></span><br><span class="line">    cout&lt;&lt;S.<span class="built_in">top</span>()&lt;&lt;endl;<span class="comment">//栈顶元素</span></span><br><span class="line">    S.<span class="built_in">pop</span>();<span class="comment">//出栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>vector</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">demo.<span class="built_in">pop_back</span>();</span><br><span class="line">demo.<span class="built_in">size</span>();</span><br><span class="line">demo.<span class="built_in">back</span>();<span class="comment">//最后一个元素</span></span><br><span class="line"><span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br><span class="line"><span class="comment">//删除指定元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = std::<span class="built_in">remove</span>(demo.<span class="built_in">begin</span>(), demo.<span class="built_in">end</span>(), <span class="number">3</span>);<span class="comment">//输出&#123;1,4,5&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>string</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造</span></span><br><span class="line">string str1;               <span class="comment">//生成空字符串</span></span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(<span class="string">&quot;123456789&quot;</span>)</span></span>;  <span class="comment">//生成&quot;1234456789&quot;的复制品</span></span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(<span class="string">&quot;12345&quot;</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为&quot;123&quot; 从&quot;12345&quot;的第0开始复制3个</span></span><br><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="string">&quot;012345&quot;</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为&quot;01234&quot; 以&quot;012345&quot;前5个作为粗值</span></span><br><span class="line"><span class="function">string <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">&#x27;1&#x27;</span>)</span></span>;       <span class="comment">//结果为&quot;11111&quot; 生成n个字符&#x27;1&#x27;</span></span><br><span class="line"><span class="function">string <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为&quot;3456789&quot; 将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span></span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="comment">//scanf读char数组</span></span><br><span class="line"><span class="built_in">gets</span>(s);<span class="comment">//整行读</span></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">string s=<span class="string">&quot;Hahah&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>,s);<span class="comment">//在原串下标为1的字符e前插入字符串s</span></span><br><span class="line">str1.<span class="built_in">insert</span>(<span class="number">4</span>,<span class="number">5</span>,s);<span class="comment">//在原串下标为4的字符o前插入5个字符s</span></span><br><span class="line">str2.<span class="built_in">insert</span>(<span class="number">0</span>,s,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//将字符串s从下标为1的a开始数3个字符，分别是aha，插入原串的下标为0的字符h前</span></span><br></pre></td></tr></table></figure>

<p><strong>set</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; occ;</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="type">int</span> b=<span class="number">0</span>;</span><br><span class="line">a.<span class="built_in">size</span>();</span><br><span class="line">a.<span class="built_in">insert</span>(b);</span><br><span class="line">a.<span class="built_in">erase</span>(b);<span class="comment">//移除</span></span><br><span class="line">a.<span class="built_in">count</span>(b);<span class="comment">//查找返回值为1</span></span><br></pre></td></tr></table></figure>

<p><strong>memset</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">功 能: 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,</span><br><span class="line">块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作</span><br><span class="line"></span><br><span class="line">用 法: <span class="function"><span class="type">void</span> *<span class="title">memset</span><span class="params">(<span class="type">void</span> *s, <span class="type">char</span> ch, <span class="type">unsigned</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">对比：</span><br><span class="line">memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；例：<span class="type">char</span> a[<span class="number">100</span>],b[<span class="number">50</span>]; <span class="built_in">memcpy</span>(b, a, <span class="built_in">sizeof</span>(b));注意如用<span class="built_in">sizeof</span>(a)，会造成b的内存地址溢出。</span><br><span class="line"></span><br><span class="line">strcpy就只能拷贝字符串了，它遇到<span class="string">&#x27;/0&#x27;</span>就结束拷贝；例：<span class="type">char</span> a[<span class="number">100</span>],b[<span class="number">50</span>];<span class="built_in">strcpy</span>(a,b);如用<span class="built_in">strcpy</span>(b,a)，要注意a中的字符串长度（第一个‘/<span class="number">0</span>’之前）是否超过<span class="number">50</span>位，如超过，则会造成b的内存地址溢出。</span><br></pre></td></tr></table></figure>

<p><strong>map</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; maps;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">maps.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">111</span>, <span class="string">&quot;kk&quot;</span>));</span><br><span class="line">maps[<span class="number">111</span>]=<span class="string">&quot;kk&quot;</span>;</span><br><span class="line"><span class="comment">//maps.find(key) 查找一个元素 返回key的映射的迭代器</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it=maps.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);<span class="comment">//在容器中寻找值为key为123的元素，返回该元素的迭代器。否则，返回map.end()。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取值</span></span><br><span class="line">map-&gt;first;<span class="comment">//对应key,111</span></span><br><span class="line">map-&gt;second;<span class="comment">//对应value,kk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">maps.<span class="built_in">clear</span>();</span><br><span class="line"><span class="comment">//删除一个元素</span></span><br><span class="line"><span class="comment">//迭代器刪除</span></span><br><span class="line">it = maps.<span class="built_in">find</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">maps.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键字删除</span></span><br><span class="line"><span class="type">int</span> n = maps.<span class="built_in">erase</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//如果刪除了返回1，否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class="line">maps.<span class="built_in">erase</span>(maps.<span class="built_in">begin</span>(), maps.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//等同于mapStudent.clear()</span></span><br><span class="line">maps.<span class="built_in">begin</span>();<span class="comment">//返回指向map头部的迭代器</span></span><br><span class="line">maps.<span class="built_in">end</span>();<span class="comment">//返回指向map末尾的迭代器</span></span><br><span class="line">maps.<span class="built_in">size</span>();</span><br><span class="line">maps.<span class="built_in">empty</span>();<span class="comment">//判空</span></span><br></pre></td></tr></table></figure>



<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur=[]</span><br><span class="line">res.append(cur) <span class="comment"># 这里是引用，cur变，res变</span></span><br><span class="line">res.append(cur.copy) <span class="comment"># 或者cur[:]y</span></span><br></pre></td></tr></table></figure>



<p>计时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.perf_counter()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Running time: <span class="subst">&#123;end - start&#125;</span> Seconds&quot;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max_value = sys.maxsize</span><br><span class="line">min_value = -sys.maxsize - <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h4><ul>
<li><p>超时之memset。N诺很多memset，然而在百度之星一直超时最后发现是memset的问题，当数组很大时比较费时(害我罚了几次时┭┮﹏┭┮)</p>
</li>
<li><p>超时之二维数组开大了，在N诺，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> store[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10005</span>][<span class="number">10005</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//前i个，达到重量的可行度 </span></span><br></pre></td></tr></table></figure>

<p>狠狠超时，然后改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> store[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//前i个，达到重量的可行度 </span></span><br></pre></td></tr></table></figure>

<p>(((φ(◎ロ◎;)φ)))</p>
</li>
<li><p>oj运行出错：数组开小了</p>
</li>
<li><p>oj和答案不对的一个重要原因：没有说明是eof的就得换一种方式读取！！，如果保持eof的方式就会错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">1</span> + n) * n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取方式有可能会造成运行超时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时版</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;n) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        v[len] = n - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不超时版</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据结构及基本操作"><a href="#数据结构及基本操作" class="headerlink" title="数据结构及基本操作"></a>数据结构及基本操作</h2><p> 数组遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="comment"># 迭代访问 arr[i]</span></span><br></pre></td></tr></table></figure>

<p>链表，迭代递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本的单链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>: <span class="comment"># -&gt; None 是类型注释的一部分，用于说明函数的返回类型。</span></span><br><span class="line">    p = head</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 迭代访问 p.val</span></span><br><span class="line">        p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 递归访问 head.val</span></span><br></pre></td></tr></table></figure>



<p>二叉树 递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本的二叉树节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    traverse(root.left) <span class="comment"># 递归遍历左子树</span></span><br><span class="line">    traverse(root.right) <span class="comment"># 递归遍历右子树</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse</span>(<span class="params">root</span>):</span><br><span class="line">    <span class="comment"># 前序位置</span></span><br><span class="line">    traverse(root.left)</span><br><span class="line">    <span class="comment"># 中序位置</span></span><br><span class="line">    traverse(root.right)</span><br><span class="line">    <span class="comment"># 后序位置</span></span><br></pre></td></tr></table></figure>

<h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//括号匹配 栈 ([)]这种可不对 应该先配对好[才能再配对( </span></span><br><span class="line"><span class="comment">//((([]))) </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string s;</span><br><span class="line">	cin&gt;&gt;s;</span><br><span class="line">	<span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			<span class="type">char</span> now=st.<span class="built_in">top</span>();</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;now==<span class="string">&#x27;(&#x27;</span>||(s[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;now==<span class="string">&#x27;[&#x27;</span>)) st.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">else</span> st.<span class="built_in">push</span>(s[i]);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//如果为空，入栈</span></span><br><span class="line">			st.<span class="built_in">push</span>(s[i]); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="comment">//栈空才成 </span></span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><a target="_blank" rel="noopener" href="https://noobdream.com/DreamJudge/Issue/page/1544/">1544 - 合并果子 _N诺计算机考研 (noobdream.com)</a></p>
<p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力&#x3D;3+12&#x3D;15。可以证明15为最小的体力耗费值。</p>
<blockquote>
<p>误区：将从小到大排序后依次合并。错误的，例如 5,6,7,8。这里合完5,6为11，再合7,8为15，最后合11和15.因此应当每次挑最小的两个合并，用到优先队列</p>
</blockquote>
<p>注意这个运算符的重载为什么符号相反？升序则相反，降序则相同，</p>
<p>在此处定义一个优先队列priority_queue<point> q;</p>
<p>如果要按照以times进行从小到大排列，操作如上。</p>
<p>进行重载&lt;操作符。</p>
<p>意思是如果a.times &gt; b.times成立，那么结构体point a &lt; point b成立。</p>
<p>由于优先队列是按照从大到小排列，所以结构体b会排列到a之前，然而b.times是最小的，所以实现了按照times的从小到大排序,其实用一句话说就是要想b更大那么b.times.<a target="_blank" rel="noopener" href="https://blog.csdn.net/riba2534/article/details/53450085">C++优先队列(priority queue)及重载运算符_c++ 优先队列重载运算符-CSDN博客</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> a)&#123;x=a;&#125;<span class="comment">//构造方法 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载关系运算符定义优先队列比较关系</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node&amp; a,<span class="type">const</span> node &amp;b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;node&gt; q;</span><br><span class="line">	<span class="type">int</span> n,x;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;x;</span><br><span class="line">		q.<span class="built_in">push</span>(<span class="built_in">node</span>(x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> anx=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//继续合并</span></span><br><span class="line">		node numa=q.<span class="built_in">top</span>();<span class="comment">//类型是Node </span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		node numb=q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		anx+=(numa.x+numb.x);</span><br><span class="line">		<span class="comment">//插入</span></span><br><span class="line">		q.<span class="built_in">push</span>(node&#123;numa.x+numb.x&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;anx;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>快慢指针找中点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">链表排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">思想 拆分完后 各自排序，再每部分合并从新排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">快慢指针找中点</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,val</span>):</span><br><span class="line">        self.val=val</span><br><span class="line">        self.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">l1,l2</span>):</span><br><span class="line">    <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> l1.val&lt;=l2.val:</span><br><span class="line">        <span class="comment"># l1放最前 后面继续成链</span></span><br><span class="line">        l1.<span class="built_in">next</span>=merge(l1.<span class="built_in">next</span>,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.<span class="built_in">next</span>=merge(l1,l2.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line"><span class="comment"># def merge_sort(node,len):</span></span><br><span class="line"><span class="comment">#     # 找链表中间</span></span><br><span class="line"><span class="comment">#     if node is None or node.next is None or len is 0:</span></span><br><span class="line"><span class="comment">#         return node</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     slow=node</span></span><br><span class="line"><span class="comment">#     mid_loc=len//2</span></span><br><span class="line"><span class="comment">#     print(f&quot;mid_loc:&#123;mid_loc&#125;&quot;)</span></span><br><span class="line"><span class="comment">#     for i in range(mid_loc): # 中点</span></span><br><span class="line"><span class="comment">#         slow=slow.next</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     mid=slow.next</span></span><br><span class="line"><span class="comment">#     slow.next=None # 断开</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     # 左右子链归并排序</span></span><br><span class="line"><span class="comment">#     left=merge_sort(node,mid_loc)</span></span><br><span class="line"><span class="comment">#     right=merge_sort(mid,len-mid_loc)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     return merge_sort(left,right)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到链表的中点</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    mid = slow.<span class="built_in">next</span></span><br><span class="line">    slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    left = merge_sort(head)</span><br><span class="line">    right = merge_sort(mid)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge(left, right)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_list</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        <span class="built_in">print</span>(node.val,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        node=node.<span class="built_in">next</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 读取构造链表</span></span><br><span class="line">    nums=<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split()))</span><br><span class="line">    head=ListNode(<span class="built_in">int</span>(nums[<span class="number">0</span>])) <span class="comment"># 记录头结点</span></span><br><span class="line">    curr=head <span class="comment"># 工作指针</span></span><br><span class="line">    <span class="built_in">len</span>=<span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[<span class="number">1</span>:]: <span class="comment"># 从1之后开始赋值，第0个已经在头结点了</span></span><br><span class="line">        curr.<span class="built_in">next</span>=ListNode(<span class="built_in">int</span>(num))</span><br><span class="line">        curr=curr.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># print_list(head)</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    new=merge_sort(head,<span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">    print_list(new)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="合并k个有序链表"><a href="#合并k个有序链表" class="headerlink" title="合并k个有序链表"></a>合并k个有序链表</h3><p>小根堆，面试常考题，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">合并k个升序列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">思想，因为每个链表都是有序的，因此对他们进行排序，每次取最小的放进去就好了</span></span><br><span class="line"><span class="string">建立小根堆</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type lists: List[ListNode]</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 虚拟头结点</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优先级队列</span></span><br><span class="line">        pq = []</span><br><span class="line">        <span class="keyword">for</span> head <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> head:</span><br><span class="line">                heapq.heappush(pq, (head.val, head)) <span class="comment"># 往pq内建立小根堆</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            <span class="comment"># 获取最小节点 接到结果链表中</span></span><br><span class="line"></span><br><span class="line">            node = heapq.heappop(pq)[<span class="number">1</span>]  <span class="comment"># heapq.heappop()是从堆中弹出并返回最小的值,取1指头节点</span></span><br><span class="line">            <span class="comment"># far=heapq.heappop(pq)[0]</span></span><br><span class="line">            <span class="comment"># print(node.val,far.val)</span></span><br><span class="line">            p.<span class="built_in">next</span> = node</span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">                heapq.heappush(pq, (node.<span class="built_in">next</span>.val, node.<span class="built_in">next</span>))</span><br><span class="line">            <span class="comment"># p前进</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># print_priority_queue(pq)</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>巧妙思想</p>
<p>如何一次遍历链表就到倒数第k个节点呢</p>
<p>用p1先走k，然后设置一个新的p2指向头节点，和p2一起走</p>
<p>当p2走到末尾，p1也就到倒数第k个了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 预防删除头结点的 虚拟节点的重要性</span></span><br><span class="line">        <span class="comment"># 如果是直接从head开始，应对不了规模为1删除为1的，或者是删除的是头结点的情况</span></span><br><span class="line">        newnode=ListNode(-<span class="number">1</span>)</span><br><span class="line">        newnode.<span class="built_in">next</span>=head</span><br><span class="line">        p1=newnode</span><br><span class="line">        p2=newnode</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            p1=p1.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># p2开始遍历，直至p1到尾</span></span><br><span class="line">        <span class="comment"># if p1==None:</span></span><br><span class="line">        <span class="comment">#     return None</span></span><br><span class="line">        <span class="keyword">while</span> p1.<span class="built_in">next</span> :</span><br><span class="line">            p1=p1.<span class="built_in">next</span></span><br><span class="line">            p2=p2.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 删除第n个，即下一个</span></span><br><span class="line">        p2.<span class="built_in">next</span>=p2.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> newnode.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h3><p>快慢指针法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">head:ListNode</span>):</span><br><span class="line">	<span class="comment"># 快慢指针初始化指向head</span></span><br><span class="line">    slow=head</span><br><span class="line">    fast=head</span><br><span class="line">    <span class="comment"># 快指针走向末尾</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:<span class="comment"># fast判断下一轮直接走出界的情况</span></span><br><span class="line">        slow=slow.<span class="built_in">next</span> <span class="comment"># 走一步</span></span><br><span class="line">        fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="comment"># 走两步</span></span><br><span class="line">    <span class="comment"># 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow </span><br></pre></td></tr></table></figure>

<h3 id="链表是否有环"><a href="#链表是否有环" class="headerlink" title="链表是否有环"></a>链表是否有环</h3><p>力扣第 142 题「<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 IIopen in new window</a>」</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20240313162945782.png" alt="image-20240313162945782"></p>
<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>太巧妙了！<br>a，b长度可能不同，但是让p1走完a然后走b，p2走完b走a，就能同时达到公共区域<br>第一次相等的那一刻就是连接点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p1,p2=headA,headB</span><br><span class="line">        <span class="keyword">while</span> p1!=p2:</span><br><span class="line">            <span class="keyword">if</span> p1==<span class="literal">None</span>:</span><br><span class="line">                p1=headB</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p1=p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> p2==<span class="literal">None</span>:</span><br><span class="line">                p2=headA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p2=p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间 - 力扣（LeetCode）</a></p>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<blockquote>
<p>排序，时间复杂度简化(思路简化)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="type">int</span> arr_nums=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (arr_nums==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;<span class="comment">//返回一个空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>()); <span class="comment">//排序一下，根据第一个元素</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;<span class="comment">//最终结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr_nums;i++)&#123;</span><br><span class="line">            <span class="comment">//如何降低复杂度，就是排序后一个一个存到结果数组</span></span><br><span class="line">            <span class="comment">//显然，结果数组最后一个一定是那个临近的合并元素，如果合不了就直接加入</span></span><br><span class="line">            <span class="type">int</span> L=intervals[i][<span class="number">0</span>],R=intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!res.<span class="built_in">size</span>()||res.<span class="built_in">back</span>()[<span class="number">1</span>]&lt;L)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;L,R&#125;);</span><br><span class="line">                <span class="comment">//只有当为空，或者新元素左值大于最后一个右值(无法合并)，才添加</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//直接合并取最大</span></span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>]=<span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>],R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked">1. 两数之和 - 力扣（LeetCode）</a></p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>从O(N)-&gt;O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it=hashtable.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=hashtable.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="comment">//找的到满足的</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second,i&#125;;<span class="comment">//value对应索引</span></span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="快慢指针技巧"><a href="#快慢指针技巧" class="headerlink" title="快慢指针技巧"></a>快慢指针技巧</h3><p>删除重复项<br>巧妙，利用快慢指针，fast扫到一个新的直接赋值给slow<br>fast直是在最开始多1，速度是同步的</p>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>167 两数组之和 输入有序数组<br>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length 。</p>
<p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p>
<p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 非递减排序就可以用类似二分法</span></span><br><span class="line">        lenth=<span class="built_in">len</span>(numbers)</span><br><span class="line">        left,right=<span class="number">0</span>,lenth-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left!=right:</span><br><span class="line">            <span class="built_in">sum</span>=numbers[left]+numbers[right]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>==target:</span><br><span class="line">                <span class="keyword">return</span> [left+<span class="number">1</span>,right+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span>&lt;target:</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>5 最长回文子串<br>核心：对每个字符向两边扩散，注意区分奇偶数情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="comment"># 以 s[i] 为中心的最长回文子串</span></span><br><span class="line">        s1 = palindrome(s, i, i)</span><br><span class="line">        <span class="comment"># 以 s[i] 和 s[i+1] 为中心的最长回文子串</span></span><br><span class="line">        s2 = palindrome(s, i, i + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># res = longest(res, s1, s2)</span></span><br><span class="line">        res = res <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="built_in">len</span>(s1) <span class="keyword">else</span> s1</span><br><span class="line">        res = res <span class="keyword">if</span> <span class="built_in">len</span>(res) &gt; <span class="built_in">len</span>(s2) <span class="keyword">else</span> s2</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">palindrome</span>(<span class="params">s, l, r</span>):</span><br><span class="line">    <span class="keyword">while</span> (l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[l] == s[r]):</span><br><span class="line">        l -= <span class="number">1</span></span><br><span class="line">        r += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br></pre></td></tr></table></figure>

<p>调用内置函数</p>
<p><code>lower_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p><code>upper_bound( begin,end,num)</code>：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>例如，求最长上升子序列长度，可以利用升序特点把遍历查找dp改成二分查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTS_nlgn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])&#123;</span><br><span class="line">            dp[++len]=a[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pos=<span class="built_in">lower_bound</span>(dp,dp+len,a[i])-dp;</span><br><span class="line">            dp[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和 - 力扣（LeetCode）</a></p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p>这题不难，但是很值得思考，各种条件限制，逻辑</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; threeSum(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> length=nums.size();</span><br><span class="line">        //排序</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> first=<span class="number">0</span>;first&lt;length;first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; // 和上一次不一样 这个很重要也难想，因为first和first-<span class="number">1</span>相同，则二三都可能有两组满足</span><br><span class="line">            <span class="built_in">int</span> third=length-<span class="number">1</span>;//三指向最后一个来递减</span><br><span class="line">            <span class="built_in">int</span> target=-nums[first];//达到这个目标</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> second=first+<span class="number">1</span>;second&lt;length-<span class="number">1</span>;second++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(second&gt;first+<span class="number">1</span> &amp;&amp; nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                //为什么是大于，排完序之后，后面是大数</span><br><span class="line">                //third越减，值越小，大于就是为了提前结束后面的没必要再比了，而不至于造成second==thrid跳出后直接second的递增被<span class="keyword">break</span>了</span><br><span class="line">                <span class="keyword">while</span>(third&gt;second&amp;&amp;nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;second&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;third;</span><br><span class="line">                cout&lt;&lt;nums[second-<span class="number">1</span>]&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;nums[second];</span><br><span class="line">                <span class="keyword">if</span> (second==third)&#123;</span><br><span class="line">                    //重合</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;</span><br><span class="line">                    //满足条件</span><br><span class="line">                    res.push_back(&#123;nums[first],nums[second],nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h3><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组 - 力扣（LeetCode）</a></p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(<span class="number">0</span>,<span class="number">1</span>));<span class="comment">//初始化前缀和为0</span></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">find</span>(sum-k)!=map.<span class="built_in">end</span>())&#123;<span class="comment">//找不到返回map.end()</span></span><br><span class="line">                count+=map[sum-k];<span class="comment">//有值对应满足个数 不会计重，因为在此时有多少个满足的就有多少个子数组了，都得算上</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记得插入</span></span><br><span class="line">            map[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>动归&#x2F;DFS&#x2F;回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：</p>
<p>动态规划算法属于分解问题的思路，它的关注点在整棵「子树」。<br>回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。<br>DFS 算法属于遍历的思路，它的关注点在单个「节点」。</p>
<p>层序遍历</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">levelTraverse</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    q = deque()</span><br><span class="line">    q.append(root)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        sz = <span class="built_in">len</span>(q)</span><br><span class="line">        <span class="comment"># 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sz):</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="comment"># 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                q.append(cur.left)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                q.append(cur.right)</span><br></pre></td></tr></table></figure>

<h3 id="前中序构造"><a href="#前中序构造" class="headerlink" title="前中序构造"></a>前中序构造</h3><p>理解前中序数组的结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://labuladong.online/algo/images/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%972/4.jpeg" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="comment"># 存索引</span></span><br><span class="line"></span><br><span class="line">val2Index=&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):<span class="comment">#这里和leftSize对应</span></span><br><span class="line">            val2Index[inorder[i]]=i</span><br><span class="line">        <span class="keyword">return</span> self.build(preorder,<span class="number">0</span>,<span class="built_in">len</span>(preorder)-<span class="number">1</span>,inorder,<span class="number">0</span>,<span class="built_in">len</span>(inorder)-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self,preorder,prestart,preend,inorder,instart,inend</span>):</span><br><span class="line">        <span class="keyword">if</span> prestart&gt;preend:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        rootVal=preorder[prestart]</span><br><span class="line">        root=TreeNode(rootVal) <span class="comment"># 构造头</span></span><br><span class="line">        index=val2Index.get(rootVal)</span><br><span class="line">        leftSize=index-instart</span><br><span class="line">        root.left=self.build(preorder,prestart+<span class="number">1</span>,prestart+leftSize,inorder,instart,index-<span class="number">1</span>)</span><br><span class="line">        root.right=self.build(preorder,prestart+leftSize+<span class="number">1</span>,preend,inorder,index+<span class="number">1</span>,inend)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="中序后序"><a href="#中序后序" class="headerlink" title="中序后序"></a>中序后序</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20240406013906501.png" alt="image-20240406013906501"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line">var2Index=&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, inorder, postorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)): <span class="comment">#这里和rightSize对应</span></span><br><span class="line">            var2Index[inorder[i]]=i</span><br><span class="line">        <span class="keyword">return</span> self.build(postorder,<span class="built_in">len</span>(postorder)-<span class="number">1</span>,<span class="number">0</span>,inorder,<span class="number">0</span>,<span class="built_in">len</span>(inorder)-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self,postorder,poststart,postend,inorder,instart,inend</span>):</span><br><span class="line">        <span class="keyword">if</span> poststart&lt;postend:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># if instart &gt; inend:</span></span><br><span class="line">        <span class="comment">#     return None</span></span><br><span class="line"></span><br><span class="line">        rootVal=postorder[poststart]</span><br><span class="line">        root=TreeNode(rootVal)</span><br><span class="line">        index=var2Index.get(rootVal)</span><br><span class="line">        rightSize=inend-index</span><br><span class="line"></span><br><span class="line">        root.right=self.build(postorder,poststart-<span class="number">1</span>,poststart-rightSize,inorder,index+<span class="number">1</span>,inend)</span><br><span class="line">        root.left=self.build(postorder,poststart-rightSize-<span class="number">1</span>,postend,inorder,instart,index-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="前序后序"><a href="#前序后序" class="headerlink" title="前序后序"></a>前序后序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var2Index=&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructFromPrePost</span>(<span class="params">self, preorder, postorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(postorder)):</span><br><span class="line">            var2Index[postorder[i]]=i</span><br><span class="line">        <span class="keyword">return</span> self.build(preorder,<span class="number">0</span>,<span class="built_in">len</span>(preorder)-<span class="number">1</span>,postorder,<span class="built_in">len</span>(postorder)-<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">self,preorder,prestart,preend,postorder,poststart,postend</span>):</span><br><span class="line">        <span class="keyword">if</span> prestart&gt;preend:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> prestart==preend:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(preorder[prestart])</span><br><span class="line">        rootVal=preorder[prestart]</span><br><span class="line">        root=TreeNode(rootVal)</span><br><span class="line">        leftrootVal=preorder[prestart+<span class="number">1</span>]</span><br><span class="line">        <span class="comment">#直接折半</span></span><br><span class="line">        index=var2Index.get(leftrootVal)</span><br><span class="line">        leftSize=index-postend+<span class="number">1</span></span><br><span class="line">        root.left=self.build(preorder,prestart+<span class="number">1</span>,prestart+leftSize,postorder,index,postend)</span><br><span class="line">        root.right=self.build(preorder,prestart+leftSize+<span class="number">1</span>,preend,postorder,poststart-<span class="number">1</span>,index+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="广度优先BFS"><a href="#广度优先BFS" class="headerlink" title="广度优先BFS"></a>广度优先BFS</h3><p><a target="_blank" rel="noopener" href="https://noobdream.com/DreamJudge/Issue/page/1563/#">1563 - 迷宫 _N诺计算机考研 (noobdream.com)</a></p>
<p>队列+访问记录</p>
<p>pop一个，push所有邻接的，并且要标记当前为访问的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> mpt[maxn][maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="comment">//代表上下左右四个动作对应的x，y变化，调用就行 </span></span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="type">int</span> step;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迷宫 BFS </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy)</span></span>&#123;</span><br><span class="line">	<span class="comment">//记录访问</span></span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">	queue&lt;node&gt; q;<span class="comment">//使用队列来维护一层层发散的优先级</span></span><br><span class="line">	q.<span class="built_in">push</span>(node&#123;sx,sy,<span class="number">0</span>&#125;);</span><br><span class="line">	vis[sx][sy]=<span class="number">1</span>;<span class="comment">//起点已访问</span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node now=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();<span class="comment">//出队</span></span><br><span class="line">		<span class="keyword">if</span>(mpt[now.x][now.y]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">//找到终点</span></span><br><span class="line">			ans=now.step;<span class="comment">//记录步数 </span></span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//上下左右四个方向都试一遍 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">			<span class="type">int</span> nx=now.x+dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ny=now.y+dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="comment">//判断可走同时未被访问</span></span><br><span class="line">			<span class="keyword">if</span>((mpt[nx][ny]==<span class="string">&#x27;*&#x27;</span>||mpt[nx][ny]==<span class="string">&#x27;E&#x27;</span>)&amp;&amp;vis[nx][ny]==<span class="number">0</span>)&#123;</span><br><span class="line">				q.<span class="built_in">push</span>(node&#123;nx,ny,now.step+<span class="number">1</span>&#125;);</span><br><span class="line">				vis[nx][ny]=<span class="number">1</span>;<span class="comment">//标记访问 </span></span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> h,w;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;h,&amp;w)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(h==<span class="number">0</span>&amp;&amp;w==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="type">int</span> sx=<span class="number">0</span>,sy=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(mpt,<span class="number">0</span>,<span class="built_in">sizeof</span>(mpt));<span class="comment">//填充0</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mpt[i]+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(mpt[i][j]==<span class="string">&#x27;S&#x27;</span>)&#123;</span><br><span class="line">					sx=i,sy=j;<span class="comment">//记录起点 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="type">int</span> ans=<span class="built_in">bfs</span>(sx,sy);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="Hanoi塔"><a href="#Hanoi塔" class="headerlink" title="Hanoi塔"></a>Hanoi塔</h4><p>注意移动要借助才行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hanoi</span>(n<span class="number">-1</span>,p,h,m);<span class="comment">//前n-1个 从第一个经过第三个移动到第二个 </span></span><br><span class="line"><span class="built_in">hanoi</span>(<span class="number">1</span>,p,m,h);<span class="comment">//最后一个经过第二个移动到第三个 </span></span><br><span class="line"><span class="built_in">hanoi</span>(n<span class="number">-1</span>,m,p,h);<span class="comment">//n-1从第二个经过第一个移动到第三个 </span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//汉诺塔 不是简单的一步移动，而是要借助其他的 </span></span><br><span class="line"><span class="type">int</span> step;<span class="comment">//移动步数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> p,<span class="type">char</span> m,<span class="type">char</span> h)</span></span>&#123;<span class="comment">//表示要将p经过m移动到h </span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>((step+<span class="number">1</span>)%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//输出格式要求</span></span><br><span class="line">			cout&lt;&lt;p&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;h&lt;&lt;endl; <span class="comment">//不能特指，而是通过变量的形式 </span></span><br><span class="line">		&#125;<span class="keyword">else</span> cout&lt;&lt;p&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;h&lt;&lt;<span class="string">&quot;   &quot;</span>;</span><br><span class="line">		step++;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">hanoi</span>(n<span class="number">-1</span>,p,h,m);<span class="comment">//前n-1个 从第一个经过第三个移动到第二个 </span></span><br><span class="line">	<span class="built_in">hanoi</span>(<span class="number">1</span>,p,m,h);<span class="comment">//最后一个经过第二个移动到第三个 </span></span><br><span class="line">	<span class="built_in">hanoi</span>(n<span class="number">-1</span>,m,p,h);<span class="comment">//n-1从第二个经过第一个移动到第三个 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n))&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		step=<span class="number">0</span>; </span><br><span class="line">		<span class="built_in">hanoi</span>(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>实现方式：递归。递归流程-&gt;递归树-&gt;多叉树</p>
<p>简单来说，BFS和DFS到底有什么区别呢？<br>对于一棵二义树，<br><strong>BFS</strong>就是二叉树的<strong>层次遍历</strong>，一层一层的扩展下去。<br>DS就是二义树的中序遍历，一条路走到底，然后回溯走第二条，直到所有路都走完。</p>
<p>需要注意的是，DFS一般情沉下效率不如BFS,比如求DFS中的迷宫的最短路径使用DFS就会超时。</p>
<p>迷宫</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> mpt[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">char</span> vis[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> H=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//上下左右 </span></span><br><span class="line"><span class="type">int</span> minres=<span class="number">1000000</span>;</span><br><span class="line"><span class="comment">//要标记vis！不然就是死循环 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sx,<span class="type">int</span> sy,<span class="type">int</span> res)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(res&gt;=minres) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(mpt[sx][sy]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (res&lt;minres)&#123;</span><br><span class="line">			minres=res;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> newx=sx+dir[i][<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> newy=sy+dir[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>((mpt[newx][newy]==<span class="string">&#x27;*&#x27;</span>||mpt[newx][newy]==<span class="string">&#x27;E&#x27;</span>)&amp;&amp;vis[newx][newy]==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//可以走，递归</span></span><br><span class="line">			vis[newx][newy]=<span class="number">1</span>;<span class="comment">//访问过 </span></span><br><span class="line">			<span class="built_in">dfs</span>(newx,newy,res+<span class="number">1</span>);</span><br><span class="line">			vis[newx][newy]=<span class="number">0</span>;<span class="comment">//记得回溯，你退出来要留给其他路径走 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> sx=<span class="number">0</span>,sy=<span class="number">0</span>;<span class="comment">//记录出入口 </span></span><br><span class="line">	<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;H,&amp;W)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(H==<span class="number">0</span>&amp;&amp;W==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;H;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;W;j++)&#123;</span><br><span class="line">				cin&gt;&gt;mpt[i][j];</span><br><span class="line">				<span class="keyword">if</span>(mpt[i][j]==<span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">					sx=i;</span><br><span class="line">					sy=j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		minres=<span class="number">1000000</span>;<span class="comment">//注意每轮都要重新设置 </span></span><br><span class="line">		<span class="built_in">dfs</span>(sx,sy,<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(minres==<span class="number">1000000</span>) cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout&lt;&lt;minres&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>邻接矩阵是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(邻接矩阵)存储图中的边或弧的信息</p>
<p>arc[i][j]&#x3D;1,若(v<sub>i</sub>,v<sub>j</sub>)∈E或(v<sub>j</sub>,v<sub>i</sub>)∈E：0,反之</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/05/29/4dWl9R5qYFBySDZ.png" alt="image.png"></p>
<p>特点：</p>
<ul>
<li>要判断任意两顶点是否有边无边就很容易了；</li>
<li>要知道某个顶点的度，其实就是这个顶点vi 在邻接矩阵中第i 行或（第i 列）的元素之和；</li>
<li>求顶点vi 的所有邻接点就是将矩阵中第i 行元素扫描一遍，arc[i][j]为1 就是邻接点；而有向图讲究入度和出度，顶点vi 的<strong>入度</strong>为1，正好是第i <strong>列</strong>各数之和。顶点vi 的<strong>出度</strong>为2，即第i <strong>行</strong>的各数之和。</li>
</ul>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>对于边数相对顶点较少的图，邻接矩阵对空间浪费。邻接表是数组和链表相结合的方法，更加适合，即顶点表(一位数组)和边表(链表)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/05/29/5iTjQse6bMByPR2.png" alt="image.png"></p>
<p>从图中可以看出，顶点表的各个结点由data 和firstedge 两个域表示，data 是数据域，存储顶点的信息，firstedge 是指针域，指向边表的第一个结点，即此顶点的第一个邻接点。边表结点由adjvex 和next 两个域组成。adjvex 是邻接点域，存储某顶点的邻接点在顶点表中的下标，next 则存储指向边表中下一个结点的指针。</p>
<blockquote>
<p>对于带权的网图，在边表结点定义下加一个weight的数据域，存储权值信息即可</p>
</blockquote>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>n个顶点e条边的无向图–&gt;邻接表表示有n个顶点表节点，2e个边表结点</p>
<p>n个顶点e条边的有向图–&gt;邻接表表示有n个顶点表节点，e个边表结点</p>
<p>如果图中边的数目远远小于n<sup>2</sup>称作<u>稀疏图</u>，这时用邻接表表示比用邻接矩阵表示节省空间;</p>
<p>如果图中边的数目接近于n<sup>2</sup>,对于无向图接近于n*(n-1)称作<u>稠密图</u>,考虑到邻接表中要附加链域，采用邻接矩阵表示法为宜。</p>
<h3 id="并查集-Disjoint-Set-Union"><a href="#并查集-Disjoint-Set-Union" class="headerlink" title="并查集(Disjoint Set Union)"></a>并查集(Disjoint Set Union)</h3><p>Disjoint Set Union：不相交集合并集</p>
<p>解决集合类问题，核心是：树形结构+路径压缩思想，加快区分集合，效率远高于map</p>
<p>并查集还有一个英文名字：<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=union&spm=1001.2101.3001.7020">union</a>-find sets，从这里可以看出，并查集就是合并(union)查找(find)的集合(set)</p>
<p>代码实现</p>
<p>1.初始化</p>
<p>假设有编号1,2,3,…,n的n个元素，用数组fa[]<strong>来存储每个元素的父节点</strong>，初始化f[i]&#x3D;i</p>
<p>2.查询</p>
<p>find，查找i的祖先代表元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[i]==i) <span class="keyword">return</span> i;<span class="comment">//递归出口到达祖先</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(fa[i]);<span class="comment">//不断往上查找祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.合并</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionn</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i_fa=<span class="built_in">find</span>(i);<span class="comment">//找到i的祖先 </span></span><br><span class="line">    <span class="type">int</span> j_fa=<span class="built_in">find</span>(j);<span class="comment">//找到j的祖先</span></span><br><span class="line">    fa[i_fa]=j_fa;<span class="comment">//i的祖先指向j的祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，每次从根开始查都要查n个结点直至到最上面的祖先，大大增加时间开销，因此，出现<strong>路径压缩方</strong>法，也就是直接指向最大的祖先</p>
<pre class="mermaid">graph TD
1-->1
2-->1
3-->2
4-->3</pre>

<p>变为</p>
<pre class="mermaid">graph TD
1-->1
2-->1
3-->1
4-->1</pre>

<p>查询语句变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==fa[i]) <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">else</span> fa[i]=<span class="built_in">find</span>(fa[i]);<span class="comment">//进行路径压缩 更新最</span></span><br><span class="line">    <span class="keyword">return</span> fa[i];<span class="comment">//返回父节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例题<a target="_blank" rel="noopener" href="https://noobdream.com/DreamJudge/Issue/page/1319/#">1319 - 畅通工程2 _N诺计算机考研 (noobdream.com)</a></p>
<p>每个城镇都要可达，最小添加多少。其实可以发现只要是有共同祖先的，都是可以连通的，那么如何判断需要加多少条呢？</p>
<ul>
<li>判断已经连通的城镇数。在查找合并的时候，如果发现祖先不同，合并的时候联通的城镇数就加1，最后N-sum-1</li>
<li>在判定完后遍历fa，如果等于本身，sum++，最后输出sum-1。这里sum表示有多少个独立的集合，连接这sum个独立集合只需要sum-1条边</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> fa[<span class="number">1001</span>];<span class="comment">//记录祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;<span class="comment">//祖先</span></span><br><span class="line">	fa[x]=<span class="built_in">find</span>(fa[x]);<span class="comment">//压缩 我要祖先的祖先 </span></span><br><span class="line">	<span class="keyword">return</span> fa[x];<span class="comment">//返回上一级祖先 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N,M;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;N)&#123;</span><br><span class="line">		<span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		cin&gt;&gt;M;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//初始化城市</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) fa[i]=i;</span><br><span class="line">		<span class="comment">//读取道路</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">			<span class="type">int</span> a,b;</span><br><span class="line">			cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			<span class="type">int</span> fxa=<span class="built_in">find</span>(a);</span><br><span class="line">			<span class="type">int</span> fxb=<span class="built_in">find</span>(b);</span><br><span class="line">			<span class="keyword">if</span>(fxa!=fxb)&#123;</span><br><span class="line">				<span class="comment">//本身不连通，现在联通了</span></span><br><span class="line">				 fa[fxa]=fxb;</span><br><span class="line">				 sum++;<span class="comment">//把对方看作一个单位，那就是多加一个连通的了 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,N-sum<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很奇怪的是上面代码在N诺如果用scanf反而超时…</p>
</blockquote>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43619271/article/details/109091314">最小生成树详解(模板 + 例题)-CSDN博客</a></p>
<p>一个图中可能存在多条相连的边,我们<strong>一定可以从一个图中挑出一些边生成一棵树。</strong>这仅仅是生成一棵树,还未满足最小,<strong>当图中每条边都存在权重时,这时候我们从图中生成一棵树(n - 1 条边)时,生成这棵树的总代价就是每条边的权重相加之和。</strong></p>
<blockquote>
<p> 找最小带权图</p>
</blockquote>
<h4 id="Kruskal-加边法"><a href="#Kruskal-加边法" class="headerlink" title="Kruskal 加边法"></a>Kruskal 加边法</h4><p><strong>Kruskal（克鲁斯卡尔）算法是一种巧妙利用并查集来求最小生成树的算法。</strong></p>
<p>Kruskal算法将一个连通块当做一个集合。Kruskal首先将所有的边按从小到大顺序排序（一般使用快排），并认为每一个点都是孤立的，分属于n个独立的集合。然后按顺序枚举每一条边。如果这条边连接着两个不同的集合，那么就把这条边加入最小生成树，这两个不同的集合就合并成了一个集合；如果这条边连接的两个点<strong>属于同一集合，就跳过</strong>。直到选取了n-1条边为止。</p>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h4><p>邻接矩阵，最大初始化，三种全遍历循环，k在外头</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> mpt[maxn][maxn]; </span><br><span class="line"><span class="type">int</span> N,M;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//k在i,j之间 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=N;k++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">				mpt[i][j]=<span class="built_in">min</span>(mpt[i][k]+mpt[k][j],mpt[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">if</span>(N+M==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//初始化赋最大值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==j) mpt[i][j]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> mpt[i][j]=<span class="number">100000000</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">			<span class="type">int</span> vi,vj,w;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;vi,&amp;vj,&amp;w);</span><br><span class="line">			<span class="comment">//注意重边！</span></span><br><span class="line">			<span class="keyword">if</span>(w&lt;mpt[vi][vj])&#123;</span><br><span class="line">				mpt[vi][vj]=w;</span><br><span class="line">				mpt[vj][vi]=w;<span class="comment">//对称 </span></span><br><span class="line">			&#125; </span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">floyd</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,mpt[<span class="number">1</span>][N]);<span class="comment">//起点到终点的最短路径 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">505</span>;</span><br><span class="line"><span class="type">bool</span> mpt[maxn][maxn];<span class="comment">//记录图 </span></span><br><span class="line"><span class="type">int</span> lev[maxn];<span class="comment">//记录i个结点的入度</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[maxn];<span class="comment">//表示被i进入的邻居 </span></span><br><span class="line"><span class="comment">//priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//最小堆优先队列存放入度为0的优先队列 </span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt;q;<span class="comment">//最小堆优先队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topo</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!lev[i]) q.<span class="built_in">push</span>(i);<span class="comment">//存放入度为1 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> flag=<span class="number">0</span>;<span class="comment">//统计出队元素个数</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> now=q.<span class="built_in">top</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();<span class="comment">//踢出 </span></span><br><span class="line">		<span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,now);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,now);</span><br><span class="line">		flag++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[now].<span class="built_in">size</span>();i++)&#123;<span class="comment">//修改邻居的入度 </span></span><br><span class="line">			<span class="type">int</span> next=v[now][i];</span><br><span class="line">			lev[next]--;</span><br><span class="line">			<span class="keyword">if</span>(!lev[next]) q.<span class="built_in">push</span>(next);<span class="comment">//入度变0了 </span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span>(flag!=n)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;这个图有环，并没有拓扑排序\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">memset</span>(lev,<span class="number">0</span>,<span class="built_in">sizeof</span>(lev));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)v[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="type">int</span> a,b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">			v[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">			lev[b]++;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">topo</span>(n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>递归和回溯相辅相成</p>
<p>递归函数下面就是回溯内容</p>
<p>回溯搜索：纯暴力搜索算法</p>
<ul>
<li>组合问题</li>
<li>切割问题</li>
<li>子集问题</li>
<li>排列问题 </li>
<li>棋盘问题，n王后，解数独</li>
</ul>
<p>抽象为n叉数问题，横向节点用for循环表示，纵向深度用递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">        在叶子节点搜集结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(集合元素)&#123;</span><br><span class="line">        处理结点;</span><br><span class="line">        递归;</span><br><span class="line">        回溯;<span class="comment">//撤销处理节点结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回溯三部曲</p>
<ul>
<li>递归函数参数返回值</li>
<li>确定终止条件</li>
<li>单层递归逻辑(最后一步回溯pop)</li>
</ul>
<h3 id="组合和排列"><a href="#组合和排列" class="headerlink" title="组合和排列"></a>组合和排列</h3><p>回溯用递归模拟了嵌套n层for循环的方式。</p>
<p>回溯：递归嵌套for循环</p>
<p>组合不区分顺序，排列区分</p>
<p>叶子结点收割结果：也就是数组大小等于数的个数</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一个完全二叉树，只有最后一层不满，且只能没有右子节点</p>
<p><strong>堆序性：</strong></p>
<ul>
<li>大根堆</li>
<li>小根堆</li>
</ul>
<p><strong>存储：</strong></p>
<p>用一位数组，从上到下从左到右给每个节点编号，这个就是在数组的存储序号</p>
<p>这样存储有一个规律，设节点下标为i：</p>
<ul>
<li>左子节点下标为2i+1</li>
<li>右子节点下标为2i+2</li>
</ul>
<p><strong>上滤和下滤：</strong>O(logN)</p>
<ul>
<li>当根节点不满足堆序性，子树都满足时(以大根堆为例)，把该节点和最有子树最大值比较然后换位，直到没有小于或者到达最后一层，这就是下滤</li>
<li>同理，上滤就是和根比较，小于就换，直到遇到比他小的或到根节点</li>
</ul>
<p><strong>建堆：</strong></p>
<ul>
<li>自顶向下建堆法 O(NlogN)<ul>
<li>将新元素放到堆的<strong>最后一位</strong>，然后进行<strong>上滤</strong>操作</li>
</ul>
</li>
<li>自下而上建堆法 O(n)<ul>
<li>首先将下面的调整成堆，然后对父节点进行下滤，直到根节点操作完毕</li>
</ul>
</li>
</ul>
<p><strong>应用：</strong></p>
<ul>
<li>优先队列(小根堆)，是插入队列后弹出最小元素。直接弹出排好序的堆的根节点<ul>
<li>弹出后，将最后一个元素放到根节点，重新进行下滤就有序了</li>
</ul>
</li>
<li>插入操作，插入到尾部，然后进行上滤</li>
</ul>
<p><strong>堆排序：</strong></p>
<p>就是将优先队列的所有元素依次弹出即可！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20240511152631639.png" alt="image-20240511152631639"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20240511152655004.png" alt="image-20240511152655004"></p>
<blockquote>
<p>然而实际为了考虑空间复杂度会利用原来堆的空余位置建立有序区</p>
</blockquote>
<p>如何做：</p>
<ol>
<li>先调整为最大堆(最大元素在顶上)</li>
<li>将根节点和最后一个元素(不一定最小)交换，此时最后一个位置就是有序区的开始</li>
<li>然后将新的根节点进行下滤，完成后根节点又是最大的，把它的倒数第二个交换(倒数第一个位置已经是有序区了)，这时有序区延伸到倒数第二个位置</li>
<li>重复扩大有序区，直到全部有序，这是会发现，大的在最后，小的在最前，也就是递增序列</li>
</ol>
<p>因此：形成递增则构造最大堆，递减则构造最小堆</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.337.search-card.all.click&vd_source=8ecff66abb776707f111647a284db8d9">【从堆的定义到优先队列、堆排序】 10分钟看懂必考的数据结构——堆_哔哩哔哩_bilibili</a></p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p><strong>核心是：最优子结构</strong>。不都是(如乘积最大子数组，根据题意适当变动</p>
<ul>
<li>动规基础</li>
<li>背包问题</li>
<li>打家劫舍</li>
<li>股票问题</li>
<li>子序列问题</li>
</ul>
<p>重要点：</p>
<ul>
<li>dp数组以及下界的含义，dp[i][j]、dp[i]</li>
<li>递推公式</li>
<li>dp数组如何初始化,0?1?…</li>
<li>遍历顺序</li>
<li>打印dp数组，看看输出结果是否正确</li>
</ul>
<p>斐波那契，dp数组降到1维，动态变化三个值即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        dp_i=<span class="number">1</span></span><br><span class="line">        dp_ii=<span class="number">1</span></span><br><span class="line">        dp_iii=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            dp_iii=dp_i+dp_ii</span><br><span class="line">            dp_i=dp_ii</span><br><span class="line">            dp_ii=dp_iii</span><br><span class="line">        <span class="keyword">return</span> dp_iii</span><br></pre></td></tr></table></figure>

<h3 id="跳楼梯"><a href="#跳楼梯" class="headerlink" title="跳楼梯"></a>跳楼梯</h3><p>照动态规划思想，我们可以先分析下问题，每次都有两种跳法，分别是一阶或者两阶，那么如果当前是第n 个台阶，那么跳法是不是是(n-1)台阶的跳法数加上(n-2)台阶的跳法数？如果划算成公式是F(n) &#x3D; F(n-1)+F(n-2)。</p>
<p>这里容易有误区，为什么不是F(n-1)加一步，然后F(n-1)加两步(跳一个和两个)。首先F(n-1)到F(n)此时只有唯一的一种操作，那么到F(n)的步数就是F(n-1)。而F(n-1)跳一步的情况已经被F(n-1)包括了，此时只有跳两步的操作，同上，只有F(n-2)的情况。因此F(n)&#x3D;F(n-1)+F(n-2)</p>
<p>如果测试样例一直过不了，考虑数据类型，要开<code>long long</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> tff=<span class="number">1</span>,tf=<span class="number">2</span>,fin=<span class="number">2</span>;<span class="comment">//开long long才够</span></span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">			cout&lt;&lt;n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				fin=tff+tf;</span><br><span class="line">				tff=tf;</span><br><span class="line">				tf=fin;	</span><br><span class="line">			&#125;</span><br><span class="line">			cout&lt;&lt;fin;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h3><h4 id="最大序列和"><a href="#最大序列和" class="headerlink" title="最大序列和"></a>最大序列和</h4><blockquote>
<p> 可能自己就已经大于加上前面的了(前面时负数)!!!!</p>
<p>并且，子序列是连续的！</p>
</blockquote>
<p>对于dp输出，dp[i]表示到第i的最大序列和，可能是前一个加上自己或者仅是自己。</p>
<p>然而，最长的不一定是最大的，如果前面已经达到最大的了呢？那么我们需要维护一个最大值，如果大于他，更新。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="comment">//维护一个最大值</span></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> maxn=<span class="number">-100000000</span>; </span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> fin=<span class="number">-100000000</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">			cin&gt;&gt;ans[i];</span><br><span class="line">			maxn=<span class="built_in">max</span>(maxn+ans[i],ans[i]);</span><br><span class="line">			<span class="keyword">if</span>(maxn&gt;fin) fin=maxn;</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//每个都要找子序列，然后跟新最大的</span></span><br><span class="line">		 </span><br><span class="line">		cout&lt;&lt;fin&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串区间翻转-题意转换"><a href="#字符串区间翻转-题意转换" class="headerlink" title="字符串区间翻转 题意转换"></a>字符串区间翻转 题意转换</h4><p><a target="_blank" rel="noopener" href="https://noobdream.com/DreamJudge/Issue/page/1642/#">1642 - 字符串区间翻转 _N诺计算机考研 (noobdream.com)</a></p>
<p>我们把01字符串的0变成1,1变成-1，然后构成一个1和-1的字符串。<br>对这样一个字符串去求它的最大子段和即可，最后再把1的个数加上就是最终的答案。</p>
<p>为什么可以这样?</p>
<ul>
<li>本质是求0和1最大数量差的区间</li>
<li>最大序列和就意味着反转后，这里会在01反转互相抵消之下又多出多少个1，因此和原本的1加上，就是翻转后1的个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> _max(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);<span class="comment">//读取字符串</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;s;</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment">//遍历构建构建新数组，0-&gt;1,1-&gt;-1 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>) a[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> a[i]=<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//			cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">		dp[<span class="number">0</span>]=a[<span class="number">0</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			dp[i]=_max(dp[i<span class="number">-1</span>]+a[i],a[i]);<span class="comment">//最大序列和</span></span><br><span class="line">			<span class="keyword">if</span>(dp[i]&gt;maxn) maxn=dp[i]; </span><br><span class="line"><span class="comment">//			cout&lt;&lt;dp[i]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>) maxn++;</span><br><span class="line">		cout&lt;&lt;maxn&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的<strong>子序列长度加一</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">        dp[i] = Math.<span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用函数lower_bound</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LTS_nlgn</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])&#123;</span><br><span class="line">            dp[++len]=a[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pos=<span class="built_in">lower_bound</span>(dp,dp+len,a[i])-dp;<span class="comment">//从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</span></span><br><span class="line">            dp[pos]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1002</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) cin&gt;&gt;a[i];</span><br><span class="line">		<span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			dp[i]=<span class="number">1</span>;<span class="comment">//清空上一个样例</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">					<span class="comment">//满足升序</span></span><br><span class="line">					dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+a[i]);</span><br><span class="line">					<span class="keyword">if</span>(dp[i]&gt;maxn) maxn=dp[i];</span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;maxn&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列-二维dp"><a href="#最长公共子序列-二维dp" class="headerlink" title="最长公共子序列 二维dp"></a>最长公共子序列 二维dp</h3><p>dp[i, j]代表a 字符串前i 个字符组成的子串和b 字符串前j 个字符组成的子串的LCS。<br>那么<br>dp[i, j] &#x3D; 0 if i &#x3D; 0 or j &#x3D; 0<br>dp[i, j] &#x3D; dp[i - 1, j - 1] + 1 if i, j &gt; 0 and ai &#x3D; bj<br>dp[i, j] &#x3D; max{dp[i, j - 1], dp[i - 1, j]} if i, j &gt; 0 and ai !&#x3D; bj 至少一个满足</p>
<blockquote>
<p>注意，这里0留空了，dp数组从1开始，因此对比是要比较s1[i-1]和s2[j-1]，最后输出是输出dp[strlen(s1)][strlen(s2)]</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s1[<span class="number">101</span>];</span><br><span class="line"><span class="type">char</span> s2[<span class="number">101</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s1)!=EOF)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s2);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(s1);i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="built_in">strlen</span>(s2);j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line"><span class="comment">//				maxn=max(maxn,dp[i][j]);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;dp[<span class="built_in">strlen</span>(s1)][<span class="built_in">strlen</span>(s2)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="最少编辑长度"><a href="#最少编辑长度" class="headerlink" title="最少编辑长度"></a>最少编辑长度</h3><p>字符串动规，递归超时</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离 - 力扣（LeetCode）</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1, word2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word1: str</span></span><br><span class="line"><span class="string">        :type word2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m,n=<span class="built_in">len</span>(word1),<span class="built_in">len</span>(word2)</span><br><span class="line">        dp=[[<span class="number">0</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>]=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j]=j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>]==word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j]=<span class="built_in">min</span>(</span><br><span class="line">                        dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,</span><br><span class="line">                        dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,</span><br><span class="line">                        dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                    )</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/description/?envType=study-plan-v2&envId=top-100-liked">152. 乘积最大子数组 - 力扣（LeetCode）</a></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续</p>
<p>子数组</p>
<p>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<p>关键：当前位置的最优解未必是由前一个位置的最优解转移得到的-&gt;<strong>根据正负性进行分类讨论</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProduct</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        length=<span class="built_in">len</span>(nums)</span><br><span class="line">        dpmax=[<span class="number">0</span>]*length</span><br><span class="line">        dpmin=[<span class="number">0</span>]*length</span><br><span class="line">        dpmax[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">        dpmin[<span class="number">0</span>]=nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">            dpmax[i]=<span class="built_in">max</span>(dpmax[i-<span class="number">1</span>]*nums[i],dpmin[i-<span class="number">1</span>]*nums[i],nums[i])</span><br><span class="line">            <span class="comment"># 「负得更多」，即尽可能小</span></span><br><span class="line">            dpmin[i]=<span class="built_in">min</span>(dpmax[i-<span class="number">1</span>]*nums[i],dpmin[i-<span class="number">1</span>]*nums[i],nums[i])</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(dpmax)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dpmax)</span><br></pre></td></tr></table></figure>



<h3 id="完全平方"><a href="#完全平方" class="headerlink" title="完全平方"></a>完全平方</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked">279. 完全平方数 - 力扣（LeetCode）</a></p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p>数学拆分为jxj+i-jxj，i-jxj就是一个子问题，遍历枚举</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dp=[<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            j=<span class="number">1</span></span><br><span class="line">            minn=sys.maxsize </span><br><span class="line">            <span class="keyword">while</span> j*j&lt;=i:</span><br><span class="line">                minn=<span class="built_in">min</span>(dp[i-j*j],minn)</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            dp[i]=minn+<span class="number">1</span> <span class="comment"># 超分成i-j*j的子集+j的情况，这个1就是代表j</span></span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><strong>第一步要明确两点，「状态」和「选择」</strong>。只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。<strong>所以状态有两个，就是「背包的容量」和「可选择的物品」</strong>。</p>
<p>对于每件物品，你能选择什么？<strong>选择就是「装进背包」或者「不装进背包」嘛</strong>。</p>
<p><strong>第二步要明确 <code>dp</code> 数组的定义</strong>。</p>
<p>两个状态-&gt;一个二维dp数组</p>
<p><code>dp[i][w]</code> 的定义如下：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code>，这种情况下可以装的最大价值是 <code>dp[i][w]</code>。 (前i个任取，放到w容量的背包)</p>
<p>比如说，如果 <code>dp[3][5] = 6</code>，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。</p>
<p>根据这个定义，我们想求的最终答案就是 <code>dp[N][W]</code>。base case 就是 <code>dp[0][..] = dp[..][0] = 0</code>，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。</p>
<p><strong>第三步，根据「选择」，思考状态转移的逻辑</strong>。</p>
<p><strong>如果你没有把这第 <code>i</code> 个物品装入背包</strong>，那么很显然，最大价值 <code>dp[i][w]</code> 应该等于 <code>dp[i-1][w]</code>，继承之前的结果。</p>
<p><strong>如果你把这第 <code>i</code> 个物品装入了背包</strong>，那么 <code>dp[i][w]</code> 应该等于 <code>val[i-1] + dp[i-1][w - wt[i-1]]</code>。(定义i从1开始，所以 <code>val[i-1]</code> 和 <code>wt[i-1]</code> 表示第 <code>i</code> 个物品的价值和重量)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：python 代码由 chatGPT🤖 根据我的 java 代码翻译，旨在帮助不同背景的读者理解算法逻辑。</span></span><br><span class="line"><span class="comment"># 本代码不保证正确性，仅供参考。如有疑惑，可以参照我写的 java 代码对比查看。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">W: <span class="built_in">int</span>, N: <span class="built_in">int</span>, wt: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">assert</span> N == <span class="built_in">len</span>(wt)</span><br><span class="line">    <span class="comment"># 初始化一个二维数组，用于存储状态</span></span><br><span class="line">    <span class="comment"># dp[i][j] 表示将前 i 个物品装入容量为 j 的背包中所获得的最大价值</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (W + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 开始进行递推</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, W + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> w - wt[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 当前商品 i 的重量已经超过了 w，无法被放入当前容量为 w 的背包中，只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 当前商品 i 的重量小于等于当前容量 w，可以尝试将其放入背包中</span></span><br><span class="line">                <span class="comment"># 取最大值，考虑是将其放入之前的最优方案中还是选择不放</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(</span><br><span class="line">                    dp[i - <span class="number">1</span>][w - wt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>],<span class="comment"># 放第i个物品，那么就要从i-1个物品中加上第i个，注意重要要从当前的减去第i个物品的开始加.同时，因为val从0开始放，所以第i个重量是val[i-1]</span></span><br><span class="line">                    dp[i - <span class="number">1</span>][w] <span class="comment"># 啥都不放</span></span><br><span class="line">                )</span><br><span class="line">    <span class="comment"># 返回最大价值</span></span><br><span class="line">    <span class="keyword">return</span> dp[N][W]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="简化版背包"><a href="#简化版背包" class="headerlink" title="简化版背包"></a>简化版背包</h4><p><strong>值得思考的简化版背包</strong></p>
<p>设有一个背包可以放入的物品重量为S，现有n件物品，重量分别是w1，w2，w3，…wn。</p>
<p>问能否从这n件物品中选择若干件放入背包中，使得放入的重量之和正好为S。</p>
<p>如果有满足条件的选择，则此背包有解，否则此背包问题无解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//int dp[1001][1001];//代表前i 个物品背包容量最大为j 最多能装的物品总重量</span></span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>]=&#123;<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> ths[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> s,n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;n)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ths[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));<span class="comment">//必要清空 </span></span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//前i件物品凑成重量0可行性为1  这一步初始化关键！</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=s;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">				<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]==<span class="number">1</span>) dp[i][j]=<span class="number">1</span>;<span class="comment">//前i-1已经可以满足</span></span><br><span class="line">				<span class="keyword">if</span>(j&gt;=ths[i<span class="number">-1</span>]&amp;&amp;dp[i<span class="number">-1</span>][j-ths[i<span class="number">-1</span>]]==<span class="number">1</span>) dp[i][j]=<span class="number">1</span>;<span class="comment">//能够凑成 </span></span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dp[n][s]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="常规01背包"><a href="#常规01背包" class="headerlink" title="常规01背包"></a>常规01背包</h4><p><a target="_blank" rel="noopener" href="https://noobdream.com/DreamJudge/Issue/page/1567/#">1567 - Buyer _N诺计算机考研 (noobdream.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cost[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> pop[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//表示前i个到达费用j的受欢迎指数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> M,N; <span class="comment">//M钱数,N种类 </span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; buy[<span class="number">105</span>];<span class="comment">//记录方案 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;M,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) cin&gt;&gt;cost[i]&gt;&gt;pop[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=M;j++)&#123; <span class="comment">//从0块开始 </span></span><br><span class="line">				<span class="comment">//放与不放 </span></span><br><span class="line">				<span class="comment">//如果大于当前的</span></span><br><span class="line">				<span class="keyword">if</span>(j&gt;=cost[i]) &#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j-cost[i]]+pop[i]&gt;dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">						buy[j]=buy[j-cost[i]];</span><br><span class="line">						buy[j].<span class="built_in">push_back</span>(i);<span class="comment">//追加</span></span><br><span class="line">						dp[i][j]= dp[i<span class="number">-1</span>][j-cost[i]]+pop[i];</span><br><span class="line">					&#125;<span class="keyword">else</span> dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">//不够买当前的 </span></span><br><span class="line">					dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出受欢迎</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[N][M]);</span><br><span class="line">		<span class="keyword">if</span>(dp[N][M]!=<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;buy[M].<span class="built_in">size</span>();++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,buy[M][i]);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><h3 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h3><p><strong>判断素数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="comment">//注意1的情况</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;2&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;;i++)&#123;<span class="comment">//它本身如果是，直接输出，否则它+1开始找！</span></span><br><span class="line">		<span class="comment">//输出大于整数的素数</span></span><br><span class="line">		 <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;<span class="built_in">sqrt</span>(n);j++)&#123;<span class="comment">//判断素数 </span></span><br><span class="line">		 	<span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">		 		flag=<span class="number">1</span>;</span><br><span class="line">		 		<span class="keyword">break</span>;</span><br><span class="line">			 &#125; </span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;<span class="comment">//是素数，输出 </span></span><br><span class="line">		 	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		 	<span class="keyword">break</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="comment">//不是的话就从+1开始找 </span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分解质因素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//质因素个数 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">1001</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N)!=EOF)&#123;</span><br><span class="line">		<span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (i*i&lt;=N)&#123;</span><br><span class="line">			<span class="keyword">if</span>(N%i==<span class="number">0</span>)&#123;</span><br><span class="line">				nums[cnt++]=i;</span><br><span class="line">				N/=i;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后跳出循环的N结果如果大于1就是一个素数 </span></span><br><span class="line">		<span class="keyword">if</span>(N&gt;<span class="number">1</span>)&#123;</span><br><span class="line">			nums[cnt++]=N;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分解质因素</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prime_factor</span>(<span class="params">num</span>):</span><br><span class="line">    factors = []</span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i * i &lt;= num:</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            factors.append(i)</span><br><span class="line">            num = num // i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        factors.append(num)</span><br><span class="line">    <span class="keyword">return</span> factors</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者 用于统计质因数指数</span></span><br><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">i=<span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> i*i&lt;=n:</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> n%i:</span><br><span class="line">        n//=i</span><br><span class="line">        <span class="built_in">print</span>(i,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n!=<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么i一般到根号x就足够了呢，我们想想，如果两个数相乘等于x，那么这两个数只有两种情况，要么都等于根号x，要么一个大于根号x，一个小于根号x</p>
</blockquote>
<h4 id="素数筛选"><a href="#素数筛选" class="headerlink" title="素数筛选"></a>素数筛选</h4><p>我们要知道一个合数，一定是某个质因素的倍数</p>
<p><strong>埃式筛法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N=<span class="number">1e6</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//埃式筛，一个合数一定是某个质因素的倍数，因此</span></span><br><span class="line">	<span class="comment">//找出一个质数，把他所有倍数筛掉(不包括自己</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N/i;i++)&#123;<span class="comment">//这里到N/i即可 </span></span><br><span class="line">		<span class="keyword">if</span>(!pri[i])<span class="comment">//如果没被筛掉，说明是质数。如7，它不可能被前面的筛掉 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;=N;j+=i)&#123;</span><br><span class="line">			<span class="comment">//从2倍开始，不包括自己 </span></span><br><span class="line">				pri[j]=i;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="comment">//统计个数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++) <span class="keyword">if</span>(!pri[i])cnt++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>欧拉筛法</strong>、</p>
<p>埃式筛法有个问题，公倍数会被重复筛好几次，比如12，会被2筛也会被3筛</p>
<p>加一个数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> N=<span class="number">1e6</span>,cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> pp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">		<span class="comment">//如果没被筛，说明是素数，存到prime数组</span></span><br><span class="line">		<span class="keyword">if</span>(!pri[i]) prime[++pp]=i;</span><br><span class="line">		<span class="comment">//接下来遍历prime来筛 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;prime[j]*i&lt;=N;j++)&#123;</span><br><span class="line">			pri[prime[j]*i]=<span class="number">1</span>;<span class="comment">//筛素数倍数 </span></span><br><span class="line">			<span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//这一步关键 防止重复筛</span></span><br><span class="line">			<span class="comment">//比如，4，假设当j到3， prime[j]*i=12，这是会筛掉12</span></span><br><span class="line">			<span class="comment">//但是有了这一步，当j是2的时候已经break了，这就保证了</span></span><br><span class="line">			<span class="comment">//12不会被重复筛，而是留到当 prime[j]为6时被掉了 </span></span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//最后直接用primes这个素数数组即可</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该时没比埃式筛快多少的</p>
<h3 id="背住最大公约数，最小公倍数，Floyd-算法！！！"><a href="#背住最大公约数，最小公倍数，Floyd-算法！！！" class="headerlink" title="背住最大公约数，最小公倍数，Floyd 算法！！！"></a><strong>背住最大公约数，最小公倍数，Floyd 算法！！！</strong></h3><p>最小公倍数* 最大公约数 &#x3D; 两数乘积 ，即 <code>x*y=LCM(x, y)*GCD(x, y)</code>。而最大公约数可以使用[辗转相除法](<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31824895#:~:text=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%8C">https://zhuanlan.zhihu.com/p/31824895#:~:text=辗转相除法，</a> 又名欧几里得算法（Euclidean algorithm），目的是求出两个正整数的最大公约数。,它是已知最古老的算法， 其可追溯至公元前300年前。 这条算法基于一个定理： 两个正整数a和b（a&gt;b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。)求解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大公倍数、最小公约数</span></span><br><span class="line"><span class="comment">#最大公约数和最小公倍数</span></span><br><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第一个数: &#x27;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第二个数: &#x27;</span>))</span><br><span class="line">Min = <span class="built_in">min</span>(a,b)</span><br><span class="line">Gys = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">int</span>(Min+<span class="number">1</span>)):</span><br><span class="line">    <span class="keyword">if</span> a%i == <span class="number">0</span> <span class="keyword">and</span> b%i == <span class="number">0</span>:</span><br><span class="line">        Gys = i</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最大公约数为：%d&#x27;</span> %Gys)</span><br><span class="line">Gbs = a*b / Gys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;最小公倍数为:%d&#x27;</span> %Gbs)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>辗转相除法基于原理“<strong>两个整数的最大公约数等于其中较小值与两数相除余数的最大公约数</strong></p>
<p>GCD(a,b)&#x3D;GCD(b,a%b)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第一个数: &#x27;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入第二个数: &#x27;</span>))</span><br><span class="line">m,n=a,b</span><br><span class="line"><span class="keyword">if</span> a&lt;b:</span><br><span class="line">    m,n=b,a</span><br><span class="line">r=m%n</span><br><span class="line"><span class="keyword">while</span> n!=<span class="number">0</span>:</span><br><span class="line">    m=n</span><br><span class="line">    n=r</span><br><span class="line">    r=m%n</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果结果为1，说明二者是最简真分数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;<span class="comment">//结束</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);<span class="comment">//辗转相除 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Floyd算法</p>
<p>原理很简单：<br>一个点 i 到另一个点 j 的最短路径无非有两种：</p>
<ol>
<li>直接到达( i –&gt; j )</li>
<li>通过走其他点(k1, k2 … kn)，一个或多个点到达（ i –&gt; k1–&gt;k2–&gt; … –&gt; j )</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">			graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h3><p>数论问题，一个整数 �<em>a</em> 是一个完全平方数，是指它是某一个整数的平方，即存在一个 整数 �<em>b</em>，使得 �&#x3D;�2<em>a</em>&#x3D;<em>b</em>2 。</p>
<p>给定一个正整数 �<em>n</em>，请找到最小的正整数 �<em>x</em>，使得它们的乘积是一个完全平方数。</p>
<p>一个完全平方数，他的质因数的指数都是偶数</p>
<p>所以要凑的话，就得分解质因数，不是偶数的补上，一直乘</p>
<p>留意未分尽的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">res = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i * i &lt;= n:</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> n % i:</span><br><span class="line">        n //= i</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> cnt % <span class="number">2</span>:</span><br><span class="line">        res *= i</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n != <span class="number">1</span>:</span><br><span class="line">    res *= n</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>string[0]输出反而代表数字的高位，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">couculate</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> carry=<span class="number">0</span>;<span class="comment">//计算进位</span></span><br><span class="line">	<span class="keyword">if</span>(a.<span class="built_in">length</span>()&lt;b.<span class="built_in">length</span>()) a.<span class="built_in">swap</span>(b);</span><br><span class="line">	<span class="function">string <span class="title">res</span><span class="params">(a.length(),<span class="number">0</span>)</span></span>;<span class="comment">//设置</span></span><br><span class="line">	b.<span class="built_in">insert</span>(<span class="number">0</span>,a.<span class="built_in">length</span>()-b.<span class="built_in">length</span>(),<span class="string">&#x27;0&#x27;</span>);<span class="comment">//较短的字符补0 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">length</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">int</span> sum=(a[i]<span class="number">-48</span>)+(b[i]<span class="number">-48</span>)+carry;</span><br><span class="line">		carry=sum/<span class="number">10</span>;</span><br><span class="line">		res[i]=sum%<span class="number">10</span>+<span class="number">48</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(carry!=<span class="number">0</span>)&#123;</span><br><span class="line">		res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(),carry+<span class="number">48</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	string a,b;</span><br><span class="line">	<span class="keyword">while</span>(cin&gt;&gt;a&gt;&gt;b)&#123;</span><br><span class="line">		cout&lt;&lt;<span class="built_in">couculate</span>(a,b)&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h1 id="SCNUOJ"><a href="#SCNUOJ" class="headerlink" title="SCNUOJ"></a>SCNUOJ</h1><h2 id="P01-最大二叉树"><a href="#P01-最大二叉树" class="headerlink" title="P01 最大二叉树"></a>P01 最大二叉树</h2><ul>
<li>读取，构造二叉树</li>
<li>构造最大二叉树<ul>
<li>特殊情况–只有一个元素</li>
<li>找最大值</li>
<li>判左右是否空，左右递归</li>
<li>返回根节点</li>
</ul>
</li>
<li>前序遍历函数<ul>
<li>终止情况：为空结点，返回</li>
<li>排除叶子结点情况</li>
<li>其他：输出结点，递归左右</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大二叉树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="comment">//无参</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() :<span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//有参</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* tr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//叶子节点的两个子空节点要去掉不输出！否则会多输出一对null</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr-&gt;left == <span class="literal">NULL</span> &amp;&amp; tr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; tr-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; tr-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(tr-&gt;left); <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(tr-&gt;right); <span class="comment">//递归右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//只有一个元素，直接返回</span></span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间找最大</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;<span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line">        <span class="comment">//左边还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//newVec左闭右开</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            <span class="comment">//左子树的构造就是对左边递归</span></span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//右边递归</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a) != EOF) &#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    Solution s1;</span><br><span class="line">    TreeNode *re;</span><br><span class="line">    re=s1.<span class="built_in">constructMaximumBinaryTree</span>(nums);</span><br><span class="line">    <span class="built_in">PreOrder</span>(re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="！P02-算法课分治-寻找多数"><a href="#！P02-算法课分治-寻找多数" class="headerlink" title="！P02. [算法课分治] 寻找多数"></a>！P02. [算法课分治] 寻找多数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找多数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//返回特定元素在特定数组中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> pivot, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == pivot) num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findM</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//规模为1直接求解</span></span><br><span class="line">	<span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">	<span class="comment">//分解</span></span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> leftNum = <span class="built_in">findM</span>(nums, left, mid);</span><br><span class="line">	<span class="type">int</span> rightNum = <span class="built_in">findM</span>(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">//当前数组的解为两个数组解在当前数组出现次数较大的解</span></span><br><span class="line">	<span class="keyword">if</span> (leftNum == rightNum) <span class="keyword">return</span> leftNum;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> lcount = <span class="built_in">traverse</span>(nums, leftNum, left, right);</span><br><span class="line">		<span class="type">int</span> rcount = <span class="built_in">traverse</span>(nums, rightNum, left, right);</span><br><span class="line">		<span class="keyword">return</span> lcount &gt; rcount ? leftNum : rightNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//读取</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">10001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		nums[i] = a;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">findM</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P03-算法课分治-找到最大子序和"><a href="#P03-算法课分治-找到最大子序和" class="headerlink" title="P03. [算法课分治] 找到最大子序和"></a>P03. [算法课分治] 找到最大子序和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b &amp;&amp; a &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a &amp;&amp; b &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSumRec</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前序列只有一个元素</span></span><br><span class="line">        <span class="keyword">return</span> data[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> center = (left + right) / <span class="number">2</span>;<span class="comment">//计算当前序列的分裂点</span></span><br><span class="line">    <span class="type">int</span> maxLeftSum = <span class="built_in">maxSumRec</span>(data, left, center);</span><br><span class="line">    <span class="type">int</span> maxRightSum = <span class="built_in">maxSumRec</span>(data, center, right);</span><br><span class="line">    <span class="comment">//计算左边界最大子序列和</span></span><br><span class="line">    <span class="type">int</span> leftBonderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLeftBonderSum = data[center - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = center - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        leftBonderSum += data[i];</span><br><span class="line">        <span class="keyword">if</span> (maxLeftBonderSum &lt; leftBonderSum) &#123;</span><br><span class="line">            maxLeftBonderSum = leftBonderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算右边界最大子序列和</span></span><br><span class="line">    <span class="type">int</span> rightBonderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxRightBonderSum = data[center];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = center; i &lt; right; i++) &#123;</span><br><span class="line">        rightBonderSum += data[i];</span><br><span class="line">        <span class="keyword">if</span> (maxRightBonderSum &lt; rightBonderSum) &#123;</span><br><span class="line">            maxRightBonderSum = rightBonderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前序列最大子序列和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMaxNum</span>(maxLeftBonderSum + maxRightBonderSum, maxLeftSum, maxRightSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> v1[<span class="number">1000000</span>];</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		v1[i]=t;<span class="comment">//读入</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    cout&lt;&lt;<span class="built_in">maxSumRec</span>(v1, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P04-算法课分治-找到-k-个最小数"><a href="#P04-算法课分治-找到-k-个最小数" class="headerlink" title="P04. [算法课分治] 找到 k 个最小数"></a>P04. [算法课分治] 找到 k 个最小数</h2><p>就是一个快速排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low, j = height, pviot = a[low]; <span class="comment">//这里是low就要从j开始，要从i开始就得是height</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (a[j]&gt;pviot&amp;&amp;i&lt;j)</span><br><span class="line">		&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i++], a[j]);<span class="comment">//交换后i后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; pviot &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j--]);<span class="comment">//交换后，j前移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; height) &#123;</span><br><span class="line">		mid = <span class="built_in">part</span>(a, low, height);</span><br><span class="line">		<span class="comment">//分治</span></span><br><span class="line">		<span class="built_in">Quicksort</span>(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, mid + <span class="number">1</span>, height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a,k;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">10001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		nums[i] = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Quicksort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P05-算法课分治-寻找第-k-个最大元素"><a href="#P05-算法课分治-寻找第-k-个最大元素" class="headerlink" title="P05. [算法课分治] 寻找第 k 个最大元素"></a>P05. [算法课分治] 寻找第 k 个最大元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low, j = height, pviot = a[low];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; pviot &amp;&amp; j &gt; i) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i++], a[j]);<span class="comment">//交换后，i后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; pviot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j--]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> low,<span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; height) &#123;</span><br><span class="line">		mid = <span class="built_in">part</span>(a, low, height);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, mid + <span class="number">1</span>, height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//数据读取</span></span><br><span class="line">	<span class="type">int</span> len, k;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; len &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		a[i] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//快速排序</span></span><br><span class="line">	<span class="built_in">Quicksort</span>(a, <span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; a[len-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P06-算法课动态规划-走网格"><a href="#P06-算法课动态规划-走网格" class="headerlink" title="P06. [算法课动态规划]走网格"></a>P06. [算法课动态规划]走网格</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//棋盘</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m, n;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span> || j == <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[m][n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P07-算法课动态规划-爬楼梯"><a href="#P07-算法课动态规划-爬楼梯" class="headerlink" title="P07. [算法课动态规划]爬楼梯"></a>P07. [算法课动态规划]爬楼梯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">21</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//零一阶都是只有一种方法达到</span></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P08-算法课动态规划-背包问题"><a href="#P08-算法课动态规划-背包问题" class="headerlink" title="P08. [算法课动态规划]背包问题"></a>P08. [算法课动态规划]背包问题</h2><ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> weight[] = &#123; <span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> value[] = &#123; <span class="number">42</span>,<span class="number">12</span>,<span class="number">40</span>,<span class="number">25</span> &#125;;</span><br><span class="line">	<span class="type">int</span> wetLen,cap;</span><br><span class="line">	cin &gt;&gt; wetLen &gt;&gt; cap;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = weight[<span class="number">0</span>]; i &lt;= cap; i++) &#123;</span><br><span class="line">		<span class="comment">//能放物品1的进行初始化</span></span><br><span class="line">		dp[<span class="number">0</span>][i] = value[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= wetLen; i++) &#123;</span><br><span class="line">		<span class="comment">//遍历背包容量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cap; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; weight[i<span class="number">-1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//放不进，就是不妨上一个物品</span></span><br><span class="line">			<span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);<span class="comment">//放的进就是比较上一个和放进这个的大小</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[wetLen][cap];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P09-最长回文子串"><a href="#P09-最长回文子串" class="headerlink" title="P09 最长回文子串"></a>P09 最长回文子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/Problem P09. [算法课动态规划]最长回文子串</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1;</span><br><span class="line">	cin &gt;&gt; s1;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对角线为1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; s1.<span class="built_in">size</span>(); i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="comment">//少了一个判断是两个字符的情况</span></span><br><span class="line">			<span class="keyword">if</span> (s1[i] == s1[j]) &#123;</span><br><span class="line">				<span class="comment">//两个字符</span></span><br><span class="line">				<span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找最长的，记录下来</span></span><br><span class="line">	<span class="type">int</span> maxI = <span class="number">0</span>, maxJ = <span class="number">0</span>, maxdis = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j - i &gt; maxdis&amp;&amp;dp[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">				maxI = i;</span><br><span class="line">				maxJ = j;</span><br><span class="line">				maxdis = j - i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> z = maxI; z &lt;= maxJ; z++) &#123;</span><br><span class="line">		cout &lt;&lt; s1[z];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P10-连续数组最大"><a href="#P10-连续数组最大" class="headerlink" title="P10 连续数组最大"></a>P10 连续数组最大</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P10.[算法课动态规划]连续数组最大和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; p;</span><br><span class="line">		a[i] = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) dp[i][j] = a[i];</span><br><span class="line">			<span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + a[i] + a[j];<span class="comment">//加端点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i][j] &gt; max) &#123;</span><br><span class="line">				max = dp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="⭐P11-最长公共子序列"><a href="#⭐P11-最长公共子序列" class="headerlink" title="⭐P11 最长公共子序列"></a>⭐P11 最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1&gt;&gt;s2;</span><br><span class="line">	<span class="comment">//空出一个外围，非则会越界</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//注意i，i都要退一个</span></span><br><span class="line">            <span class="comment">//如果当前字母想都，就是左上角加上1</span></span><br><span class="line">			<span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果不同，找左边或者上边的最大值</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[s1.<span class="built_in">size</span>()][s2.<span class="built_in">size</span>()];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12-贪婪-6和9组成的最大数字"><a href="#P12-贪婪-6和9组成的最大数字" class="headerlink" title="P12 贪婪 6和9组成的最大数字"></a>P12 贪婪 6和9组成的最大数字</h2><p>简单跳过</p>
<h2 id="P13-贪婪-三角形的最大周长"><a href="#P13-贪婪-三角形的最大周长" class="headerlink" title="P13 贪婪 三角形的最大周长"></a>P13 贪婪 三角形的最大周长</h2><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。如果不能形成任何面积不为零的三角形，返回 0。</p>
<ul>
<li>3 &lt;&#x3D; A.length &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; A[i] &lt;&#x3D; 1000</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P13. [算法课贪婪]三角形的最大周长</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v) != EOF) &#123;</span><br><span class="line">		a[count] = v;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对a进行排序 冒泡排序 降序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; count - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">				a[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">3</span> &lt;= count; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>] &gt; a[i] &amp;&amp; a[i] - a[i + <span class="number">1</span>] &lt; a[i + <span class="number">2</span>]) &#123;</span><br><span class="line">			cout &lt;&lt; a[i] + a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>];</span><br><span class="line">			mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mark == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用sort</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="P14-蛮力-种花问题"><a href="#P14-蛮力-种花问题" class="headerlink" title="P14 蛮力 种花问题"></a>P14 蛮力 种花问题</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p>提示：</p>
<ul>
<li><p>1 &lt;&#x3D; flowerbed.length &lt;&#x3D; 2 * 10^4</p>
</li>
<li><p>flowerbed[i] 为 0 或 1</p>
</li>
<li><p>flowerbed 中不存在相邻的两朵花</p>
</li>
<li><p>0 &lt;&#x3D; n &lt;&#x3D; flowerbed.length</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P14.[算法课蛮力法]种花问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;a) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			v[count] = a-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; nums;</span><br><span class="line">	<span class="comment">//nums=v[count-1];//最后一个就是插入总数</span></span><br><span class="line">	count--;<span class="comment">//去掉最后一个总数的</span></span><br><span class="line">	<span class="comment">/*cout &lt;&lt; &quot;nums:&quot; &lt;&lt; nums&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; &#x27;\n&#x27;; cout &lt;&lt; &quot;v[count+1]:&quot; &lt;&lt; v[count+1] &lt;&lt; &#x27;\n&#x27;;*/</span></span><br><span class="line">	<span class="comment">//只有一个花坛</span></span><br><span class="line">	<span class="keyword">if</span> (nums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; nums == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第一个和最后一个特殊情况 先种最左和最右</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; v[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			nums--;</span><br><span class="line">			v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( v[count - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; v[count - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			nums--;</span><br><span class="line">			v[count - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始从左往右有位置就种</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (v[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; v[i + <span class="number">1</span>] == <span class="number">0</span>&amp;&amp;v[i]==<span class="number">0</span>) &#123;</span><br><span class="line">			v[i] = <span class="number">1</span>; <span class="comment">//种上后要赋值</span></span><br><span class="line">			nums--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nums&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;false&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">/*for (int i = 0; i &lt; count; i++)</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;*/</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;最后一个数&quot; &lt;&lt; v[count - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">// 真的猪啊，nums在前面经历过--操作，你在这里调试输出肯定对应不上原始值啊！！</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;转换到的最后一个&quot; &lt;&lt; nums &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;总数&quot; &lt;&lt; count;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="❗P15-贪婪-移掉K位数字-有一步没搞懂"><a href="#❗P15-贪婪-移掉K位数字-有一步没搞懂" class="headerlink" title="❗P15 贪婪 移掉K位数字(有一步没搞懂)"></a>❗P15 贪婪 移掉K位数字(有一步没搞懂)</h2><p>给你一个以字符串表示的非负整数 <strong>num</strong> 和一个整数 <strong>k</strong> ，移除这个数中的 <strong>k</strong> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<ul>
<li>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 1000</li>
<li>num 仅由若干位数字（0 - 9）组成</li>
<li>除了 0 本身之外，num 不含任何前导零</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/12/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    string v;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;v.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;v[i]&gt;v[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//前一个大于后一个</span></span><br><span class="line">            v.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) i--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(v[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;v.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        v.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P16-贪婪-盛最多的水"><a href="#P16-贪婪-盛最多的水" class="headerlink" title="P16 贪婪 盛最多的水"></a>P16 贪婪 盛最多的水</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem P16.[算法课贪婪]盛最多的水</span></span><br><span class="line"><span class="comment">// 思路从最远两边往里收缩，不是同时收缩，是一边一边收缩，记录最大</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//找第一长，和所有其他的算，再找第一二长和所有其他的算。。。</span></span><br><span class="line">	<span class="type">char</span> n;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>,r=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		area = <span class="built_in">min</span>(v[l], v[r]) * (r - l);<span class="comment">//面积</span></span><br><span class="line">		ans=<span class="built_in">max</span>(ans,area);</span><br><span class="line">		<span class="comment">//小的一边收缩</span></span><br><span class="line">		<span class="keyword">if</span> (v[l] &lt; v[r]) &#123;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P17-回溯-括号生成-void-backTracking-int-left-int-right-string-curstr"><a href="#P17-回溯-括号生成-void-backTracking-int-left-int-right-string-curstr" class="headerlink" title="P17 回溯 括号生成 void backTracking(int left, int right, string curstr)"></a>P17 回溯 括号生成 void backTracking(int left, int right, string curstr)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P17.[算法课回溯]括号生成</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;string&gt; strs;<span class="comment">//放string的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string curstr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span> (right == <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) &#123;</span><br><span class="line">		strs.<span class="built_in">push_back</span>(curstr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当剩余左边括号小于或等于右边时，才满足</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt;= right &amp;&amp; left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">backTracking</span>(left - <span class="number">1</span>, right, curstr + <span class="string">&quot;(&quot;</span>);<span class="comment">//放左</span></span><br><span class="line">		<span class="built_in">backTracking</span>(left, right - <span class="number">1</span>, curstr + <span class="string">&quot;)&quot;</span>);<span class="comment">//放右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">backTracking</span>(n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; strs[i];</span><br><span class="line">		<span class="keyword">if</span> (i != strs.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P18-回溯-目标和-void-check-int-nums-int-tar-int-n"><a href="#P18-回溯-目标和-void-check-int-nums-int-tar-int-n" class="headerlink" title="P18 回溯 目标和 void check(int nums[], int tar, int n)"></a>P18 回溯 目标和 void check(int nums[], int tar, int n)</h2><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 20</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 1000</li>
<li>-1000 &lt;&#x3D; target &lt;&#x3D; 1000</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/12/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Problem P18. [算法课回溯]目标和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tsize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//数组 目标和 参与个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> tar, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tar == <span class="number">0</span> &amp;&amp; n == tsize) count++;</span><br><span class="line">    <span class="keyword">if</span> (n == tsize) <span class="keyword">return</span>;<span class="comment">//不满足但是退出</span></span><br><span class="line">    <span class="built_in">check</span>(nums, tar - nums[n], n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">check</span>(nums, tar + nums[n], n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">21</span>];</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[size] = a;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    tsize=size;</span><br><span class="line">    <span class="built_in">check</span>(nums,target,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P19-回溯-电话号码的字母组合-void-backtracking-const-string-amp-s-int-index-string-curStr-输入序列-序列号-可能组合"><a href="#P19-回溯-电话号码的字母组合-void-backtracking-const-string-amp-s-int-index-string-curStr-输入序列-序列号-可能组合" class="headerlink" title="P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合"></a>P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案按<strong>字母顺序</strong>返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://oj.socoding.cn/uploads/20211104/16360198642759.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//const char chara[][4]=&#123;&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;,&#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;,&#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;,&#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;,&#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;,&#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;,&#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;,&#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="type">const</span> string chara[<span class="number">8</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; strs;</span><br><span class="line"><span class="comment">//标记当前是遍历到第几个</span></span><br><span class="line"><span class="comment">//_ _ x记录遍历到第几个，n记录第x个位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> index,string curStr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==s.<span class="built_in">size</span>())&#123;<span class="comment">//当这个满足时，说明前面的坑都填完了</span></span><br><span class="line">        <span class="comment">//三个位置都放好了</span></span><br><span class="line">        strs.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=s[index]-<span class="string">&#x27;0&#x27;</span><span class="number">-2</span>;<span class="comment">//转为数值 取序号</span></span><br><span class="line">    string letter=chara[num];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;letter.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        curStr.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(s,index+<span class="number">1</span>,curStr);<span class="comment">//递归</span></span><br><span class="line">        curStr.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">printPar</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> strs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(s,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> strs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//7,9长度是4，其他都是3</span></span><br><span class="line">    string s1;</span><br><span class="line">    cin&gt;&gt;s1;</span><br><span class="line">    <span class="built_in">printPar</span>(s1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;strs[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;strs.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P20-回溯-优美的排列-void-backtracking-int-pos-int-n-位置数-长度"><a href="#P20-回溯-优美的排列-void-backtracking-int-pos-int-n-位置数-长度" class="headerlink" title="P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度"></a>P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度</h2><p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：</p>
<ul>
<li>perm[i] 能够被 i 整除</li>
<li>i 能够被 perm[i] 整除</li>
</ul>
<p>给你一个整数 n ，返回可以构造的 优美排列 的 数量 。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 15</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P20. [算法课回溯]优美的排列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//int number[]=&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>,<span class="number">0</span>);<span class="comment">//标记作用</span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos%i==<span class="number">0</span>||i%pos==<span class="number">0</span>)&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;<span class="comment">//访问</span></span><br><span class="line">            <span class="built_in">backtracking</span>(pos+<span class="number">1</span>,n);</span><br><span class="line">            vis[i]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1-n所有排列的组合，边凑数，进行判断，如果不满足，置标记为false，直接排除当前情况</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">backtracking</span>(<span class="number">1</span>,n);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P21-组合-void-backTracking-int-n-int-k-int-startIndex-长度-个数-遍历位置"><a href="#P21-组合-void-backTracking-int-n-int-k-int-startIndex-长度-个数-遍历位置" class="headerlink" title="P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置"></a>P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//n是氛围，k是个数，startIndex记录遍历到那个数了</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;<span class="comment">//到叶子了，收割结果</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;=n ; ++i) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="built_in">backTracking</span>(n,k,i+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tar[<span class="number">21</span>][<span class="number">21</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">backTracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            cout&lt;&lt;result[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P22-回溯-大礼包"><a href="#P22-回溯-大礼包" class="headerlink" title="P22 回溯 大礼包"></a>P22 回溯 大礼包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; goods;<span class="comment">//商品即对应价格</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; special;<span class="comment">//存放大礼包</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; need;<span class="comment">//需要的各个商品数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> specialn=<span class="number">0</span>;<span class="comment">//礼包种类数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">backTracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; n)</span></span>&#123;<span class="comment">//n为need</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//此层决策要花多少钱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        ans+=goods[i]*n[i];<span class="comment">//先不考虑买礼包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; specialn; ++i) &#123;<span class="comment">//遍历礼包</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;<span class="comment">//复制一遍需求，暂存</span></span><br><span class="line">        <span class="type">int</span> size_1bag=special[i].<span class="built_in">size</span>();<span class="comment">//礼包的大小</span></span><br><span class="line">        <span class="type">int</span> price=special[i][size_1bag<span class="number">-1</span>];<span class="comment">//存入礼包价格</span></span><br><span class="line">        <span class="type">bool</span> is_valid= <span class="literal">true</span>;<span class="comment">//是否能买当前礼包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size_1bag<span class="number">-1</span>; ++j) &#123;<span class="comment">//遍历礼包的物品列表</span></span><br><span class="line">            <span class="keyword">if</span>(special[i][j]&gt;n[j])&#123;</span><br><span class="line">                <span class="comment">//有一个不满足</span></span><br><span class="line">                is_valid= <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j]-=special[i][j];<span class="comment">//能买的话更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_valid)&#123;<span class="comment">//能买礼包</span></span><br><span class="line">            price+= <span class="built_in">backTracking</span>(tmp);<span class="comment">//当前礼包加上剩下需求所需的钱</span></span><br><span class="line">            ans= <span class="built_in">min</span>(ans,price);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不能买礼包，换下一个</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 假设有n个大礼包</span></span><br><span class="line">    <span class="comment">// 最基本的：一个大礼包都不买</span></span><br><span class="line">    <span class="comment">// 遍历所有大礼包包括自己（递归)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 终止条件：它加下一个礼包超出了数量</span></span><br><span class="line"><span class="comment">     * 首先大礼包的物品数要都小于目标数据</span></span><br><span class="line"><span class="comment">     * 不满足，则跳过，递归</span></span><br><span class="line"><span class="comment">     * 满足，则加入，算出总价，递归</span></span><br><span class="line"><span class="comment">     * 检查是否到最后一个大礼包</span></span><br><span class="line"><span class="comment">     *  是，判断还剩多少，用则用基本物品价格去补充</span></span><br><span class="line"><span class="comment">     * 问题:这里的k你不知道？即礼包的个数不定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; init;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        init.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前size-1都是商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; init.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        goods.<span class="built_in">push_back</span>(init[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> speciallen=init[init.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;speciallen;i++)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;goods.<span class="built_in">size</span>()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;n;</span><br><span class="line">            save.<span class="built_in">push_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        special.<span class="built_in">push_back</span>(save);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;goods.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        need.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    specialn=special.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="built_in">backTracking</span>(need);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P23-计数排序"><a href="#P23-计数排序" class="headerlink" title="P23 计数排序"></a>P23 计数排序</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20231212144444548.png" alt="image-20231212144444548"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/15.</span></span><br><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>,m=<span class="number">0</span>,bi=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        ++c[a[i]]; <span class="comment">//这里按序号赋值，本身就已经有序了，不用排序了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i];++j)&#123;</span><br><span class="line">            b[++bi]=i;<span class="comment">//重复的a[i]进行排序 0的话自动跳过了巧妙</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        (ans+=<span class="number">1LL</span>*i*b[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P24-贪心-跳跃游戏"><a href="#P24-贪心-跳跃游戏" class="headerlink" title="P24 贪心 跳跃游戏"></a>P24 贪心 跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p>
<p>判断你是否能够到达最后一个下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">100001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a)&#123;</span><br><span class="line">        num[size]=a;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> latTar=<span class="number">0</span>;<span class="comment">//上一个0</span></span><br><span class="line">    <span class="type">int</span> curTar=<span class="number">0</span>;<span class="comment">//标记当前出现0的位置</span></span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;<span class="comment">//能到最后的标记</span></span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            curTar=i;</span><br><span class="line">            <span class="type">bool</span> canFly= <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//查到0，判断前面有没有能够跳过0的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=latTar;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+num[j]&gt;curTar)&#123;</span><br><span class="line">                    canFly= <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!canFly)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2</p>
<p>维护一个可达到的最远位置maxPos，通过遍历当前可跳跃范围内的所有位置，计算每个位置能够达到的最远位置，并更新maxPos。如果maxPos超过数组长度的最后一个位置，则表示可以到达末尾，返回true；否则，根据当前位置调整下一次可跳跃范围的起点和终点，直到无法继续跳跃返回false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxPos=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxPos&gt;=v.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line"></span><br><span class="line">            maxPos=<span class="built_in">max</span>(maxPos,i+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        left=right+<span class="number">1</span>;</span><br><span class="line">        right=maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) cout&lt;&lt;<span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P25-动规-整数拆分"><a href="#P25-动规-整数拆分" class="headerlink" title="P25 动规 整数拆分"></a>P25 动规 整数拆分</h2><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;&#x3D; 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。</p>
<p>我们用dp[i]来表示分拆数字i，可以得到的最大乘积，对于每个i来说，都可以通过前面已知的拆分结果来求，遍历i前面的每个数字j，假设拆分成两个数 j 和 i-j ，这是一种情况，另外，j 又可以继续拆分，j拆分的最大值就是dp[j]， 同理 i-j 也是一样的，我们在所有情况里取最大值就是dp[i]的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">        cout&lt;&lt;dp[n];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*(i-j),dp[i-j]*j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P26-动态规划-打家劫舍"><a href="#P26-动态规划-打家劫舍" class="headerlink" title="P26 动态规划 打家劫舍"></a>P26 动态规划 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P26. [算法课动态规划] 打家劫舍</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; room;</span><br><span class="line">    room.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//占着第0个</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        room.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>]=room[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp</span></span><br><span class="line">    <span class="comment">//遍历dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=room.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+room[i]);<span class="comment">//不偷本间,偷本间加前面的第二间</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;room.size()&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;dp[room.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P27-动态规划-戳气球"><a href="#P27-动态规划-戳气球" class="headerlink" title="P27 动态规划 戳气球"></a>P27 动态规划 戳气球</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20231212145315276.png" alt="image-20231212145315276"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem P27. [算法课动态规划] 戳气球</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">points</span><span class="params">(n+<span class="number">2</span>)</span> </span>;<span class="comment">//= new int[n + 2]</span></span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];<span class="comment">//nums从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>));<span class="comment">//    int[][] dp = new int[n + 2][n + 2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                        dp[i][j],</span><br><span class="line">                        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">maxCoins</span>(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P28-贪心-跳跃游戏"><a href="#P28-贪心-跳跃游戏" class="headerlink" title="P28 贪心 跳跃游戏"></a>P28 贪心 跳跃游戏</h2><p>有一个非负整数数组 nums，最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>假设你总是可以到达数组的最后一个位置, 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/22.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基本思想</span></span><br><span class="line"><span class="comment"> * 每次在当前能跳跃范围内选择可以使得接下来能跳跃最远的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxStep</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vector1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">findMaxStep</span>(nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxStep</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vector1)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxReach=<span class="number">0</span>;<span class="comment">//记录跳到最远的</span></span><br><span class="line">    <span class="type">int</span> curReach=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxPos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curReach&lt;=maxReach&amp;&amp;maxPos&lt;vector1.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line"><span class="comment">//        curReach=maxReach;//当前的位置</span></span><br><span class="line"><span class="comment">//        maxReach=vector1[curReach]+curReach;//首先初始化一个最远</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=curReach;i&lt;=maxReach;i++)&#123;</span><br><span class="line">            <span class="comment">//跳得超越了之前的maxReach</span></span><br><span class="line">            maxPos= <span class="built_in">max</span>(maxPos,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        curReach=maxReach+<span class="number">1</span>;</span><br><span class="line">        maxReach=maxPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P29-指针-颜色分类"><a href="#P29-指针-颜色分类" class="headerlink" title="P29 指针 颜色分类"></a>P29 指针 颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>输入</p>
<p>第一行输入一个整数 n (1≤n≤300)<em>n</em> (1≤<em>n</em>≤300) 代表数组的长度。</p>
<p>第二行输入一行数字代表数组 nums[i] 为0，1，2，数字与数字之间用空格间开。</p>
<p>输出</p>
<p>输出排序后的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P29. [算法课指针] 颜色分类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> key[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//检查三种颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColor</span><span class="params">(<span class="type">int</span> *head,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> *p= <span class="literal">nullptr</span>;<span class="comment">//工作指针</span></span><br><span class="line">    <span class="type">int</span> *edge= head;</span><br><span class="line">    <span class="type">int</span> *hh=head;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//检查head</span></span><br><span class="line">        head=edge;</span><br><span class="line">        p=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*p!=i&amp;&amp;*p!=<span class="number">-1</span>) p++;<span class="comment">//找到颜色头一个</span></span><br><span class="line">        <span class="keyword">if</span>(*p==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        temp=*p;</span><br><span class="line">        *p=*head;</span><br><span class="line">        *head=temp;</span><br><span class="line">        key[i]=<span class="number">1</span>;<span class="comment">//头部解决，建议记录头部索引</span></span><br><span class="line">        edge=head;<span class="comment">//存储颜色族头</span></span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">while</span>(*head!= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//进入一个聚类的循环</span></span><br><span class="line"></span><br><span class="line">            p=head;</span><br><span class="line">            <span class="keyword">while</span>(*p!=i&amp;&amp;*p!=<span class="number">-1</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一个替换</span></span><br><span class="line">            <span class="keyword">if</span>(*p==<span class="number">-1</span>) &#123;</span><br><span class="line">                edge=head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=*p;</span><br><span class="line">            *p=*head;</span><br><span class="line">            *head=temp;</span><br><span class="line">            <span class="comment">//直到越界</span></span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">301</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">301</span>;i++) nums[i]=<span class="number">-1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        nums[i]=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sortColor</span>(nums,n);</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) cout&lt;&lt;nums[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout&lt;&lt;nums[n<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">JJuprising</div><div class="post-copyright__author_desc">蓝天白云,花草树木</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/')">JJ的算法之旅</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JJ的算法之旅&amp;url=https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/&amp;pic=/img/default_cover.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JJuprising.github.io" target="_blank">yjchen</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/14/%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="onerror=null;src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大型数据库笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/18/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="onerror=null;src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数字图像处理笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/8b962544da5c0.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">JJuprising</h1><div class="author-info__desc">蓝天白云,花草树木</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/JJuprising" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.zhihu.com/people/bo-yi-shu-qi-49" target="_blank" title="知乎"><i class="anzhiyufont anzhiyu-icon-box-archive"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.1.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.2.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.4.</span> <span class="toc-text">二进制与位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">基础运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-C"><span class="toc-number">2.1.5.</span> <span class="toc-text">STL C++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.1.6.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">python</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">c++</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">数据结构及基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">2.2.2.</span> <span class="toc-text">哈夫曼树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">合并k个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">单链表的倒数第k个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9"><span class="toc-number">2.3.3.</span> <span class="toc-text">单链表的中点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF"><span class="toc-number">2.3.4.</span> <span class="toc-text">链表是否有环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4"><span class="toc-number">2.3.5.</span> <span class="toc-text">两个链表是否相交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%95%B0%E7%BB%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">普通数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7"><span class="toc-number">2.4.3.</span> <span class="toc-text">快慢指针技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%B3%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">二分法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.4.5.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-number">2.4.6.</span> <span class="toc-text">子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">前缀和</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E4%B8%AD%E5%BA%8F%E6%9E%84%E9%80%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">前中序构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E5%90%8E%E5%BA%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">中序后序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">前序后序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">2.6.</span> <span class="toc-text">搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88BFS"><span class="toc-number">2.6.1.</span> <span class="toc-text">广度优先BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.6.2.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Hanoi%E5%A1%94"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">Hanoi塔</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DFS"><span class="toc-number">2.6.3.</span> <span class="toc-text">DFS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">2.7.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-Disjoint-Set-Union"><span class="toc-number">2.7.2.</span> <span class="toc-text">并查集(Disjoint Set Union)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">2.7.3.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal-%E5%8A%A0%E8%BE%B9%E6%B3%95"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">Kruskal 加边法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">Prim</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">2.7.4.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#floyd"><span class="toc-number">2.7.4.1.</span> <span class="toc-text">floyd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">2.7.5.</span> <span class="toc-text">拓扑排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">2.8.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">2.8.1.</span> <span class="toc-text">组合和排列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">2.9.1.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.10.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E6%A5%BC%E6%A2%AF"><span class="toc-number">2.10.1.</span> <span class="toc-text">跳楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C"><span class="toc-number">2.10.2.</span> <span class="toc-text">最大子段和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%BA%8F%E5%88%97%E5%92%8C"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">最大序列和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E9%97%B4%E7%BF%BB%E8%BD%AC-%E9%A2%98%E6%84%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">字符串区间翻转 题意转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.10.3.</span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-%E4%BA%8C%E7%BB%B4dp"><span class="toc-number">2.10.4.</span> <span class="toc-text">最长公共子序列 二维dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E7%BC%96%E8%BE%91%E9%95%BF%E5%BA%A6"><span class="toc-number">2.10.5.</span> <span class="toc-text">最少编辑长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">2.10.6.</span> <span class="toc-text">乘积最大子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9"><span class="toc-number">2.10.7.</span> <span class="toc-text">完全平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.8.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E8%83%8C%E5%8C%85"><span class="toc-number">2.10.8.1.</span> <span class="toc-text">简化版背包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%8401%E8%83%8C%E5%8C%85"><span class="toc-number">2.10.8.2.</span> <span class="toc-text">常规01背包</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.10.9.</span> <span class="toc-text">状态压缩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA"><span class="toc-number">2.11.</span> <span class="toc-text">数论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0"><span class="toc-number">2.11.1.</span> <span class="toc-text">质数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A0%E6%95%B0%E7%AD%9B%E9%80%89"><span class="toc-number">2.11.1.1.</span> <span class="toc-text">素数筛选</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E4%BD%8F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%EF%BC%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%EF%BC%8CFloyd-%E7%AE%97%E6%B3%95%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">2.11.2.</span> <span class="toc-text">背住最大公约数，最小公倍数，Floyd 算法！！！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">2.11.3.</span> <span class="toc-text">完全平方数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="toc-number">2.12.</span> <span class="toc-text">高精度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SCNUOJ"><span class="toc-number">3.</span> <span class="toc-text">SCNUOJ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P01-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">P01 最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%81P02-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E5%AF%BB%E6%89%BE%E5%A4%9A%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">！P02. [算法课分治] 寻找多数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P03-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">3.3.</span> <span class="toc-text">P03. [算法课分治] 找到最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P04-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">P04. [算法课分治] 找到 k 个最小数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P05-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E5%AF%BB%E6%89%BE%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">3.5.</span> <span class="toc-text">P05. [算法课分治] 寻找第 k 个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P06-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B5%B0%E7%BD%91%E6%A0%BC"><span class="toc-number">3.6.</span> <span class="toc-text">P06. [算法课动态规划]走网格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P07-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">3.7.</span> <span class="toc-text">P07. [算法课动态规划]爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P08-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">P08. [算法课动态规划]背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P09-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">3.9.</span> <span class="toc-text">P09 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P10-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7"><span class="toc-number">3.10.</span> <span class="toc-text">P10 连续数组最大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90P11-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.11.</span> <span class="toc-text">⭐P11 最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P12-%E8%B4%AA%E5%A9%AA-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">3.12.</span> <span class="toc-text">P12 贪婪 6和9组成的最大数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P13-%E8%B4%AA%E5%A9%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF"><span class="toc-number">3.13.</span> <span class="toc-text">P13 贪婪 三角形的最大周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P14-%E8%9B%AE%E5%8A%9B-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-number">3.14.</span> <span class="toc-text">P14 蛮力 种花问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%97P15-%E8%B4%AA%E5%A9%AA-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97-%E6%9C%89%E4%B8%80%E6%AD%A5%E6%B2%A1%E6%90%9E%E6%87%82"><span class="toc-number">3.15.</span> <span class="toc-text">❗P15 贪婪 移掉K位数字(有一步没搞懂)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P16-%E8%B4%AA%E5%A9%AA-%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4"><span class="toc-number">3.16.</span> <span class="toc-text">P16 贪婪 盛最多的水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P17-%E5%9B%9E%E6%BA%AF-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-void-backTracking-int-left-int-right-string-curstr"><span class="toc-number">3.17.</span> <span class="toc-text">P17 回溯 括号生成 void backTracking(int left, int right, string curstr)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P18-%E5%9B%9E%E6%BA%AF-%E7%9B%AE%E6%A0%87%E5%92%8C-void-check-int-nums-int-tar-int-n"><span class="toc-number">3.18.</span> <span class="toc-text">P18 回溯 目标和 void check(int nums[], int tar, int n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P19-%E5%9B%9E%E6%BA%AF-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-void-backtracking-const-string-amp-s-int-index-string-curStr-%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97-%E5%BA%8F%E5%88%97%E5%8F%B7-%E5%8F%AF%E8%83%BD%E7%BB%84%E5%90%88"><span class="toc-number">3.19.</span> <span class="toc-text">P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P20-%E5%9B%9E%E6%BA%AF-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-void-backtracking-int-pos-int-n-%E4%BD%8D%E7%BD%AE%E6%95%B0-%E9%95%BF%E5%BA%A6"><span class="toc-number">3.20.</span> <span class="toc-text">P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P21-%E7%BB%84%E5%90%88-void-backTracking-int-n-int-k-int-startIndex-%E9%95%BF%E5%BA%A6-%E4%B8%AA%E6%95%B0-%E9%81%8D%E5%8E%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.21.</span> <span class="toc-text">P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P22-%E5%9B%9E%E6%BA%AF-%E5%A4%A7%E7%A4%BC%E5%8C%85"><span class="toc-number">3.22.</span> <span class="toc-text">P22 回溯 大礼包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P23-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">3.23.</span> <span class="toc-text">P23 计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P24-%E8%B4%AA%E5%BF%83-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">3.24.</span> <span class="toc-text">P24 贪心 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P25-%E5%8A%A8%E8%A7%84-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">3.25.</span> <span class="toc-text">P25 动规 整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">3.26.</span> <span class="toc-text">P26 动态规划 打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P27-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%88%B3%E6%B0%94%E7%90%83"><span class="toc-number">3.27.</span> <span class="toc-text">P27 动态规划 戳气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P28-%E8%B4%AA%E5%BF%83-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">3.28.</span> <span class="toc-text">P28 贪心 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P29-%E6%8C%87%E9%92%88-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">3.29.</span> <span class="toc-text">P29 指针 颜色分类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="软件测试"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="软件测试"/></a><div class="content"><a class="title" href="/2024/05/27/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/" title="软件测试">软件测试</a><time datetime="2024-05-27T08:22:42.000Z" title="发表于 2024-05-27 16:22:42">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/22/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BB%8F%E9%AA%8C/" title="论文写作经验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="论文写作经验"/></a><div class="content"><a class="title" href="/2024/04/22/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C%E7%BB%8F%E9%AA%8C/" title="论文写作经验">论文写作经验</a><time datetime="2024-04-22T08:47:18.000Z" title="发表于 2024-04-22 16:47:18">2024-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/18/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB-AlexNet/" title="AlexNet"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="AlexNet"/></a><div class="content"><a class="title" href="/2024/03/18/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB-AlexNet/" title="AlexNet">AlexNet</a><time datetime="2024-03-17T16:23:18.534Z" title="发表于 2024-03-18 00:23:18">2024-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="大数据原理与实践"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/404.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="大数据原理与实践"/></a><div class="content"><a class="title" href="/2024/03/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="大数据原理与实践">大数据原理与实践</a><time datetime="2024-03-07T06:09:38.555Z" title="发表于 2024-03-07 14:09:38">2024-03-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/19/%E6%95%B0%E6%A8%A1notes/" title="数模notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="数模notes"/></a><div class="content"><a class="title" href="/2023/11/19/%E6%95%B0%E6%A8%A1notes/" title="数模notes">数模notes</a><time datetime="2023-11-18T16:00:00.000Z" title="发表于 2023-11-19 00:00:00">2023-11-19</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="JJuprising" target="_blank">JJuprising</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://jjuprising.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cv/cyj_CV.pdf"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> CV</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 0.88rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 0.88rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 0.88rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.88rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>6</sup></a><a href="/tags/%E8%84%91%E7%94%B5/" style="font-size: 0.88rem;">脑电<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 JJuprising 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>