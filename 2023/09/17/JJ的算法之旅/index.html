<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JJ的算法之旅 | Joel Station</title><meta name="author" content="Joel"><meta name="copyright" content="Joel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JJ的算法之旅"><meta name="application-name" content="JJ的算法之旅"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JJ的算法之旅"><meta property="og:url" content="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/index.html"><meta property="og:site_name" content="Joel Station"><meta property="og:description" content="kk&amp;#x3D;kk&amp;amp;(kk-1)，可以消除kk二进制的最后一个1 1#include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;    动态规划 动规基础 背包问题 打家劫舍 股票问题 子序列问题  重要点：  dp数组以及下界的含义，dp[i][j]、dp[i] 递推公式 dp数组如何初始"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="Joel"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="kk&amp;#x3D;kk&amp;amp;(kk-1)，可以消除kk二进制的最后一个1 1#include&amp;lt;bits&amp;#x2F;stdc++.h&amp;gt;    动态规划 动规基础 背包问题 打家劫舍 股票问题 子序列问题  重要点：  dp数组以及下界的含义，dp[i][j]、dp[i] 递推公式 dp数组如何初始"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Joel","link":"链接: ","source":"来源: Joel Station","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Joel Station',
  title: 'JJ的算法之旅',
  postAI: '',
  pageFillDescription: '动态规划, 最长回文子串, 最长公共子序列, 区间DP, 回溯算法, 组合和排列, 注意点, SCNUOJ, P01 最大二叉树, ！P02. [算法课分治] 寻找多数, P03. [算法课分治] 找到最大子序和, P04. [算法课分治] 找到 k 个最小数, P05. [算法课分治] 寻找第 k 个最大元素, P06. [算法课动态规划]走网格, P07. [算法课动态规划]爬楼梯, P08. [算法课动态规划]背包问题, P09 最长回文子串, P10 连续数组最大, ⭐P11 最长公共子序列, P12 贪婪 6和9组成的最大数字, P13 贪婪 三角形的最大周长, P14 蛮力 种花问题, ❗P15 贪婪 移掉K位数字(有一步没搞懂), P16 贪婪 盛最多的水, P17 回溯 括号生成 void backTracking(int left int right string curstr), P18 回溯 目标和 void check(int nums[] int tar int n), P19 回溯 电话号码的字母组合 void backtracking(const stringamp sint indexstring curStr) 输入序列 序列号 可能组合, P20 回溯 优美的排列 void backtracking(int pos int n) 位置数 长度, P21 组合 void backTracking(int nint kint startIndex) 长度 个数 遍历位置, P22 回溯 大礼包, P23 计数排序, P24 贪心 跳跃游戏, P25 动规 整数拆分, P26 动态规划 打家劫舍, P27 动态规划 戳气球, P28 贪心 跳跃游戏, P29 指针 颜色分类可以消除二进制的最后一个动态规划动规基础背包问题打家劫舍股票问题子序列问题重要点数组以及下界的含义递推公式数组如何初始化遍历顺序打印数组看看输出结果是否正确最长回文子串应该从下网上从左往右遍历推导因为是由得到布尔型表示是否为回文子串最长公共子序列区间线性一般是在前缀后缀上转移区间从小区间转移到大区间石子合并回溯算法递归和回溯相辅相成递归函数下面就是回溯内容回溯搜索纯暴力搜索算法组合问题切割问题子集问题排列问题棋盘问题王后解数独抽象为叉数问题横向节点用循环表示纵向深度用递归参数终止条件在叶子节点搜集结果集合元素处理结点递归回溯撤销处理节点结果回溯三部曲递归函数参数返回值确定终止条件单层递归逻辑最后一步回溯组合和排列回溯用递归模拟了嵌套层循环的方式回溯递归嵌套循环组合不区分顺序排列区分叶子结点收割结果也就是数组大小等于数的个数注意点运行出错数组开小了和答案不对的一个重要原因没有说明是的就得换一种方式读取如果保持的方式就会错读取方式有可能会造成运行超时超时版不超时版最大二叉树读取构造二叉树构造最大二叉树特殊情况只有一个元素找最大值判左右是否空左右递归返回根节点前序遍历函数终止情况为空结点返回排除叶子结点情况其他输出结点递归左右最大二叉树定义二叉树无参有参前序遍历叶子节点的两个子空节点要去掉不输出否则会多输出一对递归左子树递归右子树只有一个元素直接返回中间找最大找最大值左边还有元素左闭右开左子树的构造就是对左边递归右边递归读取算法课分治寻找多数寻找多数返回特定元素在特定数组中出现的次数规模为直接求解分解当前数组的解为两个数组解在当前数组出现次数较大的解读取算法课分治找到最大子序和如果当前序列只有一个元素计算当前序列的分裂点计算左边界最大子序列和计算右边界最大子序列和返回当前序列最大子序列和读入算法课分治找到个最小数就是一个快速排序这里是就要从开始要从开始就得是交换后后移交换后前移返回最终划分完成后基准元素所在的位置分治算法课分治寻找第个最大元素交换后后移返回最终划分完成后基准元素所在的位置数据读取快速排序算法课动态规划走网格棋盘初始化算法课动态规划爬楼梯零一阶都是只有一种方法达到算法课动态规划背包问题不放物品由推出即背包容量为里面不放物品的最大价值此时就是其实就是当物品的重量大于背包的重量时物品无法放进背包中所以背包内的价值依然和前面相同放物品由推出为背包容量为的时候不放物品的最大价值那么物品的价值就是背包放物品得到的最大价值背包问题能放物品的进行初始化遍历物品遍历背包容量放不进就是不妨上一个物品放的进就是比较上一个和放进这个的大小最长回文子串算法课动态规划最长回文子串对角线为少了一个判断是两个字符的情况两个字符找最长的记录下来连续数组最大算法课动态规划连续数组最大和加端点最长公共子序列空出一个外围非则会越界注意都要退一个如果当前字母想都就是左上角加上如果不同找左边或者上边的最大值贪婪和组成的最大数字简单跳过贪婪三角形的最大周长给定由一些正数代表长度组成的数组返回由其中三个长度组成的面积不为零的三角形的最大周长如果不能形成任何面积不为零的三角形返回算法课贪婪三角形的最大周长对进行排序冒泡排序降序用蛮力种花问题假设有一个很长的花坛一部分地块种植了花另一部分却没有可是花不能种植在相邻的地块上它们会争夺水源两者都会死去给你一个整数数组表示花坛由若干和组成其中表示没种植花表示种植了花另有一个数能否在不打破种植规则的情况下种入朵花能则返回不能则返回提示为或中不存在相邻的两朵花算法课蛮力法种花问题最后一个就是插入总数去掉最后一个总数的只有一个花坛第一个和最后一个特殊情况先种最左和最右开始从左往右有位置就种种上后要赋值最后一个数真的猪啊在前面经历过操作你在这里调试输出肯定对应不上原始值啊转换到的最后一个总数贪婪移掉位数字有一步没搞懂给你一个以字符串表示的非负整数和一个整数移除这个数中的位数字使得剩下的数字最小请你以字符串形式返回这个最小的数字仅由若干位数字组成除了本身之外不含任何前导零开始遍历前一个大于后一个去除前导贪婪盛最多的水给你个非负整数每个数代表坐标中的一个点在坐标内画条垂直线垂直线的两个端点分别为和找出其中的两条线使得它们与轴共同构成的容器可以容纳最多的水说明你不能倾斜容器算法课贪婪盛最多的水思路从最远两边往里收缩不是同时收缩是一边一边收缩记录最大找第一长和所有其他的算再找第一二长和所有其他的算面积小的一边收缩回溯括号生成算法课回溯括号生成放的数组递归结束条件当剩余左边括号小于或等于右边时才满足放左放右回溯目标和给你一个整数数组和一个整数向数组中的每个整数前添加或然后串联起所有整数可以构造一个表达式例如可以在之前添加在之前添加然后串联起来得到表达式返回可以通过上述方法构造的运算结果等于的不同表达式的数目提示算法课回溯目标和数组目标和参与个数不满足但是退出回溯电话号码的字母组合输入序列序列号可能组合给定一个仅包含数字的字符串返回所有它能表示的字母组合答案按字母顺序返回给出数字到字母的映射如下与电话按键相同注意不对应任何字母标记当前是遍历到第几个记录遍历到第几个记录第个位置当这个满足时说明前面的坑都填完了三个位置都放好了转为数值取序号递归回溯长度是其他都是回溯优美的排列位置数长度假设有从到的个整数用这些整数构造一个数组下标从开始只要满足下述条件之一该数组就是一个优美的排列能够被整除能够被整除给你一个整数返回可以构造的优美排列的数量提示算法课回溯优美的排列标记作用访问回溯所有排列的组合边凑数进行判断如果不满足置标记为直接排除当前情况组合长度个数遍历位置是氛围是个数记录遍历到那个数了到叶子了收割结果递归回溯回溯大礼包商品即对应价格存放大礼包需要的各个商品数量礼包种类数为此层决策要花多少钱先不考虑买礼包遍历礼包复制一遍需求暂存礼包的大小存入礼包价格是否能买当前礼包遍历礼包的物品列表有一个不满足能买的话更新能买礼包当前礼包加上剩下需求所需的钱不能买礼包换下一个读取假设有个大礼包最基本的一个大礼包都不买遍历所有大礼包包括自己递归终止条件它加下一个礼包超出了数量首先大礼包的物品数要都小于目标数据不满足则跳过递归满足则加入算出总价递归检查是否到最后一个大礼包是判断还剩多少用则用基本物品价格去补充问题这里的你不知道即礼包的个数不定前都是商品计数排序计数排序这里按序号赋值本身就已经有序了不用排序了重复的进行排序的话自动跳过了巧妙贪心跳跃游戏给定一个非负整数数组你最初位于数组的第一个下标数组中的每个元素代表你在该位置可以跳跃的最大长度判断你是否能够到达最后一个下标上一个标记当前出现的位置能到最后的标记查到判断前面有没有能够跳过的法维护一个可达到的最远位置通过遍历当前可跳跃范围内的所有位置计算每个位置能够达到的最远位置并更新如果超过数组长度的最后一个位置则表示可以到达末尾返回否则根据当前位置调整下一次可跳跃范围的起点和终点直到无法继续跳跃返回动规整数拆分给定一个正整数将其拆分为个正整数的和并使这些整数的乘积最大化返回你可以获得的最大乘积我们用来表示分拆数字可以得到的最大乘积对于每个来说都可以通过前面已知的拆分结果来求遍历前面的每个数字假设拆分成两个数和这是一种情况另外又可以继续拆分拆分的最大值就是同理也是一样的我们在所有情况里取最大值就是的结果动态规划打家劫舍你是一个专业的小偷计划偷窃沿街的房屋每间房内都藏有一定的现金影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统如果两间相邻的房屋在同一晚上被小偷闯入系统会自动报警给定一个代表每个房屋存放金额的非负整数数组计算你不触动警报装置的情况下一夜之内能够偷窃到的最高金额提示算法课动态规划打家劫舍占着第个初始化遍历不偷本间偷本间加前面的第二间动态规划戳气球算法课动态规划戳气球添加两侧的虚拟气球从开始已经都被初始化为开始状态转移应该从下往上应该从左往右最后戳破的气球是哪个择优做选择贪心跳跃游戏有一个非负整数数组最初位于数组的第一个位置数组中的每个元素代表你在该位置可以跳跃的最大长度假设你总是可以到达数组的最后一个位置你的目标是使用最少的跳跃次数到达数组的最后一个位置输入基本思想每次在当前能跳跃范围内选择可以使得接下来能跳跃最远的位置记录跳到最远的当前的位置首先初始化一个最远跳得超越了之前的指针颜色分类给定一个包含红色白色和蓝色共个元素的数组原地对它们进行排序使得相同颜色的元素相邻并按照红色白色蓝色顺序排列我们使用整数和分别表示红色白色和蓝色输入第一行输入一个整数代表数组的长度第二行输入一行数字代表数组为数字与数字之间用空格间开输出输出排序后的数组算法课指针颜色分类检查三种颜色工作指针检查找到颜色头一个头部解决建议记录头部索引存储颜色族头进入一个聚类的循环找到一个替换直到越界',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-11 08:45:43',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Joel Station</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 1.05rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 1.05rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 1.05rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 1.05rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>6</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">JJ的算法之旅</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-16T17:39:06.000Z" title="发表于 2023-09-17 01:39:06">2023-09-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-03-11T00:45:43.936Z" title="更新于 2024-03-11 08:45:43">2024-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"><header><h1 id="CrawlerTitle" itemprop="name headline">JJ的算法之旅</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Joel</span><time itemprop="dateCreated datePublished" datetime="2023-09-16T17:39:06.000Z" title="发表于 2023-09-17 01:39:06">2023-09-17</time><time itemprop="dateCreated datePublished" datetime="2024-03-11T00:45:43.936Z" title="更新于 2024-03-11 08:45:43">2024-03-11</time></header><p>kk&#x3D;kk&amp;(kk-1)，可以消除kk二进制的最后一个1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li>动规基础</li>
<li>背包问题</li>
<li>打家劫舍</li>
<li>股票问题</li>
<li>子序列问题</li>
</ul>
<p>重要点：</p>
<ul>
<li>dp数组以及下界的含义，dp[i][j]、dp[i]</li>
<li>递推公式</li>
<li>dp数组如何初始化,0?1?…</li>
<li>遍历顺序</li>
<li>打印dp数组，看看输出结果是否正确</li>
</ul>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>应该从下网上，从左往右遍历推导</p>
<p>因为d[i][j]是由d[i+1][j-1]得到，d[i][j]布尔型，表示i,j是否为回文子串</p>
<h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p>线性DP一般是在前缀&#x2F;后缀上转移</p>
<p>区间DP从小区间转移到大区间</p>
<ul>
<li>石子合并</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="D:\Blog\source_posts\JJ的算法之旅.assets\image-20231011152428565.png" alt="image-20231011152428565"></p>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>递归和回溯相辅相成</p>
<p>递归函数下面就是回溯内容</p>
<p>回溯搜索：纯暴力搜索算法</p>
<ul>
<li>组合问题</li>
<li>切割问题</li>
<li>子集问题</li>
<li>排列问题 </li>
<li>棋盘问题，n王后，解数独</li>
</ul>
<p>抽象为n叉数问题，横向节点用for循环表示，纵向深度用递归</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">        在叶子节点搜集结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(集合元素)&#123;</span><br><span class="line">        处理结点;</span><br><span class="line">        递归;</span><br><span class="line">        回溯;<span class="comment">//撤销处理节点结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>回溯三部曲</p>
<ul>
<li>递归函数参数返回值</li>
<li>确定终止条件</li>
<li>单层递归逻辑(最后一步回溯pop)</li>
</ul>
<h2 id="组合和排列"><a href="#组合和排列" class="headerlink" title="组合和排列"></a>组合和排列</h2><p>回溯用递归模拟了嵌套n层for循环的方式。</p>
<p>回溯：递归嵌套for循环</p>
<p>组合不区分顺序，排列区分</p>
<p>叶子结点收割结果：也就是数组大小等于数的个数</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li><p>oj运行出错：数组开小了</p>
</li>
<li><p>oj和答案不对的一个重要原因：没有说明是eof的就得换一种方式读取！！，如果保持eof的方式就会错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="number">1</span> + n) * n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取方式有可能会造成运行超时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//超时版</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;n) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        v[len] = n - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不超时版</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">    v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="SCNUOJ"><a href="#SCNUOJ" class="headerlink" title="SCNUOJ"></a>SCNUOJ</h1><h2 id="P01-最大二叉树"><a href="#P01-最大二叉树" class="headerlink" title="P01 最大二叉树"></a>P01 最大二叉树</h2><ul>
<li>读取，构造二叉树</li>
<li>构造最大二叉树<ul>
<li>特殊情况–只有一个元素</li>
<li>找最大值</li>
<li>判左右是否空，左右递归</li>
<li>返回根节点</li>
</ul>
</li>
<li>前序遍历函数<ul>
<li>终止情况：为空结点，返回</li>
<li>排除叶子结点情况</li>
<li>其他：输出结点，递归左右</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大二叉树</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义二叉树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="comment">//无参</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() :<span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">//有参</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode* left, TreeNode* right) :<span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* tr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;null&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//叶子节点的两个子空节点要去掉不输出！否则会多输出一对null</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (tr-&gt;left == <span class="literal">NULL</span> &amp;&amp; tr-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; tr-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; tr-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PreOrder</span>(tr-&gt;left); <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(tr-&gt;right); <span class="comment">//递归右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//只有一个元素，直接返回</span></span><br><span class="line">            node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中间找最大</span></span><br><span class="line">        <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxValueIndex = <span class="number">0</span>;<span class="comment">//找最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">                maxValue = nums[i];</span><br><span class="line">                maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;val = maxValue;</span><br><span class="line">        <span class="comment">//左边还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//newVec左闭右开</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">            <span class="comment">//左子树的构造就是对左边递归</span></span><br><span class="line">            node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//右边递归</span></span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">            node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a) != EOF) &#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    Solution s1;</span><br><span class="line">    TreeNode *re;</span><br><span class="line">    re=s1.<span class="built_in">constructMaximumBinaryTree</span>(nums);</span><br><span class="line">    <span class="built_in">PreOrder</span>(re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="！P02-算法课分治-寻找多数"><a href="#！P02-算法课分治-寻找多数" class="headerlink" title="！P02. [算法课分治] 寻找多数"></a>！P02. [算法课分治] 寻找多数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找多数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//返回特定元素在特定数组中出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> pivot, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] == pivot) num++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findM</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//规模为1直接求解</span></span><br><span class="line">	<span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line">	<span class="comment">//分解</span></span><br><span class="line">	<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> leftNum = <span class="built_in">findM</span>(nums, left, mid);</span><br><span class="line">	<span class="type">int</span> rightNum = <span class="built_in">findM</span>(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">	<span class="comment">//当前数组的解为两个数组解在当前数组出现次数较大的解</span></span><br><span class="line">	<span class="keyword">if</span> (leftNum == rightNum) <span class="keyword">return</span> leftNum;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> lcount = <span class="built_in">traverse</span>(nums, leftNum, left, right);</span><br><span class="line">		<span class="type">int</span> rcount = <span class="built_in">traverse</span>(nums, rightNum, left, right);</span><br><span class="line">		<span class="keyword">return</span> lcount &gt; rcount ? leftNum : rightNum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//读取</span></span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">10001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		nums[i] = a;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">findM</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P03-算法课分治-找到最大子序和"><a href="#P03-算法课分治-找到最大子序和" class="headerlink" title="P03. [算法课分治] 找到最大子序和"></a>P03. [算法课分治] 找到最大子序和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMaxNum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b &amp;&amp; a &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a &amp;&amp; b &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSumRec</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前序列只有一个元素</span></span><br><span class="line">        <span class="keyword">return</span> data[left];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> center = (left + right) / <span class="number">2</span>;<span class="comment">//计算当前序列的分裂点</span></span><br><span class="line">    <span class="type">int</span> maxLeftSum = <span class="built_in">maxSumRec</span>(data, left, center);</span><br><span class="line">    <span class="type">int</span> maxRightSum = <span class="built_in">maxSumRec</span>(data, center, right);</span><br><span class="line">    <span class="comment">//计算左边界最大子序列和</span></span><br><span class="line">    <span class="type">int</span> leftBonderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxLeftBonderSum = data[center - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = center - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">        leftBonderSum += data[i];</span><br><span class="line">        <span class="keyword">if</span> (maxLeftBonderSum &lt; leftBonderSum) &#123;</span><br><span class="line">            maxLeftBonderSum = leftBonderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算右边界最大子序列和</span></span><br><span class="line">    <span class="type">int</span> rightBonderSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxRightBonderSum = data[center];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = center; i &lt; right; i++) &#123;</span><br><span class="line">        rightBonderSum += data[i];</span><br><span class="line">        <span class="keyword">if</span> (maxRightBonderSum &lt; rightBonderSum) &#123;</span><br><span class="line">            maxRightBonderSum = rightBonderSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回当前序列最大子序列和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMaxNum</span>(maxLeftBonderSum + maxRightBonderSum, maxLeftSum, maxRightSum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> v1[<span class="number">1000000</span>];</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		v1[i]=t;<span class="comment">//读入</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    cout&lt;&lt;<span class="built_in">maxSumRec</span>(v1, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P04-算法课分治-找到-k-个最小数"><a href="#P04-算法课分治-找到-k-个最小数" class="headerlink" title="P04. [算法课分治] 找到 k 个最小数"></a>P04. [算法课分治] 找到 k 个最小数</h2><p>就是一个快速排序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low, j = height, pviot = a[low]; <span class="comment">//这里是low就要从j开始，要从i开始就得是height</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (a[j]&gt;pviot&amp;&amp;i&lt;j)</span><br><span class="line">		&#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i++], a[j]);<span class="comment">//交换后i后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; pviot &amp;&amp; i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j--]);<span class="comment">//交换后，j前移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; height) &#123;</span><br><span class="line">		mid = <span class="built_in">part</span>(a, low, height);</span><br><span class="line">		<span class="comment">//分治</span></span><br><span class="line">		<span class="built_in">Quicksort</span>(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, mid + <span class="number">1</span>, height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n,a,k;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">10001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		nums[i] = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Quicksort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">		cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P05-算法课分治-寻找第-k-个最大元素"><a href="#P05-算法课分治-寻找第-k-个最大元素" class="headerlink" title="P05. [算法课分治] 寻找第 k 个最大元素"></a>P05. [算法课分治] 寻找第 k 个最大元素</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">part</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> low, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = low, j = height, pviot = a[low];</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">		<span class="keyword">while</span> (a[j] &gt; pviot &amp;&amp; j &gt; i) &#123;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i++], a[j]);<span class="comment">//交换后，i后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (a[i] &lt; pviot &amp;&amp; i &lt; j) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(a[i], a[j--]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quicksort</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> low,<span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> mid;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; height) &#123;</span><br><span class="line">		mid = <span class="built_in">part</span>(a, low, height);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, low, mid - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">Quicksort</span>(a, mid + <span class="number">1</span>, height);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//数据读取</span></span><br><span class="line">	<span class="type">int</span> len, k;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; len &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		cin &gt;&gt; t;</span><br><span class="line">		a[i] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//快速排序</span></span><br><span class="line">	<span class="built_in">Quicksort</span>(a, <span class="number">0</span>,len<span class="number">-1</span>);</span><br><span class="line">	cout &lt;&lt; a[len-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P06-算法课动态规划-走网格"><a href="#P06-算法课动态规划-走网格" class="headerlink" title="P06. [算法课动态规划]走网格"></a>P06. [算法课动态规划]走网格</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//棋盘</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> m, n;</span><br><span class="line">	cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span> || j == <span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[m][n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P07-算法课动态规划-爬楼梯"><a href="#P07-算法课动态规划-爬楼梯" class="headerlink" title="P07. [算法课动态规划]爬楼梯"></a>P07. [算法课动态规划]爬楼梯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">21</span>];</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//零一阶都是只有一种方法达到</span></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P08-算法课动态规划-背包问题"><a href="#P08-算法课动态规划-背包问题" class="headerlink" title="P08. [算法课动态规划]背包问题"></a>P08. [算法课动态规划]背包问题</h2><ul>
<li><strong>不放物品i</strong>：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)</li>
<li><strong>放物品i</strong>：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背包问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> weight[] = &#123; <span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">	<span class="type">int</span> value[] = &#123; <span class="number">42</span>,<span class="number">12</span>,<span class="number">40</span>,<span class="number">25</span> &#125;;</span><br><span class="line">	<span class="type">int</span> wetLen,cap;</span><br><span class="line">	cin &gt;&gt; wetLen &gt;&gt; cap;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">11</span>][<span class="number">11</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = weight[<span class="number">0</span>]; i &lt;= cap; i++) &#123;</span><br><span class="line">		<span class="comment">//能放物品1的进行初始化</span></span><br><span class="line">		dp[<span class="number">0</span>][i] = value[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历物品</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= wetLen; i++) &#123;</span><br><span class="line">		<span class="comment">//遍历背包容量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cap; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; weight[i<span class="number">-1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//放不进，就是不妨上一个物品</span></span><br><span class="line">			<span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i<span class="number">-1</span>]] + value[i<span class="number">-1</span>]);<span class="comment">//放的进就是比较上一个和放进这个的大小</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[wetLen][cap];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P09-最长回文子串"><a href="#P09-最长回文子串" class="headerlink" title="P09 最长回文子串"></a>P09 最长回文子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/Problem P09. [算法课动态规划]最长回文子串</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1;</span><br><span class="line">	cin &gt;&gt; s1;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对角线为1</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = s1.<span class="built_in">size</span>()<span class="number">-1</span>; i &lt; s1.<span class="built_in">size</span>(); i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i ; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="comment">//少了一个判断是两个字符的情况</span></span><br><span class="line">			<span class="keyword">if</span> (s1[i] == s1[j]) &#123;</span><br><span class="line">				<span class="comment">//两个字符</span></span><br><span class="line">				<span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//找最长的，记录下来</span></span><br><span class="line">	<span class="type">int</span> maxI = <span class="number">0</span>, maxJ = <span class="number">0</span>, maxdis = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s1.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j - i &gt; maxdis&amp;&amp;dp[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">				maxI = i;</span><br><span class="line">				maxJ = j;</span><br><span class="line">				maxdis = j - i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> z = maxI; z &lt;= maxJ; z++) &#123;</span><br><span class="line">		cout &lt;&lt; s1[z];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P10-连续数组最大"><a href="#P10-连续数组最大" class="headerlink" title="P10 连续数组最大"></a>P10 连续数组最大</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P10.[算法课动态规划]连续数组最大和</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> dp[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="type">int</span> p;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; p;</span><br><span class="line">		a[i] = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == j) dp[i][j] = a[i];</span><br><span class="line">			<span class="keyword">else</span> dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + a[i] + a[j];<span class="comment">//加端点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i][j] &gt; max) &#123;</span><br><span class="line">				max = dp[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="⭐P11-最长公共子序列"><a href="#⭐P11-最长公共子序列" class="headerlink" title="⭐P11 最长公共子序列"></a>⭐P11 最长公共子序列</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1001</span>][<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string s1, s2;</span><br><span class="line">	cin &gt;&gt; s1&gt;&gt;s2;</span><br><span class="line">	<span class="comment">//空出一个外围，非则会越界</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//注意i，i都要退一个</span></span><br><span class="line">            <span class="comment">//如果当前字母想都，就是左上角加上1</span></span><br><span class="line">			<span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果不同，找左边或者上边的最大值</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[s1.<span class="built_in">size</span>()][s2.<span class="built_in">size</span>()];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P12-贪婪-6和9组成的最大数字"><a href="#P12-贪婪-6和9组成的最大数字" class="headerlink" title="P12 贪婪 6和9组成的最大数字"></a>P12 贪婪 6和9组成的最大数字</h2><p>简单跳过</p>
<h2 id="P13-贪婪-三角形的最大周长"><a href="#P13-贪婪-三角形的最大周长" class="headerlink" title="P13 贪婪 三角形的最大周长"></a>P13 贪婪 三角形的最大周长</h2><p>给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。如果不能形成任何面积不为零的三角形，返回 0。</p>
<ul>
<li>3 &lt;&#x3D; A.length &lt;&#x3D; 1000</li>
<li>1 &lt;&#x3D; A[i] &lt;&#x3D; 1000</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P13. [算法课贪婪]三角形的最大周长</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">1001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v) != EOF) &#123;</span><br><span class="line">		a[count] = v;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对a进行排序 冒泡排序 降序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; count - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a[j] &lt; a[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="type">int</span> temp = a[j];</span><br><span class="line">				a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">				a[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">3</span> &lt;= count; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>] &gt; a[i] &amp;&amp; a[i] - a[i + <span class="number">1</span>] &lt; a[i + <span class="number">2</span>]) &#123;</span><br><span class="line">			cout &lt;&lt; a[i] + a[i + <span class="number">1</span>] + a[i + <span class="number">2</span>];</span><br><span class="line">			mark = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (mark == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用sort</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="P14-蛮力-种花问题"><a href="#P14-蛮力-种花问题" class="headerlink" title="P14 蛮力 种花问题"></a>P14 蛮力 种花问题</h2><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</p>
<p>提示：</p>
<ul>
<li><p>1 &lt;&#x3D; flowerbed.length &lt;&#x3D; 2 * 10^4</p>
</li>
<li><p>flowerbed[i] 为 0 或 1</p>
</li>
<li><p>flowerbed 中不存在相邻的两朵花</p>
</li>
<li><p>0 &lt;&#x3D; n &lt;&#x3D; flowerbed.length</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P14.[算法课蛮力法]种花问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100001</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nums=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;a) != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">			v[count] = a-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; nums;</span><br><span class="line">	<span class="comment">//nums=v[count-1];//最后一个就是插入总数</span></span><br><span class="line">	count--;<span class="comment">//去掉最后一个总数的</span></span><br><span class="line">	<span class="comment">/*cout &lt;&lt; &quot;nums:&quot; &lt;&lt; nums&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; &#x27;\n&#x27;; cout &lt;&lt; &quot;v[count+1]:&quot; &lt;&lt; v[count+1] &lt;&lt; &#x27;\n&#x27;;*/</span></span><br><span class="line">	<span class="comment">//只有一个花坛</span></span><br><span class="line">	<span class="keyword">if</span> (nums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; nums == <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第一个和最后一个特殊情况 先种最左和最右</span></span><br><span class="line">	<span class="keyword">if</span> (count &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; v[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			nums--;</span><br><span class="line">			v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ( v[count - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; v[count - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">			nums--;</span><br><span class="line">			v[count - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开始从左往右有位置就种</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (v[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; v[i + <span class="number">1</span>] == <span class="number">0</span>&amp;&amp;v[i]==<span class="number">0</span>) &#123;</span><br><span class="line">			v[i] = <span class="number">1</span>; <span class="comment">//种上后要赋值</span></span><br><span class="line">			nums--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nums&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;true&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;false&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">/*for (int i = 0; i &lt; count; i++)</span></span><br><span class="line"><span class="comment">		cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;*/</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;最后一个数&quot; &lt;&lt; v[count - 1] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">// 真的猪啊，nums在前面经历过--操作，你在这里调试输出肯定对应不上原始值啊！！</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;转换到的最后一个&quot; &lt;&lt; nums &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;总数&quot; &lt;&lt; count;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="❗P15-贪婪-移掉K位数字-有一步没搞懂"><a href="#❗P15-贪婪-移掉K位数字-有一步没搞懂" class="headerlink" title="❗P15 贪婪 移掉K位数字(有一步没搞懂)"></a>❗P15 贪婪 移掉K位数字(有一步没搞懂)</h2><p>给你一个以字符串表示的非负整数 <strong>num</strong> 和一个整数 <strong>k</strong> ，移除这个数中的 <strong>k</strong> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<ul>
<li>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 1000</li>
<li>num 仅由若干位数字（0 - 9）组成</li>
<li>除了 0 本身之外，num 不含任何前导零</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/12/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    string v;</span><br><span class="line">    cin&gt;&gt;v&gt;&gt;k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span>&amp;&amp;v.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;v[i]&gt;v[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="comment">//前一个大于后一个</span></span><br><span class="line">            v.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>) i--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;v.<span class="built_in">size</span>())&#123;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(v[i]==<span class="string">&#x27;0&#x27;</span>&amp;&amp;v.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        v.<span class="built_in">erase</span>(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P16-贪婪-盛最多的水"><a href="#P16-贪婪-盛最多的水" class="headerlink" title="P16 贪婪 盛最多的水"></a>P16 贪婪 盛最多的水</h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem P16.[算法课贪婪]盛最多的水</span></span><br><span class="line"><span class="comment">// 思路从最远两边往里收缩，不是同时收缩，是一边一边收缩，记录最大</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//找第一长，和所有其他的算，再找第一二长和所有其他的算。。。</span></span><br><span class="line">	<span class="type">char</span> n;</span><br><span class="line">	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">		v.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>,r=v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>, area = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">		area = <span class="built_in">min</span>(v[l], v[r]) * (r - l);<span class="comment">//面积</span></span><br><span class="line">		ans=<span class="built_in">max</span>(ans,area);</span><br><span class="line">		<span class="comment">//小的一边收缩</span></span><br><span class="line">		<span class="keyword">if</span> (v[l] &lt; v[r]) &#123;</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P17-回溯-括号生成-void-backTracking-int-left-int-right-string-curstr"><a href="#P17-回溯-括号生成-void-backTracking-int-left-int-right-string-curstr" class="headerlink" title="P17 回溯 括号生成 void backTracking(int left, int right, string curstr)"></a>P17 回溯 括号生成 void backTracking(int left, int right, string curstr)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P17.[算法课回溯]括号生成</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;string&gt; strs;<span class="comment">//放string的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string curstr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span> (right == <span class="number">0</span> &amp;&amp; left == <span class="number">0</span>) &#123;</span><br><span class="line">		strs.<span class="built_in">push_back</span>(curstr);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当剩余左边括号小于或等于右边时，才满足</span></span><br><span class="line">	<span class="keyword">if</span> (left &lt;= right &amp;&amp; left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">backTracking</span>(left - <span class="number">1</span>, right, curstr + <span class="string">&quot;(&quot;</span>);<span class="comment">//放左</span></span><br><span class="line">		<span class="built_in">backTracking</span>(left, right - <span class="number">1</span>, curstr + <span class="string">&quot;)&quot;</span>);<span class="comment">//放右</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">backTracking</span>(n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		cout &lt;&lt; strs[i];</span><br><span class="line">		<span class="keyword">if</span> (i != strs.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P18-回溯-目标和-void-check-int-nums-int-tar-int-n"><a href="#P18-回溯-目标和-void-check-int-nums-int-tar-int-n" class="headerlink" title="P18 回溯 目标和 void check(int nums[], int tar, int n)"></a>P18 回溯 目标和 void check(int nums[], int tar, int n)</h2><p>给你一个整数数组 nums 和一个整数 target 。</p>
<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>
<p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 20</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 1000</li>
<li>0 &lt;&#x3D; sum(nums[i]) &lt;&#x3D; 1000</li>
<li>-1000 &lt;&#x3D; target &lt;&#x3D; 1000</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/12/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Problem P18. [算法课回溯]目标和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tsize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//数组 目标和 参与个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">int</span> nums[], <span class="type">int</span> tar, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tar == <span class="number">0</span> &amp;&amp; n == tsize) count++;</span><br><span class="line">    <span class="keyword">if</span> (n == tsize) <span class="keyword">return</span>;<span class="comment">//不满足但是退出</span></span><br><span class="line">    <span class="built_in">check</span>(nums, tar - nums[n], n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">check</span>(nums, tar + nums[n], n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">21</span>];</span><br><span class="line">    <span class="type">int</span> target = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;a)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[size] = a;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; target;</span><br><span class="line">    tsize=size;</span><br><span class="line">    <span class="built_in">check</span>(nums,target,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P19-回溯-电话号码的字母组合-void-backtracking-const-string-amp-s-int-index-string-curStr-输入序列-序列号-可能组合"><a href="#P19-回溯-电话号码的字母组合-void-backtracking-const-string-amp-s-int-index-string-curStr-输入序列-序列号-可能组合" class="headerlink" title="P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合"></a>P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合</h2><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案按<strong>字母顺序</strong>返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://oj.socoding.cn/uploads/20211104/16360198642759.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//const char chara[][4]=&#123;&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;,&#123;&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125;,&#123;&#x27;g&#x27;,&#x27;h&#x27;,&#x27;i&#x27;&#125;,&#123;&#x27;j&#x27;,&#x27;k&#x27;,&#x27;l&#x27;&#125;,&#123;&#x27;m&#x27;,&#x27;n&#x27;,&#x27;o&#x27;&#125;,&#123;&#x27;p&#x27;,&#x27;q&#x27;,&#x27;r&#x27;,&#x27;s&#x27;&#125;,&#123;&#x27;t&#x27;,&#x27;u&#x27;,&#x27;v&#x27;&#125;,&#123;&#x27;w&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;z&#x27;&#125;&#125;;</span></span><br><span class="line"><span class="type">const</span> string chara[<span class="number">8</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; strs;</span><br><span class="line"><span class="comment">//标记当前是遍历到第几个</span></span><br><span class="line"><span class="comment">//_ _ x记录遍历到第几个，n记录第x个位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string&amp; s,<span class="type">int</span> index,string curStr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==s.<span class="built_in">size</span>())&#123;<span class="comment">//当这个满足时，说明前面的坑都填完了</span></span><br><span class="line">        <span class="comment">//三个位置都放好了</span></span><br><span class="line">        strs.<span class="built_in">push_back</span>(curStr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=s[index]-<span class="string">&#x27;0&#x27;</span><span class="number">-2</span>;<span class="comment">//转为数值 取序号</span></span><br><span class="line">    string letter=chara[num];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;letter.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        curStr.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(s,index+<span class="number">1</span>,curStr);<span class="comment">//递归</span></span><br><span class="line">        curStr.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">printPar</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> strs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(s,<span class="number">0</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> strs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//7,9长度是4，其他都是3</span></span><br><span class="line">    string s1;</span><br><span class="line">    cin&gt;&gt;s1;</span><br><span class="line">    <span class="built_in">printPar</span>(s1);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cout&lt;&lt;strs[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;strs.<span class="built_in">size</span>()<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P20-回溯-优美的排列-void-backtracking-int-pos-int-n-位置数-长度"><a href="#P20-回溯-优美的排列-void-backtracking-int-pos-int-n-位置数-长度" class="headerlink" title="P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度"></a>P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度</h2><p>假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 perm（下标从 1 开始），只要满足下述条件 之一 ，该数组就是一个 优美的排列 ：</p>
<ul>
<li>perm[i] 能够被 i 整除</li>
<li>i 能够被 perm[i] 整除</li>
</ul>
<p>给你一个整数 n ，返回可以构造的 优美排列 的 数量 。</p>
<p>提示：</p>
<ul>
<li>1 &lt;&#x3D; n &lt;&#x3D; 15</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P20. [算法课回溯]优美的排列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//int number[]=&#123;1,2,3,4,5,6,7,8,9,10,11,12,13,14,15&#125;;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vis=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>,<span class="number">0</span>);<span class="comment">//标记作用</span></span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos&gt;n) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos%i==<span class="number">0</span>||i%pos==<span class="number">0</span>)&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;<span class="comment">//访问</span></span><br><span class="line">            <span class="built_in">backtracking</span>(pos+<span class="number">1</span>,n);</span><br><span class="line">            vis[i]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1-n所有排列的组合，边凑数，进行判断，如果不满足，置标记为false，直接排除当前情况</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">backtracking</span>(<span class="number">1</span>,n);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P21-组合-void-backTracking-int-n-int-k-int-startIndex-长度-个数-遍历位置"><a href="#P21-组合-void-backTracking-int-n-int-k-int-startIndex-长度-个数-遍历位置" class="headerlink" title="P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置"></a>P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backTracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="comment">//n是氛围，k是个数，startIndex记录遍历到那个数了</span></span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>()==k)&#123;<span class="comment">//到叶子了，收割结果</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;=n ; ++i) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="built_in">backTracking</span>(n,k,i+<span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();<span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tar[<span class="number">21</span>][<span class="number">21</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">backTracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            cout&lt;&lt;result[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P22-回溯-大礼包"><a href="#P22-回溯-大礼包" class="headerlink" title="P22 回溯 大礼包"></a>P22 回溯 大礼包</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; goods;<span class="comment">//商品即对应价格</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; special;<span class="comment">//存放大礼包</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; need;<span class="comment">//需要的各个商品数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> specialn=<span class="number">0</span>;<span class="comment">//礼包种类数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">backTracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; n)</span></span>&#123;<span class="comment">//n为need</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//此层决策要花多少钱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        ans+=goods[i]*n[i];<span class="comment">//先不考虑买礼包</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; specialn; ++i) &#123;<span class="comment">//遍历礼包</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;<span class="comment">//复制一遍需求，暂存</span></span><br><span class="line">        <span class="type">int</span> size_1bag=special[i].<span class="built_in">size</span>();<span class="comment">//礼包的大小</span></span><br><span class="line">        <span class="type">int</span> price=special[i][size_1bag<span class="number">-1</span>];<span class="comment">//存入礼包价格</span></span><br><span class="line">        <span class="type">bool</span> is_valid= <span class="literal">true</span>;<span class="comment">//是否能买当前礼包</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size_1bag<span class="number">-1</span>; ++j) &#123;<span class="comment">//遍历礼包的物品列表</span></span><br><span class="line">            <span class="keyword">if</span>(special[i][j]&gt;n[j])&#123;</span><br><span class="line">                <span class="comment">//有一个不满足</span></span><br><span class="line">                is_valid= <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp[j]-=special[i][j];<span class="comment">//能买的话更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is_valid)&#123;<span class="comment">//能买礼包</span></span><br><span class="line">            price+= <span class="built_in">backTracking</span>(tmp);<span class="comment">//当前礼包加上剩下需求所需的钱</span></span><br><span class="line">            ans= <span class="built_in">min</span>(ans,price);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//不能买礼包，换下一个</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 假设有n个大礼包</span></span><br><span class="line">    <span class="comment">// 最基本的：一个大礼包都不买</span></span><br><span class="line">    <span class="comment">// 遍历所有大礼包包括自己（递归)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 终止条件：它加下一个礼包超出了数量</span></span><br><span class="line"><span class="comment">     * 首先大礼包的物品数要都小于目标数据</span></span><br><span class="line"><span class="comment">     * 不满足，则跳过，递归</span></span><br><span class="line"><span class="comment">     * 满足，则加入，算出总价，递归</span></span><br><span class="line"><span class="comment">     * 检查是否到最后一个大礼包</span></span><br><span class="line"><span class="comment">     *  是，判断还剩多少，用则用基本物品价格去补充</span></span><br><span class="line"><span class="comment">     * 问题:这里的k你不知道？即礼包的个数不定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; init;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        init.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前size-1都是商品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; init.<span class="built_in">size</span>()<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        goods.<span class="built_in">push_back</span>(init[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> speciallen=init[init.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;speciallen;i++)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; save;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;goods.<span class="built_in">size</span>()+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            cin&gt;&gt;n;</span><br><span class="line">            save.<span class="built_in">push_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        special.<span class="built_in">push_back</span>(save);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;goods.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        need.<span class="built_in">push_back</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    specialn=special.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="built_in">backTracking</span>(need);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P23-计数排序"><a href="#P23-计数排序" class="headerlink" title="P23 计数排序"></a>P23 计数排序</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20231212144444548.png" alt="image-20231212144444548"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/15.</span></span><br><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>,m=<span class="number">0</span>,bi=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        ++c[a[i]]; <span class="comment">//这里按序号赋值，本身就已经有序了，不用排序了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c[i];++j)&#123;</span><br><span class="line">            b[++bi]=i;<span class="comment">//重复的a[i]进行排序 0的话自动跳过了巧妙</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        (ans+=<span class="number">1LL</span>*i*b[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P24-贪心-跳跃游戏"><a href="#P24-贪心-跳跃游戏" class="headerlink" title="P24 贪心 跳跃游戏"></a>P24 贪心 跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度</p>
<p>判断你是否能够到达最后一个下标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">100001</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a)&#123;</span><br><span class="line">        num[size]=a;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> latTar=<span class="number">0</span>;<span class="comment">//上一个0</span></span><br><span class="line">    <span class="type">int</span> curTar=<span class="number">0</span>;<span class="comment">//标记当前出现0的位置</span></span><br><span class="line">    <span class="type">bool</span> flag=<span class="literal">true</span>;<span class="comment">//能到最后的标记</span></span><br><span class="line">    <span class="keyword">if</span> (num[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            curTar=i;</span><br><span class="line">            <span class="type">bool</span> canFly= <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//查到0，判断前面有没有能够跳过0的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=latTar;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+num[j]&gt;curTar)&#123;</span><br><span class="line">                    canFly= <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!canFly)&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) cout&lt;&lt;<span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法2</p>
<p>维护一个可达到的最远位置maxPos，通过遍历当前可跳跃范围内的所有位置，计算每个位置能够达到的最远位置，并更新maxPos。如果maxPos超过数组长度的最后一个位置，则表示可以到达末尾，返回true；否则，根据当前位置调整下一次可跳跃范围的起点和终点，直到无法继续跳跃返回false。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;a)&#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxPos=<span class="number">0</span>,left=<span class="number">0</span>,right=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxPos&gt;=v.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line"></span><br><span class="line">            maxPos=<span class="built_in">max</span>(maxPos,i+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        left=right+<span class="number">1</span>;</span><br><span class="line">        right=maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) cout&lt;&lt;<span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;false&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P25-动规-整数拆分"><a href="#P25-动规-整数拆分" class="headerlink" title="P25 动规 整数拆分"></a>P25 动规 整数拆分</h2><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;&#x3D; 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。</p>
<p>我们用dp[i]来表示分拆数字i，可以得到的最大乘积，对于每个i来说，都可以通过前面已知的拆分结果来求，遍历i前面的每个数字j，假设拆分成两个数 j 和 i-j ，这是一种情况，另外，j 又可以继续拆分，j拆分的最大值就是dp[j]， 同理 i-j 也是一样的，我们在所有情况里取最大值就是dp[i]的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">60</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">        cout&lt;&lt;dp[n];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j*(i-j),dp[i-j]*j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P26-动态规划-打家劫舍"><a href="#P26-动态规划-打家劫舍" class="headerlink" title="P26 动态规划 打家劫舍"></a>P26 动态规划 打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li>
<li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P26. [算法课动态规划] 打家劫舍</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; room;</span><br><span class="line">    room.<span class="built_in">push_back</span>(<span class="number">0</span>);<span class="comment">//占着第0个</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">        room.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>]=room[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp</span></span><br><span class="line">    <span class="comment">//遍历dp</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=room.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+room[i]);<span class="comment">//不偷本间,偷本间加前面的第二间</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;room.size()&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;dp[room.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P27-动态规划-戳气球"><a href="#P27-动态规划-戳气球" class="headerlink" title="P27 动态规划 戳气球"></a>P27 动态规划 戳气球</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85.assets/image-20231212145315276.png" alt="image-20231212145315276"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Problem P27. [算法课动态规划] 戳气球</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCoins</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">points</span><span class="params">(n+<span class="number">2</span>)</span> </span>;<span class="comment">//= new int[n + 2]</span></span><br><span class="line">    points[<span class="number">0</span>] = points[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        points[i] = nums[i - <span class="number">1</span>];<span class="comment">//nums从0开始</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(n+<span class="number">2</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">2</span>));<span class="comment">//    int[][] dp = new int[n + 2][n + 2];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(</span><br><span class="line">                        dp[i][j],</span><br><span class="line">                        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;n)&#123;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(n);</span><br><span class="line">        <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">maxCoins</span>(nums);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="P28-贪心-跳跃游戏"><a href="#P28-贪心-跳跃游戏" class="headerlink" title="P28 贪心 跳跃游戏"></a>P28 贪心 跳跃游戏</h2><p>有一个非负整数数组 nums，最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>假设你总是可以到达数组的最后一个位置, 你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<p>输入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by chan on 2023/11/22.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基本思想</span></span><br><span class="line"><span class="comment"> * 每次在当前能跳跃范围内选择可以使得接下来能跳跃最远的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxStep</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vector1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        nums.<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">findMaxStep</span>(nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxStep</span><span class="params">(vector&lt;<span class="type">int</span>&gt; vector1)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxReach=<span class="number">0</span>;<span class="comment">//记录跳到最远的</span></span><br><span class="line">    <span class="type">int</span> curReach=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxPos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (curReach&lt;=maxReach&amp;&amp;maxPos&lt;vector1.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line"><span class="comment">//        curReach=maxReach;//当前的位置</span></span><br><span class="line"><span class="comment">//        maxReach=vector1[curReach]+curReach;//首先初始化一个最远</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=curReach;i&lt;=maxReach;i++)&#123;</span><br><span class="line">            <span class="comment">//跳得超越了之前的maxReach</span></span><br><span class="line">            maxPos= <span class="built_in">max</span>(maxPos,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        curReach=maxReach+<span class="number">1</span>;</span><br><span class="line">        maxReach=maxPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="P29-指针-颜色分类"><a href="#P29-指针-颜色分类" class="headerlink" title="P29 指针 颜色分类"></a>P29 指针 颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>输入</p>
<p>第一行输入一个整数 n (1≤n≤300)<em>n</em> (1≤<em>n</em>≤300) 代表数组的长度。</p>
<p>第二行输入一行数字代表数组 nums[i] 为0，1，2，数字与数字之间用空格间开。</p>
<p>输出</p>
<p>输出排序后的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Problem P29. [算法课指针] 颜色分类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> key[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//检查三种颜色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sortColor</span><span class="params">(<span class="type">int</span> *head,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> *p= <span class="literal">nullptr</span>;<span class="comment">//工作指针</span></span><br><span class="line">    <span class="type">int</span> *edge= head;</span><br><span class="line">    <span class="type">int</span> *hh=head;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//检查head</span></span><br><span class="line">        head=edge;</span><br><span class="line">        p=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*p!=i&amp;&amp;*p!=<span class="number">-1</span>) p++;<span class="comment">//找到颜色头一个</span></span><br><span class="line">        <span class="keyword">if</span>(*p==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        temp=*p;</span><br><span class="line">        *p=*head;</span><br><span class="line">        *head=temp;</span><br><span class="line">        key[i]=<span class="number">1</span>;<span class="comment">//头部解决，建议记录头部索引</span></span><br><span class="line">        edge=head;<span class="comment">//存储颜色族头</span></span><br><span class="line">        head++;</span><br><span class="line">        <span class="keyword">while</span>(*head!= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//进入一个聚类的循环</span></span><br><span class="line"></span><br><span class="line">            p=head;</span><br><span class="line">            <span class="keyword">while</span>(*p!=i&amp;&amp;*p!=<span class="number">-1</span>) &#123;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一个替换</span></span><br><span class="line">            <span class="keyword">if</span>(*p==<span class="number">-1</span>) &#123;</span><br><span class="line">                edge=head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=*p;</span><br><span class="line">            *p=*head;</span><br><span class="line">            *head=temp;</span><br><span class="line">            <span class="comment">//直到越界</span></span><br><span class="line">            head++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">301</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">301</span>;i++) nums[i]=<span class="number">-1</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        nums[i]=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sortColor</span>(nums,n);</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) cout&lt;&lt;nums[i]&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    cout&lt;&lt;nums[n<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Joel</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/')">JJ的算法之旅</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JJ的算法之旅&amp;url=https://jjuprising.github.io/2023/09/17/JJ%E7%9A%84%E7%AE%97%E6%B3%95%E4%B9%8B%E6%97%85/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JJuprising.github.io" target="_blank">Joel Station</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/14/%E5%A4%A7%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大型数据库笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/18/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数字图像处理笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.1.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">1.3.</span> <span class="toc-text">区间DP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">回溯算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E6%8E%92%E5%88%97"><span class="toc-number">2.1.</span> <span class="toc-text">组合和排列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">注意点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SCNUOJ"><span class="toc-number">4.</span> <span class="toc-text">SCNUOJ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#P01-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.1.</span> <span class="toc-text">P01 最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%81P02-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E5%AF%BB%E6%89%BE%E5%A4%9A%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">！P02. [算法课分治] 寻找多数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P03-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C"><span class="toc-number">4.3.</span> <span class="toc-text">P03. [算法课分治] 找到最大子序和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P04-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">P04. [算法课分治] 找到 k 个最小数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P05-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%88%86%E6%B2%BB-%E5%AF%BB%E6%89%BE%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">4.5.</span> <span class="toc-text">P05. [算法课分治] 寻找第 k 个最大元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P06-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%B5%B0%E7%BD%91%E6%A0%BC"><span class="toc-number">4.6.</span> <span class="toc-text">P06. [算法课动态规划]走网格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P07-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">4.7.</span> <span class="toc-text">P07. [算法课动态规划]爬楼梯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P08-%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">P08. [算法课动态规划]背包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P09-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">4.9.</span> <span class="toc-text">P09 最长回文子串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P10-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7"><span class="toc-number">4.10.</span> <span class="toc-text">P10 连续数组最大</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90P11-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">4.11.</span> <span class="toc-text">⭐P11 最长公共子序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P12-%E8%B4%AA%E5%A9%AA-6%E5%92%8C9%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97"><span class="toc-number">4.12.</span> <span class="toc-text">P12 贪婪 6和9组成的最大数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P13-%E8%B4%AA%E5%A9%AA-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF"><span class="toc-number">4.13.</span> <span class="toc-text">P13 贪婪 三角形的最大周长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P14-%E8%9B%AE%E5%8A%9B-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-number">4.14.</span> <span class="toc-text">P14 蛮力 种花问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%97P15-%E8%B4%AA%E5%A9%AA-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97-%E6%9C%89%E4%B8%80%E6%AD%A5%E6%B2%A1%E6%90%9E%E6%87%82"><span class="toc-number">4.15.</span> <span class="toc-text">❗P15 贪婪 移掉K位数字(有一步没搞懂)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P16-%E8%B4%AA%E5%A9%AA-%E7%9B%9B%E6%9C%80%E5%A4%9A%E7%9A%84%E6%B0%B4"><span class="toc-number">4.16.</span> <span class="toc-text">P16 贪婪 盛最多的水</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P17-%E5%9B%9E%E6%BA%AF-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-void-backTracking-int-left-int-right-string-curstr"><span class="toc-number">4.17.</span> <span class="toc-text">P17 回溯 括号生成 void backTracking(int left, int right, string curstr)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P18-%E5%9B%9E%E6%BA%AF-%E7%9B%AE%E6%A0%87%E5%92%8C-void-check-int-nums-int-tar-int-n"><span class="toc-number">4.18.</span> <span class="toc-text">P18 回溯 目标和 void check(int nums[], int tar, int n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P19-%E5%9B%9E%E6%BA%AF-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-void-backtracking-const-string-amp-s-int-index-string-curStr-%E8%BE%93%E5%85%A5%E5%BA%8F%E5%88%97-%E5%BA%8F%E5%88%97%E5%8F%B7-%E5%8F%AF%E8%83%BD%E7%BB%84%E5%90%88"><span class="toc-number">4.19.</span> <span class="toc-text">P19 回溯 电话号码的字母组合 void backtracking(const string&amp; s,int index,string curStr) 输入序列 序列号 可能组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P20-%E5%9B%9E%E6%BA%AF-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-void-backtracking-int-pos-int-n-%E4%BD%8D%E7%BD%AE%E6%95%B0-%E9%95%BF%E5%BA%A6"><span class="toc-number">4.20.</span> <span class="toc-text">P20 回溯 优美的排列 void backtracking(int pos, int n) 位置数 长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P21-%E7%BB%84%E5%90%88-void-backTracking-int-n-int-k-int-startIndex-%E9%95%BF%E5%BA%A6-%E4%B8%AA%E6%95%B0-%E9%81%8D%E5%8E%86%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.21.</span> <span class="toc-text">P21 组合 void backTracking(int n,int k,int startIndex) 长度 个数 遍历位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P22-%E5%9B%9E%E6%BA%AF-%E5%A4%A7%E7%A4%BC%E5%8C%85"><span class="toc-number">4.22.</span> <span class="toc-text">P22 回溯 大礼包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P23-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.23.</span> <span class="toc-text">P23 计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P24-%E8%B4%AA%E5%BF%83-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">4.24.</span> <span class="toc-text">P24 贪心 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P25-%E5%8A%A8%E8%A7%84-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">4.25.</span> <span class="toc-text">P25 动规 整数拆分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P26-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="toc-number">4.26.</span> <span class="toc-text">P26 动态规划 打家劫舍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P27-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%88%B3%E6%B0%94%E7%90%83"><span class="toc-number">4.27.</span> <span class="toc-text">P27 动态规划 戳气球</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P28-%E8%B4%AA%E5%BF%83-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">4.28.</span> <span class="toc-text">P28 贪心 跳跃游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#P29-%E6%8C%87%E9%92%88-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="toc-number">4.29.</span> <span class="toc-text">P29 指针 颜色分类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB-AlexNet/" title="AlexNet">AlexNet</a><time datetime="2024-03-17T16:23:18.534Z" title="发表于 2024-03-18 00:23:18">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/07/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="大数据原理与实践">大数据原理与实践</a><time datetime="2024-03-07T06:09:38.555Z" title="发表于 2024-03-07 14:09:38">2024-03-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/19/%E6%95%B0%E6%A8%A1notes/" title="数模notes">数模notes</a><time datetime="2023-11-18T16:00:00.000Z" title="发表于 2023-11-19 00:00:00">2023-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/30/BCI-MindBrige%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" title="BCI-MindBrige使用手册">BCI-MindBrige使用手册</a><time datetime="2023-10-30T09:09:43.000Z" title="发表于 2023-10-30 17:09:43">2023-10-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/11/latex%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="latex常用命令"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2023/10/17/bGawt1HvRmexfpI.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="latex常用命令"/></a><div class="content"><a class="title" href="/2023/10/11/latex%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="latex常用命令">latex常用命令</a><time datetime="2023-10-11T14:35:28.000Z" title="发表于 2023-10-11 22:35:28">2023-10-11</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="Joel" target="_blank">Joel</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">10</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 0.88rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 0.88rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 0.88rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.88rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>6</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Joel 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>