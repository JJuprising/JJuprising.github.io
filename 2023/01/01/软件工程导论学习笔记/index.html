<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>软件工程导论学习笔记 | Joel Station</title><meta name="keywords" content="笔记"><meta name="author" content="Joel"><meta name="copyright" content="Joel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="作业题能力成熟度模型 软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性  B.使用标准开发过程（或方法论）构建（或集成）系统  C.管理层寻求更主动地应对系统的开发问题  D.连续地监督和改进标准化的系统开发过程 解析：A基本管理属于2可">
<meta property="og:type" content="article">
<meta property="og:title" content="软件工程导论学习笔记">
<meta property="og:url" content="https://jjuprising.github.io/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Joel Station">
<meta property="og:description" content="作业题能力成熟度模型 软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是 A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性  B.使用标准开发过程（或方法论）构建（或集成）系统  C.管理层寻求更主动地应对系统的开发问题  D.连续地监督和改进标准化的系统开发过程 解析：A基本管理属于2可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jjuprising.github.io/images/NoCover.jpg">
<meta property="article:published_time" content="2023-01-01T14:45:01.000Z">
<meta property="article:modified_time" content="2023-01-02T05:01:59.803Z">
<meta property="article:author" content="Joel">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jjuprising.github.io/images/NoCover.jpg"><link rel="shortcut icon" href="/img/jc_favicon2.png"><link rel="canonical" href="https://jjuprising.github.io/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '软件工程导论学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-02 13:01:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jc_avator2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/NoCover.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Joel Station</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程导论学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-01T14:45:01.000Z" title="发表于 2023-01-01 22:45:01">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-02T05:01:59.803Z" title="更新于 2023-01-02 13:01:59">2023-01-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/">本科课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="软件工程导论学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h1><h2 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h2><ul>
<li><p>软件能力成熟度模型（CMM)将软件能力成熟度自低到高依次划分为 5 级。目前， 达到 CMM 第 3 级（已定义级）是许多组织努力的目标，该级的核心是</p>
<p>A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 </p>
<p><u>B.使用标准开发过程（或方法论）构建（或集成）系统</u> </p>
<p>C.管理层寻求更主动地应对系统的开发问题 </p>
<p>D.连续地监督和改进标准化的系统开发过程</p>
<p>解析：A基本管理属于2可重复级；C属于已管理级；D改进属于5优化级；B标准属于3已定义级</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/09/05/QlKeMdZCzwSc4ks.png" alt="image.png"></p>
<ul>
<li><p>软件能力成熟度模型（CMM)的第 4 级（已管理级）的核心是 。 </p>
<p>A.建立基本的项目管理和实践来跟踪项目费用、进度和功能特性 </p>
<p>B.组织具有标准软件过程 </p>
<p>C.对软件过程和产品都有定量的理解和控制 </p>
<p>D.先进的新思想和新技术促进过程不断改进</p>
<p>解析：4已管理级关键词：定量，预测</p>
</li>
</ul>
<h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><ul>
<li><p>为了有效地捕获系统需求，应采用 .</p>
<p>A.瀑布模型 B.V 模型 <u>C.原型模型</u> D.螺旋模型</p>
<p>解析：</p>
<ul>
<li><p>瀑布模型从一种非常高层的角度描述了软件开发过程中进行的活动，并且提出了要求开发人员经过的事件序列。该模型适用于项目<strong>开始时需求已确定</strong>的情况。</p>
</li>
<li><p>V 模型是<strong>瀑布模型的变种</strong>，它说明测试活动是如何与分析和设计相联系的。</p>
</li>
<li><p>原型模型允许开发人员<strong>快速地构造</strong>整个系统或系统的一部分以理解或澄清问题。原型的用途是<strong>获知用户的真正需求</strong>，因此原型模型可以有效地引发系统需求。</p>
</li>
<li><p>螺旋模型把开发活动和<strong>风险管理</strong>结合起来，以将风险减到最小并控制风险。</p>
</li>
<li><p>演化模型在获取<strong>一组基本的需求</strong>后，通过快速分析构造出该软件的一个初始可运行版本，然后逐步演化成为最终软件产品。</p>
</li>
<li><p>增量模型是一种阶段化的软件开发过程模型。在该过程模型中，客户提出系统需求，并指出<strong>哪些需求是最重要的</strong>。开发团队把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成， 并且能完成特定的功能。其优点包括：能<strong>较短时间</strong>内向用户提交可完成一些有用的工作产品；逐步增加产品的功能，使用户有较充裕的时间学习和适应新产品；项目失败的风险较低；优先级最高的服务首先交付，然后依次将其他 构件集成进来，这意味着最重要的服务将接受最多的测试。<strong>快速发布</strong></p>
</li>
<li><p>喷泉模型是典型的<strong>面向对象</strong>生命周期模型，是一种以用户需求为动力，以对象作为驱动的模 型。该模型克服了瀑布模型不支持软件重用和多项开发活动集成的局限性。“喷泉” 一词本 身体现了迭代和无间隙特性。迭代意味着模型中的开发活动常常需要重复多次，在迭代过程 中不断地完善软件系统；无间隙是指在开发活动之间<strong>不存在明显的边界</strong>。</p>
</li>
</ul>
</li>
</ul>
<h2 id="系统工程"><a href="#系统工程" class="headerlink" title="系统工程"></a>系统工程</h2><ul>
<li><p>经济可行性研究的范围包括（ ） </p>
<p>A、技术有效性 B、管理制度 <u>C、效益分析</u> D、开发风险</p>
<p>解析：</p>
<ul>
<li>经济可行性主要进行成本效益分析，从经济角度，确定系统是否值得开发</li>
<li>技术可行性主要根据系统的功能、性能、约束条件等，分析在现有资源和技术条件下系统能否实现</li>
<li>法律可行性合同责任、侵犯专利权、版权等问题</li>
</ul>
</li>
<li><p>（多选题）在对协同电子商务平台项目进行技术可行性分析的过程中需要注意哪些方面？ （ ） </p>
<p><u>A、在限制条件下，功能目标是否能达到</u></p>
<p><u>B、利用现有技术，性能目标是否能够达到</u> </p>
<p><u>C、对开发人员数量和质量的要求，并说明能否满足</u> </p>
<p><u>D、在规定的期限内，开发是否能够完成</u></p>
<p>解析：根据软件设计文档国家标准（GB8567-2006）的要求，技术可行性章节应该主要包含 以下内容： </p>
<p>1.在当前的限制条件下，该系统的功能目标能否达到 </p>
<p>2.利用现有的技术，该系统的功能能否实现 </p>
<p>3.对开发人员的数量和质量的要求，并说明这些要求能否满足 </p>
<p>4.在规定的期限内，本系统的开发能否完成 除了上述内容之外，技术可行性部分应该对当前开发所使用的主流研发框架和架构做简要的 介绍和说明，不限于图表和文字等方式。</p>
</li>
<li><p>为了分析顾客不同情况下的订票习惯，可采用以下哪种需求获取方式（ ）</p>
<p>A、正式访谈 B、非正式访谈 C、调查表 <u>D、观察实践</u></p>
<p>解析：错选C，使用观察实践，情景分析获取用户在不同场景下的不同需求。</p>
</li>
</ul>
<h2 id="结构化方法和数据流图"><a href="#结构化方法和数据流图" class="headerlink" title="结构化方法和数据流图"></a>结构化方法和数据流图</h2><ul>
<li>面向数据流自顶向下求精过程不包括</li>
</ul>
<p>A、分析追踪数据流图</p>
<p>B、用户复查</p>
<p>C、细化数据流图</p>
<p>D、实现数据流图</p>
<h1 id="软件工程与软件过程"><a href="#软件工程与软件过程" class="headerlink" title="软件工程与软件过程"></a>软件工程与软件过程</h1><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p><strong>软件&#x3D;程序+数据+文档</strong></p>
<h3 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h3><ul>
<li>计算机软件是指计算机系统中的程序及其文档</li>
<li>程序是计算任务的处理对象和处理规则的描述</li>
<li>文档是为了便于了解程序所需的阐明性资料</li>
</ul>
<h3 id="软件的特点"><a href="#软件的特点" class="headerlink" title="软件的特点"></a>软件的特点</h3><ul>
<li>软件是一种逻辑实体，而不是有形的系统元件，其开发成本和进度难以准确地估算</li>
<li>软件是被开发或被设计的，没有明确的制造过程，一旦开发成功，只需复制即可，但其维护的工作量大</li>
<li>软件的使用没有硬件那样的机械磨损和老化问题</li>
<li>软件不能独立存在，需要依附于一定的环境(如硬件、网络以及其他软件等)</li>
<li>软件必须遵从人为的惯例，并适应已有的技术和系统。</li>
<li>软件需要随接口的不同而改变</li>
</ul>
<h3 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h3><p>有多种分类方法。</p>
<ul>
<li>基础设施类<ul>
<li>系统软件</li>
<li>支持软件</li>
</ul>
</li>
<li>应用类<ul>
<li>应用软件</li>
</ul>
</li>
</ul>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><p><strong>软件工程学科出现的主要原因是软件危机的出现</strong></p>
<h3 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h3><ul>
<li>一个合格的软件开发是按时按量按质实现软件</li>
<li>许多软件项目不能满足客户的要求</li>
<li>许多软件项目超出预算和时间安排</li>
</ul>
<p><img src="https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png" alt="image.png"></p>
<h3 id="软件工程的定义"><a href="#软件工程的定义" class="headerlink" title="软件工程的定义"></a>软件工程的定义</h3><p><strong>1968年NATO(北大西洋公约组织)会议上首次提出</strong></p>
<p><strong>计算机科学技术百科全书</strong>：软件工程是应用计算机 科学、数学及管理科学等原理，开发软件的工程。 软件工程借鉴传统工程的原则、方法，以提高质量、 降低成本为目的</p>
<h3 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h3><p>软件有一个孕育、诞生、成长、成熟、衰亡的生存过程。这个过程即为计算机<strong>软件的生存周期</strong></p>
<p>软件生存周期大体可分为如下几个活动：</p>
<pre class="mermaid">graph LR
A(计算机系统工程) ---B(需求分析)

    B --- C(设计)
    C ---D(编码)
    D---E(测试)
    E---F(运行)
    F---G(维护)</pre>



<h1 id="软件过程模型-8种"><a href="#软件过程模型-8种" class="headerlink" title="软件过程模型(8种)"></a>软件过程模型(8种)</h1><p><img src="https://s2.loli.net/2022/09/05/zkxCEQYegBRqwyO.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/09/05/tpu6mjN18L3hBvf.png" alt="image.png"></p>
<h2 id="能力成熟度模型-1"><a href="#能力成熟度模型-1" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h2><h3 id="能力成熟度模型CMM"><a href="#能力成熟度模型CMM" class="headerlink" title="能力成熟度模型CMM"></a>能力成熟度模型CMM</h3><p>原本是评估依据，后来用于改进软件管理过程</p>
<p><img src="https://s2.loli.net/2022/09/05/QlKeMdZCzwSc4ks.png" alt="image.png"></p>
<h3 id="能力成熟度模型集成CMMI"><a href="#能力成熟度模型集成CMMI" class="headerlink" title="能力成熟度模型集成CMMI"></a>能力成熟度模型集成CMMI</h3><h4 id="阶段式模型-整体能力的划分"><a href="#阶段式模型-整体能力的划分" class="headerlink" title="阶段式模型 (整体能力的划分)"></a>阶段式模型 (整体能力的划分)</h4><p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905211312772.png" alt="image-20220905211312772"></p>
<h4 id="连续式模型-某方面能力的衡量"><a href="#连续式模型-某方面能力的衡量" class="headerlink" title="连续式模型(某方面能力的衡量)"></a>连续式模型(某方面能力的衡量)</h4><p><img src="/../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220905211353252.png" alt="image-20220905211353252"></p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905211407538.png" alt="image-20220905211407538"></p>
<h2 id="软件过程模型-1"><a href="#软件过程模型-1" class="headerlink" title="软件过程模型"></a>软件过程模型</h2><table>
<thead>
<tr>
<th>软件过程模型</th>
<th>瀑布模型</th>
<th>增量模型</th>
<th>原型模型</th>
<th>螺旋模型</th>
<th>喷泉模型</th>
<th>基于构件的开发模型</th>
<th>形式化方法</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td></td>
<td>首先有完成核心基本需求，再逐步确定非核心；多个增量可叠加</td>
<td>反映系统性质的一个子集</td>
<td>风险驱动的软件过程模型，把开发活动和<strong>风险管理</strong>结合起来，以将风险减到最小并控制风险</td>
<td>基于面向对象思想、迭代、无间隙。模型各个阶段没有明显界限，开发人员同步进行开发</td>
<td>利用预先包装的构件来构造应用系统</td>
<td>是建立在 <strong>严格数学基础</strong>上。开发过程重凡是采用严格 的数学语言，具有精确的数学语义的方法，都称为形 式化方法</td>
</tr>
<tr>
<td>适用场景</td>
<td>项目开始前需求和解决方案就很明确，短期或中期项目</td>
<td>不完全明确但知道核心需求，急需使用的软件，需求经常变化</td>
<td>要从用户身上了解主要需求，周期是一个环型，可废弃上一个原型或在其基础上追加</td>
<td></td>
<td>适应于面向对象的软件开发过程，以对象为驱动，只用对象和关系实现活动的迭代和无间隙</td>
<td>构件化结构，可以尽量重用已有的组件。</td>
<td>对安全性、可靠性极高</td>
</tr>
<tr>
<td>优缺点</td>
<td>缺：缺乏灵活性、维护代价大</td>
<td>各增量构件均为一个可操作产品。融合了瀑布模 型的基本成分（重复地应用）和演化模型的迭代特征，特别适用于<strong>需求经常发生变化</strong>的软件开发。</td>
<td>用户需要方面，重交互。缩短了开发周期，加快了工程进 度，降低成本。</td>
<td>将原型实现的<strong>迭代特征</strong>与瀑布模型中<strong>控制的</strong>和<strong>系统化的</strong>方面结合起来， 不仅体现了这两种模型的优点，而且增加了<strong>风险分析</strong></td>
<td>可以提高软件 项目开发效率，节省开发时间</td>
<td>减少开发、降低风险和成本、需求妥协、快速交付</td>
<td>易于发现需求的歧义性、不完整性和不一致性，易于对分析模型、 设计模型和程序进行验证。</td>
</tr>
</tbody></table>
<h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p><strong>项目需求方案明确，短期小型工程</strong></p>
<p>从下到上很难，不适用需求经常换的</p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905211552135.png" alt="image-20220905211552135"></p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905211651996.png" alt="image-20220905211651996"></p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905211703289.png" alt="image-20220905211703289"></p>
<h3 id="演化模型"><a href="#演化模型" class="headerlink" title="演化模型"></a>演化模型</h3><p>开发早期对软件需求的认识是模糊的、不确定的，因此软件很难一次开发成功。逐步演化而来</p>
<p><strong>开发的软件，需求不能一次搞清楚</strong>，且系统需求比较复杂？</p>
<p>答案：用演化模型</p>
<pre class="mermaid">graph LR
A{演化模型}-->B(增量模型)
A-->C(原型模型)
A-->D(螺旋模型)</pre>

<h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h4><p><strong>每次增量都可用</strong>，有核心需求，急需使用的软件。多个增量可重叠</p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905212334175.png" alt="image-20220905212334175"></p>
<ul>
<li>适用于<strong>需求经常发生变化</strong>的软件开发</li>
<li>第一个增量<strong>通常是核心产品</strong></li>
</ul>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905212549792.png" alt="image-20220905212549792"></p>
<h4 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h4><p><strong>原型</strong>（prototype）是预期系统的一个可执行版本，反映 了系统性质（如功能、计算结果等）的一个选定的子集。</p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905212656390.png" alt="image-20220905212656390"></p>
<p><strong>特点：</strong></p>
<ul>
<li>用户不能完全准确表达对未来系统的全面要求</li>
<li>开发者对要解决的问题的应用问题模糊不清</li>
<li>一圈出来一个版本</li>
</ul>
<p><strong>类型：</strong></p>
<ul>
<li>探索型</li>
<li>实验型</li>
<li>演化型</li>
</ul>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905212802183.png" alt="image-20220905212802183"></p>
<h4 id="增量模型和原型模型的区别"><a href="#增量模型和原型模型的区别" class="headerlink" title="增量模型和原型模型的区别"></a>增量模型和原型模型的区别</h4><p>核心都是迭代，但增量模型强调<strong>各增量构建均是一个可操作产品</strong>。原型模型不断讨论修改完善。</p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905212909013.png" alt="image-20220905212909013"></p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905213105101.png" alt="image-20220905213105101"></p>
<h4 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h4><ul>
<li>有风险机制</li>
</ul>
<p><img src="https://jjuprising.github.io/images/SE_Note//image-20220905213228769.png" alt="image-20220905213228769"></p>
<p><img src="https://jjuprising.github.io/images/SE_Note/image-20220905213239716.png" alt="image-20220905213239716"></p>
<p><img src="/../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220905213315281.png" alt="image-20220905213315281"></p>
<h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><ul>
<li>像喷泉从下往上，后面的工作在做前面的也没停止</li>
<li><strong>基于面向对象思想</strong>，迭代、无间隙</li>
</ul>
<blockquote>
<p>注意，面向对象不是喷泉独有的，其他一些模型也有</p>
</blockquote>
<h3 id="基于构件的开发模型"><a href="#基于构件的开发模型" class="headerlink" title="基于构件的开发模型"></a>基于构件的开发模型</h3><p><img src="https://s2.loli.net/2023/01/01/J6ESlVFpTYn2toH.png" alt="image-20220905213500212.png"></p>
<p><img src="https://s2.loli.net/2023/01/01/E5jG9oyJmnvCDQP.png" alt="image-20220905213513555.png"></p>
<h3 id="形式化模型"><a href="#形式化模型" class="headerlink" title="形式化模型"></a>形式化模型</h3><p><strong>建立在严格数学基础上</strong></p>
<p><img src="https://s2.loli.net/2023/01/01/xLlysfnHRP4CeU2.png" alt="image-20220905213521544.png"></p>
<h2 id="CASE工具和环境的重要性"><a href="#CASE工具和环境的重要性" class="headerlink" title="CASE工具和环境的重要性"></a>CASE工具和环境的重要性</h2><p>CASE 已被证明可以<strong>加快开发速度</strong>,提高应用软件生产率并保证应用软件的可靠品质。计算机专业人员利用计算机使他们的企业提高了<strong>效率</strong>,企业的各个部门通过使用计算机 <strong>提高了生产率和效率</strong>,增强了企业的竞争力并使之<strong>带来了更多的利润</strong>。</p>
<h1 id="系统工程-1"><a href="#系统工程-1" class="headerlink" title="系统工程"></a>系统工程</h1><h2 id="系统工程的任务"><a href="#系统工程的任务" class="headerlink" title="系统工程的任务"></a>系统工程的任务</h2><ol>
<li><p>识别用户的要求</p>
<ul>
<li>识别基于计算机系统的整体要求</li>
<li>标识系统的功能和性能范围</li>
<li>确定系统的功能、性能、约束和接口</li>
</ul>
</li>
<li><p>系统建模和模拟</p>
<p>考虑以下模型：</p>
<ul>
<li>硬件系统模型</li>
<li>软件系统模型</li>
<li>人机接口模型</li>
<li>数据模型</li>
</ul>
</li>
<li><p>成本估算及进度安排</p>
<p>需要一定的资金投入和时间约束</p>
<ul>
<li>进行成本估算</li>
<li>作出进度安排</li>
</ul>
</li>
<li><p>可行性分析</p>
<p>主要从<strong>经济</strong>、<strong>技术</strong>、<strong>法律</strong>等方面分析所给出的解决方案是否科学。</p>
</li>
<li><p>生成系统规格说明</p>
<p>作为以后开发基于计算机的系统的依据</p>
</li>
</ol>
<h2 id="可行性分析的任务"><a href="#可行性分析的任务" class="headerlink" title="可行性分析的任务"></a>可行性分析的任务</h2><ol>
<li>经济可行性：确定系统是否值得开发<ul>
<li>成本</li>
<li>效益</li>
<li>货币的时间价值</li>
<li>投资的回收期</li>
<li>纯收入</li>
</ul>
</li>
<li>技术可行性：分析系统在现有资源和条件下能否实现<ul>
<li>风险分析</li>
<li>资源分析</li>
<li>技术分析</li>
</ul>
</li>
<li>法律可行性：是否引起侵权、破坏等责任问题</li>
<li>方法的选择和折衷</li>
</ol>
<h1 id="需求工程"><a href="#需求工程" class="headerlink" title="需求工程"></a>需求工程</h1><h2 id="需求工程的具体步骤和任务"><a href="#需求工程的具体步骤和任务" class="headerlink" title="需求工程的具体步骤和任务"></a>需求工程的具体步骤和任务</h2><ol>
<li><p>需求获取</p>
<ul>
<li><p>系统分析人员通过与用户的交流</p>
</li>
<li><p>对现有系统的观察及时对任务进行分析</p>
</li>
</ul>
</li>
<li><p>需求分析与协商：</p>
<ul>
<li>分析每个需求与其他需求的关系以检查需求的一致性、重叠和遗漏的情况</li>
<li>并根据用户的需求对需求进行排序</li>
</ul>
</li>
<li><p>系统建模</p>
<p>通过合适的工具和符号系统地描述需求</p>
</li>
<li><p>需求规约</p>
<p>给出对目标软件的各种需求</p>
</li>
<li><p>需求验证</p>
<p>对功能的正确性、完整性和清晰性以及其他需求给予评价</p>
</li>
<li><p>需求管理</p>
<p>对需求工程所有相关活动的规约和控制</p>
</li>
</ol>
<h2 id="制定需求获取策略主要考虑因素"><a href="#制定需求获取策略主要考虑因素" class="headerlink" title="制定需求获取策略主要考虑因素"></a>制定需求获取策略主要考虑因素</h2><ol>
<li><p>功能需求</p>
<ul>
<li>考虑系统要做什么，在何时做</li>
<li>在合适及如何修改或升级</li>
</ul>
</li>
<li><p>性能需求</p>
<p>考虑软件开发的技术性指标</p>
</li>
<li><p>用户或人为因素</p>
<p>考虑用户的类型</p>
</li>
</ol>
<h2 id="需求获取的方法和策略"><a href="#需求获取的方法和策略" class="headerlink" title="需求获取的方法和策略"></a>需求获取的方法和策略</h2><ul>
<li>建立顺畅的通信途径</li>
<li>访谈与调查</li>
<li>亲身实践</li>
<li>会议</li>
<li>头脑风暴</li>
<li>概念建模</li>
<li>原型、仿真</li>
<li>自省</li>
<li>用户行为数据在线采集</li>
</ul>
<h1 id="设计工程"><a href="#设计工程" class="headerlink" title="设计工程"></a>设计工程</h1><h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><p><img src="https://s2.loli.net/2022/10/10/davFu8RwlArpiVI.png" alt="image.png"></p>
<h3 id="抽象与逐步求精"><a href="#抽象与逐步求精" class="headerlink" title="抽象与逐步求精"></a>抽象与逐步求精</h3><p>抽象</p>
<ul>
<li>在最高层用术语概括性描述</li>
<li>在中间层次用面向过程化方法</li>
<li>在最低层用直接实现的方式</li>
</ul>
<p>抽象：忽略一个问题中与当前目标无关的那些方面，以便更充分地关注与当前目标有关的方面</p>
<p>分解：将问题不断分解为较小的问题，直到每个最底层的问题都足够简单为止</p>
<p>随着分解层次的增加，抽象的级别越来越低，也越接近问题的解(算法和数据结构)</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化：就是把程序划分成<strong>独立命名</strong>且<strong>可独立访问</strong>的模块，<u>每个模块完成一个子功能</u>，把这些模块集成起来构成 一个整体，可以完成指定的功能满足用户的需求。</p>
<p>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</p>
<p>“分而治之”</p>
<p>问：程序采用模块化设计，有哪些优点？</p>
<p>答：程序采用模块化设计，有以下优点：</p>
<ul>
<li><p>将问题<strong>简化</strong>，划分模块可使每一个模块完成单一的功能， 模块之间的联接<strong>关系简单，具有独立性</strong>；</p>
</li>
<li><p>可以独立的进行模块的编码测试，<strong>便于</strong>软件开发工作的<strong>组织</strong>； </p>
</li>
<li><p>把每一个模块要解决的问题局限在有限的范围，减少出错 机会，易于修改和维护； </p>
</li>
<li><p>有助于软件项目的组织管理，一个复杂的大型软件可以由许多程序员分工编写，提高了开发效率；</p>
</li>
<li><p>一个模块可被重复使用，以提高软件产品的复用率；</p>
</li>
<li><p>利于估计工作量和开发成本。</p>
</li>
</ul>
<h3 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h3><p>David Parnas在1972年最早提出信息隐藏的观点。 他在其论文中指出：代码模块应该采用定义<strong>良好的接口来封装</strong>，这些模块的内部结构应该是程序员的<u>私有财产</u>，<strong>外部是不可见的</strong>。</p>
<p><img src="https://s2.loli.net/2022/10/10/9nd6RIPijVxOTJB.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/10/VrDELpCFW39o8qu.png" alt="image.png"></p>
<h3 id="功能独立"><a href="#功能独立" class="headerlink" title="功能独立"></a>功能独立</h3><p><strong>功能独立</strong>：功能独立是模块化、抽象、信息隐藏和局部化等概念的直接结果。</p>
<p>两个定性标准:</p>
<ul>
<li><strong>内聚</strong>衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高， 每个模块完成一个相对独立的特定子功能。</li>
<li><strong>耦合</strong>衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低， 即每个模块和其他模块之间的关系要简单。</li>
</ul>
<h4 id="内聚"><a href="#内聚" class="headerlink" title="内聚"></a>内聚</h4><p>紧密程度</p>
<p><img src="https://s2.loli.net/2022/10/10/jaSGfgXEFWDPJ8c.png" alt="image.png"></p>
<p><strong>逻辑内聚</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/nF8tCzcJSG13lwj.png" alt="image.png"></p>
<p><strong>时间内聚</strong>：初始化</p>
<p><img src="https://s2.loli.net/2022/10/10/5FKcoBhSNVbADPi.png" alt="image.png"></p>
<p><strong>过程内聚</strong>：按任务的顺序</p>
<p><img src="https://s2.loli.net/2022/10/10/kwQKtarTVlUfO6b.png" alt="image.png"></p>
<p><strong>通信内聚：</strong>模块的功能都要做，但数据集都是同一个(和逻辑内聚区分)</p>
<p><img src="https://s2.loli.net/2022/10/10/fFGLyZwlS1DzPH6.png" alt="image.png"></p>
<p><strong>顺序内聚</strong>：既要按任务的顺序，一个的输出要作为另一个的输入</p>
<p><img src="https://s2.loli.net/2022/10/10/lqcG8YRELWIj2B6.png" alt="image.png"></p>
<p><strong>功能内聚：</strong>只完成一项工作</p>
<p><img src="https://s2.loli.net/2022/10/10/u7xpYin3QfP6vrw.png" alt="image.png"></p>
<blockquote>
<p>通信内聚和逻辑内聚区分：前者数据集都是同一个，但是逻辑内聚也可以同一个数据集，这时看是否有传入参数来决定执行的操作。</p>
</blockquote>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>相互依赖程度</p>
<p><img src="https://s2.loli.net/2022/10/10/muHznSwG4AUZh9D.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/10/4RskMoqDwX1IZBl.png" alt="image.png"></p>
<p><strong>内容耦合</strong></p>
<p><img src="/../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221010112727856.png" alt="image-20221010112727856"></p>
<p><strong>公共耦合</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/gp8JmvDkSNWCjKt.png" alt="image.png"></p>
<p><strong>外部耦合</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/ihCr2TUudtngO5p.png" alt="image.png"></p>
<p><strong>控制耦合</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/d27ZoUByTLlGgpH.png" alt="image.png"></p>
<p><strong>标记耦合</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/j4zUNOKLHdBc3b8.png" alt="image.png"></p>
<p><strong>数据耦合</strong></p>
<p>例如中途调用的函数</p>
<p><img src="https://s2.loli.net/2022/10/10/7rn6oSjt13lwFNY.png" alt="image.png"></p>
<p><strong>非直接耦合</strong></p>
<p><img src="https://s2.loli.net/2022/10/10/k5Wa8xEfKgqIe4O.png" alt="image.png"></p>
<blockquote>
<p>标记耦合传的是数据结构的一部分，如数组、字符串等，而数据耦合传的是简单数据</p>
</blockquote>
<p><strong>高内聚，低耦合</strong></p>
<h1 id="结构化程序设计方法"><a href="#结构化程序设计方法" class="headerlink" title="结构化程序设计方法"></a>结构化程序设计方法</h1><p>详细描述处理过程常用工具：图形、表格和语言</p>
<ul>
<li><strong>图形</strong>：程序流程图、N-S图、PAD图</li>
<li><strong>表格：</strong>判定表</li>
<li><strong>语言：</strong>过程设计语言(PDL)</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/PEJ5udxMpYl3LFQ.png" alt="image-20221222113658687.png"></p>
<h2 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h2><ul>
<li><strong>结构化方法</strong>：它以<strong>数据流</strong>为中心构建软件的分析模型和设计模型</li>
<li><strong>结构化分析与建模：</strong>主要思想：<strong>抽象</strong>与自顶向下的<strong>逐层分解</strong>（控制复杂性的两个基本手段）</li>
<li><strong>抽象</strong>：<u>忽略</u>一个问题中与当前目标<u>无关</u>的那些方面，以便更<u>充分地关注</u>与当前目标<u>有关</u>的方面。</li>
<li><strong>分解</strong>：将问题<u>不断分解为较小的问题</u>，直到每个最底层的问题都足够简单为止。</li>
<li>结构化系统分析模型组成结构有：<ul>
<li>E-R图</li>
<li>数据流图(DFD)</li>
<li>状态变迁图(STD图)</li>
<li>数据字典(DD)</li>
</ul>
</li>
</ul>
<h2 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h2><p>主要思想：数据流图描述<strong>输入数据流到输出数据流的变换（即加工）</strong>，用于对系统的<strong>功能建模</strong>。</p>
<p>符号：</p>
<ul>
<li>⚪或椭圆 表示加工，也叫数据处理</li>
<li>▭ 矩形表示数据流的源点或终点，统称外部实体</li>
<li>＝ 双杠，文件或数据存储</li>
<li>→ 箭头表示数据流</li>
</ul>
<p>使用数据流图进行需求分析的过程： </p>
<ol>
<li><p>画出<strong>系统的输入和输出</strong>。 </p>
<p>A. 确定源和宿 </p>
<p>B. 确定加工 </p>
<p>C. 确定数据流 :输入数据流，输出数据流</p>
<p>D. 顶层图通常没有文件</p>
</li>
<li><p>画出<strong>系统内部</strong>。 </p>
<p>A. 确定加工 ：确定父图中某加工分解而成的子加工</p>
<p>B. 确定数据流 ：沿用或新增</p>
<p>C. 确定文件 </p>
<p>D. 确定源和宿 </p>
</li>
<li><p>画出<strong>加工内部</strong>。 </p>
</li>
<li><p><strong>重复第 3 步</strong>，直至每个尚未分解的加工都足够简单（即不必再分解）。</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/10/17/e2A5DEB9hJbNQSd.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/17/iJW7DaF1Vecdp98.jpg" alt="1f10dc03d569bb00e848cdecb12578d.jpg"></p>
<h3 id="画顶层图"><a href="#画顶层图" class="headerlink" title="画顶层图"></a>画顶层图</h3><ul>
<li>顶层图有唯一的<strong>加工</strong>：<strong>椭圆</strong>表示</li>
<li>系统之外的源或宿(<strong>外部实体</strong>)：<strong>矩形</strong>表示</li>
</ul>
<p><img src="https://s2.loli.net/2022/10/17/mbPQCDagNr3YwsA.png" alt="image.png"></p>
<p>步骤：</p>
<ul>
<li>确定唯一加工</li>
<li>确定功能需求和外部实体(源或宿)</li>
<li>确定数据流：系统的输入&#x2F;输出信息</li>
</ul>
<h3 id="画0层图"><a href="#画0层图" class="headerlink" title="画0层图"></a>画0层图</h3><p>步骤：</p>
<ul>
<li><p>确定加工：确定父图中某加工分解而成的子加工</p>
<ul>
<li>根据功能分解来确定加工：将一个复杂的功能分解成若干个较小的功能，较多应用于高层DFD中的分解</li>
</ul>
<p><img src="https://s2.loli.net/2022/10/17/x6VMIClHh4kjSva.png" alt="image.png"></p>
</li>
<li><p>确定源和宿</p>
<p><img src="https://s2.loli.net/2022/10/17/pSnGTO9XbVtL7aK.png" alt="image.png"></p>
</li>
<li><p>确定数据流</p>
<ul>
<li>沿用父图</li>
<li>新增数据流</li>
</ul>
</li>
</ul>
<p>​    <img src="https://s2.loli.net/2022/10/17/VDchlKxzmu61bjU.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/10/17/gYoK9xfAPbw4HBm.png" alt="image.png"></p>
<ul>
<li>确定文件<ul>
<li>已有文件则应画在子图中</li>
<li>分解子图中，若需要保存某些<strong>中间数据</strong>以备后用，则可以讲这些数据<strong>组成一个新的文件</strong></li>
<li>新文件<strong>至少</strong>应有<strong>一个加工</strong>为其<strong>写入</strong>记录，同时至少存在<strong>另一个加工</strong>来<strong>读</strong>该文件。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/10/17/4C1gEOSxVMWvBdw.png" alt="image.png"></p>
<h3 id="画1层图-画加工内部"><a href="#画1层图-画加工内部" class="headerlink" title="画1层图(画加工内部)"></a>画1层图(画加工内部)</h3><p>复杂的加工可以继续分解为一张DFD子图</p>
<p>分解方法：</p>
<ol>
<li>指定图中的某一个加工看作一个小系统，系统的输入输出流就是这个加工的输入输出流</li>
<li>然后采用画0层图的方法，画出该加工的子图</li>
</ol>
<ul>
<li><p>加工1子图内部，即考试报名内部</p>
<p><img src="https://s2.loli.net/2022/10/17/QAyS8zXP56MdBFv.png" alt="image.png"></p>
</li>
<li><p>加工2子图，即统计成绩</p>
<p><img src="https://s2.loli.net/2022/10/17/LXCn9rv8dRhwF4O.png" alt="image.png"></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>画分层数据流图的步骤：</p>
<ol>
<li>画系统的输入和输出 </li>
<li>画系统内部 </li>
<li>画加工内部 </li>
<li>重复第3步，直至每个尚未分解的加工都足够简单 (即不必再分解)</li>
</ol>
<p><strong>注意：</strong>千万不要试图在数据流图中表现分支条件或循环，这样会造 成混乱，画不出正确的数据流图。</p>
<p>检查分层细化时是否保持信息的连续性，即当把一个处理分解成一 系列处理时，<strong>分解前和分解后的一系列输入输出数据流必须相同</strong>， 这条规则也成为数据流图的数据平衡原则。</p>
<h3 id="审查"><a href="#审查" class="headerlink" title="审查"></a>审查</h3><p>完整性：</p>
<ul>
<li>每个加工至少有一个输入数据流和一个输出数据流</li>
<li>分层数据流图，每个文件应至少有一个加工读取该文件，有另一个加工写该文件</li>
<li>画的是数据流而不是控制流</li>
</ul>
<h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><h3 id="判定表"><a href="#判定表" class="headerlink" title="判定表"></a>判定表</h3><p>确定四个区域的内容</p>
<p><img src="https://s2.loli.net/2022/10/24/JSYHGaeViP3xkpq.png" alt="image.png"></p>
<p>简化标准：</p>
<ul>
<li>具有相同的操作</li>
<li>有且仅有一个不同的取值，简化后用小横杠表示，如本题简化后第四列第一个</li>
</ul>
<h3 id="判定树"><a href="#判定树" class="headerlink" title="判定树"></a>判定树</h3><p><img src="https://s2.loli.net/2022/10/24/u4pPRwCJdNif8H2.png" alt="image.png"></p>
<ul>
<li>根节点是加工过</li>
<li>最右边是具体的部分</li>
<li>中间的部分都是影响条件</li>
</ul>
<h2 id="模块结构图"><a href="#模块结构图" class="headerlink" title="模块结构图"></a>模块结构图</h2><p><img src="https://s2.loli.net/2022/10/24/mUgcPKGrYQ1HZxN.png" alt="image-20221024114704451.png"></p>
<p><strong>注意：</strong></p>
<ul>
<li>模块之间相连的线段(调用)是没有方向的，有方向的是数据流</li>
</ul>
<h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>基本成分：模块，调用，数据</p>
<p>类树形结构</p>
<p><img src="https://s2.loli.net/2022/10/24/exKtDhSZQsT49EO.png" alt="image.png"></p>
<ul>
<li>扇入是别人调用他的个数</li>
<li>扇出是他调用别人的个数</li>
</ul>
<h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><ul>
<li>深度和宽度在一定程度上反映了程序的规模和复杂程度</li>
<li>一个模块的扇出过大通常意味着该模块<strong>比较复杂</strong>，然而扇出太少可能导致深度增加</li>
<li>一个模块的扇入表示有多少模块可直接调用它，它反映了该模块的<strong>复用程度</strong>，因此模块的扇入越大越好</li>
</ul>
<h1 id="面向数据结构的分析与设计"><a href="#面向数据结构的分析与设计" class="headerlink" title="面向数据结构的分析与设计"></a>面向数据结构的分析与设计</h1><h2 id="什么是面向数据结构的方法"><a href="#什么是面向数据结构的方法" class="headerlink" title="什么是面向数据结构的方法"></a>什么是面向数据结构的方法</h2><h3 id="面向数据结构的方法是"><a href="#面向数据结构的方法是" class="headerlink" title="面向数据结构的方法是"></a>面向数据结构的方法是</h3><p>·    以数据结构为中心</p>
<p>·    从输入&#x2F;输出的数据结构导出程序结构的</p>
<p>·    一种软件需求分析与设计的方法</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>·    ①以信息对象及其操作作为核心进行需求分析</p>
<p>·    ②认为复合信息对象具有层次结构，并且可按顺序、选择、重复3种结构分解为成员对象信息</p>
<p>·    ③提供由层次信息结构映射为程序结构的机制，从而为软件设计奠定良好的基础</p>
<h2 id="Jackson图的三种结构"><a href="#Jackson图的三种结构" class="headerlink" title="Jackson图的三种结构"></a>Jackson图的三种结构</h2><h3 id="顺序元素"><a href="#顺序元素" class="headerlink" title="顺序元素"></a>顺序元素</h3><p><img src="https://s2.loli.net/2023/01/02/1yQb58xAS4MXKJF.jpg" alt="clip_image002-16726347926341.jpg"></p>
<h3 id="1-1-1-选择元素"><a href="#1-1-1-选择元素" class="headerlink" title="1.1.1.   选择元素"></a>1.1.1.   选择元素</h3><p><img src="https://s2.loli.net/2023/01/02/njSyKTiwJHlGs9c.jpg" alt="clip_image004.jpg"></p>
<h3 id="1-1-2-重复元素"><a href="#1-1-2-重复元素" class="headerlink" title="1.1.2.   重复元素"></a>1.1.2.   重复元素</h3><p><img src="https://s2.loli.net/2023/01/02/XGRIbx8d6tNSjDa.jpg" alt="clip_image006.jpg"></p>
<h1 id="面向对象方法基础"><a href="#面向对象方法基础" class="headerlink" title="面向对象方法基础"></a>面向对象方法基础</h1><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://s2.loli.net/2022/11/07/KW6VSTxIouspc1M.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/11/07/KW6VSTxIouspc1M.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/11/07/42SDw59mAWZMY8Q.png" alt="image.png"></p>
<p><img src="https://s2.loli.net/2022/11/07/mzcuO8wNeVX4Sja.png" alt="image.png"></p>
<h3 id="UML语言中的关系"><a href="#UML语言中的关系" class="headerlink" title="UML语言中的关系"></a>UML语言中的关系</h3><p>·    关联</p>
<p>·    依赖</p>
<p>·    泛化</p>
<p>·    实现</p>
<p>·    聚合</p>
<p>·    组合</p>
<h3 id="UML包含的视图-红色为已学"><a href="#UML包含的视图-红色为已学" class="headerlink" title="UML包含的视图(红色为已学)"></a>UML包含的视图(红色为已学)</h3><h4 id="结构化"><a href="#结构化" class="headerlink" title="结构化"></a>结构化</h4><h5 id="静态视图"><a href="#静态视图" class="headerlink" title="静态视图"></a>静态视图</h5><p>•  类图(class)</p>
<p>•   展示类与类之间的相互联系，如关联、依赖、泛化等。可以把若干个相关类包装在一起作为一个单元(包)，相当于一个子系统。。</p>
<p>•   一个系统可以有多张类图，一个类也可以出现在几张类图中</p>
<p>•   对象图是类的实例。区分：对象图在对象名下面加了下划线，同时显示对象间的实例连结关系</p>
<p>•   类</p>
<p>•   类间关系</p>
<p>•   四种</p>
<p>•   依赖</p>
<p>•   —&gt; 被依赖元素的变化会要求或指示依赖元素的改变(例如类A的方法仅仅使用了类B的对象，那么类A依赖于类B)</p>
<p>•   访问</p>
<p>•   绑定</p>
<p>•   调用</p>
<p>•   创建</p>
<p>•   派生</p>
<p>•   实例化</p>
<p>•   允许</p>
<p>•   实现</p>
<p>•   精化</p>
<p>•   发送</p>
<p>•   使用</p>
<p>•   关联(聚集、组合)</p>
<p>•   对象与其他实例的连接</p>
<p>•   聚集 ——♢ “部分”对象可以是任意整体对象的一部分</p>
<p>•   组合 ——◆ 更强形式的关联，具有强的物主身份，即“整体”对象拥有“部分”对象(例如类A的部分是由类B的对象组成，并且类A控制类B的生命周期，那么类A与类B是组合关系)</p>
<p>•   是一种拥有的关系，它使一个类知道另一個类的属性和方法；如：老师与学生，丈夫与妻子的关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者沒有箭头，单向的关联有一个箭头。</p>
<p>•   泛化 —▷ 继承，由子类指向父类</p>
<p>•   实现 —▷ 类连接到接口，接口是行为规划而不是结构</p>
<p>•   强度：依赖&lt;关联&lt;聚集&lt;组合&lt;泛化&#x3D;实现，类间关系依次增强</p>
<p>属性和操作</p>
<p>•   属性中的变量名要小写</p>
<p>主要版型</p>
<p>•   边界类</p>
<p>•   控制类</p>
<p>•   实体类</p>
<p>设计视图</p>
<p>•  内部结构(internal structure)</p>
<p>•  协作图(collaboration)</p>
<p>•  构件图(component)</p>
<p>用况视图</p>
<p>•  用况图(use case)</p>
<p>•   展示各类外部执行者与系统提供的用况之间的连接。用况图给出用户所感受到的系统行为，但不描述系统如何实现该功能</p>
<p>•   用况–系统的功能，执行者–使用功能的人或外部系统</p>
<p>•   主要元素</p>
<p>•   参与者</p>
<p>•   用例</p>
<p>•   关系</p>
<p>•   关联 ———————————</p>
<p>•   包含 ——&lt;<include>&gt;——</p>
<p>•   扩展 ——&lt;<Extend>&gt;——</p>
<p>•   泛化 ——————————▷</p>
<p>动态的</p>
<p>•   状态机视图</p>
<ul>
<li>状态机图(state machine)<ul>
<li>通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。</li>
<li>状态的改变成为迁移(transition)。一个状态迁移还可以有与之相关的动作，该动作指出状态迁移时应做什么。</li>
<li>不是所有的类都要画状态，应当满足这些条件才画</li>
<li>有一些意义明确的状态</li>
<li>其行为受不同的状态所影响和改变</li>
</ul>
</li>
</ul>
<p>•  活动视图</p>
<ul>
<li>活动图(activity)<ul>
<li>描述完成一个操作(如用况)所需要的活动</li>
<li>由动作状态组成</li>
<li>完成一个动作的活动的规约</li>
<li>一个动作完成时，离开该动作状态</li>
<li>消息发送和接收的规约</li>
</ul>
</li>
</ul>
<p>•   交互视图</p>
<ul>
<li><p>顺序图(sequence)</p>
<ul>
<li>展示几个对象之间的动态交互关系。</li>
<li>主要显示:对象之间发送消息的顺序，显示对象之间的交互，即系统执行的某一特定点所发生的事</li>
</ul>
</li>
<li><p>通信图(communication)</p>
</li>
</ul>
<p>·    物理的</p>
<ul>
<li>部署视图<ul>
<li>部署图(deployment)</li>
</ul>
</li>
</ul>
<p>·    模型管理</p>
<ul>
<li><p>模型管理视图</p>
<ul>
<li>包图(package)</li>
</ul>
</li>
<li><p>剖图</p>
<ul>
<li>包图(package)</li>
</ul>
</li>
</ul>
<h3 id="UML包括哪四种事物？"><a href="#UML包括哪四种事物？" class="headerlink" title="UML包括哪四种事物？"></a>UML包括哪四种事物？</h3><p>·    1.结构事物</p>
<p>•   类</p>
<p>•   接口</p>
<p>•   用例</p>
<p>•   主动类</p>
<p>•   构件</p>
<p>•   结点等</p>
<p>·    2.动作事物</p>
<p>•   状态等</p>
<p>·    3.组织事物</p>
<p>•   包</p>
<p>·    4.注释事物</p>
<p>•   给建模者提供信息，提供关于任意信息的文本说明，但没有语义作用</p>
<h1 id="面向对象建模"><a href="#面向对象建模" class="headerlink" title="面向对象建模"></a>面向对象建模</h1><h2 id="用况建模"><a href="#用况建模" class="headerlink" title="用况建模"></a>用况建模</h2><p>执行者，用况</p>
<p>用况是执行者想要做的事，执行者执行用况</p>
<p>线段带箭头表示发起的方向</p>
<p>注意扩展关系是扩展指向用况</p>
<p>泛化(归纳)关系是子用况指向父用况，类似继承</p>
<p><strong>实验****5</strong> <strong>面向对象方法的应用（1）</strong></p>
<p><strong>用况建模</strong></p>
<p>（1） <strong>实验目的</strong></p>
<p>掌握UML用况图的画法，学习在软件构思和需求分析阶段进行用况建模，学会填写相关文档。</p>
<p>（2） <strong>实验原理</strong></p>
<p>ü <strong>统一建模语言</strong></p>
<p>统一建模语言（UML）是一种用来对真实世界物体进行建模的标准标记，这个建模的过程是开发面向对象设计方法的第一步。</p>
<p>UML从考虑系统的不同角度出发，定义了<strong>用况****图、类图、对象图、状态图、活动图、序列图</strong>、协作图、构件图、部署图等图形，这些图从不同的侧面对系统进行描述。系统模型将这些不同的侧面综合成一致的整体，便于系统的分析和构造。尽管UML和其它开发工具还会设计出许多派生的视图，但上述这些图和其它辅助性的文档是软件开发人员所见的最基本的构造。</p>
<p>UML适用于系统开发过程中从需求规格描述到系统完成后测试的不同阶段。在需求分析阶段，可以用用况来捕获用户需求。通过用况建模，描述对系统感兴趣的外部角色及其对系统（用况）的功能要求。分析和设计阶段主要关心问题域中的主要概念（如类和对象等）和机制，需要识别这些类以及它们相互间的关系，并用UML类图来描述。为实现用况，类之间需要协作，这可以用UML动态模型来描述。</p>
<p>ü <strong>用况模型</strong></p>
<p><strong>用况</strong>图定义：由执行者（Actor）、用况（Use Case）以及它们之间的关系构成的用于描述系统功能的静态视图称为用况图。用况图（User Case Diagram）是被称为执行者的外部实体所能观察到的系统功能的模型图，呈现了一些执行者和一些用例，以及它们之间的关系，展示了用况之间以及与执行者之间是怎样相互联系的，主要用于对系统、子系统或类的功能行为进行<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/44500.htm">建模</a>。用况图定义了系统的功能<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/195818.htm">需求</a>，它是从系统的外部看系统功能，并不描述系统内部对功能的具体实现。</p>
<p>用况图由执行者（Actor）、用况（<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1299332.htm">Use Case</a>）、<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3638793.htm">系统边界</a>、箭头组成，用画图的方法来完成。 <a target="_blank" rel="noopener" href="http://baike.baidu.com/picview/1281729/1281729/0/ae10edde0c56496f95ee3732.html?fr=lemma"> </a> </p>
<ul>
<li><strong>执行者</strong>（Actor）<ul>
<li>定义：执行者（Actor）不是特指人，是指系统以外的，在使用系统或与系统交互中所扮演的角色。因此执行者可以是人，可以是事物，也可以是时间或其他系统等等。还有一点要注意的是，参与者不是指人或事物本身，而是表示人或事物当时所扮演的角色。比如小明是图书馆的<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/315045.htm">管理员</a>，他参与<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/125121.htm">图书馆管理系统</a>的交互，这时他既可以作为管理员这个角色参与管理，也可以作为借书者向图书馆借书，在这里小明扮演了两个角色，是两个不同的执行者。</li>
<li>画法：执行者<strong>在Visio称为“参与者”</strong>，在画图中用简笔人物画来表示，人物下面附上执行者的名称。执行者的命名，通常是一些角色名，或者系统设备名等。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/lgSo1nzI4u6krPQ.png" alt="wps1.png"></p>
<ul>
<li>用况<ul>
<li>定义：是对包括<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/296689.htm">变量</a>在内的一组动作序列的描述，系统执行这些动作，并产生传递特定执行者的价值的可观察结果。这是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/23396.htm">UML</a>对用况的正式定义，对我们初学者可能有点难懂。我们可以这样去理解，<strong>用况</strong>是执行者想要系统做的事情。</li>
<li>画法：<strong>用况</strong>在Visio称为“用例”，在画图中用<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/36981.htm">椭圆</a>来表示，椭圆下面附上用况的名称。对于<strong>用况</strong>的命名，我们可以给用况取一个简单、描述性的名称，一般为<strong>带有动作性</strong>的词。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/g4etP6vLOEWkNVi.png" alt="wps2.png"></p>
<ul>
<li><strong>系统边界</strong><ul>
<li>定义：<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3638793.htm">系统边界</a>是用来表示正在<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/44500.htm">建模</a>系统的边界。边界内表示系统的组成部分，边界外表示系统外部。</li>
<li>画法：可使用Visio的“子系统”画系统边界，因为<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3638793.htm">系统边界</a>的作用有时候不是很明显，所以在画图时可省略。<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/3638793.htm">系统边界</a>在画图中用方框来表示，同时附上系统的名称，执行者画在边界的外面，用况画在边界里面。命名时使用系统或子系统的名称就可以了。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/24ZFocTfRMJKGCw.png" alt="wps3.png"></p>
<p><strong>用况图中的关系</strong></p>
<p> 定义：用况图中可表示执行者和用况之间，用况与用况之间，执行者与执行者之间的多种关系。</p>
<ul>
<li><strong>关联关系</strong>：执行者与用况之间的关系，表示用况是这个执行者发起的，执行者可以行使系统中的这个功能。关联关系在Visio中就称为“关联”，为一条<strong>不带箭头</strong>的线段。</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/q6X1YKl9kTBPcEN.png" alt="wps4.png"></p>
<ul>
<li><strong>包含关系</strong>：用况与用况之间的关系。基用况必须和被包含用况一起使用才够完整，被包含用况也必然被执行。包含关系在Visio中就称为“包含”，使用带箭头的虚线表示（在线上标注《》），箭头从基用况指向被包含用况。</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/VTmEqrXUxPMGFAo.png" alt="wps5.png"></p>
<ul>
<li><strong>扩展关系</strong>：用况与用况之间的关系。扩展用况是对基用况（被扩展用况）的扩展，<strong>即使没有扩展用况的参与，也可以完成一个完整的功能</strong>。扩展关系在Visio中就称为“扩展”，使用带箭头的虚线表示（在线上标注《》），箭头从扩展用况指向基用况（被扩展用况）。</li>
</ul>
<p><img src="https://s2.loli.net/2023/01/01/bsXFLu1EOaGZmUV.png" alt="wps6.png"></p>
<ul>
<li><strong>泛化关系</strong>：同类元素之间的关系，如用况与用况之间，执行者与执行者之间。类似面向对象中的继承关系。泛化关系在Visio中称为“归纳”，用实线+空心三角形表示，空心三角形指向父，<strong>子可以继承父所有的行为</strong>。</li>
</ul>
<p><strong>用况图</strong> </p>
<p>用况图主要的作用有三个：（1）获取<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/195818.htm">需求</a>；（2）指导测试；（3）还可在整个过程中的其它<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/60285.htm">工作流</a>起到指导作用。</p>
<h3 id="用况图"><a href="#用况图" class="headerlink" title="用况图"></a>用况图</h3><p>用况图是从程序员角度描述系统的功能？错</p>
<h2 id="静态建模"><a href="#静态建模" class="headerlink" title="静态建模"></a>静态建模</h2><h3 id="类图和对象图"><a href="#类图和对象图" class="headerlink" title="类图和对象图"></a>类图和对象图</h3><ul>
<li><p>对象图是类图的实例</p>
</li>
<li><p>类之间的关系有<strong>关联、依赖、泛化、实现</strong>等</p>
</li>
<li><p>类图是一种静态模型，是其他图的基础</p>
</li>
<li><p>一个系统可以有多张类图，一个类也可以出现在几张类图中</p>
</li>
</ul>
<h4 id="如何用UML表示一个类"><a href="#如何用UML表示一个类" class="headerlink" title="如何用UML表示一个类"></a>如何用UML表示一个类</h4><p>类又名称，属性和操作组成</p>
<p>名称唯一，一般采用双驼峰命名法</p>
<p>属性，操作首字母通常小写，单驼峰</p>
<p>属性的语法：属性名：类型&#x3D;初始值  例如：maxCount:Interger&#x3D;0</p>
<p>操作的语法：操作名 (参数表)：返回类型  例如：method1(Object par):void</p>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><p>— 关联</p>
<p>–&gt; 依赖</p>
<p>—▷泛化 需要协助</p>
<p>–▷ 实现</p>
<p><strong>重数：</strong>表示这个类的多少个实例对象可以与另一个类的一个实例<strong>关联</strong></p>
<p>允许一个类与自身关联</p>
<h1 id="状态图和活动图"><a href="#状态图和活动图" class="headerlink" title="状态图和活动图"></a>状态图和活动图</h1><h3 id="什么是状态图？"><a href="#什么是状态图？" class="headerlink" title="什么是状态图？"></a>什么是状态图？</h3><p>·    通常是对类描述的补充，说明该类的对象所有可能的状态以及哪些事件将导致状态的改变。</p>
<h3 id="状态图的组成元素"><a href="#状态图的组成元素" class="headerlink" title="状态图的组成元素"></a>状态图的组成元素</h3><p>·    状态</p>
<p>·    状态之间的迁移</p>
<p>·    分支</p>
<p>·    状态内的迁移</p>
<p>·    复合状态</p>
<h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><h3 id="什么是活动图？"><a href="#什么是活动图？" class="headerlink" title="什么是活动图？"></a>什么是活动图？</h3><p>·    描述完成一个操作(如用况)所需要的活动</p>
<h3 id="活动图的组成元素"><a href="#活动图的组成元素" class="headerlink" title="活动图的组成元素"></a>活动图的组成元素</h3><p>·    活动</p>
<p>·    泳道</p>
<p>·    分支</p>
<p>·    分岔和汇合</p>
<p>·    对象流</p>
<h2 id="1-1-顺序图"><a href="#1-1-顺序图" class="headerlink" title="1.1.    顺序图"></a>1.1.    顺序图</h2><h3 id="1-1-1-什么是顺序图？"><a href="#1-1-1-什么是顺序图？" class="headerlink" title="1.1.1.   什么是顺序图？"></a>1.1.1.   什么是顺序图？</h3><p>展示几个对象之间的动态交互关系</p>
<h3 id="1-1-2-顺序图"><a href="#1-1-2-顺序图" class="headerlink" title="1.1.2.   顺序图"></a>1.1.2.   顺序图</h3><p>1.组成</p>
<p>•   ①对象</p>
<p>•   ②生命线</p>
<p>•   ③激活</p>
<p>•   ④消息(其中描述消息语法不是重点)</p>
<p>•   ⑤组合片段</p>
<p>2.带条件和分支的顺序图</p>
<p>3.带约束的顺序图</p>
<p>4.带循环和自身消息的顺序图</p>
<p>5.创建对象和删除对象的顺序图</p>
<h3 id="结构化控制结构"><a href="#结构化控制结构" class="headerlink" title="结构化控制结构"></a>结构化控制结构</h3><p>6.带组合片段的顺序图</p>
<p>•   组合片段是矩形的，注意其覆盖的高度和宽度，高度对应时长，宽度对应覆盖的对象</p>
<p>•   框住一个范围，也可以嵌套</p>
<p>7.网上在线订购的顺序图</p>
<h3 id="买饮料的顺序图"><a href="#买饮料的顺序图" class="headerlink" title="买饮料的顺序图"></a>买饮料的顺序图</h3><h1 id="第九章-基于构件的软件开发"><a href="#第九章-基于构件的软件开发" class="headerlink" title="第九章 基于构件的软件开发"></a>第九章 基于构件的软件开发</h1><h2 id="什么是构件"><a href="#什么是构件" class="headerlink" title="什么是构件"></a>什么是构件</h2><p>软件构件是软件系统中具有相对独立功能，可以明确标识，接口由规约指定，与语境有明显依赖关系，可独立部署，且多由第三方提供的可组装软件实体。</p>
<h3 id="可复用构建是指具有可复用价值的构件"><a href="#可复用构建是指具有可复用价值的构件" class="headerlink" title="可复用构建是指具有可复用价值的构件"></a>可复用构建是指具有可复用价值的构件</h3><h2 id="可变性分析"><a href="#可变性分析" class="headerlink" title="可变性分析"></a>可变性分析</h2><h3 id="构件应具有较强的通用性和可变性"><a href="#构件应具有较强的通用性和可变性" class="headerlink" title="构件应具有较强的通用性和可变性"></a>构件应具有较强的通用性和可变性</h3><p>为了满足不同的复用需求，需要在构件复用时可能发生变化的一个或多个位置上标识变化点，同时为变化点附加一个或多个变体</p>
<h2 id="基于构建的软件开发过程"><a href="#基于构建的软件开发过程" class="headerlink" title="基于构建的软件开发过程"></a>基于构建的软件开发过程</h2><h3 id="领域工程步骤-生产构建"><a href="#领域工程步骤-生产构建" class="headerlink" title="领域工程步骤(生产构建)"></a>领域工程步骤(生产构建)</h3><p>1领域分析</p>
<p>2建立领域特定的基准体系结构模型</p>
<p>3标识候选构件</p>
<p>4泛化和可变性分析</p>
<p>5构件重构</p>
<p>6构件的测试</p>
<p>7构件的包装</p>
<p>8构件的入库</p>
<h3 id="应用系统工程的步骤-使用构件"><a href="#应用系统工程的步骤-使用构件" class="headerlink" title="应用系统工程的步骤(使用构件)"></a>应用系统工程的步骤(使用构件)</h3><p>1建立应用系统的体系结构模型</p>
<p>2寻找候选构件</p>
<p>3评价和选择合适的构件</p>
<p>4构件的修改和特化</p>
<p>5开发未被复用的部分</p>
<p>6构件的组装</p>
<p>7集成测试</p>
<p>8评价被复用的构件，并推荐可能的新构件</p>
<p><img src="https://s2.loli.net/2023/01/02/ickNdgLUse31RTW.jpg" alt="clip_image002-16726355802722.jpg"></p>
<h1 id="第十章-敏捷软件开发"><a href="#第十章-敏捷软件开发" class="headerlink" title="第十章 敏捷软件开发"></a>第十章 敏捷软件开发</h1><h2 id="什么是敏捷开发方法"><a href="#什么是敏捷开发方法" class="headerlink" title="什么是敏捷开发方法"></a>什么是敏捷开发方法</h2><p>敏捷开发是一种基于更紧密的团队协作、能够有效应对快速变化需求、快速交付高质量软件的迭代和增量的新型软件开发方法</p>
<h2 id="代表性的敏捷开发方法"><a href="#代表性的敏捷开发方法" class="headerlink" title="代表性的敏捷开发方法"></a>代表性的敏捷开发方法</h2><h3 id="Scrum-迭代式增量软件开发过程-为基础的方法论"><a href="#Scrum-迭代式增量软件开发过程-为基础的方法论" class="headerlink" title="Scrum(迭代式增量软件开发过程)为基础的方法论"></a>Scrum(迭代式增量软件开发过程)为基础的方法论</h3><p>·    Scrum</p>
<p>·    Scrum&#x2F;XP混合</p>
<p>·    …</p>
<h3 id="看板方法"><a href="#看板方法" class="headerlink" title="看板方法"></a>看板方法</h3><h3 id="精益创业"><a href="#精益创业" class="headerlink" title="精益创业"></a>精益创业</h3><h3 id="极限编程-XP"><a href="#极限编程-XP" class="headerlink" title="极限编程(XP)"></a>极限编程(XP)</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jjuprising.github.io/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://jjuprising.github.io/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JJuprising.github.io" target="_blank">Joel Station</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/images/NoCover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/02/Linux%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://www.silicon.es/wp-content/uploads/2016/10/linux-logo-2-684x500.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/12/%E7%94%A8ChatGPT%E5%86%99%E4%B8%80%E4%B8%AA%E5%88%B7%E9%A2%98%E8%BD%AF%E4%BB%B6/"><img class="next-cover" src="https://image.woshipm.com/wp-files/2022/12/lLVcSjH9pWlnnthYmqJ0.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">用ChatGPT写一个刷题软件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/02/Linux%E7%AC%94%E8%AE%B0/" title="Linux笔记"><img class="cover" src="https://www.silicon.es/wp-content/uploads/2016/10/linux-logo-2-684x500.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-02</div><div class="title">Linux笔记</div></div></a></div><div><a href="/2022/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构学习笔记"><img class="cover" src="/images/NoCover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-16</div><div class="title">数据结构学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/jc_avator2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Joel</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JJuprising"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JJuprising" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">作业题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">能力成熟度模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">软件过程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">系统工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%96%B9%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">结构化方法和数据流图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">软件工程与软件过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">计算机软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">软件的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">软件的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">软件危机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">软件工程的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">软件生存周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B-8%E7%A7%8D"><span class="toc-number">3.</span> <span class="toc-text">软件过程模型(8种)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.1.</span> <span class="toc-text">能力成熟度模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8BCMM"><span class="toc-number">3.1.1.</span> <span class="toc-text">能力成熟度模型CMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90CMMI"><span class="toc-number">3.1.2.</span> <span class="toc-text">能力成熟度模型集成CMMI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E6%95%B4%E4%BD%93%E8%83%BD%E5%8A%9B%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">阶段式模型 (整体能力的划分)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%BC%8F%E6%A8%A1%E5%9E%8B-%E6%9F%90%E6%96%B9%E9%9D%A2%E8%83%BD%E5%8A%9B%E7%9A%84%E8%A1%A1%E9%87%8F"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">连续式模型(某方面能力的衡量)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">3.2.</span> <span class="toc-text">软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">瀑布模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">演化模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">增量模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">原型模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">增量模型和原型模型的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">螺旋模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">喷泉模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.4.</span> <span class="toc-text">基于构件的开发模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">形式化模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CASE%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">CASE工具和环境的重要性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B-1"><span class="toc-number">4.</span> <span class="toc-text">系统工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.1.</span> <span class="toc-text">系统工程的任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A1%8C%E6%80%A7%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.2.</span> <span class="toc-text">可行性分析的任务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">需求工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4%E5%92%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">需求工程的具体步骤和任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%B6%E5%AE%9A%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E7%AD%96%E7%95%A5%E4%B8%BB%E8%A6%81%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">制定需求获取策略主要考虑因素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E8%8E%B7%E5%8F%96%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.</span> <span class="toc-text">需求获取的方法和策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%B7%A5%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">设计工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.1.</span> <span class="toc-text">软件设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%B8%8E%E9%80%90%E6%AD%A5%E6%B1%82%E7%B2%BE"><span class="toc-number">6.1.1.</span> <span class="toc-text">抽象与逐步求精</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">6.1.2.</span> <span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">信息隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%8B%AC%E7%AB%8B"><span class="toc-number">6.1.4.</span> <span class="toc-text">功能独立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%9A"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">内聚</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%80%A6%E5%90%88"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">耦合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">结构化程序设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">结构化分析方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">数据流图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB%E9%A1%B6%E5%B1%82%E5%9B%BE"><span class="toc-number">7.2.1.</span> <span class="toc-text">画顶层图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB0%E5%B1%82%E5%9B%BE"><span class="toc-number">7.2.2.</span> <span class="toc-text">画0层图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%BB1%E5%B1%82%E5%9B%BE-%E7%94%BB%E5%8A%A0%E5%B7%A5%E5%86%85%E9%83%A8"><span class="toc-number">7.2.3.</span> <span class="toc-text">画1层图(画加工内部)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.2.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A1%E6%9F%A5"><span class="toc-number">7.2.5.</span> <span class="toc-text">审查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="toc-number">7.3.</span> <span class="toc-text">数据字典</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E8%A1%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">判定表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E5%AE%9A%E6%A0%91"><span class="toc-number">7.3.2.</span> <span class="toc-text">判定树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">7.4.</span> <span class="toc-text">模块结构图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">7.4.1.</span> <span class="toc-text">结构图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">7.4.1.1.</span> <span class="toc-text">含义</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">面向数据结构的分析与设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">什么是面向数据结构的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF"><span class="toc-number">8.1.1.</span> <span class="toc-text">面向数据结构的方法是</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.2.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jackson%E5%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">Jackson图的三种结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%85%83%E7%B4%A0"><span class="toc-number">8.2.1.</span> <span class="toc-text">顺序元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0"><span class="toc-number">8.2.2.</span> <span class="toc-text">1.1.1.   选择元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-number">8.2.3.</span> <span class="toc-text">1.1.2.   重复元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">9.</span> <span class="toc-text">面向对象方法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-number">9.1.</span> <span class="toc-text">UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">9.1.1.</span> <span class="toc-text">UML语言中的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E5%8C%85%E5%90%AB%E7%9A%84%E8%A7%86%E5%9B%BE-%E7%BA%A2%E8%89%B2%E4%B8%BA%E5%B7%B2%E5%AD%A6"><span class="toc-number">9.1.2.</span> <span class="toc-text">UML包含的视图(红色为已学)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">结构化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%A7%86%E5%9B%BE"><span class="toc-number">9.1.2.1.1.</span> <span class="toc-text">静态视图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UML%E5%8C%85%E6%8B%AC%E5%93%AA%E5%9B%9B%E7%A7%8D%E4%BA%8B%E7%89%A9%EF%BC%9F"><span class="toc-number">9.1.3.</span> <span class="toc-text">UML包括哪四种事物？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1"><span class="toc-number">10.</span> <span class="toc-text">面向对象建模</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%86%B5%E5%BB%BA%E6%A8%A1"><span class="toc-number">10.1.</span> <span class="toc-text">用况建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%86%B5%E5%9B%BE"><span class="toc-number">10.1.1.</span> <span class="toc-text">用况图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">10.2.</span> <span class="toc-text">静态建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9B%BE"><span class="toc-number">10.2.1.</span> <span class="toc-text">类图和对象图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8UML%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">如何用UML表示一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">类之间的关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE%E5%92%8C%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">状态图和活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8A%B6%E6%80%81%E5%9B%BE%EF%BC%9F"><span class="toc-number">11.0.1.</span> <span class="toc-text">什么是状态图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">11.0.2.</span> <span class="toc-text">状态图的组成元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-number">11.1.</span> <span class="toc-text">活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B4%BB%E5%8A%A8%E5%9B%BE%EF%BC%9F"><span class="toc-number">11.1.1.</span> <span class="toc-text">什么是活动图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">11.1.2.</span> <span class="toc-text">活动图的组成元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">11.2.</span> <span class="toc-text">1.1.    顺序图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E5%9B%BE%EF%BC%9F"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.1.1.   什么是顺序图？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">11.2.2.</span> <span class="toc-text">1.1.2.   顺序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">11.2.3.</span> <span class="toc-text">结构化控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E9%A5%AE%E6%96%99%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">11.2.4.</span> <span class="toc-text">买饮料的顺序图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%9E%84%E4%BB%B6%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">12.</span> <span class="toc-text">第九章 基于构件的软件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E4%BB%B6"><span class="toc-number">12.1.</span> <span class="toc-text">什么是构件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E6%98%AF%E6%8C%87%E5%85%B7%E6%9C%89%E5%8F%AF%E5%A4%8D%E7%94%A8%E4%BB%B7%E5%80%BC%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-number">12.1.1.</span> <span class="toc-text">可复用构建是指具有可复用价值的构件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">12.2.</span> <span class="toc-text">可变性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E4%BB%B6%E5%BA%94%E5%85%B7%E6%9C%89%E8%BE%83%E5%BC%BA%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%A7%E5%92%8C%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">12.2.1.</span> <span class="toc-text">构件应具有较强的通用性和可变性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E5%BB%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="toc-number">12.3.</span> <span class="toc-text">基于构建的软件开发过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E5%B7%A5%E7%A8%8B%E6%AD%A5%E9%AA%A4-%E7%94%9F%E4%BA%A7%E6%9E%84%E5%BB%BA"><span class="toc-number">12.3.1.</span> <span class="toc-text">领域工程步骤(生产构建)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%AD%A5%E9%AA%A4-%E4%BD%BF%E7%94%A8%E6%9E%84%E4%BB%B6"><span class="toc-number">12.3.2.</span> <span class="toc-text">应用系统工程的步骤(使用构件)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">13.</span> <span class="toc-text">第十章 敏捷软件开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">13.1.</span> <span class="toc-text">什么是敏捷开发方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E8%A1%A8%E6%80%A7%E7%9A%84%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">代表性的敏捷开发方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scrum-%E8%BF%AD%E4%BB%A3%E5%BC%8F%E5%A2%9E%E9%87%8F%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B-%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-number">13.2.1.</span> <span class="toc-text">Scrum(迭代式增量软件开发过程)为基础的方法论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.2.</span> <span class="toc-text">看板方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E7%9B%8A%E5%88%9B%E4%B8%9A"><span class="toc-number">13.2.3.</span> <span class="toc-text">精益创业</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B-XP"><span class="toc-number">13.2.4.</span> <span class="toc-text">极限编程(XP)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/01/02/Linux%E7%AC%94%E8%AE%B0/" title="Linux笔记"><img src="https://www.silicon.es/wp-content/uploads/2016/10/linux-logo-2-684x500.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux笔记"/></a><div class="content"><a class="title" href="/2023/01/02/Linux%E7%AC%94%E8%AE%B0/" title="Linux笔记">Linux笔记</a><time datetime="2023-01-02T03:27:01.000Z" title="发表于 2023-01-02 11:27:01">2023-01-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件工程导论学习笔记"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件工程导论学习笔记"/></a><div class="content"><a class="title" href="/2023/01/01/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="软件工程导论学习笔记">软件工程导论学习笔记</a><time datetime="2023-01-01T14:45:01.000Z" title="发表于 2023-01-01 22:45:01">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/%E7%94%A8ChatGPT%E5%86%99%E4%B8%80%E4%B8%AA%E5%88%B7%E9%A2%98%E8%BD%AF%E4%BB%B6/" title="用ChatGPT写一个刷题软件"><img src="https://image.woshipm.com/wp-files/2022/12/lLVcSjH9pWlnnthYmqJ0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用ChatGPT写一个刷题软件"/></a><div class="content"><a class="title" href="/2022/12/12/%E7%94%A8ChatGPT%E5%86%99%E4%B8%80%E4%B8%AA%E5%88%B7%E9%A2%98%E8%BD%AF%E4%BB%B6/" title="用ChatGPT写一个刷题软件">用ChatGPT写一个刷题软件</a><time datetime="2022-12-12T02:05:00.000Z" title="发表于 2022-12-12 10:05:00">2022-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构学习笔记"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构学习笔记"/></a><div class="content"><a class="title" href="/2022/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="数据结构学习笔记">数据结构学习笔记</a><time datetime="2022-11-16T09:00:15.000Z" title="发表于 2022-11-16 17:00:15">2022-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/16/Dijkstra%E7%AE%97%E6%B3%95C++%E5%AE%9E%E7%8E%B0/" title="课本Dijkstra算法Cpp实现及改正"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="课本Dijkstra算法Cpp实现及改正"/></a><div class="content"><a class="title" href="/2022/11/16/Dijkstra%E7%AE%97%E6%B3%95C++%E5%AE%9E%E7%8E%B0/" title="课本Dijkstra算法Cpp实现及改正">课本Dijkstra算法Cpp实现及改正</a><time datetime="2022-11-15T17:16:42.000Z" title="发表于 2022-11-16 01:16:42">2022-11-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bc.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Joel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>