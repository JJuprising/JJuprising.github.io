<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java学习笔记 | Joel Station</title><meta name="keywords" content="编程语言"><meta name="author" content="Joel"><meta name="copyright" content="Joel"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="错题 通过super可调用父类构造函数。对  构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的  一般在创建新对象时，系统会自动调用构造函数。对  【单选题】下面赋值语句不合法的是___D___。 A.Long a&#x3D;(Long)(long)3; B.Long b&#x3D;3L; C. Long c&#x3D;Long.">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="https://jjuprising.github.io/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Joel Station">
<meta property="og:description" content="错题 通过super可调用父类构造函数。对  构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的  一般在创建新对象时，系统会自动调用构造函数。对  【单选题】下面赋值语句不合法的是___D___。 A.Long a&#x3D;(Long)(long)3; B.Long b&#x3D;3L; C. Long c&#x3D;Long.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/10/07/XTCDJwhl5OKGyFW.png">
<meta property="article:published_time" content="2022-09-29T00:40:55.000Z">
<meta property="article:modified_time" content="2023-01-01T14:42:48.713Z">
<meta property="article:author" content="Joel">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/07/XTCDJwhl5OKGyFW.png"><link rel="shortcut icon" href="/img/jc_favicon2.png"><link rel="canonical" href="https://jjuprising.github.io/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-01 22:42:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/jc_avator2.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/10/07/XTCDJwhl5OKGyFW.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Joel Station</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-29T00:40:55.000Z" title="发表于 2022-09-29 08:40:55">2022-09-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-01T14:42:48.713Z" title="更新于 2023-01-01 22:42:48">2023-01-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>79分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h1><ul>
<li><p>通过super可调用父类构造函数。对</p>
</li>
<li><p>构造函数的返回类型只能是void型。错，造函数必须与类名相同且没有返回值，void是空返回值并不是无返回值所以是错的</p>
</li>
<li><p>一般在创建新对象时，系统会自动调用构造函数。对</p>
</li>
<li><p>【单选题】下面赋值语句不合法的是___D___。</p>
<p>A.Long a&#x3D;(Long)(long)3;</p>
<p>B.Long b&#x3D;3L;</p>
<p>C. Long c&#x3D;Long.parseLong(“3”);</p>
<p>D.Long d&#x3D;(Long )3; </p>
<p>下面赋值语句不合法的是 D。在Java中，”Long”类是原始数据类型long的<strong>包装类</strong>，必须使用关键字”new”来构造包装类，才能创建有效的对象。从长值3创建Long对象的正确方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>其他三个选项都是从长值3创建Long对象的有效方法。选项A从将整数值3转换为长值，然后再转换为Long的结果创建Long对象。选项B从长值3L创建Long对象。选项C通过调用Long类的parseLong方法，从字符串值”3”创建Long对象。</p>
</li>
<li><p>【单选题】java语言中，在定义类时不能使用的修饰符是____B______。 A.public  B.private C.abstract D.final</p>
<ul>
<li>答案是 B：private。在 Java 语言中，private 是一种访问修饰符，它只能在类的内部使用，不能用于定义类。</li>
<li>A 选项：public。public 是一种访问修饰符，它表示在任何地方都能够访问。定义类时可以使用 public 修饰符。</li>
<li>C 选项：abstract。abstract 是一种修饰符，它用于定义抽象类和抽象方法。定义类时可以使用 abstract 修饰符。</li>
<li>D 选项：final。final 是一种修饰符，它表示类不能被继承，方法不能被重写。定义类时可以使用 final 修饰符。</li>
</ul>
</li>
<li><p>在Java语言中，下面关于Math类的常见操作不正确的描述是_____D__B___。</p>
</li>
</ul>
<p>  A.执行Math.ceil(-10.5) 语句的结果是-10.0</p>
<p>  B.执行Math.round(10.5) 语句的结果是11.0 <strong>(答案是11，没有小数点！)</strong></p>
<p>  C.执行Math.floor(-10.5) 语句的结果是-11.0</p>
<p>  D.执行Math.round(-10.5) 语句的结果是-10</p>
<p>  <code>Math.round</code> 不完全是四舍五入，当刚好为负数且刚好0.5，舍入到正无穷方向上的整数。如<code>Math.round(-20.5)</code>结果为<code>-20</code></p>
<ul>
<li><p>【单选题】执行下面程序段后，输出结果是___C______。</p>
<p>int a&#x3D;4,b&#x3D;6,c&#x3D;8;</p>
<p>System.out.println(++a*b—c );</p>
<p>A.11</p>
<p>B.16</p>
<p>C.22</p>
<p>D.23</p>
<p>注意后面的—前两个应该是b的后缀，而不是后两个是c的前缀，由于是后缀，无影响，而a的前缀加了用，因此是5×6-8结果为22，而且b的值变为5，a为5。</p>
</li>
<li><p>下面概念中，不属于面向对象程序设计的是_____A_____。</p>
<p>A.过程调用 </p>
<p>B.对象 </p>
<p>C.类 </p>
<p>D.继承</p>
<p>文本框获得焦点时回车和按钮单击，都属于<strong>ActionEvent</strong>事件，也就是说<strong>文本框和按钮</strong>可以作为ActionEvent事件的事件源。</p>
<p>而<strong>选择框</strong>的选中，和<strong>下拉列表</strong>的选中，都是在触发<strong>ItemEvent</strong>事件。</p>
<p>不同类型的事件的监听器要实现的接口不同，对于ActionEvent事件，这个接口是  ActionListener，实现其中的actionPerformed方法，方法传入的也是ActionEvent对象。</p>
<p>而对于ItemEvent事件，则要实现的是ItemListener接口，实现其中的itemStateChanged方法，方法传入的是ItemEvent对象。</p>
</li>
<li><p>下面关于java.sql包中接口和类的描述不正确的是__B__。</p>
<p>A.Connection 接口：表示数据库连接</p>
<p>B.DriverManager类：表示驱动器 <strong>(错，JDBC 的管理层，作用于用户和驱动程序之间。)</strong></p>
<p>C.ResultSet接口：表示SQL查询语句返回的<u>结果集</u></p>
<p>D.Statement接口：负责<u>执行</u>SQL语句</p>
</li>
<li><p>在Java语言中，下面用于执行<u>存储过程</u>SQL语句的是___B___。</p>
<p>A.Statement</p>
<p>B.CallableStatement</p>
<p>C.createStatement</p>
<p>D.PreparedStatement</p>
<p>Statement 对象有三种:(Statement)对象用于执行不带参数的简单 SQL语句; (PreparedStatement)对象继承Statement，用于执行<strong>带或不带参数</strong>的预编译 SOL语句:<strong>(CallableStatement)</strong> 对象继承PreparedStatement，<strong>用于执行对数据库存储过程的调用</strong></p>
</li>
<li><p>在Java语言中，下面关于Scanner类描述错误的是_____D__C___。</p>
<p>A.Scanner类可以方便的完成输入流的输入操作</p>
<p>B.Scanner sc&#x3D;new Scanner(System.in);&#x2F;&#x2F;从标准输入中扫描</p>
<p>C.Scanner类位于javax.util包中，使用时需要import导入**(是java.util)**</p>
<p>D.Scanner可以<strong>扫描指定的文件</strong>.</p>
<p>D是对的，C是错的。</p>
</li>
<li><p>在Java语言中，下面不属于ComponentEvent的子类是____D______。</p>
<p>A.InputEvent</p>
<p>B.FocusEvent</p>
<p>C.WindowEvent</p>
<p>D.ItemEvent</p>
<p>ItemEvent不属于ComponentEvent的子类。</p>
</li>
<li><p>在Java语言中，下面关于组件定义错误的是____ D_____。</p>
<p>A.TextField tf&#x3D;new TextField(3);&#x2F;&#x2F;int型指定列宽</p>
<p>B.Timer tr&#x3D;new Timer();</p>
<p>C.JFileChooser jf&#x3D;new   JFileChooser();</p>
<p>D.TextArea ta&#x3D;new TextArea(3);</p>
</li>
<li><p>在Java语言中，以下____C____项是<strong>接口</strong>B的正确定义。</p>
<p>A.interface B{ void print(){ };}</p>
<p>B.abstract interface B{void print(){}}</p>
<p>C.interface B {void print();}</p>
<p>D.interface B extend A { void print(){}}&#x2F;&#x2F;A为已定义接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Paintable</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;<span class="comment">//没有&#123;&#125;，可省略public abstract关键字</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">intf1</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">intf2</span> <span class="keyword">extends</span> <span class="title class_">intf1</span>&#123;&#125;<span class="comment">//接口继承接口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面概念中，不属于面向对象程序设计的是_____A_____。</p>
<p>A.过程调用 </p>
<p>B.对象 </p>
<p>C.类 </p>
<p>D.继承</p>
</li>
<li><p>在Java语言中，成员变量中被static关键字修饰的变量，叫 B</p>
<p>A.变量 </p>
<p>B.类变量 <strong>（静态变量的成员变量）</strong></p>
<p>C.实例变量 </p>
<p>D.整型变量</p>
</li>
<li><p>在Java语言中，下面关于String类的常见操作不正确的描述是______B____。</p>
<p>A.假设 <code>s =&quot;class&quot;</code>;则执行<code>char c = s.charAt(1)</code>语句后变量c的值是<code>l</code></p>
<p>B.<code>indexOf</code>方法是查找特定字符或字符串在当前字符串中的起始位置，如果不存在则返回0 。<strong>（返回-1）</strong></p>
<p>C.<code>concat</code>方法的作用是进行字符串的连接，将两个字符串连接以后形成一个新的字符串</p>
<p>D.<code>equals</code>方法的作用是判断两个字符串对象的内容是否相同</p>
<p><code>charAt()</code> 方法用于返回指定索引处的字符。索引范围为从 <code>0</code> 到 <code>length() - 1</code>。</p>
</li>
<li><p>下面关于try catch语句中异常类排列顺序正确的说法是____B______。</p>
<p>A.父类异常在前，子类异常在后</p>
<p><strong>B.父类异常在后，子类异常在前</strong></p>
<p>C.父类和子类异常排列顺序前后无影响</p>
<p>D.只能有子类异常</p>
</li>
<li><p>已知Integer.MAX_VALUE 的值为2147483647，在执行“Integer max1&#x3D;Integer.MAX_VALUE,max2&#x3D; max1+1;”语句后，max2等于____A______。</p>
<p><strong>A.-2147483648</strong></p>
<p>B.2147483647</p>
<p>C.0</p>
<p>D.2147483648</p>
</li>
<li><p>在Java语言中，Person类有一个成员变量age被protected修饰，下面关于age说法不正确的是___C_______。</p>
<p>A.能被Person的子类访问。</p>
<p>B.能被Person类所在同一个包中的其它类访问。</p>
<p>C.能被Person类所在包之外的其它类访问。</p>
<p>D.不能被Person类所在包之外的其它类访问。</p>
<p>protected 访问控制符能被用于方法和成员变量<br> 声明为protected的方法和成员变量<strong>能被同一个包里的所有类所访问</strong>，就像默认修饰符package一样<br>能被<strong>该类的子类所访问</strong>，子类可以和父类不在一个包中。<br>另一个包中的子类<strong>只能通过子类或其子类的引用来访问</strong>父类中受保护的成员。同一包中的子类没有此限制。这样可以确保来自其他包的类只访问属于其继承层次结构一部分的成员</p>
</li>
<li><p>下面哪项不属于Statement接口提供的3个执行SQL语句的方法______A____。</p>
<p>A.executeDelete(String sql)</p>
<p><strong>B.executeUpdate(String sql)</strong></p>
<p><strong>C.executeQuery(String sql)</strong></p>
<p><strong>D.execute(String sql)</strong></p>
</li>
<li><p>在Java语言中，下面关于RandomAccessFile描述错误的是_____D_____。</p>
<p>A.实现DataInput和DataOutput接口</p>
<p>B.getFilePointer()方法：返回此文件中的当前偏移量</p>
<p>C.readFloat()方法：从此文件读取一个 float</p>
<p>D.writeChar(int v)：按双字节值将char写入该文件，先写低字节(<strong>将一个字符作为一个两个字节的值写入基础输出流，其中高字节在前</strong>。)</p>
</li>
<li><p>在Java语言中，下面相关描述错误的是____B______。</p>
<p>A.File类对象对应于系统中的一个目录或文件</p>
<p>B.CharArrayReader 是一个把字符数组作为源的输出流的实现.<strong>(输入流)</strong></p>
<p>C.FileInputStream：以字节流方式读取</p>
<p>D.FileReader：把文件转换为字符流读入</p>
</li>
<li><p>下面关于Java事件描述错误的是_____A_____。</p>
<p>A.只有外部操作会产生事件</p>
<p><strong>B.可以通过继承EventObject类编写自定义事件类</strong></p>
<p><strong>C.事件处理的三要素包括事件源、事件以及事件监听器</strong></p>
<p><strong>D.要在事件源上注册事件监听器</strong></p>
</li>
<li><p>在Java语言中，下面关于Applet描述错误的是A。</p>
<p>A.Applet能执行任何本地计算机上的程序(错误)</p>
<p>B.Applet的生命周期中有四个状态：初始态、运行态、停止态和消亡态</p>
<p>C.Applet的init()方法在Applet的生存周期中只调用一次</p>
<p>D.Applet应用程序必须嵌入在HTML页面中，才能得到解释执行</p>
<p>此外，Applet是Java类，且通常情况下不能进行文件的I&#x2F;O操作</p>
</li>
<li><p>在Java语言中，下面关于List不正确的描述是_______B___。</p>
<p>A.List是在java.util包中</p>
<p>B.List是一个类<strong>（是接口）</strong></p>
<p>C.List具有get(int index)方法</p>
<p>D.List是一个接口</p>
<p>List，Set，Map都是接口</p>
</li>
<li><p>在Java语言中，类Double定义在以下的哪个包中_____C_____。</p>
<p>A.java.io</p>
<p>B.javax.lang</p>
<p>C.java.lang</p>
<p>D.java.util</p>
</li>
<li><p>在Java语言中，下面关于接口错误描述的是___A___。</p>
<p>A.接口不仅包括方法的特征，还有方法的实现。</p>
<p><strong>B.接口只允许public 和abstract修饰。</strong></p>
<p><strong>C.接口中的<u>属性</u>只能被public 、final、static修饰。</strong></p>
<p><strong>D.一个类可以实现多个接口。</strong></p>
<p>接口中的<u>属性</u>只能被public 、final、static修饰，而且必须赋值，因为是常量，在后面不能改变，否则会报错，不会给默认值的</p>
</li>
<li><p>在Java语言中，执行下列程序段后，i的结果是____D______。</p>
<p>int i;</p>
<p>for(i&#x3D;0;i&lt;10;i++)</p>
<p>{      </p>
<p> if (i&gt;4){  continue;}&#x2F;&#x2F; 一直跳过</p>
<p> if(i&gt;7 ){ System.out.println(i); break;}</p>
<p>}</p>
<p>A.6</p>
<p>B.8</p>
<p>C.9</p>
<p>D.10</p>
</li>
<li><p>在Java语言中，下面关于颜色定义不合法的是___B_______。</p>
<p>A.Color c1&#x3D;new Color(0xffffff) </p>
<p>B.Color c2&#x3D;new Color(Color.BLUE) </p>
<p>C.Color c3&#x3D;new Color(0,0,255) </p>
<p>D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f)</p>
<p>Color 是 Java 中的一个类，可以用来表示颜色。在 Java 中，可以使用以下几种方法来定义颜色：</p>
<ul>
<li>使用 16 进制 RGB 值来定义颜色，例如 A.Color c1&#x3D;new Color(0xffffff)。</li>
<li>使用 24 位 RGB 值来定义颜色，例如 C.Color c3&#x3D;new Color(0,0,255)。</li>
<li>使用浮点型 RGB 值来定义颜色，例如 D.Color c4&#x3D;new Color(0.2f,0.6f,1.0f)。</li>
</ul>
<p>B.Color c2&#x3D;new Color(Color.BLUE) 中的 Color.BLUE 是预定义的颜色常量，它表示蓝色。这种方式并不能用来定义颜色，因此 B 选项是不合法的。</p>
</li>
<li><p>下面<strong>不属于</strong>Java语言中常见事件类型的是____C______。</p>
<p><strong>A.KeyEvent</strong> </p>
<p><strong>B.MouseEvent</strong> </p>
<p>C.TouchEvent </p>
<p><strong>D.ItemEvent</strong></p>
</li>
<li><p>在Java语言中，下面不符合数组定义格式的是___D_______。</p>
<p>A.int []a&#x3D;new int [3]; </p>
<p>B.int b[]&#x3D;{1,2,3}; </p>
<p>C.int c[]&#x3D;new int [3]; </p>
<p>D.int e[3]&#x3D;new int [3];</p>
<p>在 Java 中，数组是用于存储一组相同类型的数据的数据结构。在 Java 中，可以使用以下几种方法来定义数组：</p>
<ul>
<li>使用 new 运算符来定义数组，例如 A.int []a&#x3D;new int [3]; 和 C.int c[]&#x3D;new int [3];。</li>
<li>使用 {} 来定义数组并初始化数组元素，例如 B.int b[]&#x3D;{1,2,3};。</li>
</ul>
</li>
<li><p>在Java语言中，下面变量命名不合法的有 C</p>
<p>A.$fn</p>
<p>B.p5p</p>
<p>C.static</p>
<p>D._user</p>
<p>必须以字母、下划线、或者美元符$开头；</p>
</li>
<li><p>在Java语言中，下面不属于JDBC的主要功能是A</p>
<p>A.解析SQL语句</p>
<p><strong>B.处理数据库的返回结果</strong></p>
<p><strong>C.建立与数据库或者其他数据源的连接</strong></p>
<p><strong>D.向数据库发送SQL命令</strong></p>
</li>
<li><p>在Java语言中，下面用于执行<strong>简单的不带参数的</strong>SQL语句是 A</p>
<p>A.Statement</p>
<p>B.PreparedStatement</p>
<p>C.CallableStatement</p>
<p>D.createStatement</p>
</li>
<li><p>定义int A&#x3D;5，执行“System.out.println(“a&#x3D;”+((A&lt;5)?5.1:4));” 语句的结果是 B</p>
<p>A.a&#x3D;5.1</p>
<p>B.a&#x3D;4.0</p>
<p>C.a&#x3D;5</p>
<p>D.a&#x3D;4</p>
<p>三目运算符后面类型不同需要类型升级</p>
</li>
<li><p>在Java语言中，下面关于包描述不正确的是 C</p>
<p><strong>A.包提供了访问权限和命名的管理机制</strong></p>
<p><strong>B.包是Java提供的一种区别类的名字空间的机制</strong></p>
<p>C.类只能访问其所在包中的所有类</p>
<p><strong>D.包是类的组织方式，是一组相关类和接口的集合</strong></p>
<p>(1)具有public权限的类能<strong>被所有包中的类访问</strong>,与所在的包无关(2)具有缺省权限的类只能被所在包中的类访问,不能再其包外访问</p>
</li>
<li><p>定义char x&#x3D;’a’，下面赋值语句不合法的有 <strong>B</strong></p>
<p>A.float b&#x3D;x；</p>
<p>B.byte c&#x3D;x;</p>
<p>C.double d&#x3D;x;</p>
<p>D.int a&#x3D;x;</p>
<p>应该为 byte c&#x3D;(byte)x;</p>
</li>
<li><p>在Java语言中，下面关于异常的错误描述是_____D_____。</p>
<p>A.异常是java提供的用于处理程序中错误的一种机制</p>
<p>B.java.lang. Exception类是所有异常的父类</p>
<p>C.java.lang.NullPointerException是空指针异常类</p>
<p>D.当异常产生时，程序会自动跳转到异常处理程序</p>
</li>
<li><p>在Java语言中，下面关于File类描述错误的是 A</p>
<p>A.执行File f&#x3D;new File(“e:\txx.txt”)语句的结果是在e盘上创建了一个txx.txt文件</p>
<p>B.File类对象对应于系统中的一个目录和文件</p>
<p>C.File类对象描述文件名、可否读写等属性，但不读写文件</p>
<p>D.一旦创建，File对象表示的抽象路径名将不会改变</p>
<p>File f&#x3D;new File;创建的是一个对象</p>
</li>
<li><p>在Java语言中，下面关于AWT组件描述错误的是 C</p>
<p>A.Choice:制作用于单选的下拉列表</p>
<p>B.与菜单相关的类主要有三个: MenuBar、Menu、Menultem</p>
<p>C.Panel类可作为容器容纳其它组件，也可以独立存在</p>
<p>D.Canvas:代表屏幕上一块空白的矩形区域</p>
<p>Panel类可作为容器容纳其它组件，也可以独立存在必须在窗体容器中使用，无法脱离窗体显示</p>
</li>
<li><p><code>substring()</code>截取字符串，从索引0开始计数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">Str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;This is text&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        System.out.print(<span class="string">&quot;返回值 :&quot;</span> );</span><br><span class="line">        System.out.println(Str.substring(<span class="number">4</span>) );<span class="comment">//4开始到最后</span></span><br><span class="line"> </span><br><span class="line">        System.out.print(<span class="string">&quot;返回值 :&quot;</span> );</span><br><span class="line">        System.out.println(Str.substring(<span class="number">4</span>, <span class="number">10</span>) );<span class="comment">//含头不含尾</span></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">返回值 : is text</span><br><span class="line">返回值 : is te</span><br></pre></td></tr></table></figure>

<p><code>public int index0f(int ch,int fromlndex)</code>: 返回从 <code>fromlndex</code> 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</p>
</li>
<li><p>编译JavaApplication源程序文件将产生相应的字节码文件，这些字节码文件的扩展名为<strong>D</strong></p>
<p>A. .html</p>
<p>B. .Java</p>
<p>C. .exe</p>
<p><strong>D. .class</strong></p>
</li>
<li><p>字符串比较。Java中，使用”&#x3D;&#x3D;”比较字符串时，判断的是两个字符串是否存放在相同的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：x = <span class="string">&quot;Hello&quot;</span>; y = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">x == y; <span class="comment">//就是True</span></span><br><span class="line"></span><br><span class="line">x == <span class="string">&quot;Hello&quot;</span>; <span class="comment">//也是True</span></span><br><span class="line"></span><br><span class="line">如果 String z=<span class="keyword">new</span> <span class="title class_">String</span>(x);</span><br><span class="line">x==z;<span class="comment">//结果就是false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Java语言中，关于final修饰符的说法不正确的是 C</p>
<p><strong>A.fnal成员变量表示常量，只能被赋值一次，赋值后值不再改变</strong></p>
<p><strong>B.final类不能被继承，没有子类，fnal类中的方法默认是final的</strong></p>
<p>C.final能用于修饰构造方法</p>
<p><strong>D.final方法不能被子类的方法覆盖，但可以被继承</strong></p>
<p> final修饰的类，为最终类，该<strong>类不能被继承</strong>。如String 类；final修饰的<strong>方法可以被继承和重载</strong>，但不能被重写、覆盖；final修饰的变量不能被修改，是个<strong>常量</strong></p>
</li>
<li><p>main是static，所以不能直接调用非静态的方法</p>
</li>
<li><p>方法重载就是一个类中有多个同名但有<strong>不同形参和方法体</strong>的方法 对</p>
</li>
<li><p>Java String类 trim() 方法用于删除字符串的头尾空白符</p>
</li>
</ul>
<h2 id="大题模板"><a href="#大题模板" class="headerlink" title="大题模板"></a>大题模板</h2><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="comment">//第一种</span></span><br><span class="line">		Iterator&lt;String&gt; iterator=list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">			iterator.remove();<span class="comment">//移除</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第二种</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			System.out.println(list.get(i));</span><br><span class="line">			list.remove(i)<span class="comment">//移除</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>截取部分输出 <code>it=tree.SubSet(头,尾).iterator();</code>  <code>it=tree.headSet(边界).iterator();</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TreeSet&lt;UpdateStu&gt;tree =<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">UpdateStu stu1=<span class="keyword">new</span> <span class="title class_">UpdateStu</span>(<span class="string">&quot;李同学&quot;</span>, <span class="number">01011</span>);</span><br><span class="line">UpdateStu stu2=<span class="keyword">new</span> <span class="title class_">UpdateStu</span>(<span class="string">&quot;陈同学&quot;</span>,<span class="number">01021</span>);</span><br><span class="line">...;</span><br><span class="line">tree.add(stu1);</span><br><span class="line">tree.add(stu2);</span><br><span class="line">tree.add(stu3);</span><br><span class="line">tree.add(stu4);</span><br><span class="line">Iterator&lt;UpdateStu&gt; it=tree.iterator();</span><br><span class="line">it=tree.headSet(stu2).iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;截取前面部分的集合：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());			</span><br><span class="line">&#125;</span><br><span class="line">it=tree.subSet(stu2, stu3).iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;截取中间部分的集合&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">	System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h3><h4 id="字节流创建–输入–读取"><a href="#字节流创建–输入–读取" class="headerlink" title="字节流创建–输入–读取"></a>字节流创建–输入–读取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;MyFile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>写入文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream outputStream=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);<span class="comment">//创建输出流</span></span><br><span class="line"><span class="type">byte</span> buy[]=<span class="string">&quot;Java程序设计&quot;</span>.getBytes();<span class="comment">//准备字节数组</span></span><br><span class="line">outputStream.write(buy);<span class="comment">//写入</span></span><br><span class="line">outputStream.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileOutputStream里放file，准备byte[]是字符串.getBytes()，写入用write</p>
</blockquote>
<p>读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream inputStream=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//准备输入流</span></span><br><span class="line"><span class="type">byte</span> byt[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//准备字节数组接收</span></span><br><span class="line"><span class="type">int</span> len=inputStream.read(byt);<span class="comment">//read读取</span></span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读取用read，返回值是长度</p>
</blockquote>
<p>文件信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;文件长度：&quot;</span>+file.length()+<span class="string">&quot;字节&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;文件路径：&quot;</span>+file.getAbsolutePath());</span><br><span class="line">SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;YYYY-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;修改时间&quot;</span>+simpleDateFormat.format(file.lastModified()));</span><br></pre></td></tr></table></figure>

<h4 id="缓存-字符流"><a href="#缓存-字符流" class="headerlink" title="(缓存)字符流"></a>(缓存)字符流</h4><p>写入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">String str=<span class="string">&quot;你好&quot;</span>;</span><br><span class="line">bw.write(str);<span class="comment">//写入字符串</span></span><br><span class="line">bw.newLine();<span class="comment">//写入换行符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileWriter里放file，Buffered里放FW，写入用write，换行符newLine()</p>
</blockquote>
<p>读取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">String tmp=<span class="literal">null</span>;<span class="comment">//缓存临时字符串</span></span><br><span class="line"><span class="keyword">while</span> ((tmp=br.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(tmp);<span class="comment">//输出每一行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FileReader里放file，BufferedReader里放FR，读取每一行用br.readLine()，字符串存</p>
</blockquote>
<h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyJDialog</span> <span class="keyword">extends</span> <span class="title class_">JDialog</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyJDialog</span><span class="params">(MyFrame frame)</span> &#123;<span class="comment">//参数是MyFrame</span></span><br><span class="line">		<span class="built_in">super</span>(frame,<span class="string">&quot;这是一个对话框&quot;</span>,flase);<span class="comment">//窗体、标题、是否阻塞</span></span><br><span class="line">		Container container=getContentPane();<span class="comment">//获取主窗体</span></span><br><span class="line">		container.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;这是一个对话框&quot;</span>));<span class="comment">//在容器中添加标签</span></span><br><span class="line">		setBounds(<span class="number">120</span>,<span class="number">120</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//设置对话框在桌面显示的坐标和大小</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyFrame</span><span class="params">()</span> &#123;</span><br><span class="line">		Container container=getContentPane();<span class="comment">//获取窗体主容器</span></span><br><span class="line">		</span><br><span class="line">		bl.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">MyJDialog</span>(MyFrame.<span class="built_in">this</span>).setVisible(<span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		container.add(bl);</span><br><span class="line">		setVisible(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">MyFrame</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组件.addAcitonListener里边new Actionlistener</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="消费生产栈"><a href="#消费生产栈" class="headerlink" title="消费生产栈"></a>消费生产栈</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ms</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Thread consume;</span><br><span class="line">	<span class="keyword">private</span> Thread product;</span><br><span class="line">	<span class="keyword">private</span> Random random=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; st=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ms</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		product=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(count&lt;<span class="number">10</span>)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="type">int</span> s=random.nextInt(<span class="number">1000</span>);</span><br><span class="line">								st.push(s);</span><br><span class="line">								count++;</span><br><span class="line">								System.out.println(<span class="string">&quot;生产数据&quot;</span>+s);</span><br><span class="line">								Thread.sleep(<span class="number">1</span>);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span></span><br><span class="line">								Thread.sleep(<span class="number">100</span>);</span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">						&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;&#125;);</span><br><span class="line">		product.start();</span><br><span class="line">		</span><br><span class="line">		consume=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">						<span class="keyword">try</span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">							&#123;								</span><br><span class="line">								<span class="type">int</span> s=st.pop();</span><br><span class="line">								count--;</span><br><span class="line">								System.out.println(<span class="string">&quot;消费数据：&quot;</span>+s);</span><br><span class="line">								Thread.sleep(<span class="number">1</span>);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">else</span> </span><br><span class="line">								Thread.sleep(<span class="number">100</span>);</span><br><span class="line">						&#125; </span><br><span class="line">						<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">						&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;&#125;);</span><br><span class="line">		consume.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lab14_4</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">ms</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><h4 id="TCP-双向通信"><a href="#TCP-双向通信" class="headerlink" title="TCP 双向通信"></a>TCP 双向通信</h4><h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><p>接收用BufferReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySever</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ServerSocket sever;<span class="comment">//创建热线</span></span><br><span class="line">    <span class="keyword">public</span> Socket socket;<span class="comment">//客服</span></span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;<span class="comment">//输出流</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        server=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8998</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            socket=server.accept();<span class="comment">//等待接收，阻塞</span></span><br><span class="line">            <span class="comment">//套接字客服传信息，用缓存输入流，里边是InputStreamReader，再里边是socket.getInputStream</span></span><br><span class="line">            BufferedReader reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream));</span><br><span class="line">            writer=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream,<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="comment">//又一个</span></span><br><span class="line">                <span class="comment">//字符串接数据 readerLine()</span></span><br><span class="line">                String message=reader.readerLine();</span><br><span class="line">                wrter.println(<span class="string">&quot;收到，谢谢你！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();<span class="comment">//先关流</span></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>socket.getInputStream就是文件存取的file，类比一下，而InputStreamReader就是FileReader</p>
</blockquote>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>发出用PrintWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClient</span>&#123;</span><br><span class="line">    Socket socket;<span class="comment">//套接字</span></span><br><span class="line">    <span class="keyword">private</span> PrintWriter writer;<span class="comment">//写数据，用PrintWriter而不是Buffer</span></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;<span class="comment">//输入流，读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//一些修饰，如swing之类的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传数据</span></span><br><span class="line">        String message=<span class="string">&quot;hello&quot;</span>;<span class="comment">//准备数据</span></span><br><span class="line">        writer.println(message);<span class="comment">//传输即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接另外写一个函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span>&#123;</span><br><span class="line">        socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8998</span>);<span class="comment">//绑定ip和端口</span></span><br><span class="line">        writer=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(),<span class="literal">true</span>);<span class="comment">//创建流，一层就够了</span></span><br><span class="line"> 		<span class="comment">//接收信息</span></span><br><span class="line">        reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInpuString));</span><br><span class="line">        <span class="comment">//准备线程</span></span><br><span class="line">        readThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                String message=reader.reaLine();</span><br><span class="line">                syso(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>connect里：绑定端口指定ip，准备流</p>
<p>构造里：writer.println传数据</p>
</blockquote>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><h5 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定地址</span></span><br><span class="line"><span class="comment">//实例化，绑定端口</span></span><br><span class="line"><span class="comment">//加入组</span></span><br><span class="line"><span class="comment">//构造里配置，run里边接收/发送</span></span><br><span class="line"><span class="comment">//准备DataPackage，字符转字节数组，发送socket.send()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Notification</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="type">int</span> port;<span class="comment">//端口</span></span><br><span class="line">    InetAddress iAddress=<span class="literal">null</span>;<span class="comment">//ip</span></span><br><span class="line">    MulticastSocket socket=<span class="literal">null</span>;<span class="comment">//MulticastSocket socket</span></span><br><span class="line">    String weather=<span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//发送的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receive</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//配置</span></span><br><span class="line">    	<span class="comment">//指定地址</span></span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		port=<span class="number">9898</span>;</span><br><span class="line">			iAddress=InetAddress.getByName(<span class="string">&quot;224.255.10.0&quot;</span>);<span class="comment">//getByName返回的InetAddress</span></span><br><span class="line">			MulticastSocket socket=<span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(port);</span><br><span class="line">			socket.setTimeToLive(<span class="number">1</span>);</span><br><span class="line">			socket.joinGroup(iAddress);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">// 发送信息</span></span><br><span class="line">    	<span class="comment">//准备</span></span><br><span class="line">    	DatagramPacket packet=<span class="literal">null</span>;</span><br><span class="line">    	<span class="type">byte</span> data[]=weather.getBytes();<span class="comment">//字符转字节数组</span></span><br><span class="line">    	packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, iAddress, port);</span><br><span class="line">    	socket.send(packet);</span><br><span class="line">    	sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组</p>
<p>run()里边：准备包，字符转字节数组，实例化DatagramPacket，socket.send(packet)</p>
</blockquote>
<h5 id="客户机端"><a href="#客户机端" class="headerlink" title="客户机端"></a>客户机端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receive</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> port;<span class="comment">//端口</span></span><br><span class="line">    InetAddress group=<span class="literal">null</span>;<span class="comment">//ip</span></span><br><span class="line">    MulticastSocket socket=<span class="literal">null</span>;<span class="comment">//MulticastSocket socket</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Receive</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//配置</span></span><br><span class="line">    	<span class="comment">//指定地址</span></span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">    		port=<span class="number">9898</span>;</span><br><span class="line">    		group=InetAddress.getByName(<span class="string">&quot;224.255.10.0&quot;</span>);<span class="comment">//getByName返回的InetAddress</span></span><br><span class="line">			MulticastSocket socket=<span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(port);</span><br><span class="line">			socket.joinGroup(group);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="type">byte</span> bty[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    	DatagramPacket packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bty, bty.length, group, port);</span><br><span class="line">    	<span class="keyword">try</span> &#123;</span><br><span class="line">			socket.receive(packet);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    	String message=<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">    	System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>构造里边：构造里边配置：getName获取指定地址，实例化MulticastSocket绑定端口，socket加入组</p>
<p>run()里边：准备字节数组，实例化DatagramPacket，socket.receive(packet)，然后new String(packet.getData(), packet.getLength())packet转字符</p>
</blockquote>
<p>main函数当作类外的函数来看待</p>
<p>1、包内访问权限和protected有何不同？(p98)</p>
<p>包内访问权限介于private和protected之间</p>
<p>包外的派生类，可以在派生类内部调用基类的protected成员</p>
<p>包外的派生类，无法在派生类内部调用基类的包内访问成员</p>
<ul>
<li>当两个包在同一个项目之中时，可以通过完整类目继承包外的基类访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Lab2;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">newClass</span> <span class="keyword">extends</span> <span class="title class_">Lab1</span>.myClass&#123;<span class="comment">//包名.类名</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当两个包在不同的项目之中时，将基类项目导出为.jar，将该.jar文件复制到派生类所在的项目文件夹中，然后右键点击选择”add building path”添加到构建路径，然后代码与上面相同。</li>
</ul>
<p>2、所有数组都能排序吗？</p>
<p>错误。排序要有一定依据，没有指定依据无法排序。如类型为类的数组，可比较的属性不止一种（implements比较器)。</p>
<p>3、接口</p>
<p>接口的本质是标准，是设计者、实现者，调用者之间的桥梁</p>
<ul>
<li><p>类内实现的可比较器Comparable，由被比较的类implements实现，重写<code>compareTo</code>函数</p>
</li>
<li><p>类外实现的可比较器Comparator，由另外一个类implements实现，重写<code>compare</code>函数</p>
<ul>
<li>如果是一次性的考虑用<strong>匿名内部类</strong>来实现比较器。否则这个只用一次的有名字的类可能会对代码理解造成困扰。</li>
</ul>
</li>
</ul>
<h1 id="基本输入输出范例代码"><a href="#基本输入输出范例代码" class="headerlink" title="基本输入输出范例代码"></a>基本输入输出范例代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> n=sc.nextInt();</span><br><span class="line">String str1=sc.next();</span><br><span class="line">System.out.println(<span class="string">&quot;欢迎&quot;</span>+n+<span class="string">&quot;号同学&quot;</span>+str1);</span><br></pre></td></tr></table></figure>



<h1 id="第四章-流程控制"><a href="#第四章-流程控制" class="headerlink" title="第四章 流程控制"></a>第四章 流程控制</h1><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="foreach语句"><a href="#foreach语句" class="headerlink" title="foreach语句"></a>foreach语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型x:遍历对象obj)&#123;</span><br><span class="line">    引用了x的java语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子：</strong>遍历一维数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Repetition</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[]=&#123;<span class="number">5</span>,<span class="number">13</span>,<span class="number">96</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;一维数组中的元素分别为：&quot;</span>);</span><br><span class="line">        <span class="comment">//x的类型与arr元素的类型相同 。for循环依次取出arr中的值并赋给x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:arr)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">一维数组中的元素分别为：</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">13</span></span><br><span class="line"><span class="comment">96</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h1 id="第五章-数组"><a href="#第五章-数组" class="headerlink" title="第五章 数组"></a>第五章 数组</h1><h2 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><ul>
<li><code>Arrays.sort(arr);</code></li>
<li><code>Arrays.parallelSort(arr);</code>多线程排序，数据量大于一百万</li>
</ul>
<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><h4 id="copyof-方法"><a href="#copyof-方法" class="headerlink" title="copyof()方法"></a>copyof()方法</h4><p>语法：<code>int a[]=Arrays.copyOf(arr,int newlength);</code></p>
<ul>
<li>newlength：复制后新数组的长度</li>
</ul>
<blockquote>
<p>！注：不能直接<code>a=b</code>，数组名是指针常量（常指针）</p>
</blockquote>
<h1 id="第六章-类和对象"><a href="#第六章-类和对象" class="headerlink" title="第六章 类和对象"></a>第六章 类和对象</h1><h2 id="面向对象概述"><a href="#面向对象概述" class="headerlink" title="面向对象概述"></a>面向对象概述</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>避免外部操作对内部数据的影响，提高程序的可维护性</li>
<li>提高工作效率，把无需调用者关心的内容隐藏，简化编程，知道面对外部的接口能调用即可</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>对于人来说，</strong></p>
<p>public：学历、知识（别人抢不走的）</p>
<p>protected：身体等</p>
<p>public：很多</p>
<p><strong>protected同包其他类或子类(继承)可见，其他包的类或子类不可见；private都不可见，只有本类可见。</strong></p>
<h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>this关键字用于表示本类当前的对象，只能在本类中使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;<span class="comment">//定义一个setName()的方法</span></span><br><span class="line">    <span class="built_in">this</span>.name=name;<span class="comment">//将参数值赋予类中的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h2><blockquote>
<p>Java类内的属性值不支持默认值，不能直接定义 <code>int count=0</code> </p>
<p>应使用默认构造函数初始化</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">eggCake</span>&#123;</span><br><span class="line">    <span class="type">int</span> eggCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EggCake</span><span class="params">(<span class="type">int</span> eggCount)</span>&#123;<span class="comment">//有参构造</span></span><br><span class="line">        <span class="built_in">this</span>.eggCount=eggCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EggCake</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//设置鸡蛋灌饼里蛋的个数为1</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lab2_1</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Lab2_1</span>().show();<span class="comment">//临时无名对象</span></span><br><span class="line">        <span class="comment">//如果是show.()直接调用会报错，除非把show 声明为静态函数，说这是上面的方法，调用类内成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类内静态成员共用一份空间</p>
<p>如果函数</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lab2_1</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Lab2_1 l2=<span class="keyword">new</span> <span class="title class_">Lab2_1</span>();</span><br><span class="line">        <span class="comment">//l2=null; 销毁对象 之后如果是l2.show();那么会报错NullPointerException </span></span><br><span class="line">    &#125;<span class="comment">//超过作用域 对象l2销毁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第七章-继承、多态、抽象类与接口"><a href="#第七章-继承、多态、抽象类与接口" class="headerlink" title="第七章 继承、多态、抽象类与接口"></a>第七章 继承、多态、抽象类与接口</h1><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><h3 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a>extends 关键字</h3><p>语法：<code>CHild extends Parents</code></p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p><strong>Object类是一切类的基类</strong>，隐含的继承</p>
<ul>
<li><p>如果没声明，toString()一定是调用自Object类，输出是字符编号。</p>
</li>
<li><p>输出字符串自动会调用toString()函数，应当重写以达到需要的输出目的。</p>
</li>
<li><p>重写只能保持或扩大访问权限，如原本是Public不能改成Private。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//加这个帮助检查重写的函数名是否正确</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我叫&quot;</span>+name+<span class="string">&quot;,今年&quot;</span>+age+<span class="string">&quot;岁。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Student s1=<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">16</span>);</span><br><span class="line">        System.out.println(s1);<span class="comment">//就是System.out.println(s1.toString());</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对象的类型转换"><a href="#对象的类型转换" class="headerlink" title="对象的类型转换"></a>对象的类型转换</h2><p><strong>需要基类对象的任何地方，都可以用派生类对象替代</strong></p>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><h2 id="instanceof关键字判断对象类型"><a href="#instanceof关键字判断对象类型" class="headerlink" title="instanceof关键字判断对象类型"></a>instanceof关键字判断对象类型</h2><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><blockquote>
<p> 函数的返回值类型不属于重载的依据</p>
</blockquote>
<h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>最终的、终态</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>只要类中有一个抽象方法，此类就是抽象类</li>
<li>抽象类不能实例化，抽象类存在的目的就是为了被继承</li>
<li>c++中全是抽象方法就叫纯虚类</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>只能声明，不能实现</li>
</ul>
<h1 id="第9章-异常处理"><a href="#第9章-异常处理" class="headerlink" title="第9章 异常处理"></a>第9章 异常处理</h1><p>异常与错误：</p>
<p>一个不好的问题发生了，如果对该问题提前有应对措施，就是<strong>异常处理</strong>；</p>
<p>如果没有任何准备，就是<strong>错误</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//想要正确执行，但是不可控的语句段</span></span><br><span class="line">    <span class="comment">//数据输入输出、网络连接、文件读写、数据库连接访问</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//可以有多个catch语句，捕获不同的异常 </span></span><br><span class="line">    <span class="comment">//必须是小范围异常(异常类)在前，Exception必须放在最后，Exception是所有异常的基类，范围最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管是否有捕获异常，都想要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第10章-字符串"><a href="#第10章-字符串" class="headerlink" title="第10章 字符串"></a>第10章 字符串</h1><p>String类，字符常量存储。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);<span class="comment">//相当于String s = new String(&quot;good&quot;)</span></span><br></pre></td></tr></table></figure>

<p>截取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[]=&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a,<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//相当于String s = new String(&quot;oo&quot;)</span></span><br></pre></td></tr></table></figure>



<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p><code>int+&#39;&#39;</code>把<code>int</code>转为<code>String</code>类型</p>
<h2 id="获取字符串信息"><a href="#获取字符串信息" class="headerlink" title="获取字符串信息"></a>获取字符串信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s[<span class="number">0</span>]);<span class="comment">//是错误的</span></span><br><span class="line">System.out.println(s.charAt[<span class="number">0</span>]);<span class="comment">//才对</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串的查找"><a href="#字符串的查找" class="headerlink" title="字符串的查找"></a>字符串的查找</h3><p><code>indexOf(String s)</code> 区分大小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;We are students&quot;</span>;</span><br><span class="line"><span class="type">int</span> size=str.indexOf(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">int</span> size2=str.toLowerCase().indexOf(<span class="string">&quot;a&quot;</span>);<span class="comment">//转为小写再查找，这个toLowerCase()或toUpperCase()是生成新的字符串对象，不会修改原来的字符串</span></span><br></pre></td></tr></table></figure>



<h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="获取字符串"><a href="#获取字符串" class="headerlink" title="获取字符串"></a>获取字符串</h3><p>substring(int beginIndex)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">String substr=str.substring(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p><code>replace()</code></p>
<p><code>replaceAll()</code>支持正则表达式</p>
<h3 id="判断相等"><a href="#判断相等" class="headerlink" title="判断相等"></a>判断相等</h3><p><code>equals()</code>而不是用<code>==</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1==s2);<span class="comment">//结果是true</span></span><br><span class="line">System.out.println(s3==s4);<span class="comment">//结果是false</span></span><br></pre></td></tr></table></figure>

<p>如果直接等号赋值，就是基本数据类型，用<code>==</code>可以判断；当用<code>new</code>，把变量当对象来看待，两个对象不可能相等，因此只能用<code>equals()</code>来判断相等。</p>
<p>equals在基本数据类型比较的是值，引用数据类型对象、数组、函数比较的是地址，如果要比较值需要重写equals。String是已经重写好equals了的</p>
<p>没重写之前两者都是比较地址，重写之后前者比较地址后者比较值</p>
<p>比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">       <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">       <span class="keyword">return</span> name.equalsIgnoreCase(person.getName().trim());</span><br><span class="line">     &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String regex1=<span class="string">&quot;[a-zA-Z_$]+[a-zA-Z_$]*&quot;</span>;<span class="comment">//</span></span><br><span class="line">String regex2=<span class="string">&quot;[1-9][0-9]&#123;4,10&#125;*&quot;</span>;<span class="comment">//qq号码规则</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lesson5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegExp</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		String contentString=<span class="string">&quot;1998,1239,12,144&quot;</span>;</span><br><span class="line">		<span class="comment">//1.\\d表示一个任意的数字</span></span><br><span class="line">		String regString=<span class="string">&quot;\\d\\d\\d\\d&quot;</span>;<span class="comment">//找四个连续的数字,分组的话是(//d)(//d)</span></span><br><span class="line">		<span class="comment">//2.创建模式对象[即正则表达式对象]</span></span><br><span class="line">		Pattern pattern=Pattern.compile(regString);</span><br><span class="line">		<span class="comment">//3.创建匹配器</span></span><br><span class="line">		<span class="comment">//说明：创建匹配器matcher，按照正则表达式的规则去匹配content字符串</span></span><br><span class="line">		Matcher matcher=pattern.matcher(contentString);</span><br><span class="line">		<span class="comment">//4.开始匹配</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * match.find()完成的任务 (考虑分组，如(//d//d)(//d//d))</span></span><br><span class="line"><span class="comment">		 * 1. 根据给定的规则，定位满足规则的字符串（如1999,分组即(19)(99))</span></span><br><span class="line"><span class="comment">		 * 2. 找到时，将字符串的开始的索引记录到matcher对象的属性 int[] groups;</span></span><br><span class="line"><span class="comment">		 *    2.1groups[0]=0，把该子字符串的结束的索引+1的值记录到group[1]=35,+1是因为取字符串左闭右开</span></span><br><span class="line"><span class="comment">		 *    2.2 记录第一组()匹配的字符串的区间group[2]=0,group[3]=2</span></span><br><span class="line"><span class="comment">		 *    2.3 记录第二组()匹配的字符串的区间group[4]=2,group[5]=4</span></span><br><span class="line"><span class="comment">		 *    2.4 如果有更多分组以此类推</span></span><br><span class="line"><span class="comment">		 * 3. 同时记录oldLast的值为子字符串的结束的索引+1的值即5，那下一次执行find时，从5开始匹配</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;找到：&quot;</span>+matcher.group(<span class="number">0</span>));<span class="comment">//group(0)记录找到的字符串开头,同时可以找到结尾</span></span><br><span class="line">			System.out.println(<span class="string">&quot;第一组()的值： &quot;</span>+matcher.group(<span class="number">1</span>));<span class="comment">//19</span></span><br><span class="line">			System.out.println(<span class="string">&quot;第二组()的值： &quot;</span>+matcher.group(<span class="number">2</span>));<span class="comment">//99</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>检索特殊字符要用转义符号<code>\\</code>，在java的正则表达式中两个<code>\\</code>代表其他语言一个<code>\</code></p>
<h4 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>实例</th>
<th>说明</th>
<th>匹配输入</th>
</tr>
</thead>
<tbody><tr>
<td><code>[ ]</code></td>
<td>匹配任意一个</td>
<td><code>[efgh]</code></td>
<td>e,f,g,h任意一个</td>
<td>e,f,g,h</td>
</tr>
<tr>
<td><code>[^ ]</code></td>
<td>排除</td>
<td><code>[^abc]</code></td>
<td>除了abc之外的任意一个字符包括数字和特殊符号</td>
<td>d,f,p</td>
</tr>
<tr>
<td><code>.</code></td>
<td>匹配除\n以外的任何字符</td>
<td><code>a..b</code></td>
<td>a开头b结尾中间任意两个字符</td>
<td>aaab,a#*b</td>
</tr>
<tr>
<td><code>\\d</code></td>
<td>匹配单个数字字符相当于{0-9}</td>
<td><code>\\d&#123;3&#125;&#123;\\d&#125;?</code></td>
<td>包含3个或4个数字的字符串</td>
<td>123,9876</td>
</tr>
<tr>
<td><code>\\D</code></td>
<td>匹配单个非数字字符，相当于<code>[^0-9]</code></td>
<td><code>\\D&#123;\\d&#125;*</code></td>
<td>以单个非数字字符开头后接任意个数字的字符串</td>
<td>a,A342</td>
</tr>
<tr>
<td><code>\\w</code></td>
<td>匹配单个数字、大小英文写字母，下划线，相当于<code>[0-9a-zA-Z_]</code></td>
<td><code>\\d&#123;3&#125;\\w&#123;4&#125;</code></td>
<td>以3个数字字符开头的任意长度为7的数字字母字符串</td>
<td>234abcd、1234Pe</td>
</tr>
<tr>
<td><code>\\W</code></td>
<td>匹配单个非数字、大小写字母和下划线字符，相当于<code>[^0-9a-zA-Z_]</code></td>
<td><code>\\W+\\d&#123;2&#125;</code></td>
<td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td>
<td></td>
</tr>
<tr>
<td><code>\\s</code></td>
<td>匹配任何空白字符(空格，制表符等)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\\S</code></td>
<td>匹配任何非空白字符</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>\\.</code></td>
<td>匹配除\n之外的所有字符</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>区分大小写</strong></p>
<p>默认区分大小写，如模式串写<code>&quot;abc&quot;</code>匹配出来abc而<code>(?i)abc</code>表示不区分大小写,<code>a(?i)bc</code>是bc不区分大小写</p>
<h2 id="常用类库"><a href="#常用类库" class="headerlink" title="常用类库"></a>常用类库</h2><h3 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h3><p>能在int类型和String类型之间互相转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;456&quot;</span>);<span class="comment">//返回包含在由str指定的字符串中的数字的等价整数值</span></span><br><span class="line">Integer iNum=Integer.valueOf(<span class="string">&quot;456&quot;</span>);<span class="comment">//返回保存指定的String值的Integer对象</span></span><br><span class="line">iNum.equal(num);<span class="comment">//比较，返回值是true</span></span><br></pre></td></tr></table></figure>

<h3 id="Double类"><a href="#Double类" class="headerlink" title="Double类"></a>Double类</h3><p>是Number类的子类，都是对浮点数进行操作。Double类在对象中包装一个基本类型为double的值，每个Double类的对象都包含一个double类型的字段。可将String和double相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double dNum=Double.valueOf(<span class="string">&quot;3.14&quot;</span>);</span><br><span class="line">Double.isNaN(dNum.doubleValue());<span class="comment">//是否返回非数字(NaN)值</span></span><br><span class="line">dNum.intValue();<span class="comment">//转为int类型</span></span><br></pre></td></tr></table></figure>

<h3 id="Boolean类"><a href="#Boolean类" class="headerlink" title="Boolean类"></a>Boolean类</h3><p>当 String 的参数值在不区分大小写的时候等于 “true” ，则 Boolean.valueOf(String) 返回值为 true；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Boolean b1=Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Boolean b2=Boolean.valueOf(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">b1.booleanValue();<span class="comment">//将Boolean对象的值以对应的boolean值返回，值为true</span></span><br><span class="line">b2.booleanValue();<span class="comment">//值为false</span></span><br></pre></td></tr></table></figure>

<h3 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h3><p>字符大小转小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Character mychar1=Character.valueOf(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//返回保存指定char值的Character对象</span></span><br><span class="line">Character.isUpperCase(mychar1);<span class="comment">//判断是否为大写字母</span></span><br><span class="line">Character.toUpperCase(mychar1);<span class="comment">//转为大写</span></span><br><span class="line">Character.toLowerCase(mychar1);<span class="comment">//转小写，不改变原来字符串</span></span><br></pre></td></tr></table></figure>

<h1 id="第12章-集合类"><a href="#第12章-集合类" class="headerlink" title="第12章 集合类"></a>第12章 集合类</h1><pre class="mermaid">graph LR
A[集合类]-->集合类概述
A-->Collection接口
A-->List集合
A-->Set集合
A-->Map集合</pre>

<h2 id="集合类概述"><a href="#集合类概述" class="headerlink" title="集合类概述"></a>集合类概述</h2><p>集合与数组</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>数组</th>
<th>集合</th>
</tr>
</thead>
<tbody><tr>
<td>长度</td>
<td>长度固定</td>
<td>长度可变</td>
</tr>
<tr>
<td>存放的东西</td>
<td>存放基本数据类型</td>
<td>存放对象的引用</td>
</tr>
</tbody></table>
<pre class="mermaid">graph LR
HashMap-->A[Map]
TreeMap-->A
HashSet-->B[Set]
TreeSet-->B
ArrayList-->C[List]
LinkedList-->C
C-->D[Collection]
B-->D
A-->Java.lang.Object
D-->Java.lang.Object</pre>

<h2 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;类名&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//尖括号只能呢是类，比如不能放int要放integer</span></span><br></pre></td></tr></table></figure>

<p>方法：</p>
<ul>
<li><code>add(E e)</code></li>
<li><code>remove(Object o)</code></li>
<li><code>isEmpty()</code></li>
<li><code>iterator()</code></li>
<li><code>size()</code>  返回int型</li>
</ul>
<p>遍历集合通过迭代器(Iterator)来实现，只读且向前。Collection接口中的iterator()方法可返回在此Collection进行迭代的迭代器。</p>
<p>可以用foreach，可读可写，但是不能break，除非抛出异常。遍历修改迭代器(ListIterator)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Muster</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Collection&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="string">&quot;《Java从入门到精通》&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;《java实战》&quot;</span>);</span><br><span class="line">        lteratior&lt;String&gt; it=list.lterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            String str=(String)it.next();<span class="comment">//获取集合中的元素</span></span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><blockquote>
<p>List集合中的元素允许重复，各元素的顺序就是对象插入的顺序。类似Java数组，用户通过使用索引(元素在集合中的位置)来访问集合</p>
</blockquote>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><p>继承Collection接口，包含其所有方法。还定义两个重要的方法：</p>
<ul>
<li><code>get(int index)</code>：获取指定索引位置的元素</li>
<li><code>set(int index,Object obj)</code>：将集合中指定索引位置<code>index</code>的对象修改为指定的对象<code>obj</code></li>
</ul>
<h3 id="List接口的实现类"><a href="#List接口的实现类" class="headerlink" title="List接口的实现类"></a>List接口的实现类</h3><p>属于有序集合，不是自动排序的意思</p>
<ul>
<li><code>ArrayList</code>类 可变的数组，允许重复 允许null</li>
<li><code>LinkedList</code>类链表结构保存对象</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th><code>ArrayList</code></th>
<th><code>LinkedList</code></th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>根据索引快速访问</td>
<td>便于向集合插入和删除对象</td>
</tr>
<tr>
<td>缺点</td>
<td>插入或删除对象速度较慢</td>
<td>随机访问效率较低</td>
</tr>
</tbody></table>
<p>动态数组，索引存取</p>
<p>链表，存取有序，不是存到链表头就是链表尾</p>
<p><strong>实例化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;E&gt; list2=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>开头是List，后面别忘了&lt;&gt;</p>
</blockquote>
<h2 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h2><p><code>Set</code>集合传入的<code>Collection</code>对象<strong>不能有重复值</strong></p>
<p>Set接口实现的类：</p>
<ul>
<li><code>HashSet</code>类，由哈希表(HashMap实例)支持。允许null</li>
<li><code>TreeSet</code>类，还实现了Java.util.SortedSet接口</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th><code>HashSet</code></th>
<th><code>TreeSet</code></th>
</tr>
</thead>
<tbody><tr>
<td>区别</td>
<td>不保证Set集合的迭代顺序和顺序的恒久不变</td>
<td><strong>按自然顺序递增</strong>，也可按比较器实现排序</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;类名&gt; set=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>必须可比较，传入的对象的类必须是包装类(默认字典顺序)或者实现<code>comparable</code>接口的类</p>
<p>HashSet哈希存储，计算哈希值散列导不同位置，存取位置不能保证，效率高</p>
<p>TreeSet树存储，按照树结构对元素进行比较，放到合适位置，这也就说明，元素会按照树的性质去存储，那么也就无法保证存和取元素的顺序。但是元素可以在存储的时候根据自身的大小排好序，从而可以很轻易的找到最大值，最小值，以及给定一个元素，找到比他大和比他小元素等操作。</p>
<p>问：在定义对象类型时，应该定义为基类或接口的类型，还是派生类的类型？</p>
<ul>
<li><p>创建的时候<strong>类型不确定</strong>，先定义为基类；或如果定义为接口给别人调用就声明为基类。要<strong>专门调用</strong>派生类具有的功能直接声明为派生类。</p>
</li>
<li><p>但是定义为基类无法调用子类特有的成员，如<code>subSet()</code>是<code>TresSet</code>特有的，定义为基类时无法调用，除非强制转型为子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">TreeSet set2=((TreeSet&lt;Interger&gt;)set.)subSet(<span class="number">3</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>TreeSet增加的方法:</p>
<ul>
<li>first() 返回此Set集合第一个(最低)元素</li>
<li>last() 返回当前最后一个(最高)元素</li>
<li>comparator() 返回进行排序的比较器，若自然顺序则null</li>
<li>headSet(E toElement) 返回一个<strong>新Set集合</strong>是toElement对象(不包含)之前的所有对象</li>
<li>subSet(E fromElement,E toElement) 返回Set集合是fromElement对象与toElement之间的所有对象，<strong>含头不含尾</strong></li>
<li>tailSet(E fromElement) 返回包含fromElement之后所有对象</li>
</ul>
<blockquote>
<p>含头不含尾</p>
</blockquote>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><p>没有继承Collection接口，每个对象是<strong>键值</strong>(&lt;key,value&gt;)的形式。</p>
<blockquote>
<p> 每个key只能映射一个value；类要可比较；iterator()的next()输出的仅是key值</p>
</blockquote>
<p>Map接口除集合方法的特殊方法</p>
<ul>
<li>put(K key,V value)</li>
<li>containsKey(Object key) 若包含指定key的映射关系返回true</li>
<li>containsValue(Object value) 若将一个或多个key映射到指定值，返回true</li>
<li>get(Object key) 返回对象对应的值，否则null</li>
<li>values() 返回该集合所有值对象形成的Collection对象，用iterator()遍历输出</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>HashMap</th>
<th>TreeMap</th>
</tr>
</thead>
<tbody><tr>
<td>特点1</td>
<td>允许nul值和null键，键唯一</td>
<td>不允许值对象null(要排序的原因)</td>
</tr>
<tr>
<td>映射</td>
<td>通过哈希表</td>
<td>具有一定顺序</td>
</tr>
<tr>
<td>优缺</td>
<td>不保证顺序不变；快速访问</td>
<td>添加、删除、定位性能差；顺序排序</td>
</tr>
</tbody></table>
<blockquote>
<p>运用的时候使用HashMap类实现Map集合，当需要顺序输出时再创建一个完成相同映射关系的TreeMap类实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;java从入门到精通&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果key传入的是像Integer，String这样本身有序的，就会按字典序排列，而不是按哈希码。</p>
<p>原理：<code>add()</code>时用<code>hashcode</code>找哈希地址，用<code>equal()</code>看是否有存东西。如果是<code>false</code>就先并排放；若是<code>true</code>说明有了不用重复存。取值的时候找哈希地址，如果存在多个用<code>equal()</code>取具体的那一个。以上哈希码相同的情况为<strong>哈希冲突</strong>，同一个哈希地址可以存放多个不同对象。</p>
<p>优点：不用全部遍历，找到哈希地址再判断哪个是需要的取出即可。</p>
<h1 id="第13章-枚举类型与泛型"><a href="#第13章-枚举类型与泛型" class="headerlink" title="第13章 枚举类型与泛型"></a>第13章 枚举类型与泛型</h1><p>将“填空题”变为“选择题”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明为int/String类型方便switch case用</span></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">SeasonInterface</span>&#123;</span><br><span class="line">    <span class="type">int</span> Spring=<span class="number">1</span>,SUMMER=<span class="number">2</span>,AUTUMN=<span class="number">3</span>,WINTER=<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//开头隐含的public static final</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">SeasonEnum</span>&#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeasonDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSeason1</span><span class="params">(<span class="type">int</span> season)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(season)&#123;</span><br><span class="line">            <span class="keyword">case</span> SeasonInterface.SPRING:</span><br><span class="line">                System.out.println(<span class="string">&quot;这是春季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SeasonInterface.SUMMER:</span><br><span class="line">                System.out.println(<span class="string">&quot;这是夏季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SeasonInterface.AUTUMN:</span><br><span class="line">                System.out.println(<span class="string">&quot;这是秋季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SeasonInterface.WINTER:</span><br><span class="line">                System.out.println(<span class="string">&quot;这是冬季&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问：接口和枚举如何选择？</p>
<ul>
<li>接口一般是给别人来实现，功能可以更强大，如果不需要实现直接用枚举就行。</li>
<li>枚举优点：简单，运行效率高，类型安全</li>
</ul>
<h3 id="枚举类型中的构造方法"><a href="#枚举类型中的构造方法" class="headerlink" title="枚举类型中的构造方法"></a>枚举类型中的构造方法</h3><p>在枚举类型中，可以添加构造方法，但是规定这个构造方法必须被private修饰符所修饰。用于提示枚举值更加详细的含义、</p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="向上向下转型"><a href="#向上向下转型" class="headerlink" title="向上向下转型"></a>向上向下转型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类 a=<span class="keyword">new</span> 子类();<span class="comment">//向上转型</span></span><br><span class="line">子类 b=(子类)a;<span class="comment">//向下转型</span></span><br><span class="line">子类 b=<span class="keyword">new</span> 父类();<span class="comment">//！这是不可行的！</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object b;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(Object b)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.b=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Test t=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        t.setB(Boolean.valueOf(<span class="literal">true</span>));<span class="comment">//向上转型</span></span><br><span class="line">        System.out.println(t.getB());</span><br><span class="line">        t.setB(Float.valueOf(<span class="string">&quot;12.3&quot;</span>));</span><br><span class="line">        Float f=(Float)t.getB();<span class="comment">//向下转型</span></span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="定义泛型类"><a href="#定义泛型类" class="headerlink" title="定义泛型类"></a>定义泛型类</h3><p><code>Object</code>类为最上层的类，为了通用通常使传入的值与返回的值都以<code>Object</code>类型为主(<code>Object</code>太大了，不能统统用<code>Object</code>类)。当需要使用这些实例时，必须正确地将该实例<strong>转换为原来的类型</strong>，否则运行时将会发生<code>ClassCaseException</code>为了预防，<code>Java</code>提供泛型机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型&lt;T&gt;</span><br></pre></td></tr></table></figure>

<h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><h4 id="泛型限制"><a href="#泛型限制" class="headerlink" title="泛型限制"></a>泛型限制</h4><p>对泛型类的实例类型做了限制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LimitClass</span>&lt;T <span class="keyword">extends</span> <span class="title class_">List</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stirng[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//可以实例化已经实现List接口的类</span></span><br><span class="line">        LimitClass&lt;ArrayList&gt; l1=<span class="keyword">new</span> <span class="title class_">LimitClass</span>&lt;ArrayList&gt;();</span><br><span class="line">        <span class="comment">//这句是错误的，因为HashMap类没有实现List()接口</span></span><br><span class="line">        LimitClass&lt;HashMap&gt; l3=<span class="keyword">new</span> <span class="title class_">LimitClass</span>&lt;HashMap&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T extends Serializable&gt;</code> 序列化，泛型必须是<code>Serializable</code>的子类，可传<code>Integer</code>或<code>String</code></p>
<h4 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A&lt;?&gt; a;</span><br><span class="line">A&lt;? <span class="keyword">extends</span> <span class="title class_">anyClass</span>&gt; a;</span><br><span class="line">A&lt;?&gt; a= <span class="keyword">new</span> <span class="title class_">List</span>&lt;&gt;;<span class="comment">//这样是不可以的，实例化需要要具体的类型</span></span><br></pre></td></tr></table></figure>



<h1 id="第14章-lambda表达式与流处理"><a href="#第14章-lambda表达式与流处理" class="headerlink" title="第14章 lambda表达式与流处理"></a>第14章 lambda表达式与流处理</h1><p>将lambda表达式用来<strong>简化</strong>表示匿名函数，也就是没有名字的函数，提高开发<strong>效率</strong>。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用匿名类创建对象</span></span><br><span class="line">A a=<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;创建了接口的匿名对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//使用lambda表达式创建</span></span><br><span class="line">A a=()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;创建了接口的匿名对象&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>lamba表达式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">()-&gt;结果表达式</span><br><span class="line">参数-&gt;结果表达式</span><br><span class="line"><span class="comment">//多形参</span></span><br><span class="line">(参数<span class="number">1</span>,参数<span class="number">2</span>,...,参数n)-&gt;结果表达式</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AdditionInterface</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamterDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//lamba 表达式实现加法接口，返回参数相加的值(自动加return)</span></span><br><span class="line">        AdditionInterface np=(x,y)-&gt;x+y;</span><br><span class="line">        <span class="type">int</span> result=np.add(<span class="number">15</span>,<span class="number">26</span>);<span class="comment">//调用接口方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;相加结果：&quot;</span>+result);<span class="comment">//输出相加结果</span></span><br><span class="line">        <span class="comment">//而同一个接口可以实现不同的方法,关键在于接口的实现方式</span></span><br><span class="line">        AdditionInterface np2=(a,b)-&gt;a*b;</span><br><span class="line">        result=np2.add(a,b);</span><br><span class="line">        System.out.println(<span class="string">&quot;相乘结果：&quot;</span>+result);<span class="comment">//输出相乘结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>lamba表达式不能修改局部变量的值，只能使用</li>
</ul>
<h2 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h2><p>引用静态方法(复制一个已有的函数实现接口，甚至可以不需要这个已有函数内部是如何实现的)</p>
<p><code>类名::静态方法名</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StaticMethodInterface</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticM</span></span><br></pre></td></tr></table></figure>

<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p><code>Function&lt;T,R&gt;</code>,T:被操作的类型，可以理解为方法的参数类型；R：操作结果类型，方法的返回类型。</p>
<p><code>Iterator&lt;T&gt;</code>只读！</p>
<p><code>ListIterator&lt;T&gt;</code>才能修改list的元素</p>
<h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><p>Stream流只能被消费一次，之后失效</p>
<h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据转化为流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilerDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list=Employee.getEmpList();</span><br><span class="line">        Stream&lt;Employee&gt; stream=list.stream();</span><br><span class="line">        stream=stream.filter(people-&gt;people.getAge()&gt;<span class="number">30</span>);<span class="comment">//过滤出符合条件的数据</span></span><br><span class="line">        List&lt;Employee&gt; result=stream.collect(Collectors.toList());<span class="comment">//将流对象重新封装成一个List集合</span></span><br><span class="line">        List&lt;Employee&gt; result2=list.stream().filter(p-&gt;p.getDept().equals(<span class="string">&quot;开发部&quot;</span>)).peek(p-&gt;p.setSalary(p.getSalary()*<span class="number">10</span>)).collect(Collect.toList());<span class="comment">//过滤得到符合的让其工资翻十倍</span></span><br><span class="line">        <span class="keyword">for</span>(Employee emp:result)&#123;</span><br><span class="line">            System.out.println(emp);<span class="comment">//输出员工信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>filter(predicate类)</code>用lamba表达式不需要管类型，直接放进去</p>
<p><code>peek(consumer类型)和map()</code>一个里面不用返回值，一个需要。</p>
<p><code>collect()</code> 收集重新归类。</p>
<h1 id="第15章-I-x2F-O-输入与输出"><a href="#第15章-I-x2F-O-输入与输出" class="headerlink" title="第15章 I&#x2F;O(输入与输出)"></a>第15章 I&#x2F;O(输入与输出)</h1><pre class="mermaid">graph LR
A[I/O]-->输入/输出流
A-->File类
A-->文件输入/输出流
A-->带缓存的输入/输出流
A-->数据输入/输出流</pre>

<h2 id="输入-x2F-输出流"><a href="#输入-x2F-输出流" class="headerlink" title="输入&#x2F;输出流"></a>输入&#x2F;输出流</h2><p>程序从指向源的输入流中读取源中的数据。</p>
<p>各种数据源通过输入流传递到目的地</p>
<p>源通过数据流传递到各种数据输出目标</p>
<blockquote>
<p>InputStream类用来处理字节，不适合处理字符。而Java字符是Unicode编码，双字节，用Reader类处理。但注意Reader类不是InputStream的替换者，只是在处理字符串时简化了编程。</p>
</blockquote>
<p>read(byte[] b);返回值是读取到的字节数</p>
<h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><p><code>File</code>类是<code>java.io</code>包中<strong>唯一代表磁盘文件本身的类</strong>。因为是代表磁盘，操作要用try catch语句</p>
<p>三种构造方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname)</span><br><span class="line">File(String parent,String child)</span><br><span class="line">File(File f,String child)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;word.txt&quot;</span>);<span class="comment">//相对路径，是在项目目录下创建而不是在所在包类,此时是在内存中创建对象</span></span><br><span class="line">		<span class="comment">//File file2=new File(&quot;D:\\1.txt&quot;);//绝对路径</span></span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;<span class="comment">//如果存在</span></span><br><span class="line">            file.delete();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件已删除&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                file.createNewFile();<span class="comment">//这一步才真正在磁盘中创建文件</span></span><br><span class="line">                System.out.println(<span class="string">&quot;文件已创建&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>File类创建的是一个文件对象！说是在磁盘创建是错误的；除了在内存中的操作，其他都是不保证成功的，</p>
</blockquote>
<ul>
<li>getName() 文件名称</li>
<li>length() 文件的长度(以字节为单位)</li>
<li>isHidden() 判断是否隐藏文件，返回布尔值</li>
</ul>
<h2 id="文件输入-x2F-输出流"><a href="#文件输入-x2F-输出流" class="headerlink" title="文件输入&#x2F;输出流"></a>文件输入&#x2F;输出流</h2><h3 id="FileInputStream与FileOutputStream类"><a href="#FileInputStream与FileOutputStream类" class="headerlink" title="FileInputStream与FileOutputStream类"></a>FileInputStream与FileOutputStream类</h3><blockquote>
<p>是字节流，读取写入参数得是字节byte，读取汉字容易乱码</p>
</blockquote>
<ul>
<li>创建一个FileOutputStream对象时，可以指定不存在的文件，但是不能是已被其他程序打开的文件</li>
<li>文件输入流FileInputStream类实现！读取！，用read(byte[] b)，从磁盘输入到目的地</li>
<li>文件输出流FileOutputStream类实现！写入！，用write(byte[] b)，从程序输出到磁盘</li>
</ul>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileStreamDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\word.txt&quot;</span>);<span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="comment">//写入</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileOutputStream out=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(File);<span class="comment">//创建输出对象</span></span><br><span class="line">            <span class="type">byte</span> buy[]=<span class="string">&quot;我有一只小毛驴&quot;</span>.getBytes();<span class="comment">//写入内容的字节数组，字符串转转字节</span></span><br><span class="line">            out.write(buy);<span class="comment">//将字节写入到文件</span></span><br><span class="line">            out.close();<span class="comment">//关闭流</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            FileInputStream in=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//创建输入流</span></span><br><span class="line">            <span class="type">byte</span> byt[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//缓存字节流</span></span><br><span class="line">            <span class="type">int</span> len=in.read(byt[]);<span class="comment">//字节转字符串要用</span></span><br><span class="line">            System.out.println(<span class="string">&quot;文件的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(byt,<span class="number">0</span>,len));<span class="comment">//字节转为字符串输出</span></span><br><span class="line">            in.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileReader和FileWriter"><a href="#FileReader和FileWriter" class="headerlink" title="FileReader和FileWriter"></a>FileReader和FileWriter</h3><blockquote>
<p> 是字符流，读取写入参数字符串即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\word.txt&quot;</span>);<span class="comment">//创建文件对象</span></span><br><span class="line"><span class="comment">//写入</span></span><br><span class="line">FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);</span><br><span class="line">String word=<span class="string">&quot;我有一只小毛驴&quot;</span>;</span><br><span class="line">fw.write(word);</span><br><span class="line">fw.close();</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line">FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReade</span>(file);</span><br><span class="line"><span class="type">char</span> ch[]=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];<span class="comment">//缓存字符数组</span></span><br><span class="line"><span class="type">int</span> len=fr.read(ch);</span><br><span class="line">System.out.println(<span class="string">&quot;文件的信息是：&quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(ch,<span class="number">0</span>,len));<span class="comment">//字节转为字符串输出</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure>



<h2 id="带缓存的输入-x2F-输出流"><a href="#带缓存的输入-x2F-输出流" class="headerlink" title="带缓存的输入&#x2F;输出流"></a>带缓存的输入&#x2F;输出流</h2><p>缓存是I&#x2F;O的一种性能优化。缓存流增加了内存缓冲区，使得在流上执行<code>skip()</code>、<code>mark()</code>和<code>reset()</code>方法都成为可能。</p>
<h3 id="BufferedReader与BufferedWriter类"><a href="#BufferedReader与BufferedWriter类" class="headerlink" title="BufferedReader与BufferedWriter类"></a>BufferedReader与BufferedWriter类</h3><p>分别继承Reader类和Writer类，以<strong>行为单位</strong>进行输入&#x2F;输出</p>
<p>读取文件过程：</p>
<p>文件–&gt;<code>InputStream</code>–&gt;<code>InputStreamReader</code>–&gt;<code>BufferedReader</code>–&gt;字符数据</p>
<p>BufferReader类常用的方法：</p>
<ul>
<li>read() 读取单个字符</li>
<li>readLine() 读取一个文本行，返回字符串型。若无返回null</li>
</ul>
<p>BufferWriter类的方法都返回void:</p>
<ul>
<li>write(String s, int off, int len) 写入字符串的一部分</li>
<li>flush() 刷新流的缓存</li>
<li>newLine() 写入一个行分隔符</li>
</ul>
<blockquote>
<p>在使用<code>BufferedWriter</code>类的<code>Writer()</code>方法时，数据首先进入缓存区，<strong>没有立刻被写入输出流</strong>。如果想立即将缓存区中的数据写入输出流，一定要调用<code>flush()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));<span class="comment">//缓存输入流</span></span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="基本文件操作"><a href="#基本文件操作" class="headerlink" title="基本文件操作"></a>基本文件操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String content[]= &#123;<span class="string">&quot;好久不见&quot;</span>,<span class="string">&quot;最近好吗&quot;</span>,<span class="string">&quot;常联系&quot;</span>&#125;;</span><br><span class="line">		File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;word.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedWriter bWriter=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(file));<span class="comment">//文件字符输出流转缓冲输出流</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; content.length; k++) &#123;</span><br><span class="line">				bWriter.write(content[k]);<span class="comment">//写入字符串</span></span><br><span class="line">				bWriter.newLine();<span class="comment">//写入一个换行符</span></span><br><span class="line">			&#125;</span><br><span class="line">			bWriter.close();<span class="comment">//关闭缓冲输出流</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader bReader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(file));<span class="comment">//文件字符输入流转缓冲输入流</span></span><br><span class="line">			String tmpString=<span class="literal">null</span>;<span class="comment">//作为缓冲的临时字符串</span></span><br><span class="line">			<span class="type">int</span> i=<span class="number">1</span>;<span class="comment">//行数</span></span><br><span class="line">			<span class="comment">//从文件重读取一行，如果读出内容不为null，则进入循环</span></span><br><span class="line">			<span class="keyword">while</span> ((tmpString=bReader.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;行：&quot;</span>+tmpString);</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			bReader.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">第<span class="number">1</span>行：好久不见</span><br><span class="line">第<span class="number">2</span>行：最近好吗</span><br><span class="line">第<span class="number">3</span>行：常联系</span><br></pre></td></tr></table></figure>







<h3 id="获取网页源代码"><a href="#获取网页源代码" class="headerlink" title="获取网页源代码"></a>获取网页源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetPageCode</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="type">URL</span> <span class="variable">page</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			page = <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.qq.com&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">			<span class="comment">// TODO 自动生成的 catch 块</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> (HttpURLConnection) page.openConnection();</span><br><span class="line"></span><br><span class="line">		<span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(conn.getInputStream());</span><br><span class="line"></span><br><span class="line">		<span class="type">BufferedReader</span> <span class="variable">buff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(in);</span><br><span class="line">		String tmp=<span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">		<span class="comment">//从流中读出一行，如果内容不为null，则进入循环</span></span><br><span class="line">		<span class="keyword">while</span> ((tmp=buff.readLine())!=<span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.println(tmp);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第16章-反射与注释"><a href="#第16章-反射与注释" class="headerlink" title="第16章 反射与注释"></a>第16章 反射与注释</h1><p>实现访问、检测和修改描述Java对象本身信息的功能。</p>
<p><code>getCLass()</code>是Object类定义的，任何类都可以用，获取类信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Class newC=hashSet.getClass();<span class="comment">//获取hashSet的描述信息，假设hashSet是一本书，那newC是书的目录，作者等等基本信息但不包括内容</span></span><br><span class="line"><span class="comment">//查构造方法</span></span><br><span class="line">Constructor[] constructors=mewC.getDeclaredConstructor;</span><br><span class="line"><span class="keyword">for</span>(Constructor constructor:constructors)&#123;</span><br><span class="line">    System.out.println(constructor);<span class="comment">//找到构造函数foreach遍历显示</span></span><br><span class="line">&#125;</span><br><span class="line">declarednewC=newC.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields=demClass.getDeclaredFields();</span><br><span class="line">		<span class="keyword">for</span>(Field field:declaredFields) &#123;</span><br><span class="line">			System.out.println(field);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查成员方法 用户输入参数</span></span><br><span class="line">Method[] declaredMethods=demClass.getDeclaredMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method method:declaredMethods) &#123;</span><br><span class="line">			System.out.println(method);</span><br><span class="line">		&#125;</span><br><span class="line">		Scanner scanner=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		String key=scanner.next();</span><br><span class="line">		<span class="keyword">for</span>(Method method:declaredMethods) &#123;</span><br><span class="line">			<span class="keyword">if</span>(key.equals(<span class="string">&quot;size&quot;</span>)&amp;&amp;key.equals(method.getName())) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(method.invoke(hashSet));</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (key.equals(<span class="string">&quot;add&quot;</span>) &amp;&amp; key.equals(method.getName())) &#123;<span class="comment">//作判断才知道用户要做那个</span></span><br><span class="line">				<span class="type">String</span> <span class="variable">addString</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(method.invoke(hashSet, addString));</span><br><span class="line">					<span class="keyword">for</span> (String hash : hashSet) &#123;</span><br><span class="line">						System.out.print(hash+<span class="string">&quot; &quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br></pre></td></tr></table></figure>



<h1 id="第18章-Swing程序设计"><a href="#第18章-Swing程序设计" class="headerlink" title="第18章 Swing程序设计"></a>第18章 Swing程序设计</h1><h2 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h2><pre class="mermaid">graph LR
javax.swing.JLabel-->D[javax.swing.JComponent]
Javax.swing.JPanel-->D
javax.swing.JDialog-->A[java.awt.Dialog]
javax.swing.JFrame-->B[java.awt.Frame]
A-->C[java.awt.Window]
B-->C
D-->E[java.awt.Container]
C-->E
E-->F[java.awt.Component]
F-->java.lang.Object</pre>

<p>由Swing包的层次结构和继承关系可知</p>
<ul>
<li>Dialog和Frame都在awt.Window里</li>
<li>而JDialog在awt.Dialog里，JFrame在awt.Frame里</li>
<li>JPanel和JLabel在swing.JComponent里</li>
<li>它们都在awt.Container里，最顶层是java.lang.Object</li>
</ul>
<h2 id="Swing常用窗体"><a href="#Swing常用窗体" class="headerlink" title="Swing常用窗体"></a>Swing常用窗体</h2><ul>
<li><p><code>public JFrame(String title);</code> 默认不可见窗体，可以标题</p>
</li>
<li><p>将窗体转为容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JFrame jf=<span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">Container container=jf.getContentPane();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>container.add();container.remove()</code> 添加；删除容器中的组件</p>
</li>
<li><p><code>container</code> 是主容器，组件都在这个范围内</p>
</li>
<li><p><code>JLabel</code> 内容可以用html标签</p>
</li>
<li><p><code>setBounds(距离左边x,距离上边y,宽度,高度)</code> 设置窗体左上角的坐标和大小，对于<code>JFrame</code>是设置距离屏幕的位置，对于<code>container</code>里的就是相对灰色的<code>container</code>位置</p>
</li>
<li><p><code>setLocation(int x,int y);</code></p>
</li>
<li><p><code>setSize(int width, int height);</code> 设置窗体宽高</p>
</li>
<li><p><code>setVisibale(boolean b);</code> 是否可见</p>
</li>
<li><p><code>setDefaultCloseOperation(int operation);</code> 设置关闭方式</p>
<ul>
<li>默认是<code>DISPOSE_ON_CLOSE</code> 窗体关闭释放窗体资源，窗体消失<strong>但程序不停止</strong></li>
<li><code>EXIT_ON_CLOSE</code> 窗体关闭，释放窗体资源<strong>并关闭程序</strong></li>
</ul>
</li>
</ul>
<h3 id="Jdialog-对话框"><a href="#Jdialog-对话框" class="headerlink" title="Jdialog 对话框"></a><code>Jdialog</code> 对话框</h3><ul>
<li><code>public JDialog(Frame f, Sring title,boolean mode)</code>设置<code>model</code>为<code>true</code>时，打开对话框时，阻塞主窗体不可操作。</li>
</ul>
<p><code>JButton</code>单击事件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyJDialog</span> extends JDialog&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyJDialog</span><span class="params">(MyFrame frame)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(frame,<span class="string">&quot;第一个JDialog窗体&quot;</span>,<span class="literal">true</span>);<span class="comment">//调用父类构造方法，参数：父类窗体,标题，是否阻塞父窗体</span></span><br><span class="line">		Container container=<span class="built_in">getContentPane</span>();<span class="comment">//获取主窗体</span></span><br><span class="line">		container.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">JLabel</span>(<span class="string">&quot;这是一个对话框&quot;</span>));<span class="comment">//在容器中添加标签</span></span><br><span class="line">		<span class="built_in">setBounds</span>(<span class="number">120</span>,<span class="number">120</span>,<span class="number">100</span>,<span class="number">100</span>);<span class="comment">//设置对话框在桌面显示的坐标和大小</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFrame</span> extends JFrame&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Container container=<span class="built_in">getContentPane</span>();<span class="comment">//获取窗体主容器</span></span><br><span class="line">		container.<span class="built_in">setLayout</span>(null);<span class="comment">//窗体使用绝对布局</span></span><br><span class="line">		JButton bl=<span class="keyword">new</span> <span class="built_in">JButton</span>(<span class="string">&quot;弹出对话框&quot;</span>);</span><br><span class="line">		bl.<span class="built_in">setBounds</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">21</span>);<span class="comment">//按钮坐标大小</span></span><br><span class="line">		bl.<span class="built_in">addActionListener</span>(<span class="keyword">new</span> <span class="built_in">ActionListener</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			@Override</span><br><span class="line">			<span class="keyword">public</span> <span class="type">void</span> <span class="built_in">actionPerformed</span>(ActionEvent e) &#123;</span><br><span class="line">				<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">				MyJDialog dialog=<span class="keyword">new</span> <span class="built_in">MyJDialog</span>(MyFrame.<span class="keyword">this</span>);<span class="comment">//创建对话框，传参是当前窗体</span></span><br><span class="line">				dialog.<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		container.<span class="built_in">add</span>(bl);</span><br><span class="line">		<span class="built_in">setSize</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">		<span class="built_in">setDefaultCloseOperation</span>(WindowConstants.EXIT_ON_CLOSE);<span class="comment">//关闭窗体停止程序</span></span><br><span class="line">		<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">MyFrame</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="常用布局管理器"><a href="#常用布局管理器" class="headerlink" title="常用布局管理器"></a>常用布局管理器</h2><h3 id="null-绝对布局"><a href="#null-绝对布局" class="headerlink" title="null 绝对布局"></a>null 绝对布局</h3><blockquote>
<p>硬性指定位置和大小，组件位置通过绝对坐标的方式来指定</p>
</blockquote>
<ul>
<li>首先取消布局管理器：<code>Container.setLayout(null)</code></li>
<li>设置每个组件在容器的位置和大小：<code>Component.setBounds(int x,int y,int width,int height)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbsolutePosition</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AbsolutePosition</span><span class="params">()</span> &#123;</span><br><span class="line">		setTitle(<span class="string">&quot;绝对布局&quot;</span>);</span><br><span class="line">		setLayout(<span class="literal">null</span>);<span class="comment">//取消布局管理器</span></span><br><span class="line">		setBounds(<span class="number">0</span>,<span class="number">0</span>,<span class="number">300</span>,<span class="number">150</span>);</span><br><span class="line">		Container container=getContentPane();</span><br><span class="line">		JButton b1=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;按钮1&quot;</span>);</span><br><span class="line">		JButton b2=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;按钮2&quot;</span>);</span><br><span class="line">		b1.setBounds(<span class="number">10</span>,<span class="number">30</span>,<span class="number">80</span>,<span class="number">30</span>);<span class="comment">//设置按钮位置和大小</span></span><br><span class="line">		b2.setBounds(<span class="number">60</span>,<span class="number">70</span>,<span class="number">100</span>,<span class="number">20</span>);</span><br><span class="line">		container.add(b1);</span><br><span class="line">		container.add(b2);</span><br><span class="line">		setVisible(<span class="literal">true</span>);</span><br><span class="line">		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">AbsolutePosition</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlowLayout-流布局管理器"><a href="#FlowLayout-流布局管理器" class="headerlink" title="FlowLayout 流布局管理器"></a>FlowLayout 流布局管理器</h3><ul>
<li>流布局组件<strong>从左到右</strong>摆放。当组件占据了当前行的所有空间时，<strong>溢出的到下一行</strong></li>
<li>默认情况，行组件排列方式为<strong>居中对齐</strong>，可以通过设置更改</li>
</ul>
<p>FlowLayout类具有以下常用的构造方法</p>
<ul>
<li><code>public  FlowLayout()</code></li>
<li><code>public FlowLayout(int alignment)</code></li>
<li><code>public FlowLayout(int alignment,int horizGap,int vertGap)</code></li>
</ul>
<p><code>alignment</code>参数表示排列方式，可以设置为<code>Flowlayout.LEFT</code>、<code>FlowLayout.CENTER</code>或<code>FlowLayout.RIGHT</code></p>
<p><code>horizGap</code>,<code>vertGap</code>这两个参数以像素为单位指定组件之间的水平间隔和垂直间隔</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLayoutPosition</span> extends JFrame&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FlowLayoutPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">setTitle</span>(<span class="string">&quot;流布局管理器&quot;</span>);</span><br><span class="line">		Container container=<span class="built_in">getContentPane</span>();</span><br><span class="line">		<span class="built_in">setLayout</span>(<span class="keyword">new</span> <span class="built_in">FlowLayout</span>(FlowLayout.RIGHT,<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			container.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">Button</span>(<span class="string">&quot;button&quot;</span>+i));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">setSize</span>(<span class="number">300</span>,<span class="number">200</span>);</span><br><span class="line">		<span class="built_in">setDefaultCloseOperation</span>(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">		<span class="built_in">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">FlowLayoutPosition</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="BorderLayout-边界布局管理器"><a href="#BorderLayout-边界布局管理器" class="headerlink" title="BorderLayout 边界布局管理器"></a>BorderLayout 边界布局管理器</h3><ul>
<li><p>Swing创建窗体默认是边界布局管理器</p>
</li>
<li><p>边界布局管理器把容器<strong>分为东、南、西、北、中5个区域</strong></p>
</li>
<li><p>当组件添加时，需要使用BorderLayout类中的成员变量<strong>指定其区域</strong></p>
<ul>
<li><p>BorderLayout.NORTH 北</p>
</li>
<li><p>BorderLayout.SOUTH 南</p>
</li>
<li><p>BorderLayout.EAST 东</p>
</li>
<li><p>BorderLayout.WEST 西</p>
</li>
<li><p>BorderLayout.CENTER 中</p>
<p>———–NORTH———–</p>
<p>WEST—CENTER—-EAST</p>
<p>———–SOUTH———–</p>
</li>
</ul>
</li>
<li><p><code>add(组件，成员变量)</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BorderLayoutPosition</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">BorderLayoutPosition</span><span class="params">()</span> &#123;</span><br><span class="line">		setTitle(<span class="string">&quot;边界布局管理器&quot;</span>);</span><br><span class="line">		Container container=getContentPane();</span><br><span class="line">		setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());<span class="comment">//使用边界布局管理器</span></span><br><span class="line">		JButton centerButton=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;中&quot;</span>);</span><br><span class="line">		JButton northButton=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;北&quot;</span>);</span><br><span class="line">		JButton southButton=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;南&quot;</span>);</span><br><span class="line">		JButton westButton=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;西&quot;</span>);</span><br><span class="line">		JButton eastButton=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;东&quot;</span>);</span><br><span class="line">		container.add(centerButton,BorderLayout.CENTER);</span><br><span class="line">		container.add(eastButton,BorderLayout.EAST);</span><br><span class="line">		container.add(westButton,BorderLayout.WEST);</span><br><span class="line">		container.add(southButton,BorderLayout.SOUTH);</span><br><span class="line">		container.add(northButton,BorderLayout.NORTH);</span><br><span class="line">		setSize(<span class="number">350</span>,<span class="number">200</span>);</span><br><span class="line">		setVisible(<span class="literal">true</span>);</span><br><span class="line">		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">BorderLayoutPosition</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="GridLayout-网格布局管理器"><a href="#GridLayout-网格布局管理器" class="headerlink" title="GridLayout 网格布局管理器"></a>GridLayout 网格布局管理器</h3><ul>
<li>划分为<strong>网格</strong>，组件可以按<strong>行、列</strong>进行排序</li>
<li>网格个数由行数和列数决定，每个网格大小相同</li>
<li>组件从网格左上角开始，<strong>从左到右从上到下</strong>被添加到网格中</li>
<li>每个组件都会<strong>填满</strong>整个网格</li>
<li><strong>改变窗体大小，组件大小也会随之改变</strong></li>
</ul>
<p>构造方法</p>
<ul>
<li><code>public GridLayout(int rows, int columns)</code></li>
<li><code>public GridLayout(int rows, int columns, int horizGap, int vertGap)</code></li>
</ul>
<blockquote>
<p>rows和columns只有一个可以是0，被用于一行或一列排列任意多个组件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GridLayoutPosition</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">GridLayoutPosition</span><span class="params">()</span> &#123;</span><br><span class="line">		Container container=getContentPane();</span><br><span class="line">		setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>));<span class="comment">//7行3列网格，组件水平间距5像素，垂直间距5像素</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			container.add(<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;button&quot;</span>+i));</span><br><span class="line">		&#125;</span><br><span class="line">		setSize(<span class="number">300</span>,<span class="number">300</span>);</span><br><span class="line">		setTitle(<span class="string">&quot;网格布局管理器&quot;</span>);</span><br><span class="line">		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常用面板"><a href="#常用面板" class="headerlink" title="常用面板"></a>常用面板</h2><h3 id="JPanel-面板"><a href="#JPanel-面板" class="headerlink" title="JPanel 面板"></a>JPanel 面板</h3><p>必须在窗体容器中使用，无法脱离窗体显示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jpanel p1=<span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">1</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">10</span>));<span class="comment">//初始化面板，使用1行4列的网格布局，组件水平间隔10像素，垂直间隔10像素</span></span><br></pre></td></tr></table></figure>

<h3 id="JScrollPane-滚动面板"><a href="#JScrollPane-滚动面板" class="headerlink" title="JScrollPane 滚动面板"></a>JScrollPane 滚动面板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Container c=<span class="built_in">getContentPane</span>();</span><br><span class="line">JTextArea ta=<span class="keyword">new</span> <span class="built_in">JTextArea</span>(<span class="number">20</span>,<span class="number">50</span>);<span class="comment">//创建文本区域组件，文本域默认大小为20行、50列</span></span><br><span class="line">JScrollPane sp=<span class="keyword">new</span> <span class="built_in">JScrollPane</span>(ta);<span class="comment">//创建滚动面板，并将其文本域放到滚动面板中</span></span><br><span class="line">c.<span class="built_in">add</span>(sp);</span><br></pre></td></tr></table></figure>

<h4 id="图片路径"><a href="#图片路径" class="headerlink" title="图片路径"></a><strong>图片路径</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Icon con=<span class="keyword">new</span> <span class="built_in">ImageIcon</span>(<span class="string">&quot;src/注意.png&quot;</span>);<span class="comment">//使用字符串作为路径，是以项目文件夹为根目录</span></span><br><span class="line">URL url=MyImageIcon.<span class="keyword">class</span>.<span class="built_in">getResourse</span>(<span class="string">&quot;注意.png&quot;</span>);<span class="comment">//getResourse是以类所在文件夹为根目录</span></span><br><span class="line">Icon icon=<span class="keyword">new</span> <span class="built_in">ImageIcon</span>(url);<span class="comment">//创建Icon对象</span></span><br></pre></td></tr></table></figure>

<p>当用<code>new File()</code>时相对路径是相对于项目的路径，例如JavaSE下面有src，src下面有包，包里有类，当在类中用<code>new File()</code>相对路径访问src下的文件时应该是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file=<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;src/[文件名]&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h2><h3 id="ActionEvent动作事件"><a href="#ActionEvent动作事件" class="headerlink" title="ActionEvent动作事件"></a>ActionEvent动作事件</h3><p>动作事件监听器</p>
<table>
<thead>
<tr>
<th>相关定义</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>事件名</td>
<td><code>ActionEvent</code></td>
</tr>
<tr>
<td>事件源</td>
<td><code>JButton</code>、<code>JList</code>、<code>JTextField</code>等组件</td>
</tr>
<tr>
<td>监听接口</td>
<td><code>ActionListener</code></td>
</tr>
<tr>
<td>添加监听方法</td>
<td><code>addActionListener()</code></td>
</tr>
<tr>
<td>删除监听方法</td>
<td><code>removeActionListener()</code></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JButton b1=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;按钮&quot;</span>);</span><br><span class="line">bl.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">			</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">	<span class="comment">// 要触发的动作</span></span><br><span class="line">				</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者用类调用接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleEvent</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JButton jb=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;我是按钮&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleEvent</span><span class="params">()</span>&#123;</span><br><span class="line">        jb.addActionListener(<span class="keyword">new</span> <span class="title class_">jbAction</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">jbAction</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent arg0)</span>&#123;</span><br><span class="line">            jb.setText(<span class="string">&quot;我被点击了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>jbAction</code>实现<code>ActionListner</code>接口，同时在该内部类中实现<code>actionPerform()</code>方法，这个方法中定义当用户单击该按钮后实现怎样的功能</p>
</blockquote>
<h3 id="KeyEvent键盘事件"><a href="#KeyEvent键盘事件" class="headerlink" title="KeyEvent键盘事件"></a>KeyEvent键盘事件</h3><p><code>KeyEvent</code>类负责捕获键盘事件，可以通过为组件添加实现了<code>KeyListener</code>接口的监听器类来处理相应的键盘事件。</p>
<p><code>KeyListerner</code>接口3个抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="comment">//发生击键事件时触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span>;</span><br><span class="line">    <span class="comment">//按键被按下时被触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ketPressed</span><span class="params">(KeyEvent e)</span>;</span><br><span class="line">    <span class="comment">//案件被释放时被触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KeyEvent</code>类中的常用方法</p>
<ul>
<li><code>getKeyChar()</code> 获得与此事件中的键相关联的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textField=<span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">textField.addKeyListener(<span class="keyword">new</span> <span class="title class_">KeyAdapter</span>()&#123;<span class="comment">//文本框添加键盘事件的监听</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span>&#123;<span class="comment">//按键按下时触发</span></span><br><span class="line">        <span class="comment">//实现的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="MouseEvent鼠标事件"><a href="#MouseEvent鼠标事件" class="headerlink" title="MouseEvent鼠标事件"></a>MouseEvent鼠标事件</h3><p>所有组件都能发生鼠标事件。添加<code>MouseListener</code>接口监听，有5个抽象对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent e)</span>;<span class="comment">//光标移入组件时触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent e)</span>;<span class="comment">//鼠标按键按下</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent e)</span>;<span class="comment">//鼠标按键释放时被触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseClicked</span><span class="params">(MouseEvent e)</span>;<span class="comment">//发生单击事件被触发</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseExited</span><span class="params">(MouseEvent e)</span>;<span class="comment">//光标移出组件时被触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意单击事件如果按键在移除组件之后才被释放，则不会触发单机事件</p>
</blockquote>
<p>MouseEvent类中的常用方法</p>
<ul>
<li>getSource() 获得触发此次事件的组件对象，返回值为Object类型</li>
<li>getButton() 获得按键的int值</li>
<li>getClickCount() 获得单击按钮的次数</li>
</ul>
<p>按键的int值：</p>
<table>
<thead>
<tr>
<th>静态常量</th>
<th>常量值</th>
<th>代表的键</th>
</tr>
</thead>
<tbody><tr>
<td>BUTTON1</td>
<td>1</td>
<td>鼠标左键</td>
</tr>
<tr>
<td>BUTTON2</td>
<td>2</td>
<td>鼠标滚轮</td>
</tr>
<tr>
<td>BUTTON3</td>
<td>3</td>
<td>鼠标右键</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mouseOper</span><span class="params">(MouseEvent e)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=e.getButton();<span class="comment">//获得按键的int值</span></span><br><span class="line">    <span class="keyword">if</span>(i==MouseEvent.BUTTON1)</span><br><span class="line">        System.out.println(<span class="string">&quot;按下的是鼠标左键&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==MouseEvent.BUTTON2)</span><br><span class="line">        System.out.println(<span class="string">&quot;按下的是鼠标滚轮&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i==MouseEvent.BUTTON3)</span><br><span class="line">        System.out.println(<span class="string">&quot;按下的是鼠标右键&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MouseEvent_Example</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JLable label=<span class="keyword">new</span> <span class="title class_">JLable</span>();</span><br><span class="line">    label.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseListener</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseEntered</span><span class="params">(MouseEvent e)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;光标移入组件&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mousePressed</span><span class="params">(MouseEvent e)</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;鼠标按键被按下&quot;</span>);</span><br><span class="line">            mouseOper(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二十章-多线程"><a href="#第二十章-多线程" class="headerlink" title="第二十章 多线程"></a>第二十章 多线程</h1><p>多种活动同时进行的思想称为<strong>并发</strong>，而将完成的每一件事情称为<strong>线程</strong></p>
<p>CPU在一个时间片中执行某个进程，然后下一个时间片又跳至另一个进程中去执行。由于CPU转换较快，好像同时执行一样</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>Thread类是java.lang包中的一个类</li>
<li>完成线程真正功能的代码放在类的run()方法里</li>
<li>start()方法会启动线程，线程自动执行run()方法里的代码。</li>
<li>如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()前，Thread对象只是实例，不是真正的线程</li>
<li>主方法线程由Java虚拟机负责启动</li>
</ul>
<blockquote>
<p>如果start()方法调用一个已经启动的线程，抛出IllegalThreadStateException异常</p>
</blockquote>
<h3 id="实现Runnable-接口"><a href="#实现Runnable-接口" class="headerlink" title="实现Runnable()接口"></a>实现Runnable()接口</h3><p>当要继承其他非Thread类，通过Runnable接口来实现多线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Threadtest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		String string=Thread.currentThread().getName();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(string+<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次操作&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">		Threadtest threadtest=<span class="keyword">new</span> <span class="title class_">Threadtest</span>();</span><br><span class="line">		Thread t1=<span class="keyword">new</span> <span class="title class_">Thread</span>(threadtest,<span class="string">&quot;线程1&quot;</span>);<span class="comment">//第二个是Thread的名字，一般是Thread(String name)</span></span><br><span class="line">		Thread t2=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Threadtest</span>(),<span class="string">&quot;线程2&quot;</span>);<span class="comment">//匿名方式</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现Runnable()接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联</p>
</blockquote>
<p>使用Runnable接口启动新的线程步骤如下：</p>
<ol>
<li>建立Runnable对象</li>
<li>使用参数为Runnable对象的构造方法创建Thread实例</li>
<li>调用start()方法启动线程</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)  </span><br></pre></td></tr></table></figure>



<p>Swing与Thread结合实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwingAndThread</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//图像横坐标</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SwingAndThread</span><span class="params">()</span> &#123;</span><br><span class="line">		setBounds(<span class="number">300</span>,<span class="number">200</span>,<span class="number">250</span>,<span class="number">100</span>);</span><br><span class="line">		Container container=getContentPane();<span class="comment">//主容器</span></span><br><span class="line">		container.setLayout(<span class="literal">null</span>);</span><br><span class="line">		</span><br><span class="line">		Icon icon=<span class="keyword">new</span> <span class="title class_">ImageIcon</span>(<span class="string">&quot;src/1.gif&quot;</span>);</span><br><span class="line">		JLabel jLabel=<span class="keyword">new</span> <span class="title class_">JLabel</span>(icon);</span><br><span class="line">		jLabel.setBounds(<span class="number">10</span>,<span class="number">10</span>,<span class="number">200</span>,<span class="number">50</span>);</span><br><span class="line">		Thread thread=<span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;<span class="comment">//匿名线程对象</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					jLabel.setBounds(count,<span class="number">10</span>,<span class="number">200</span>,<span class="number">50</span>);<span class="comment">//将标签的横坐标用变量表示</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);<span class="comment">//休眠500毫秒</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					count+=<span class="number">4</span>;<span class="comment">//横坐标每次增加4</span></span><br><span class="line">					<span class="keyword">if</span>(count&gt;=<span class="number">200</span>) &#123;</span><br><span class="line">						count=<span class="number">10</span>;<span class="comment">//到达最右边时使其回到最左边</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		thread.start();</span><br><span class="line">		container.add(jLabel);</span><br><span class="line">		setVisible(<span class="literal">true</span>);</span><br><span class="line">		setDefaultCloseOperation(EXIT_ON_CLOSE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">SwingAndThread</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线程的生命期"><a href="#线程的生命期" class="headerlink" title="线程的生命期"></a>线程的生命期</h2><ul>
<li><strong>出生状态</strong>就是线程被创建时处于的状态，在用户使用该线程实例调用<code>start()</code>方法之前线程都是出生状态。</li>
<li>当调用<code>start()</code>方法后，线程处于<strong>就绪状态</strong>(可执行状态)</li>
<li>当线程得到系统资源进入<strong>运行状态</strong>。</li>
<li>处于运行状态调用<code>Thread</code>类中的<code>wait()</code>方法时，进入<strong>等待状态</strong>。进入等待状态<u>必须由其他的线程调用<code>notify()</code>唤醒，自己无法唤醒自己</u>，<code>notifyAll()</code>方法将所有处于等待状态下的线程唤醒</li>
<li><code>sleep()</code><strong>休眠状态</strong>，时间到了会自动唤醒，区别于等待状态。</li>
<li>线程中运行状态下发出输入&#x2F;输出请求时，该线程将进入阻塞状态。等待输入输出结束时线程进入<strong>就绪状态</strong></li>
<li>当线程的<code>run()</code>方法执行完毕时，线程进入<strong>死亡状态</strong>。</li>
</ul>
<pre class="mermaid">graph TD
出生-->A[就绪]
A-->B[运行]
B-->A
B-->C[等待]
B-->D[休眠]
B-->E[阻塞]
B-->死亡
C-->A
D-->A
E-->A</pre>



<h2 id="操作线程的方法"><a href="#操作线程的方法" class="headerlink" title="操作线程的方法"></a>操作线程的方法</h2><h3 id="线程的加入"><a href="#线程的加入" class="headerlink" title="线程的加入"></a>线程的加入</h3><p>join()方法加入到另外一个线程。例如存在一个线程A，现在需要插入B要求线程B先执行完毕，然后再执行线程A，调用join()，类似插入队伍。</p>
<p>当某个线程使用join()加入另外一个线程时，另一个线程会等待该线程执行完毕后再继续执行。</p>
<p>使用方法：在某一个线程A的run函数中使用B.join()插入B线程。</p>
<p>插入到主线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Stirng[] args)</span>&#123;</span><br><span class="line">    类 A=<span class="keyword">new</span> 类();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 类&#123;</span><br><span class="line">    线程实例化;</span><br><span class="line">    线程.start;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        线程.join();<span class="comment">//这样就插入到主线程</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(..)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><ul>
<li>每个线程具有各自的优先级，可以表明在程序中该线程的重要性</li>
<li>系统根据优先级决定首先使哪个线程进入运行状态</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Priority</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	String nameString;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Priority</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.nameString=name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		String tmpString=<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">			tmpString+=i;<span class="comment">//进行50000次字符拼接</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(nameString+<span class="string">&quot;线程完成任务&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		Thread aThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Priority</span>(<span class="string">&quot;A&quot;</span>));</span><br><span class="line">		aThread.setPriority(<span class="number">1</span>);</span><br><span class="line">		Thread bThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Priority</span>(<span class="string">&quot;B&quot;</span>));</span><br><span class="line">		bThread.setPriority(<span class="number">3</span>);</span><br><span class="line">		Thread cThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Priority</span>(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">		cThread.setPriority(<span class="number">7</span>);</span><br><span class="line">		Thread dThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Priority</span>(<span class="string">&quot;D&quot;</span>));</span><br><span class="line">		dThread.setPriority(<span class="number">10</span>);</span><br><span class="line">		aThread.start();</span><br><span class="line">		bThread.start();</span><br><span class="line">		cThread.start();</span><br><span class="line">		dThread.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">D线程完成任务</span><br><span class="line">B线程完成任务</span><br><span class="line">C线程完成任务</span><br><span class="line">A线程完成任务</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由输出结果，不一定按优先级，知识作为CPU的参考依据。执行顺序由CPU决定</p>
</blockquote>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全问题来源于两个线程同时存取单一对象的数据</p>
<h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><blockquote>
<p> 解决资源共享问题</p>
</blockquote>
<p><strong>同步块</strong></p>
<p><code>synchronized(Object)&#123;&#125;</code></p>
<p>通常<strong>将共享资源的操作放置</strong>在<code>synchronized</code>定义的区域内，当其他线程获取这个锁时，就必须<strong>等待锁被释放后才可以进入该区域</strong>。其中<code>Object</code>有标志位，0和1，若为0，表示此同步块内存在其他线程，这是当前线程处于就绪状态，直到同步块中的线程执行完同步块代码后，该对象标志位设置为1，当前线程开始执行同步块。</p>
<p>在run()里边添加同步块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);<span class="comment">//使当前线程休眠100毫秒</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+<span class="string">&quot;——票数&quot;</span>+num--);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="comment">//实例化类对象</span></span><br><span class="line">		SynchronizedTest test=<span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">		<span class="comment">//以该类对象分别实例化4个线程</span></span><br><span class="line">		Thread tA=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">		Thread tB=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">		Thread tC=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程三&quot;</span>);</span><br><span class="line">		tA.start();</span><br><span class="line">		tB.start();</span><br><span class="line">		tC.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">线程一——票数<span class="number">10</span></span><br><span class="line">线程一——票数<span class="number">9</span></span><br><span class="line">线程一——票数<span class="number">8</span></span><br><span class="line">线程一——票数<span class="number">7</span></span><br><span class="line">线程一——票数<span class="number">6</span></span><br><span class="line">线程一——票数<span class="number">5</span></span><br><span class="line">线程一——票数<span class="number">4</span></span><br><span class="line">线程一——票数<span class="number">3</span></span><br><span class="line">线程一——票数<span class="number">2</span></span><br><span class="line">线程一——票数<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果不加同步块结果会出现负数</p>
<p>线程中执行n++结果不一定正确，因为n++不是原子操作，其中包含三步包括取值，加一，赋值，中间可能会被打断，导致结果不一定准确。可以加入锁解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">        aomicinteger.incrementAndGet();</span><br><span class="line">        longAdder.increment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步方法</strong></p>
<p>在方法前面用<code>synchronized</code>关键字修饰方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>同上面的例子实现一样的功能，不过运用同步方法而不是同步块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doit</span><span class="params">()</span> &#123;<span class="comment">//定义同步方法</span></span><br><span class="line">		<span class="keyword">if</span> (num&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);<span class="comment">//使当前线程休眠100毫秒</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">&quot;——票数&quot;</span>+num--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			doit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="comment">//实例化类对象</span></span><br><span class="line">		SynchronizedTest test=<span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();</span><br><span class="line">		<span class="comment">//以该类对象分别实例化4个线程</span></span><br><span class="line">		Thread tA=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">		Thread tB=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">		Thread tC=<span class="keyword">new</span> <span class="title class_">Thread</span>(test,<span class="string">&quot;线程三&quot;</span>);</span><br><span class="line">		tA.start();</span><br><span class="line">		tB.start();</span><br><span class="line">		tC.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="网络通信-1"><a href="#网络通信-1" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="网络程序设计基础"><a href="#网络程序设计基础" class="headerlink" title="网络程序设计基础"></a>网络程序设计基础</h2><p>在TCP&#x2F;IP协议栈中，有两个高级协议，即传输控制协议(Transmission Control Protocol，TCP)与用户数据传输报协议(User Datagram Protocol，UDP)</p>
<table>
<thead>
<tr>
<th>高级协议</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>以固接连线为基础，从一端送至连接的另一端</td>
<td>以发送数据包的方式进行，向若干目标发送数据或接受来自若干源的数据</td>
</tr>
<tr>
<td>数据顺序</td>
<td>数据能够送达，且抵达数据的顺序&#x3D;送出时的顺序</td>
<td>不保证抵达的顺序&#x3D;送出时的顺序</td>
</tr>
<tr>
<td>类比</td>
<td>就像打电话，必须先拨号给对方，等两端确定连接后，互相才能听到对方说法，也知道对方回应的是什么</td>
<td>邮递员送信，可以寄出很多信给同一个人，且每封信相对独立。各封信到达的顺序并不重要，收信人接收信件的顺序也不能保证与寄出信件的顺序相同</td>
</tr>
</tbody></table>
<blockquote>
<p> TCP是面向<strong>连接</strong>的可靠协议，效率低，保证确实送达。UDP是面向<strong>无连接</strong>的不可靠协议，效率高，不保证数据可靠的传输。</p>
</blockquote>
<p>一些防火墙或路由器可能设置不允许UDP数据传输协议</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>类似营业厅的窗口，提供某些服务</p>
<p>HTTP 80</p>
<p>FTP 21</p>
<p>Tomcat 8080</p>
<p>MySQL 3306</p>
<h3 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h3><p>套接字(Socket)用于将<strong>应用程序与端口</strong>连接起来。</p>
<p>客户端(应用程序&lt;–&gt;Socket&lt;–&gt;Port&lt;-)-(-&gt;Port&lt;–&gt;Socket&lt;–&gt;应用程序)服务器</p>
<blockquote>
<p>类似插座一样连接电器与电线</p>
</blockquote>
<h2 id="TCP程序"><a href="#TCP程序" class="headerlink" title="TCP程序"></a>TCP程序</h2><p>TCP协议进行通信的两个应用程序有主次之分，一个称为服务器程序，另一个称为客户机程序，服务端与客户端的交互过程如下：</p>
<ol>
<li>服务器程序创建一个<code>SeverSocket</code>(服务器端套接字)对象，调用<code>accept()</code>方法等待客户机来连接</li>
<li>客户端程序创建一个<code>Socket</code>对象，请求与服务器建立连接</li>
<li>服务器接受客户机的连接请求，同时创建一个新的<code>Socket</code>对象与客户建立连接。随后服务器继续等待新的请求</li>
</ol>
<blockquote>
<p><code>SeverSocket</code>可以理解为售后部门的电话；服务器端运行的<code>Socket</code>可以理解为客服人员；客户端运行的<code>Socket</code>可以理解为顾客</p>
</blockquote>
<h3 id="IntetAddress类"><a href="#IntetAddress类" class="headerlink" title="IntetAddress类"></a>IntetAddress类</h3><p>这是一个与ip地址相关的类，可以获取ip地址，主机地址等信息，常用方法：</p>
<ul>
<li><code>getByName(String host)</code> 返回InterAddress 获取Host项对应的InterAddress对象</li>
<li><code>getHostAddress()</code> 返回String 获取InterAddress对象所包含的IP地址</li>
<li><code>getHostName(</code>) String 获取此ip地址的主机名</li>
<li><code>getLocalHost()</code> InterAddress 返回本地主机的InterAddress对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		InetAddress ip;<span class="comment">//创建对象</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ip=InetAddress.getLocalHost();<span class="comment">//实例化对象</span></span><br><span class="line">			String localname=ip.getHostName();<span class="comment">//获取本机名</span></span><br><span class="line">			String localip=ip.getHostAddress();<span class="comment">//获取本机ip地址</span></span><br><span class="line">			System.out.println(<span class="string">&quot;本机名：&quot;</span>+localname);</span><br><span class="line">			System.out.println(<span class="string">&quot;本机IP地址：&quot;</span>+localip);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">本机名：LAPTOP-6G798SAR</span><br><span class="line">本机IP地址：<span class="number">192.168</span><span class="number">.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h3 id="SeverSocket类"><a href="#SeverSocket类" class="headerlink" title="SeverSocket类"></a>SeverSocket类</h3><p>服务器套接字</p>
<p>SeverSocket(int port)：绑定到接口port的服务器套接字</p>
<blockquote>
<p>当服务器向输出流写入信息时，客户端通过相应的输入流就能读取，反之亦然</p>
</blockquote>
<p>注意accept()方法会阻塞线程的继续指行，直至接收到客户的呼叫</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yu=server.accept();</span><br><span class="line">System.out.println(<span class="string">&quot;连接中&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果没有客户呼叫服务机，那么“连接中”语句不会执行</p>
</blockquote>
<h3 id="TCP网络程序设计"><a href="#TCP网络程序设计" class="headerlink" title="TCP网络程序设计"></a>TCP网络程序设计</h3><p>单项通信的例子，客户机通过<strong>输出流</strong>发送数据，服务器通过<strong>输入流</strong>接收数据：</p>
<p><strong>服务器端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> ServerSocket server;<span class="comment">//服务器套接字</span></span><br><span class="line">	<span class="keyword">private</span> Socket socket;<span class="comment">//客户机套接字</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			server=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8998</span>);<span class="comment">//服务器启用8998端口</span></span><br><span class="line">			System.out.println(<span class="string">&quot;服务器套接字已经创建成功&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;等待客户机的连接&quot;</span>);</span><br><span class="line">				socket=server.accept();<span class="comment">//服务器监听客户机连接</span></span><br><span class="line">				BufferedReader reader=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">					String message=reader.readLine();<span class="comment">//读取一行文本</span></span><br><span class="line">					<span class="keyword">if</span>(<span class="string">&quot;exit&quot;</span>.equals(message)) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;客户机退出&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;<span class="comment">//停止接受信息</span></span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;客户机：&quot;</span>+message);</span><br><span class="line">				&#125;</span><br><span class="line">				reader.close();</span><br><span class="line">				socket.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		MyServer tcp=<span class="keyword">new</span> <span class="title class_">MyServer</span>();</span><br><span class="line">		tcp.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户机端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PrintWriter writer;<span class="comment">//根据套接字字节流创建的字符输出流</span></span><br><span class="line">	Socket socket;</span><br><span class="line">	<span class="keyword">private</span> JTextArea area=<span class="keyword">new</span> <span class="title class_">JTextArea</span>();<span class="comment">//展示信息的文本域</span></span><br><span class="line">	<span class="keyword">private</span> JTextField text=<span class="keyword">new</span> <span class="title class_">JTextField</span>();<span class="comment">//发送信息的文本框</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyClient</span><span class="params">()</span> &#123;</span><br><span class="line">		setTitle(<span class="string">&quot;向服务器送数据&quot;</span>);</span><br><span class="line">		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">		Container container=getContentPane();</span><br><span class="line">		JScrollPane scrollPane=<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(area);</span><br><span class="line">		getContentPane().add(scrollPane,BorderLayout.CENTER);</span><br><span class="line">		container.add(text,<span class="string">&quot;South&quot;</span>);</span><br><span class="line">		text.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">				<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">				writer.println(text.getText().trim());<span class="comment">//将文本框中的信息写入流</span></span><br><span class="line">				area.append(text.getText()+<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//将文本框中的信息显示到文本域中</span></span><br><span class="line">				text.setText(<span class="string">&quot;&quot;</span>);<span class="comment">//清空</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">		area.append(<span class="string">&quot;尝试连接\n&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			socket=<span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8998</span>);<span class="comment">//连接本地计算机的8998接口</span></span><br><span class="line">			writer=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(socket.getOutputStream(),<span class="literal">true</span>);</span><br><span class="line">			area.append(<span class="string">&quot;完成连接\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		MyClient client=<span class="keyword">new</span> <span class="title class_">MyClient</span>();</span><br><span class="line">		client.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">		client.setVisible(<span class="literal">true</span>);</span><br><span class="line">		client.connect();<span class="comment">//连接服务器</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP程序"><a href="#UDP程序" class="headerlink" title="UDP程序"></a>UDP程序</h2><p>UDP通信基本模式：</p>
<ul>
<li>将数据打包（数据包），然后将数据包发往目的地</li>
<li>接收别人发来的数据包，然后查看数据包</li>
</ul>
<p><strong>发送数据包：</strong></p>
<ol>
<li>创建：使用<code>DatagramSocket()</code>创建一个数据包套接字。</li>
<li>打包：使用<code>DatagramPacker(byte[] buf, int offset, int length, InetAddress address, int port)</code>创建要发送的数据包。</li>
<li>发送：使用<code>DatagramSocket()</code>类的<code>send()</code>方法发送数据包。</li>
</ol>
<p><strong>接收数据包：</strong></p>
<ol>
<li>创建：使用<code>DatagramSocket(int port)</code>创建数据包套接字，绑定到指定的接口。</li>
<li>准备包：使用<code>DatagramPacket(byte[] buf, int length)</code>创建字节数组来接收数据包。</li>
<li>接收：使用<code>DatagramPocket</code>类的<code>receive()</code>方法接收UDP包。</li>
</ol>
<h3 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h3><p><strong>数据包</strong>，构造方法：</p>
<ul>
<li><code>DatagramPacket(byte[] buf, int length) </code>指定包的内存空间和大小</li>
<li><code>DatagramPacket(byte[] buf, int length,InetAddress address,int port)</code> 多指定了数据包的目标地址和端口</li>
</ul>
<blockquote>
<p>发送数据需指定接收方的Socket地址和端口号</p>
</blockquote>
<h3 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h3><ul>
<li>DatagramSocket()</li>
<li>DatagramSocket(int port)</li>
<li>DatagramSocket(int port, InetAddress addr) 适用多块网卡有多个IP地址</li>
</ul>
<blockquote>
<p>接收时要指定端口号一般用第二种，发送时不知道用第一种。</p>
</blockquote>
<h3 id="UDP网络程序设计"><a href="#UDP网络程序设计" class="headerlink" title="UDP网络程序设计"></a>UDP网络程序设计</h3><p>下面创建一个广播数据报程序，原理类似电台广播。广播电台需要在指定的波段和频率上广播信号，接收者也要将收音机调到指定的波段、频率，才可以收听广播内容。</p>
<p><strong>广播主机程序不断向外播出信息：</strong></p>
<p><img src="https://jjuprising.github.io/images/Ja_Note/image-20221224205156462.png" alt="image-20221224205156462"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Notification</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	String weather=<span class="string">&quot;节目预报：八点有大型晚会，请收听&quot;</span>;<span class="comment">//发送的信息</span></span><br><span class="line">	<span class="type">int</span> port=<span class="number">9898</span>;</span><br><span class="line">	InetAddress iaddress=<span class="literal">null</span>;</span><br><span class="line">	MulticastSocket socket=<span class="literal">null</span>;<span class="comment">//多点广播套接字，是一种DatagramPacket</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Notification</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			iaddress=InetAddress.getByName(<span class="string">&quot;224.255.10.0&quot;</span>);<span class="comment">//广播组地址</span></span><br><span class="line">			socket=<span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(port);<span class="comment">//实例化</span></span><br><span class="line">			socket.setTimeToLive(<span class="number">1</span>);<span class="comment">//指定发送范围是本地网络</span></span><br><span class="line">			socket.joinGroup(iaddress);<span class="comment">//加入广播组</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			DatagramPacket packet=<span class="literal">null</span>;<span class="comment">//数据包</span></span><br><span class="line">			<span class="type">byte</span> data[]=weather.getBytes();<span class="comment">//字符串消息的字节数组</span></span><br><span class="line">			packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length,iaddress, port);<span class="comment">//将数据打包</span></span><br><span class="line">			System.out.println(weather);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socket.send(packet);</span><br><span class="line">				sleep(<span class="number">3000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		Notification w=<span class="keyword">new</span> <span class="title class_">Notification</span>();</span><br><span class="line">		w.start();<span class="comment">//启动线程</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>接收广播程序：</strong></p>
<p><img src="https://jjuprising.github.io/images/Ja_Note/image-20221224205211236.png" alt="image-20221224205211236"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receive</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>,ActionListener&#123;</span><br><span class="line">	<span class="type">int</span> port;<span class="comment">//端口</span></span><br><span class="line">	InetAddress group=<span class="literal">null</span>;<span class="comment">//广播组地址</span></span><br><span class="line">	MulticastSocket socket=<span class="literal">null</span>;<span class="comment">//多点广播套接字对象</span></span><br><span class="line">	JButton inceBtn=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;开始接收&quot;</span>);</span><br><span class="line">	JButton stopBtn=<span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;停止接收&quot;</span>);</span><br><span class="line">	JTextArea inceAr=<span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">	JTextArea inced=<span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">	Thread thread;</span><br><span class="line">	<span class="type">boolean</span> stop=<span class="literal">false</span>;<span class="comment">//停止接收信息状态</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Receive</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//界面设计</span></span><br><span class="line">		setTitle(<span class="string">&quot;广播数据报&quot;</span>);</span><br><span class="line">		setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);</span><br><span class="line">		thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">		inceBtn.addActionListener(<span class="built_in">this</span>);<span class="comment">//绑定按钮ince的单击事件</span></span><br><span class="line">		stopBtn.addActionListener(<span class="built_in">this</span>);<span class="comment">//绑定按钮stop的单击事件</span></span><br><span class="line">		inceAr.setForeground(Color.blue);</span><br><span class="line">		JPanel north=<span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">		north.add(inceBtn);<span class="comment">//将按钮添加到north面板</span></span><br><span class="line">		north.add(stopBtn);</span><br><span class="line">		add(north,BorderLayout.NORTH);<span class="comment">//将north放置在窗体上部</span></span><br><span class="line">		JPanel center=<span class="keyword">new</span> <span class="title class_">JPanel</span>();<span class="comment">//创建面板对象center</span></span><br><span class="line">		center.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//设置面板布局</span></span><br><span class="line">		center.add(inceAr);<span class="comment">//将文本域添加到面板上</span></span><br><span class="line">		center.add(inced);</span><br><span class="line">		add(center,BorderLayout.CENTER);<span class="comment">//设置面板布局</span></span><br><span class="line">		validate();<span class="comment">//刷新</span></span><br><span class="line">		<span class="comment">//UDP部分</span></span><br><span class="line">		port=<span class="number">9898</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			group=InetAddress.getByName(<span class="string">&quot;224.255.10.0&quot;</span>);<span class="comment">//指定接收地址</span></span><br><span class="line">			socket=<span class="keyword">new</span> <span class="title class_">MulticastSocket</span>(port);<span class="comment">//绑定</span></span><br><span class="line">			socket.joinGroup(group);<span class="comment">//加入广播组</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		setBounds(<span class="number">100</span>,<span class="number">50</span>,<span class="number">360</span>,<span class="number">380</span>);</span><br><span class="line">		setVisible(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">while</span> (stop==<span class="literal">false</span>) &#123;</span><br><span class="line">			<span class="type">byte</span> data[]=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">//创建缓存字节数组</span></span><br><span class="line">			DatagramPacket packet=<span class="literal">null</span>;</span><br><span class="line">			packet=<span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length,group, port);<span class="comment">//待接收数据包</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socket.receive(packet);<span class="comment">//接收数据包</span></span><br><span class="line">				<span class="comment">//获取数据包中的内容</span></span><br><span class="line">				String message=<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength());</span><br><span class="line">				inceAr.setText(<span class="string">&quot;正在接收的内容：\n&quot;</span>+message);<span class="comment">//将接收内容显示在文本域中</span></span><br><span class="line">				inced.append(message+<span class="string">&quot;\n&quot;</span>);<span class="comment">//每条信息为一行</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		<span class="keyword">if</span> (e.getSource()==inceBtn) &#123;<span class="comment">//单击inceBtn按钮触发的事件</span></span><br><span class="line">			inceBtn.setBackground(Color.red);<span class="comment">//设置按钮颜色</span></span><br><span class="line">			stopBtn.setBackground(Color.yellow);</span><br><span class="line">			<span class="keyword">if</span> (!(thread.isAlive())) &#123;<span class="comment">//线程不处于”新建状态”</span></span><br><span class="line">				thread=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			thread.start();<span class="comment">//启动线程</span></span><br><span class="line">			stop=<span class="literal">false</span>;<span class="comment">//开始接收信息</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e.getSource()==stopBtn) &#123;<span class="comment">//单击stop按钮触发的事件</span></span><br><span class="line">			inceBtn.setBackground(Color.yellow);</span><br><span class="line">			stopBtn.setBackground(Color.red);</span><br><span class="line">			stop=<span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">		Receive receive=<span class="keyword">new</span> <span class="title class_">Receive</span>();</span><br><span class="line">		receive.setSize(<span class="number">460</span>,<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Joel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jjuprising.github.io/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://jjuprising.github.io/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JJuprising.github.io" target="_blank">Joel Station</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/10/07/XTCDJwhl5OKGyFW.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/02/%E8%A7%A3%E5%86%B3rehl8-Unable-to-read-consumer-identity%E7%9A%84%E9%97%AE%E9%A2%98/"><img class="prev-cover" src="/images/NoCover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">解决rehl8 Unable to read consumer identity的问题</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/27/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/images/NoCover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">pytorch深度学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/01/2022web%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="2022web大作业"><img class="cover" src="https://s2.loli.net/2022/05/28/7OZLM2B8ie1jaxn.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">2022web大作业</div></div></a></div><div><a href="/2022/07/01/Cpp%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="Cpp语言程序设计"><img class="cover" src="https://wallpapercave.com/wp/wp4009913.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">Cpp语言程序设计</div></div></a></div><div><a href="/2022/09/24/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="python学习笔记"><img class="cover" src="https://pic1.zhimg.com/v2-dbe054265f77076e47cc1bc80532b054_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="title">python学习笔记</div></div></a></div><div><a href="/2022/07/01/%E4%B8%AD%E5%8D%8E%E6%96%87%E5%8C%96%E9%85%B7%EF%BC%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/" title="中华文化酷！小程序"><img class="cover" src="https://s2.loli.net/2022/07/01/FNZEgU93CRYuVIJ.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">中华文化酷！小程序</div></div></a></div><div><a href="/2022/08/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" title="微信小程序学习笔记"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.d8cc952403d8e025ab31420a7ebbb3f4?rik=8r8bU7RUT2092Q&riu=http%3a%2f%2fwww.kuaipng.com%2fUploads%2fpic%2fw%2f2020%2f06-11%2f85112%2fwater_85112_698_698_.png&ehk=7TE1Ln1gInebI2BQO5CZO97ryOn%2bSQh3kx17RZXKvlM%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-24</div><div class="title">微信小程序学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/jc_avator2.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Joel</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JJuprising"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JJuprising" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">错题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E9%A2%98%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.</span> <span class="toc-text">大题模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%8F%96"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件存取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%88%9B%E5%BB%BA%E2%80%93%E8%BE%93%E5%85%A5%E2%80%93%E8%AF%BB%E5%8F%96"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">字节流创建–输入–读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">(缓存)字符流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swing"><span class="toc-number">1.1.3.</span> <span class="toc-text">Swing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">事件监听</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%94%9F%E4%BA%A7%E6%A0%88"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">消费生产栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.5.</span> <span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%8F%8C%E5%90%91%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">TCP 双向通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">客户端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-1"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">服务器端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E6%9C%BA%E7%AB%AF"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">客户机端</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%8C%83%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">基本输入输出范例代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">第四章 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.</span> <span class="toc-text">循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#foreach%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.1.1.</span> <span class="toc-text">foreach语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">第五章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">数组的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">复制数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#copyof-%E6%96%B9%E6%B3%95"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">copyof()方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">第六章 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">面向对象概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">5.1.1.</span> <span class="toc-text">封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.2.1.</span> <span class="toc-text">this 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">类的构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-number">5.4.</span> <span class="toc-text">静态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.5.1.</span> <span class="toc-text">对象的销毁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">第七章 继承、多态、抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">6.1.</span> <span class="toc-text">类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.1.1.</span> <span class="toc-text">extends 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.1.2.</span> <span class="toc-text">super 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">Object 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.3.</span> <span class="toc-text">对象的类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">向下转型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.4.</span> <span class="toc-text">instanceof关键字判断对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">6.5.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.6.</span> <span class="toc-text">final 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.7.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.8.</span> <span class="toc-text">抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.8.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.8.2.</span> <span class="toc-text">接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">第9章 异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">第10章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">8.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">8.2.</span> <span class="toc-text">字符串连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%A1%E6%81%AF"><span class="toc-number">8.3.</span> <span class="toc-text">获取字符串信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">8.3.1.</span> <span class="toc-text">字符串的查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">8.4.</span> <span class="toc-text">字符串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.4.1.</span> <span class="toc-text">获取字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-number">8.4.2.</span> <span class="toc-text">字符串替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89"><span class="toc-number">8.4.3.</span> <span class="toc-text">判断相等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.4.4.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">8.4.4.1.</span> <span class="toc-text">元字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="toc-number">8.4.4.2.</span> <span class="toc-text">字符匹配符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93"><span class="toc-number">8.5.</span> <span class="toc-text">常用类库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer%E7%B1%BB"><span class="toc-number">8.5.1.</span> <span class="toc-text">Integer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Double%E7%B1%BB"><span class="toc-number">8.5.2.</span> <span class="toc-text">Double类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean%E7%B1%BB"><span class="toc-number">8.5.3.</span> <span class="toc-text">Boolean类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Character%E7%B1%BB"><span class="toc-number">8.5.4.</span> <span class="toc-text">Character类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">第12章 集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">9.1.</span> <span class="toc-text">集合类概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.2.</span> <span class="toc-text">Collection 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">9.3.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.1.</span> <span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">9.3.2.</span> <span class="toc-text">List接口的实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">9.4.</span> <span class="toc-text">Set集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">9.5.</span> <span class="toc-text">Map集合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">第13章 枚举类型与泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">10.0.1.</span> <span class="toc-text">枚举类型中的构造方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">向上向下转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">10.1.2.</span> <span class="toc-text">定义泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">10.1.3.</span> <span class="toc-text">高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%99%90%E5%88%B6"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">泛型限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">泛型通配符</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">第14章 lambda表达式与流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">方法的引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Function%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.1.1.</span> <span class="toc-text">Function接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text">流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4"><span class="toc-number">11.2.1.</span> <span class="toc-text">数据过滤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-I-x2F-O-%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="toc-number">12.</span> <span class="toc-text">第15章 I&#x2F;O(输入与输出)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">12.1.</span> <span class="toc-text">输入&#x2F;输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">12.3.</span> <span class="toc-text">文件输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileInputStream%E4%B8%8EFileOutputStream%E7%B1%BB"><span class="toc-number">12.3.1.</span> <span class="toc-text">FileInputStream与FileOutputStream类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader%E5%92%8CFileWriter"><span class="toc-number">12.3.2.</span> <span class="toc-text">FileReader和FileWriter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E8%BE%93%E5%85%A5-x2F-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">12.4.</span> <span class="toc-text">带缓存的输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BufferedReader%E4%B8%8EBufferedWriter%E7%B1%BB"><span class="toc-number">12.4.1.</span> <span class="toc-text">BufferedReader与BufferedWriter类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">12.4.1.1.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">12.4.1.1.1.</span> <span class="toc-text">基本文件操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">12.4.2.</span> <span class="toc-text">获取网页源代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="toc-number">13.</span> <span class="toc-text">第16章 反射与注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">14.</span> <span class="toc-text">第18章 Swing程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Swing%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">Swing概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swing%E5%B8%B8%E7%94%A8%E7%AA%97%E4%BD%93"><span class="toc-number">14.2.</span> <span class="toc-text">Swing常用窗体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jdialog-%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">14.2.1.</span> <span class="toc-text">Jdialog 对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">14.3.</span> <span class="toc-text">常用布局管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#null-%E7%BB%9D%E5%AF%B9%E5%B8%83%E5%B1%80"><span class="toc-number">14.3.1.</span> <span class="toc-text">null 绝对布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlowLayout-%E6%B5%81%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">14.3.2.</span> <span class="toc-text">FlowLayout 流布局管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BorderLayout-%E8%BE%B9%E7%95%8C%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">14.3.3.</span> <span class="toc-text">BorderLayout 边界布局管理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GridLayout-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">14.3.4.</span> <span class="toc-text">GridLayout 网格布局管理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E9%9D%A2%E6%9D%BF"><span class="toc-number">14.4.</span> <span class="toc-text">常用面板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JPanel-%E9%9D%A2%E6%9D%BF"><span class="toc-number">14.4.1.</span> <span class="toc-text">JPanel 面板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JScrollPane-%E6%BB%9A%E5%8A%A8%E9%9D%A2%E6%9D%BF"><span class="toc-number">14.4.2.</span> <span class="toc-text">JScrollPane 滚动面板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84"><span class="toc-number">14.4.2.1.</span> <span class="toc-text">图片路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">14.5.</span> <span class="toc-text">事件监听器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ActionEvent%E5%8A%A8%E4%BD%9C%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.5.1.</span> <span class="toc-text">ActionEvent动作事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KeyEvent%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.5.2.</span> <span class="toc-text">KeyEvent键盘事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MouseEvent%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">14.5.3.</span> <span class="toc-text">MouseEvent鼠标事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">第二十章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.1.</span> <span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.1.1.</span> <span class="toc-text">实现Runnable()接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="toc-number">15.2.</span> <span class="toc-text">线程的生命期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">15.3.</span> <span class="toc-text">操作线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8A%A0%E5%85%A5"><span class="toc-number">15.3.1.</span> <span class="toc-text">线程的加入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">15.4.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">15.5.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">15.5.1.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">15.5.2.</span> <span class="toc-text">线程同步机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1-1"><span class="toc-number">16.</span> <span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">16.1.</span> <span class="toc-text">网络程序设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">16.1.1.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">16.1.2.</span> <span class="toc-text">套接字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.2.</span> <span class="toc-text">TCP程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IntetAddress%E7%B1%BB"><span class="toc-number">16.2.1.</span> <span class="toc-text">IntetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SeverSocket%E7%B1%BB"><span class="toc-number">16.2.2.</span> <span class="toc-text">SeverSocket类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.2.3.</span> <span class="toc-text">TCP网络程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E7%A8%8B%E5%BA%8F"><span class="toc-number">16.3.</span> <span class="toc-text">UDP程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramPacket%E7%B1%BB"><span class="toc-number">16.3.1.</span> <span class="toc-text">DatagramPacket类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DatagramSocket%E7%B1%BB"><span class="toc-number">16.3.2.</span> <span class="toc-text">DatagramSocket类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">16.3.3.</span> <span class="toc-text">UDP网络程序设计</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93-php%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="数据库&amp;php大作业"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库&amp;php大作业"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93-php%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="数据库&amp;php大作业">数据库&amp;php大作业</a><time datetime="2023-07-10T02:51:46.000Z" title="发表于 2023-07-10 10:51:46">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E7%A3%A8%E8%B9%AD%E5%A4%A9%E6%B0%94app-%E5%AE%89%E5%8D%93%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="磨蹭天气app--安卓大作业"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="磨蹭天气app--安卓大作业"/></a><div class="content"><a class="title" href="/2023/07/10/%E7%A3%A8%E8%B9%AD%E5%A4%A9%E6%B0%94app-%E5%AE%89%E5%8D%93%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="磨蹭天气app--安卓大作业">磨蹭天气app--安卓大作业</a><time datetime="2023-07-10T02:28:07.000Z" title="发表于 2023-07-10 10:28:07">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="数据库笔记"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库笔记"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" title="数据库笔记">数据库笔记</a><time datetime="2023-07-10T02:09:42.000Z" title="发表于 2023-07-10 10:09:42">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%AC%94%E8%AE%B0/" title="软件需求笔记"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件需求笔记"/></a><div class="content"><a class="title" href="/2023/07/10/%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%AC%94%E8%AE%B0/" title="软件需求笔记">软件需求笔记</a><time datetime="2023-07-09T16:24:37.000Z" title="发表于 2023-07-10 00:24:37">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/09/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%AC%94%E8%AE%B0/" title="人机交互笔记"><img src="/images/NoCover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="人机交互笔记"/></a><div class="content"><a class="title" href="/2023/07/09/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92%E7%AC%94%E8%AE%B0/" title="人机交互笔记">人机交互笔记</a><time datetime="2023-07-09T15:05:50.000Z" title="发表于 2023-07-09 23:05:50">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bc.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Joel</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@undefined/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>