<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Deep Learning | yjchen</title><meta name="keywords" content="python,深度学习"><meta name="author" content="JJuprising"><meta name="copyright" content="JJuprising"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Deep Learning"><meta name="application-name" content="Deep Learning"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Deep Learning"><meta property="og:url" content="https://jjuprising.github.io/2022/09/27/Deep%20Learning/index.html"><meta property="og:site_name" content="yjchen"><meta property="og:description" content="基础知识机器学习机器学习三大范式  监督学习，数据+标签 无监督学习，大数据没法给标签，根据相似性将用户自动分成几类 同一类人群，产品可以互推   强化学习 扫地机器人，撞到扣分，没撞到加分    K邻近聚类算法  簇的个数是超参数，假设是3 随机选三个中心点，计算中心点和其他点的距离，求平均距离"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://jjuprising.github.io/img/404.jpg"><meta property="article:author" content="JJuprising"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://jjuprising.github.io/img/404.jpg"><meta name="description" content="基础知识机器学习机器学习三大范式  监督学习，数据+标签 无监督学习，大数据没法给标签，根据相似性将用户自动分成几类 同一类人群，产品可以互推   强化学习 扫地机器人，撞到扣分，没撞到加分    K邻近聚类算法  簇的个数是超参数，假设是3 随机选三个中心点，计算中心点和其他点的距离，求平均距离"><link rel="shortcut icon" href="/images/sta_logo.jpg"><link rel="canonical" href="https://jjuprising.github.io/2022/09/27/Deep%20Learning/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: JJuprising","link":"链接: ","source":"来源: yjchen","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'yjchen',
  title: 'Deep Learning',
  postAI: '',
  pageFillDescription: '基础知识, 机器学习, K邻近, 逻辑回归, 线性回归, 代价函数, 逻辑损失函数, 梯度下降, 如何理解, 学习率, 多维线性回归, 多元特征, 矢量化 vectorization, , 多层感知机, 激活函数, 损失函数, 梯度下降, 什么是梯度下降, 神经网络与梯度下降, 超参数, 学习率, 如何设置和调整学习率, 优化器, 卷积神经网络, 卷积, 采样层(池化层pooling), 最大池化, 如何进行, 池化的性质, 激活函数, 线性方程, 待解决问题, 非线性, 输出需要进行分类, 输入可能特别大, 线性方程梯度与输入无关了, 激活函数, dropout, 全连接层, 编码器解码器, 深度学习, 残差网络Resnet, 为什么有效果, 注意力机制, 组件, Transformer, QKV, 关键点, Norm, 迁移学习transfer learning, Domain Adaptation, 适用环境, 域对抗训练 Damain Aversival Trainng, 损失计算, limitation, BCI, 常见指标, 图像生成, 自监督学习, 对比学习, CLIP, 扩散模型, 正态分布, 扩散模型, 前向加噪, GAN, DALL 3, Pytorch, 加载数据, 数据的组织形式, Tensorboard, add_scalar, add_image(), Transform, tensor数据类型, ToTensorampNormalize, resize(), Compose(), RandomCrop(), 总结, 和transform联动, DataLoader, 神经网络, 卷积操作, 卷积层, 池化层, 非线性激活 Non-linear, 线性层及其他层, CRAF10小实战及Sequential()基础知识机器学习机器学习三大范式监督学习数据标签无监督学习大数据没法给标签根据相似性将用户自动分成几类同一类人群产品可以互推强化学习扫地机器人撞到扣分没撞到加分邻近聚类算法簇的个数是超参数假设是随机选三个中心点计算中心点和其他点的距离求平均距离改变中心点如果距离要小说明更合适作为中心点中心点改变有多种策略如何选取簇对于多维两两选择特征画图多画几个看能分成几个簇然后直接选最大的那个如果在报告里就做主成分分析找出最具代表性的特征两两组合判断簇个数然后开始聚类随机初始化选簇然后进行聚类计算目的就是逐渐逼近一个最优解聚类算法在里有开源代码邻近传播算法逻辑回归这里就要提到函数比如预测会不会下雨样本标签只有会和不会这种情况没办法用线性方差拟合而就可以拟合这个关系假设横轴是云雾密度那么我们可以更具轴得到一个预测值如果大于就预测为会下雨小于预测不会下雨逻辑回归就是对于我们本身是一个函数这是就是一个逻辑回归函数决策边界就是将两种类型的样本划分的边界先观察再确定例如直线椭圆线性回归代价函数对于线性回归一般是凸代价函数在梯度下降中就能够一步一步逼近全局最优然而逻辑回归的非凸代价函数就容易陷入局部最小值上面的代价函数求和里边代表单个训练样本我们在计算损失时就是用的里面单个训练样本来计算因此我们需要选择合适的损失函数使得总的代价函数是一个凸函数逻辑损失函数为什么要这样定义损失函数我们根据图来分析核心点就是当预测值越接近实际值则越小奖励越大当越远离则越带需要惩罚参考下图对于标签为的样本我们看的蓝色因为取值只有所以直接看左边图例的看作当越接近对应的越小越小同理也就是当越接近损失越小可以证明当用这样一组去优化上面的总代价函数就是一个凸函数能够逐步得到全局最优解梯度下降尽管两个的损失函数是一样的但是函数的定义不一样定义是加快梯度下降的方法和线性回归相似观察学习曲线矢量化特征缩放如投影到如何理解例如对于下面的损失函数我们假设函数图像学习率下面可以看到后面的微分就是在点处的导数即斜率当斜率为正数正数变小斜率为负数负数变大可以看到都在朝着代价函数不断减小的方向进行指的是学习率学习率可以看到学习率比较小的时候梯度下降会很慢当学习率很大的时候可能收敛不了局部最小值问题当损失函数处于最小值根据公式此时导数项为不会再更新了陷入局部最小值当函数是一凸函数例如线性回归他的损失函数是一个碗形也就是只有一个全局最小值那么梯度下降就可以找到最小值从上图可以看到当点的越接近最小值左上角的直线能够更好拟合数据批梯度下降多维线性回归多元特征一位特征多维特征把和表示为向量即向量点积这个算法叫多元线性回归矢量化在的中效率更高在硬件中通过矢量化并行计算的数据量大用这个很关键相当于多层感知机激活函数损失函数梯度下降什么是梯度下降作用优化损失函数找极小值损失函数要找最小梯度梯度就是函数对它的各个自变量求偏导后由偏导数组成的一个向量简单来说就是导数多了方向这个很关键后面提到在下图情况有可能陷入局部最小值也就是左边最小值但他不是全局最小因此就需要随机初始化几次多尝试几次那么如何找呢以一元二次函数为例假设红点处是一个初始值我们对该点进行求导导函数当减小也就是黑色箭头方向导数是在减小的代表导数反方向橙色箭头方向导数增加代表导数正向为了找到极小值我们需要让红点朝着黑色方向移动这就是梯度下降的目的实现这一过程需要提到学习率让减去学习率乘以函数的导数学习率的目的是控制更新的幅度如果小那么每次更新的幅度就小进行迭代更新曲线逐渐平缓最终会收敛到一个局部的极值点也就是当导数无限逼近最终停留在极值点全世界最通俗易懂的梯度下降法详解优化函数大法知乎神经网络与梯度下降神经网络方面的一个巨大突破是从函数转换到一个函数为什么使用在轴负向梯度会接近学习速度变得很慢而换用对于输入的负值梯度都是不会趋向逐渐减少到这使得梯度下降算法运行得更快超参数学习率学习率决定了在每步参数更新中模型参数有多大程度或多快多大步长的调整学习率是在梯度下降的过程中更新权重时的超参数即下面公式中的学习率越低损失函数的变化速度就越慢容易过拟合虽然使用低学习率可以确保我们不会错过任何局部极小值但也意味着我们将花费更长的时间来进行收敛特别是在被困在局部最优点的时候而学习率过高容易发生梯度爆炸振动幅度较大模型难以收敛学习率的影响如何设置和调整学习率调整学习率的套路通常是先设置一个初始学习率这个初始学习率应该让损失尽可能快地降低然后训练过程中按照一定的降低学习率或用算法根据实际训练情况自适应地调整学习率另外在正式开始训练之前还应该有一小段热身的过程热身的原因是一开始模型参数是完全随机的需要谨慎地更新参数不能一上来就用初始学习率优化器随机梯度下降基本思想在每一步更新中仅使用一个或一小批样本来计算梯度而不是使用整个数据集这种方法可以显著减少计算量使得训练大规模数据集变得可行学习率通常需要手动调整学习率并且可能会使用如学习率衰减这样的技巧来帮助模型收敛学习率的选择对的性能影响很大收敛速度的收敛速度通常比较慢尤其是在接近最小值的平坦区域泛化能力研究表明由于的噪声更大它可能有助于模型找到泛化性能更好的解自适应矩估计基本思想是一种自适应学习率的优化算法它结合了动量和的优点会为不同的参数计算不同的自适应学习率学习率自动调整学习率通常不需要像那样手动微调学习率这使得在很多情况下都能较快地收敛收敛速度由于自适应学习率的特性在初期训练阶段通常比收敛得更快泛化能力尽管在许多任务中都显示出了较快的收敛速度但一些研究表明对于某些问题可能导致过拟合泛化能力不如卷积神经网络简单神经网络和卷积神经网络卷积神经网络起到一个分类器的作用卷积层负责提取特征采样层负责特征选择全连接层负责分类卷积卷积层如何提取特征呢用到卷积核又叫滤波器是可以用来提取特征的卷积核放在神经网络里就代表对应的权重卷积核和图像进行点乘就代表卷积核里的权重单独对相应位置的进行作用至于为什么要把点乘完所有结果加起来实际上就是把所有作用效果叠加起来我们知道输入知道神经元的权值了根据神经网络公式还需要设置偏置先假设为我们分别对三个分量的其中一个的九宫格进行卷积所以结果为三个卷积核的输出为什么要叠加在一起呢你可以理解为三个颜色特征分量叠加成特征分量但是不能够对随即找然后进行卷积除了特征值还有相对位置需要考虑因此也需要按照正确的顺序去进行卷积最经典的就是从左到右每隔列向右移动一次卷积核进行卷积可以自己定义到达最右从上到下每隔行向下移动一次卷积核移动完成再继续如上所述从左到右进行就这样我们先从左到右再从上到下直到所有都被卷积核过了一遍完成输入图片的第一层卷积层的特征提取这里的我们叫作就是步长的意思如果我们就是相当每隔两行或者两列进行卷积同时我们可以看到分量的外面还围了一圈称为补相当于什么信息都没加对比补了和没补同样一行补执行了多几次的卷积操作好处在于可以获得更多细致特征信息比如图像的边缘信息我们可以控制卷积层输出的特征图的从而可以达到控制网络结构的作用还是以上面的例子如果没有做以及第二层卷积层的卷积核仍然是那么第二层卷积层输出的特征图就是的特征提取就这么结束了同样的情况下加了的第二层卷积层输出特征图仍然为这样我们可以再增加一层卷积层提取更深层次的特征卷积神经网络入门讲解知乎涉及到具体代码如何变化举例在类中每一步的数据维度变化如下输入输入张量的形状为在方法的开始这个形状被打印出来扩展维度增加一个通道维度使得输入形状变为经过后形状为卷积层是一个卷积层它的输入形状是的参数是意味着卷积核大小为步幅为输出通道数为卷积运算后形状变为在之后输出形状为激活函数是一个激活函数不改变形状在之后输出形状仍为是一个层也不改变形状在之后输出形状仍为展平将输出展平成二维张量计算除了批次维度外的所有维度的乘积即将输出形状展平为最终输出形状为修改后的完整代码如下复制代码层是一个二维卷积层我们来详细解释一下的参数以及它是如何改变输入张量的维度的参数输入的通道数是输出的通道数是卷积核的大小是步幅是在高度方向和在宽度方向没有偏置项输入形状输入形状是即卷积计算卷积层的输出维度计算如下输出高度公式在我们的例子中输出宽度公式在我们的例子中输出形状通道数变为即高度变为即宽度变为即所以卷积层的输出形状是即总结具体维度变化如下输入形状输入张量的形状是即扩展维度将输入形状扩展为即卷积层将输入形状变为因此通过层数据维度从变为采样层池化层最大池化最大池化字面意思就是直接取最大的例如下面矩阵图数值代表特征程度最大池化选择含义就是代表这个区域最符合特征的然后去掉没有的为什么要这么做作者举了个很形象的例子比如这里四个美女要选一个每个人的选择都是最符合自己的也就是四个中最符合的特征其他的丢掉那为什么不能都选呢不做首先你娶回个她们会各种勾心斗角让你崩溃然后你会有巨大的经济压力身体也吃不消参数过多导致运算量大最后可能还会难以平衡婆上一次卷积层媳或者母子下一层卷积层关系无法满足模型结构需求如何进行例如下图可以类比卷积就是一个的卷积核为从左到右从上到下作用是选取核里最大的值而不是做卷积运算池化的性质可以一定程度提高空间不变性比如说平移不变性尺度不变性形变不变性空间不变性体现在卷积是对一个区域一个区域进行卷积关注单独区域的特征以及特征之间的相对位置当图像发生细微变化经过卷积和输出结果和原来差别可能不大甚至很小平移不变性图像经过一个小小的平移之后依然产生相同的池化特征激活函数在接触到深度学习后特别是神经网络中我们会发现在每一层的神经网络输出后都会使用一个函数比如等等对结果进行运算这个函数就是激活函数为什么要激活函数简而言之因为神经网络每层输入输出都是线性求和过程不管怎么叠加变换都是线性组合不能解决非线性问题而通过激活函数可以使神经网络逼近任何非线性函数应用于复杂的非线性分类问题我们从最简单的开始讲线性方程下图就是一个最简单的神经元其实就是一个线性方程然而这个神经网络只能够解决普通的线性二分类问题比如现实中其实更多的都是复杂的二分类具有非线性的特点那么怎么做呢首先叠加神经网络行不行这里我们对神经元进行叠加列出公式我们假设那么这又回到了一个线性方程由于线性函数具有可加性和其次性所以仅靠简单的叠加是不能够解决非线性问题的待解决问题非线性那如何将线性神经网络转为非线性呢我们首先想到二次函数某一个二次函数经过调整可以将非线性问题进行分类输出需要进行分类我们的神经网络还是最简单的根据的值我们会得到值所以我们需要一个函数可以对得到的值进行分类的比如大于分类为小于分类为输入可能特别大对于神经网络我们需要算出输出误差来更新权值如果输出绝对值太大甚至无限大那么输出会特别大直接导致非常大那么更新出来的权值没有意义或无法更新权值线性方程梯度与输入无关了线性神经网络导数为常数那么梯度就与输入无关了在反向传播时候梯度改变也变为常数和输入的改变关联不上了激活函数解决上面的问题就需要激活函数了入门讲解什么是激活函数知乎为什么需要采样一个更薄的神经网络减少神经元之间的共适应性迫使学习更加鲁棒的特征产生的动机使用训练的神经网络中的每个隐藏单元必须学会与随机选择的其他单元样本一起工作这样会使得每个隐藏单元更加的健壮并使得他们尽量自己可以创造有用的功能而不是依赖其他隐藏单元即按照论文的话来说减少神经元之间复杂的共适应关系官方论文例子个人分十个组每五个人完成一个小阴谋可能比个人正确扮演各自角色完成一个大的阴谋更容易当然在时间足够各种条件没有改变的情况下那么完成一个大阴谋是更适合的但生活总是充满变数大阴谋往往不太容易实现这样小的阴谋发挥作用的机会就会更大同样的在训练集上各个隐藏单元可以协同发挥作用即可以在训练集上可以训练的很好但是这并不是我们需要的我们需要他们在新的测试集上可以很好的合作这时候体现出了它的价值本质上看通过使其它隐藏层神经网络单元不可靠从而阻止了共适应的发生因此一个隐藏层神经元不能依赖其它特定神经元去纠正其错误因为程序导致两个神经元不一定每次都在一个网络中出现这样权值的更新不再依赖于有固定关系的隐含节点的共同作用阻止了某些特征仅仅在其它特定特征下才有效果的情况迫使网络去学习更加鲁棒的特征这些特征在其它的神经元的随机子集中也存在全连接层全连接层的作用主要就是实现分类训练完到最后一步猫头猫尾猫再往前可以做对子特征进行分类猫眼猫胡须猫头这些细节特征哪来的呢就是从前面的卷积层下采样层来的二层全连接全连接层对模型的影响因素全连接层的总层数长度单个全连接层的神经元数宽度激活函数作用增加模型的非线性表达能力如果全连接层宽度不变增加长度总层数优点全连接层数加深模型非线性表达能力提高理论上都可以提高模型的学习能力如果全连接层长度不变增加宽度神经元个数优点神经元个数增加模型复杂度提升理论上可以提高模型的学习能力难度长度和宽度都是越多越好肯定不是缺点学习能力太好容易造成过拟合缺点运算时间增加效率变低那么怎么判断模型学习能力如何看以及在其他条件理想的情况下如果高低也就是过拟合了可以尝试去减少层数或者参数如果低说明模型学的不好可以尝试增加参数或者层数至于是增加长度和宽度这个又要根据实际情况来考虑了编码器解码器表征学习数据压缩特征降维编码器学习数据的特征逐步压缩输入信息目的是将所有必要信息编码到一个抽象的中间表达表示中解码器的任务是将编码器输出的内部表示转换为目标序列解码器逐步生成输出序列每一步都可能依赖于前一步的输出以及从编码器传递过来的上下文信息在生成过程中解码器逐渐解开编码器压缩的信息将其转化为有意义的输出在这个抽象可以给一些随机数如果模型学习的好应该能够出来一个和相近的结果输入数据要洗牌从不同角度观察保证多样性编码器解码器结构的基类结合一些其他输入深度学习推荐动手学深度学习动手学深度学习残差网络封私信条消息为什么残差连接的网络结构更容易学习知乎解决层数增多两个问题梯度消失或梯度爆炸退化问题亮点提出了残差结构超深层数也能训练很好使用加速训练丢弃就是弯弯的线就是除了弯弯的线为什么有效果在计算图中经过了如下的权重层导致有多条路径可以选择的结果由于上述计算过程同时设计正向传播和反向传播会贯穿整个网络导致网络越深最后的梯度计算结果中前面乘上的权重系数也会越来越多结果是前面乘的权重系数会越来越多因为不管是正向传播还是反向传播每条路径经过一个权重因子都会乘上这个权重因子随着层数的增加路径变得越来越长在这条路上走一走遇到的权重因子也会越来越多梯度会整体的变小也就是说网络变深了梯度虽然每层的相同但是整体变小了如果网络足够深每一层的梯度都变小到感受不到了这也就是当初祖师爷虽然用这个神器解决了梯度分布不均匀的问题但是却留下了一个更大的问题权重分布是均匀了但是整体变小了的解决方法非常粗暴就是加入这个在梯度计算图中相当于增加了一条可以跳过权重的层的路径使得最终计算所得的权重处的梯度加上一项没有经过权重层衰减的梯度注意力机制组件查询代表需要获取信息的请求键与相关性的衡量标准值包含需要被提取信息的实际数据权重通过和的相似度计算得来决定了从各个中提取多少信息举例说明假设我们有一个简单的句子猫喜欢追逐老鼠如果我们要对喜欢这个词进行编码一个简单的方法是只看这个词本身但这样会忽略它的上下文喜欢的对象是猫而被喜欢的是追逐老鼠在这里猫和追逐老鼠就是喜欢的上下文而注意力机制能够帮助模型更好地捕获这种上下文关系使用实现简单的点积注意力初始化对应于喜欢的编码对应于猫追逐老鼠的编码也对应于猫追逐老鼠的编码计算注意力权重计算注意力输出注意力权重注意力输出输出注意力权重注意力输出这里喜欢通过注意力权重与猫和追逐老鼠进行了信息的融合并得到了一个新的编码从而更准确地捕获了其在句子中的语义信息解码注意力机制从技术解析到实战代码博客简单来说包含架构就是输入输出只不过一般和都会叠很多层在包含和前馈网络表示将输入赋不同权重关注度后拆解在包含和这里的编解码就是不仅要关注零件本身还要考虑全局上下文关系在翻译中就是不仅要考虑已经翻译的内容还要考虑上下文意思每个分解为多个部分也就是多头注意力是由输入的词向量经过线性变换得到的其中各个矩阵可以经过学习得到这种变换可以提升模型的拟合能力得到的可以理解为要查询的信息被查询的向量查询得到的值总结一下首先都源于输入特征本身是根据输入特征产生的向量但目前我们现在无需关注是如何产生这组向量的可以看做表示单个输入特征的向量当我们直接把一组输入到网络中进行训练那这个网络就是没有引入机制的网络但如果引入就需要将这组分别乘以一组权重那么就可以做到有重点性地关注输入特征如同人的注意力一般中的通俗理解渣男与备胎的故事博客关键点自注意力机制每个字和序列中其他次都有一个权重来表示关系重要程度这解决了传统面对长序列会遗忘掉关联信息地问题位置编码输入数据首先进行词嵌入即将词用一串数字表示然后每个字会有一个位置向量添加到输入序列中模型不仅能理解每个词意思还知道它和上下文的关系从而理解不同词的顺序借助位置编码就可以并行计算因为已经知道每个词和序列的关系不像按顺序依次处理文本训练慢在中我们可以看到很多操作也就是说它是先将上一层的输出和当前层的输出相加之后再进行的这就属于如果我们像绿色箭头指向的那样在输入下一层之前现执行操作然后传入下一层同时在下一层只把和相加那就是也可以作如下总结是在操作后进行操作因此叫做而则是之后再所以叫是什么知乎浅谈的初始化参数化与标准化科学空间迁移学习训练集是一个分分布输入分布与训练是不同的那么效果会变差很多例如训练时黑底白字源域测试是彩色底目标域彩色字在现实应用中这种情况非常需要解决你训练的模型是否能够适应新的分布情况呢适用环境目标域有标签的数据很少那就可以用来回调源域的训练因为目标域很少避免迭代次数不要过多避免过拟合少数据学习率减少目标域数据很多但是没有标注符合真实场景下面讲讲这种如图也就是找一个特征提取器都提取两个域的特征然后我们留下共性的部分来用那么如何找到这个呢域对抗训练一个基本的模型就是有输入特征提取标签预测输出不能直接把目标域丢进去因为就算丢进去出来一个预测标签因为原始数据中没有没有办法判断他们的用处就在于丢进去后在特征提取器之后拿出来看我们希望它的和源域丢进去得到的分不出差异也就是下图蓝点和红点差异分不出因此问题就来到了如何涉及一个是一个二元分类器他的作用就是判断我们拿到的是来自源域还是来自目标域而的任务就是学习如何骗过使得它分不出是来自哪个域的它的结构和很小可以把类比成把类比成问题来了如果每次都输出一个不就达到目的了吗不行的因为还要让判断出实际的所以不能耍赖损失计算在因为知道真实标签和域标签所以可以用去算一个记为在二元分类计算越小越好越能分出域而则是要让越大越好即能很好分出又能够让分不出目标域在分布不同下图显然右边效果是我们期望看到的解决办法就是离越远越好即输出的结果越集中在某个类别文献目标域因为没有标签他的类别可能会和源域不同文章强行拉直可能损失信息并且的权重如果过高的效果会很差因此是不好训练的当对目标域完全位置的时候就变成了也就是训练是真实的素描的狗但是测试的是卡通的狗又比如训练只有一个测试有多个这种一般就是先做数据增强然后就变成上一步的问题常见指标信号传输率为可选目标数为目标识别准确率为响应时间上式的单位为值的大小代表了单位时间系统输出的信息量计算公式如下表示系统在单位时间内所能做出的决策次数图像生成自监督学习自监督学习不需要人工标注的类别标签信息直接利用数据本身作为监督信息学习样本数据的特征表达应用于下游的任务自监督学习又可以分为对比学习和生成学习两条主要的技术路线对比学习首先学习未标记数据集上图像的通用表示形式然后可以使用少量标记图像对其进行微调以提升在给定任务例如分类的性能简单地说对比表示学习可以被认为是通过比较学习相对来说生成学习是学习某些伪标签的映射的判别模型然后重构输入样本对比学习对比学习的核心思想是讲正样本和负样本在特征空间对比学习样本的特征表示难点在于如何构造正负样本对比学习通过使用三个关键的元素正样本负样本的表征来实现上述思想为了创建一个正样本对我们需要两个相似的样本而当我们创建一个负样本对时我们将使用第三个与两个正样本不相似的样本自监督学习中的对比学习持续更新对比学习和生成学习博客的英文全称是即一种基于对比文本图像对的预训练模型基础论文学习博客扩散模型正态分布正态分布如果一个随机事件收很多随机因素影响但没有任何一个决定性那么概率分布密度函数就会呈现钟形曲线即正态分布高斯分布标准正态分布表示即均值表示即标准差一组随机数大部分接近均值小部分超出正负一个标准差的数称为高斯噪声扩散模型往水里滴一滴墨水墨水在水中会扩散开了布朗运动扩散指物质例子从高浓度往低浓度移动的过程一堆花粉足够长的时间扩散出一团就是高斯分布也就是正态分布而扩散模型受此启发通过往图片加入高斯噪声模拟这一过程并通过逆向过程从随机的噪声中生成图片时光倒流时间往回推就会更靠近初始位置一点正向是无序的但是反序就变回有序的熵增删减我们需要一个向量场类似一个导航指引杂乱无章的例子逐渐靠近源头这与图片生成有什么关系生成图片本质就是让一堆无序的粒子排成有序的队形一个图片比前向加噪表示的图片每个像素都一个调整逐渐增加使得加噪比例越来越大是服从标准正态分布重新采样的随机数不需要罗列只需要两个序列方向匹配不断平移对齐分别计算出上下点数各组合的概率求和就得到了响应总点数的概率叫卷积对两个概率分布进行卷积操作实际上就是计算两个分布所有组合的情况得到叠加后的概率分布卷积后的概率密度仍符合正态分布硬核科普清华博士教你是怎么生成图片和视频的哔哩哔哩如何理解通过从文本到图像生成的过程答加入文本信息后实际上最大的改变就是在噪声预测的时候加入了一个新的输入即文本这里我们可以和条件对比来理解关于的问题和理解知乎损失函数表示的是生成样本和真实样本的差异度可以使用二分类真假两个类别的交叉熵损失目的就是让生成的图片能够骗过判别器原理文本编码器将图像描述映射到表示空间然后扩散先验从文本编码映射到相应的图像编码最后修改版的生成模型通过反向扩散从表示空间映射到图像空间生成众多可能图像中的一个海量数据对改进最大的改进就是样本质量的提高其次模型结构微调了论文未披露最后就是加持提示词转化精度更高发布原理简介知乎函数能让我们知道工具箱以及工具箱中的分隔区有什么东西函数能让我们知道每个工具是如何使用的工具的使用方法或者三个区域编写代码的文件整体运行文件的块是所有行的代码适用大型项目每次都是整体运行的控制台以任意行为块变量属性在右边查看出现错误可阅读性大大降低同控制台执行块可以直接修改块中的错误阅读性加强环境需要配置加载数据一堆数据提供一种方式去获取数据及其为后面的网络提供不同的数据形式如何获取每一个数据及其告诉我们总共有多少数据数据的组织形式文件夹名就是一个图片对应图片的文字坐标信息图片名就是实战案例数据集文件夹数据集标签拼接路径这里正好文件夹名就是标签名将文件夹下图片转换成列表是索引获取单张图片名字拼接获得单张图的地址图片读取获取标签长度即数据集的列表长度大路径蚂蚁标签蜜蜂标签实例化蚂蚁实例化蜜蜂拼接数据集看模块的代码按住点模块打开窗口不接默认打开端口的标题轴轴重新画删掉文件下下的所有文件在终端结束后重新打开窗口读取到的数据是型从到需要在中指定中每一个数字维表示的含义默认是即通道高度宽度如果导入图片是就要加入说明见案例打开图片转成型验证时型检查图片的形状发现是即高度宽度通道对应图片的形状工具箱有等工具用于处理图片输出想要的图片结果的使用数据类型在括号内查看要输入的参数数据类型转成类型标准差接上面代码原图的大小改大小中的参数需要一个列表中列表的表示形式为数据数据在中数据需要是类型所以得到的参数参数将几步打包成一步只改了宽没改长随机裁剪出一部分设置不同步数总结关注输入和输出多看官方文档关注方法需要什么参数不知道返回值的时候调试数据集的使用官网文档的下有很多数据集可以使用提供训练好的模型上面讲了提供小工具下载训练集下载测试集的形式发现第一个是图片第二个是查看图片有哪些类型调式看有属性接收和联动设置加入参数结果准备测试数据集测试数据集中第一张照片及返回值是设定的一组图片打包的和神经网络是所有神经网络的基类隐藏层经过一次卷积然后一次非线性输出卷积操作各种参数表示卷积核在输入图像上移动一格对应格相乘得到数从左到右到边界回到最左向下移动然后重复操作只有两个参数不能直接放进卷积要矩阵变成四个参数输出卷积层一维卷积二维卷积层彩色图像一般是三通道参数表输入通道数输出通道数卷积核大小卷积操作步径大小边缘填充卷积核距离后面都是默认参数卷积层示例动图要梯子才能刷出来设置为时会生成两个卷积核得到两个叠加的输出一般卷积操作会不断增加数例子原本输出通道数变两倍这一步相当于切开放到一个池化层向下取整向上取整默认不够对应不取值实现最大池化声明一下类型否则报错注意当设置为结果当设置为结果最大池化目的为了保持原先数据的特征同时减少数据量加快训练速度例如也能大致看明白视频内容例子最大池化可以看到输出图片变模糊了非线性激活用到或主要目的在网络中引入更多非线性特征才能训练出符合更多特征的模型线性层及其他层表示要不要设置偏振展平成一行小实战及由公式计算第一步卷积得到是默认设置为通过对每一步的解析我们建立出一个简单的模型代码如下提供的一个假设的输入',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-31 15:36:08',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/./images/ava.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">yjchen</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cv/cyj_CV.pdf"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> CV</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 1.05rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 1.05rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 1.05rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 1.05rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 1.05rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 1.05rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 1.05rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.05rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.05rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 1.05rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>6</sup></a><a href="/tags/%E8%84%91%E7%94%B5/" style="font-size: 1.05rem;">脑电<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 1.05rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/11/"><span class="card-archive-list-date">十一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url">深度学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/python/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>python</span></a><a class="article-meta__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>深度学习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Deep Learning</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2022-09-27T13:01:14.000Z" title="发表于 2022-09-27 21:01:14">2022-09-27</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-10-31T07:36:08.707Z" title="更新于 2024-10-31 15:36:08">2024-10-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为广州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>广州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/404.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://jjuprising.github.io/2022/09/27/Deep%20Learning/"><header><a class="post-meta-categories" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url">深度学习</a><a href="/tags/python/" tabindex="-1" itemprop="url">python</a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url">深度学习</a><h1 id="CrawlerTitle" itemprop="name headline">Deep Learning</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">JJuprising</span><time itemprop="dateCreated datePublished" datetime="2022-09-27T13:01:14.000Z" title="发表于 2022-09-27 21:01:14">2022-09-27</time><time itemprop="dateCreated datePublished" datetime="2024-10-31T07:36:08.707Z" title="更新于 2024-10-31 15:36:08">2024-10-31</time></header><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>机器学习三大范式</p>
<ul>
<li>监督学习，数据+标签</li>
<li>无监督学习，大数据没法给标签，根据相似性将用户自动分成几类<ul>
<li>同一类人群，产品可以互推</li>
</ul>
</li>
<li>强化学习<ul>
<li>扫地机器人，撞到扣分，没撞到加分</li>
</ul>
</li>
</ul>
<h3 id="K邻近"><a href="#K邻近" class="headerlink" title="K邻近"></a>K邻近</h3><p>聚类算法</p>
<ul>
<li>簇的个数是超参数，假设是3</li>
<li>随机选三个中心点，计算中心点和其他点的距离，求平均距离</li>
<li>改变中心点，如果距离要小，说明更合适作为中心点</li>
<li>中心点改变有多种策略</li>
</ul>
<p>如何选取簇，对于多维，两两选择特征画图，多画几个看能分成几个簇，然后直接选最大的那个</p>
<p>如果在报告里，就做主成分分析，找出最具代表性的特征，两两组合判断簇个数，然后开始聚类</p>
<p>随机初始化选簇，然后进行聚类计算。目的就是逐渐逼近一个最优解</p>
<p>聚类算法</p>
<ul>
<li>DBSCAN，在skilearn里有开源代码</li>
<li>AP邻近传播算法</li>
</ul>
<h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>这里就要提到sigmoid函数。比如，预测会不会下雨，样本标签只有会(1)和不会(0)，这种情况没办法用线性方差拟合。而sigmoid就可以拟合这个关系。假设横轴是云雾密度，那么我们可以更具x轴得到一个预测值，如果大于0.5就预测为会下雨，小于0.5预测不会下雨</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/zJ64RApWTjHyhIq.jpg" alt="Standard sigmoid function | Download Scientific Diagram"></p>
<p>逻辑回归(logistic regression)就是对于我们f(z)&#x3D;sigmoid(z)&#x3D;1&#x2F;(1+e<sup>z</sup>)，z本身是一个函数z&#x3D;wx+b，这是f(z)就是一个逻辑回归函数</p>
<p>决策边界：就是将两种类型的样本划分的边界，先观察，再确定，例如直线&#x2F;椭圆</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/39N6u1GkOfWLbAn.jpg" alt="决策边界 的图像结果"></p>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h4 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h4><p>$$<br>J(\vec{w},b)&#x3D;\frac{1}{m}\sum_{i&#x3D;1}^{m}\frac{1}{2}(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)-y^{(i)})^{2}<br>$$</p>
<p>对于线性回归，一般是凸代价函数，在梯度下降中就能够一步一步逼近全局最优，然而逻辑回归的非凸代价函数就容易陷入局部最小值。上面的代价函数，求和里边代表单个训练样本。我们在计算损失时就是用的里面单个训练样本来计算。</p>
<p>因此我们需要选择合适的损失函数，使得总的代价函数是一个凸函数</p>
<h5 id="逻辑损失函数"><a href="#逻辑损失函数" class="headerlink" title="逻辑损失函数"></a>逻辑损失函数</h5><p>为什么要这样定义损失函数，我们根据图来分析<br>$$<br>L\big(f_{\vec{w},b}\big(\vec{x}^{(i)}\big),y^{(i)}\big)&#x3D;\begin{cases}-\log\Big(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\Big)&amp;\text{if}y^{(i)}&#x3D;1\-\log\Big(1-f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\Big)&amp;\text{if}y^{(i)}&#x3D;0\end{cases}<br>$$<br>核心点就是，当预测值越接近实际值，则loss越小奖励越大</p>
<p>当越远离，则loss越带，需要惩罚</p>
<p>参考下图，对于y标签为1的样本，我们看-log的蓝色，因为y取值只有0-1，所以直接看左边。(图例的1&#x2F;3看作1)当x越接近1，对应的y越小，loss越小</p>
<p>同理，-log(1-x)也就是当x越接近0，损失越小</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://tse2-mm.cn.bing.net/th/id/OIP-C.VCRolTXt6cesoiFS-5BWeQHaGp?w=186&h=180&c=7&r=0&o=5&dpr=1.1&pid=1.7" alt="fx=-logx 的图像结果"></p>
<p>可以证明，当用这样一组loss去优化上面的总代价函数就是一个凸函数，能够逐步得到全局最优解。</p>
<h4 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h4><p>尽管两个的损失函数是一样的，但是f函数的定义不一样，logistic定义是sigmoid</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/WL8nsP7KtJkRYMo.png" alt="image-20240627010113912"></p>
<p>加快梯度下降的方法(和线性回归相似)</p>
<ul>
<li>观察学习曲线</li>
<li>矢量化</li>
<li>特征缩放(如投影到-1,1)</li>
</ul>
<h5 id="如何理解"><a href="#如何理解" class="headerlink" title="如何理解"></a>如何理解</h5><p>例如对于下面的损失函数：<br>$$<br>w&#x3D;w-α×\frac{\partial J(w)}{\partial w}<br>$$<br>我们假设J(w)函数图像(学习率下面)，可以看到后面的微分就是在w点处的导数即斜率，当斜率为正数，w&#x3D;w-α×正数，w变小；斜率为负数，w&#x3D;w-α×负数，w变大。可以看到，w都在朝着代价函数J(w)不断减小的方向进行。α指的是学习率</p>
<h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/dl2x5WbcEDUnKOI.png" alt="image-20240923203212952"></p>
<p>可以看到，学习率比较小的时候，梯度下降会很慢；当学习率很大的时候，可能收敛不了</p>
<p><strong>局部最小值问题</strong></p>
<p>当损失函数处于最小值，根据公式此时导数项为0，w&#x3D;w，不会再更新了，陷入局部最小值</p>
<p>当函数是一凸函数，例如线性回归，他的损失函数是一个碗形，也就是只有一个全局最小值，那么梯度下降就可以找到最小值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/KJs5LeoDcwl1jXF.png" alt="理解梯度下降"></p>
<p>从上图可以看到，当点的越接近最小值，左上角的直线能够更好拟合数据</p>
<p>批梯度下降</p>
<h3 id="多维线性回归"><a href="#多维线性回归" class="headerlink" title="多维线性回归"></a>多维线性回归</h3><h4 id="多元特征"><a href="#多元特征" class="headerlink" title="多元特征"></a>多元特征</h4><p>一位特征：f(x)&#x3D;wx+b</p>
<p>多维特征：f(x)&#x3D;w1x1+w2x2+w3x3+w4x4+b</p>
<p>把x和w表示为向量，即W&#x3D;[w1,w1,…,wn]，X&#x3D;[x1,x2,…,xn]</p>
<p>f(x)&#x3D;W·X+b，·向量点积，这个算法叫多元线性回归。</p>
<h4 id="矢量化-vectorization"><a href="#矢量化-vectorization" class="headerlink" title="矢量化 vectorization"></a>矢量化 vectorization</h4><p>在python的numpy中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w=np.array([<span class="number">1.0</span>,<span class="number">2.5</span>,-<span class="number">3.3</span>])</span><br><span class="line">b=<span class="number">4</span></span><br><span class="line">x=np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>])</span><br><span class="line">f=np.dot(w,x)+b <span class="comment"># 效率更高，在硬件中通过矢量化并行计算的，数据量大用这个很关键 efficient-&gt;large scale datasets</span></span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">    f=f+w[j]*x[j]</span><br><span class="line">f=f+b</span><br></pre></td></tr></table></figure>



<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="多层感知机"><a href="#多层感知机" class="headerlink" title="多层感知机"></a>多层感知机</h2><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h2 id="梯度下降-1"><a href="#梯度下降-1" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="什么是梯度下降"><a href="#什么是梯度下降" class="headerlink" title="什么是梯度下降"></a>什么是梯度下降</h3><p>作用：优化损失函数</p>
<p>找极小值(损失函数要找最小)</p>
<p>梯度：梯度就是函数对它的各个自变量求偏导后，由偏导数组成的一个向量。简单来说就是导数多了<strong>方向</strong>(这个很关键，后面提到)</p>
<p>在下图情况有可能陷入局部最小值，也就是左边最小值，但他不是全局最小</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/dKTQAXzuVjSWZ1x.webp" alt="img"></p>
<p>因此，就需要随机初始化几次，多尝试几次</p>
<p>那么如何找呢，以一元二次函数f(x)&#x3D;(x-1)^2+1为例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/P8qpnCUsZoiJRjm.webp" alt="img"></p>
<p>假设红点处是一个初始值，我们对该点进行求导，导函数fx&#x3D;2x-2，当x减小，也就是黑色箭头方向，导数是在减小的，代表导数反方向；橙色箭头方向，导数增加，代表导数正向。</p>
<p>为了找到极小值，我们需要让红点x朝着黑色方向移动，这就是梯度下降的目的。实现这一过程，需要提到<strong>学习率eta</strong><br>$$<br>x\leftarrow x-eta*\frac{df(x)}{dx}<br>$$<br>让x减去学习率eta乘以函数的导数。学习率eta的目的是控制x更新的幅度，如果eta小，那么x每次更新的幅度就小</p>
<p>进行迭代更新，曲线逐渐平缓，最终会收敛到一个局部的极值点，也就是当导数无限逼近0，最终停留在极值点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/6gPmIpaw4o9b52z.webp" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/261375491">Gradient-Descent（全世界最通俗易懂的梯度下降法详解-优化函数大法） - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="神经网络与梯度下降"><a href="#神经网络与梯度下降" class="headerlink" title="神经网络与梯度下降"></a>神经网络与梯度下降</h3><p>神经网络方面的一个巨大突破是从 <strong>sigmoid</strong> 函数转换到一个 <strong>ReLU</strong> 函数,<strong>Rectified Linear Unit</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/GrNCgMEtnYclKuP.png" alt="image-20240407202927937"></p>
<p>为什么？</p>
<p>使用sigmoid，在x轴负向，梯度会接近0，学习速度变得很慢</p>
<p>而换用ReLU，对于输入的负值，梯度都是0，不会趋向逐渐减少到0，这使得<strong>梯度下降</strong>算法运行得更快。</p>
<h2 id="超参数"><a href="#超参数" class="headerlink" title="超参数"></a>超参数</h2><h3 id="学习率-1"><a href="#学习率-1" class="headerlink" title="学习率"></a>学习率</h3><p>学习率决定了在每步参数更新中，模型参数有多大程度（或多快、多大步长）的调整</p>
<p>学习率是在梯度下降的过程中更新权重时的超参数，即下面公式中的eta<br>$$<br>x\leftarrow x-eta*\frac{df(x)}{dx}<br>$$<br>学习率越低，<strong>损失函数的变化速度就越慢</strong>，容易过拟合。虽然使用低学习率可以确保我们不会错过任何局部极小值，但也意味着我们将花费更长的时间来进行收敛，特别是在被困在局部最优点的时候。而学习率过高容易发生梯度爆炸，loss振动幅度较大，模型难以收敛。</p>
<p>学习率的影响：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/JszfZyUNeL6HQp1.webp" alt="img"></p>
<h4 id="如何设置和调整学习率"><a href="#如何设置和调整学习率" class="headerlink" title="如何设置和调整学习率"></a>如何设置和调整学习率</h4><p>调整学习率的套路通常是：</p>
<ul>
<li>先设置一个初始学习率。这个初始学习率应该让损失尽可能快地降低。</li>
<li>然后训练过程中按照一定的schedule降低学习率；或用算法根据实际训练情况，自适应地调整学习率。</li>
</ul>
<p>另外，在正式开始训练之前， 还应该有一小段热身的过程。热身的原因是一开始模型参数是完全随机的，需要谨慎地更新参数，不能一上来就用初始学习率。</p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>SGD（随机梯度下降）<br>基本思想： SGD在每一步更新中仅使用一个（或一小批）样本来计算梯度，而不是使用整个数据集。这种方法可以显著减少计算量，使得训练大规模数据集变得可行。<br>学习率： SGD通常需要手动调整学习率，并且可能会使用如学习率衰减这样的技巧来帮助模型收敛。学习率的选择对SGD的性能影响很大。<br>收敛速度： SGD的收敛速度通常比较慢，尤其是在接近最小值的平坦区域。<br>泛化能力： 研究表明，由于SGD的噪声更大，它可能有助于模型找到泛化性能更好的解。<br>Adam（自适应矩估计）<br>基本思想： Adam是一种自适应学习率的优化算法，它结合了动量（Momentum）和RMSprop的优点。Adam会为不同的参数计算不同的自适应学习率。<br>学习率： Adam自动调整学习率，通常不需要像SGD那样手动微调学习率，这使得Adam在很多情况下都能较快地收敛。<br>收敛速度： 由于自适应学习率的特性，Adam在初期训练阶段通常比SGD收敛得更快。<br>泛化能力： 尽管Adam在许多任务中都显示出了较快的收敛速度，但一些研究表明，对于某些问题，Adam可能导致过拟合，泛化能力不如SGD。</p>
<h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>简单神经网络和卷积神经网络</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/xXZT3lnIOWvRYPp.png" alt="image-20240407202301840"></p>
<p>卷积神经网络起到一个分类器的作用</p>
<p><strong>卷积层负责提取特征，采样层负责特征选择，全连接层负责分类</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-05f7af4e1d59e82412832c01b1144f52_b.jpg" alt="img"></p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>卷积层如何提取特征呢？</p>
<p>用到卷积核又叫滤波器，(convolution kernel）是可以用来提取特征的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-c9b00043ba326451979abda5417bfcdf_b.jpg" alt="img"></p>
<p><strong>卷积核放在神经网络里，就代表对应的权重（weight)</strong></p>
<p><strong>卷积核和图像进行点乘（dot product),</strong> <strong>就代表卷积核里的权重单独对相应位置的Pixel进行作用</strong></p>
<p>至于为什么要把点乘完所有结果加起来，实际上就是把所有作用效果叠加起来</p>
<p>我们知道输入，知道神经元的权值（weights）了，根据神经网络公式：<br>$$<br>\sum_iw_ix_i+b<br>$$<br>还需要设置偏置bias，先假设为0</p>
<p>我们分别对三个分量的其中一个3x3的九宫格进行卷积</p>
<p>所以，结果为：</p>
<p>W1output &#x3D; 1*(-1) +1<em>1+1</em>0+0*(-1)+1<em>0+2</em>1+0*(-1)+1<em>1+2</em>(-1) &#x3D;1</p>
<p>W2output &#x3D; 2<em>1+2</em>0+1<em>1+1</em>1+0<em>1+0</em>2+0<em>1+0</em>0+1*1&#x3D;5</p>
<p>W3output &#x3D; 1*(-1)+1*(-1)+0*(-1)+0<em>2+0</em>(1)+0<em>2+1</em>0+1<em>1+0</em>1 &#x3D; -1</p>
<p>Bias &#x3D; 0</p>
<p>Final_output &#x3D;<strong>W1output + W2output+W3output+bias</strong>&#x3D; 1+5-1+0 &#x3D; 5</p>
<p>三个卷积核的输出为什么要叠加在一起呢</p>
<p><strong>你可以理解为三个颜色特征分量叠加成RGB特征分量</strong></p>
<p>但是，不能够对pixels随即找然后进行卷积，除了特征值，还有相对位置需要考虑。</p>
<p>因此，也需要按照正确的顺序去进行卷积。</p>
<p>最经典的就是从左到右，每隔x列Pixel，向右移动一次卷积核进行卷积(x可以自己定义)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-0e86ac3e69a31e47477f658b76842c7c_b.jpg" alt="img"></p>
<p>到达最右。从上到下，每隔y行pixel,向下移动一次卷积核，移动完成，再继续如上所述，从左到右进行</p>
<p>就这样，我们先从左到右，再从上到下，直到所有pixels都被卷积核过了一遍，完成输入图片的第一层卷积层的特征提取</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-8d0c46394cac2f192e236c7cffff2559_b.jpg" alt="img"></p>
<p><strong>这里的x我们叫作stride,就是步长的意思，如果我们x &#x3D; 2, 就是相当每隔两行或者两列进行卷积</strong></p>
<p>同时我们可以看到，分量的pixel 外面还围了一圈0，称为补0(相当于什么信息都没加)。对比补了0和没补0，同样一行，补0执行了多几次的卷积操作，好处在于：</p>
<ul>
<li><p>可以获得更多细致特征信息，比如图像的<strong>边缘信息</strong></p>
</li>
<li><p>我们可以控制卷积层输出的特征图的size，从而可以达到<strong>控制网络结构的作用</strong>，还是以上面的例子，如果没有做zero-padding以及第二层卷积层的卷积核仍然是3x3, 那么第二层卷积层输出的特征图就是1x1，CNN的特征提取就这么结束了。</p>
<p><strong>同样的情况下加了zero-padding的第二层卷积层输出特征图仍然为5x5,这样我们可以再增加一层卷积层提取更深层次的特征</strong></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_141391545">卷积神经网络（CNN）入门讲解 - 知乎 (zhihu.com)</a></p>
<p>涉及到具体代码，如何变化举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 Feed_Forward 类中，每一步的数据维度变化如下：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line"></span><br><span class="line">输入张量 x 的形状为 [batch_size, seq_len, d_model]。</span><br><span class="line">在 forward 方法的开始，这个形状被打印出来：([<span class="number">64</span>, <span class="number">125</span>, <span class="number">128</span>])。</span><br><span class="line">扩展维度：</span><br><span class="line"></span><br><span class="line">x.unsqueeze(<span class="number">1</span>) 增加一个通道维度，使得输入形状变为 [batch_size, <span class="number">1</span>, seq_len, d_model]。</span><br><span class="line">经过 x.unsqueeze(<span class="number">1</span>) 后，形状为 ([<span class="number">64</span>, <span class="number">1</span>, <span class="number">125</span>, <span class="number">128</span>])。</span><br><span class="line">卷积层：</span><br><span class="line"></span><br><span class="line">self.conv1 是一个卷积层，它的输入形状是 [batch_size, <span class="number">1</span>, seq_len, d_model]。</span><br><span class="line">self.conv1 的参数是 nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, (<span class="number">15</span>, <span class="number">16</span>), bias=<span class="literal">False</span>, stride=(<span class="number">15</span>, <span class="number">16</span>))，意味着卷积核大小为 (<span class="number">15</span>, <span class="number">16</span>)，步幅为 (<span class="number">15</span>, <span class="number">16</span>)，输出通道数为 <span class="number">16</span>。</span><br><span class="line">卷积运算后，形状变为 ([<span class="number">64</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">8</span>])。</span><br><span class="line">在 self.gelu(self.conv1(x.unsqueeze(<span class="number">1</span>))) 之后，输出形状为 ([<span class="number">64</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">8</span>])。</span><br><span class="line">激活函数：</span><br><span class="line"></span><br><span class="line">self.gelu 是一个激活函数，不改变形状。</span><br><span class="line">在 output = self.gelu(self.conv1(x.unsqueeze(<span class="number">1</span>))) 之后，输出形状仍为 ([<span class="number">64</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">8</span>])。</span><br><span class="line">Dropout：</span><br><span class="line"></span><br><span class="line">self.dropout 是一个 Dropout 层，也不改变形状。</span><br><span class="line">在 output = self.dropout(output) 之后，输出形状仍为 ([<span class="number">64</span>, <span class="number">16</span>, <span class="number">8</span>, <span class="number">8</span>])。</span><br><span class="line">展平：</span><br><span class="line"></span><br><span class="line">output.contiguous().view(-<span class="number">1</span>, self.num_flat_features(output)) 将输出展平成二维张量。</span><br><span class="line">self.num_flat_features(output) 计算除了批次维度外的所有维度的乘积，即 <span class="number">16</span> * <span class="number">8</span> * <span class="number">8</span> = <span class="number">1024</span>。</span><br><span class="line">output.contiguous().view(-<span class="number">1</span>, <span class="number">1024</span>) 将输出形状展平为 [batch_size, <span class="number">1024</span>]。</span><br><span class="line">最终输出形状为 ([<span class="number">64</span>, <span class="number">1024</span>])。</span><br><span class="line">修改后的完整代码如下：</span><br><span class="line"></span><br><span class="line">python</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Feed_Forward</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, device</span>):</span><br><span class="line">        <span class="built_in">super</span>(Feed_Forward, self).__init__()</span><br><span class="line">        F1 = <span class="number">16</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, F1, (<span class="number">15</span>, <span class="number">16</span>), bias=<span class="literal">False</span>, stride=(<span class="number">15</span>, <span class="number">16</span>))  <span class="comment"># Conv2d #F1*4*8</span></span><br><span class="line">        self.dropout = nn.Dropout(<span class="number">0.45</span>)</span><br><span class="line">        self.gelu = GELU().to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Feed_Forward input shape : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(x.shape))  <span class="comment"># ([64, 125, 128])</span></span><br><span class="line">        output = self.gelu(self.conv1(x.unsqueeze(<span class="number">1</span>)))  <span class="comment"># ([64, 16, 8, 8])</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Feed_Forward output shape : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(output.shape))</span><br><span class="line">        output = self.dropout(output)  <span class="comment"># ([64, 16, 8, 8])</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Feed_Forward output shape : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(output.shape))</span><br><span class="line">        output = output.contiguous().view(-<span class="number">1</span>, self.num_flat_features(output))  <span class="comment"># torch.Size([64, 1024])</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Feed_Forward output shape : &#123;&#125;&quot;</span>.<span class="built_in">format</span>(output.shape))</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">num_flat_features</span>(<span class="params">self, x</span>):</span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features = num_features * s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br></pre></td></tr></table></figure>

<p><code>conv1</code> 层是一个二维卷积层。我们来详细解释一下 <code>conv1</code> 的参数以及它是如何改变输入张量的维度的。</p>
<p><strong><code>conv1</code> 参数</strong></p>
<ul>
<li><code>in_channels=1</code>：输入的通道数是 1。</li>
<li><code>out_channels=16</code>：输出的通道数是 16。</li>
<li><code>kernel_size=(15, 16)</code>：卷积核的大小是 15x16。</li>
<li><code>stride=(15, 16)</code>：步幅是 15（在高度方向）和 16（在宽度方向）。</li>
<li><code>bias=False</code>：没有偏置项。</li>
</ul>
<p><strong>输入形状</strong></p>
<ul>
<li>输入形状是 <code>[batch_size, 1, seq_len, d_model]</code>，即 <code>[64, 1, 125, 128]</code>。</li>
</ul>
<p><strong>卷积计算</strong></p>
<p>卷积层的输出维度计算如下：</p>
<p><strong>输出高度 (Output Height)</strong></p>
<p>公式：<br>$$<br>\text{output_height} &#x3D; \left\lfloor \frac{\text{input_height} - \text{kernel_height}}{\text{stride_height}} \right\rfloor + 1<br>$$<br>在我们的例子中：<br>$$<br> \text{output_height} &#x3D; \left\lfloor \frac{125 - 15}{15} \right\rfloor + 1 &#x3D; \left\lfloor \frac{110}{15} \right\rfloor + 1 &#x3D; 7 + 1 &#x3D; 8<br>$$</p>
<p><strong>输出宽度 (Output Width)</strong></p>
<p>公式：<br>$$<br>\text{output_width} &#x3D; \left\lfloor \frac{\text{input_width} - \text{kernel_width}}{\text{stride_width}} \right\rfloor + 1<br>$$</p>
<p>在我们的例子中：<br>$$<br>\text{output_width} &#x3D; \left\lfloor \frac{128 - 16}{16} \right\rfloor + 1 &#x3D; \left\lfloor \frac{112}{16} \right\rfloor + 1 &#x3D; 7 + 1 &#x3D; 8<br>$$<br><strong>输出形状</strong></p>
<ul>
<li>通道数变为 <code>out_channels</code>，即 16。</li>
<li>高度变为 <code>output_height</code>，即 8。</li>
<li>宽度变为 <code>output_width</code>，即 8。</li>
</ul>
<p>所以卷积层 <code>conv1</code> 的输出形状是 <code>[batch_size, out_channels, output_height, output_width]</code>，即 <code>[64, 16, 8, 8]</code>。</p>
<p><strong>总结</strong></p>
<p>具体维度变化如下：</p>
<ol>
<li><p><strong>输入形状</strong>：</p>
<ul>
<li>输入张量 <code>x</code> 的形状是 <code>[batch_size, seq_len, d_model]</code>，即 <code>[64, 125, 128]</code>。</li>
</ul>
</li>
<li><p><strong>扩展维度</strong>：</p>
<ul>
<li><code>x.unsqueeze(1)</code> 将输入形状扩展为 <code>[batch_size, 1, seq_len, d_model]</code>，即 <code>[64, 1, 125, 128]</code>。</li>
</ul>
</li>
<li><p><strong>卷积层</strong>：</p>
<ul>
<li><code>self.conv1(x.unsqueeze(1))</code> 将输入形状 <code>[64, 1, 125, 128]</code> 变为 <code>[64, 16, 8, 8]</code>。</li>
</ul>
</li>
</ol>
<p>因此，通过 <code>conv1</code> 层，数据维度从 <code>[64, 1, 125, 128]</code> 变为 <code>[64, 16, 8, 8]</code>。</p>
<h3 id="采样层-池化层，pooling"><a href="#采样层-池化层，pooling" class="headerlink" title="采样层(池化层，pooling)"></a>采样层(池化层，pooling)</h3><h4 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h4><p>最大池化Maxpooling字面意思就是，直接取最大的</p>
<p>例如下面矩阵图，数值代表特征程度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://picx.zhimg.com/v2-c03717a0e283578ab302075c1c1fe029_720w.jpg?source=d16d100b" alt="img"></p>
<p>最大池化选择9，含义就是9代表这个区域，最符合特征的，然后去掉没有的。</p>
<p>为什么要这么做？作者举了个很形象的例子</p>
<p>比如这里四个美女要选一个，每个人的选择都是最符合自己的(也就是四个中最符合的特征)，其他的丢掉</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://picx.zhimg.com/v2-642db2909cdf8230fdcf509b85746556_720w.jpg?source=d16d100b" alt="img"></p>
<p>那为什么不能都选呢？——不做Maxpooling</p>
<p>首先你娶回4个，她们会各种勾心斗角，让你崩溃<strong>（overfitting）</strong></p>
<p>然后你会有巨大的经济压力，身体也吃不消<strong>（参数过多导致运算量大）</strong></p>
<p>最后可能还会难以平衡婆（上一次卷积层）媳或者母子（下一层卷积层）关系<strong>（无法满足模型结构需求）</strong></p>
<h4 id="如何进行"><a href="#如何进行" class="headerlink" title="如何进行"></a>如何进行</h4><p>例如下图 ，可以类比卷积，就是一个2X2的卷积核，stride为2，从左到右从上到下，作用是选取核里最大的值，而不是做卷积运算</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-16b276fe8c010af144383da29336c1e9_720w.jpg?source=d16d100b" alt="img"></p>
<h4 id="池化的性质"><a href="#池化的性质" class="headerlink" title="池化的性质"></a>池化的性质</h4><p><strong>可以一定程度提高空间不变性</strong>，比如说平移不变性，尺度不变性，形变不变性</p>
<p>空间不变性体现在，卷积是对一个区域一个区域进行卷积，CNN关注单独区域的特征以及特征之间的相对位置。</p>
<p>当图像发生细微变化，经过卷积和maxpooling，输出结果和原来差别可能不大甚至很小</p>
<p>平移不变性：图像经过一个小小的平移之后，依然产生相同的池化特征</p>
<h3 id="激活函数-1"><a href="#激活函数-1" class="headerlink" title="激活函数"></a>激活函数</h3><p>在接触到深度学习（Deep Learning）后，特别是神经网络中，我们会发现在<strong>每一层的神经网络输出后都会使用一个函数</strong>（比如sigmoid，tanh，Relu等等）对结果进行运算，这个函数就是激活函数（Activation Function）。</p>
<p>为什么要激活函数？简而言之因为神经网络每层输入输出都是线性求和过程，不管怎么叠加变换，都是线性组合不能解决非线性问题。而通过激活函数可以使神经网络逼近任何非线性函数，应用于复杂的非线性分类问题</p>
<p>我们从最简单的开始讲</p>
<h4 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h4><p>下图就是一个最简单的神经元，Y&#x3D;W*X1+1，其实就是一个线性方程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-5fa9312ed3aecb8c3f84c437e4933dd9_b.jpg" alt="img"></p>
<p>然而，这个神经网络只能够解决普通的线性二分类问题，比如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/v2-825e4434307215b82ee5607512d1695b_b.jpg" alt="img"></p>
<p>现实中，其实更多的都是复杂的二分类，具有非线性的特点。那么怎么做呢？</p>
<p>首先叠加神经网络行不行？这里我们对神经元进行叠加，列出公式</p>
<p>Output &#x3D; w7(input1<em>w1 +input2</em>w2)+w8(input1<em>w3+input2</em>w4)+w9(input1<em>w5+input2</em>w6)</p>
<p>Output &#x3D; input1(w1<em>w7+w3</em>w8+w9<em>w5)+input2</em>(w2<em>w7+w4</em>w8+w6*w9)</p>
<p>我们假设Output &#x3D; 0 </p>
<p>那么input1 &#x3D; input2*( w2<em>w7+w4</em>w8+w6<em>w9)&#x2F;(-w2</em>w7+w4<em>w8+w6</em>w9)</p>
<p>这又回到了一个线性方程。由于线性函数具有可加性和其次性，所以仅靠简单的叠加是不能够解决非线性问题的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-99edcb8c87dbcdc5eb2884cf7076884c_b.jpg" alt="img"></p>
<h4 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h4><h5 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h5><p>那如何将线性神经网络转为非线性呢？我们首先想到二次函数y&#x3D;wx<sup>2</sup>+B</p>
<p>某一个二次函数经过调整，可以将非线性问题进行分类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-10f91a9a61f22aea9a46ebaf63c1e3ad_b.jpg" alt="img"></p>
<h5 id="输出需要进行分类"><a href="#输出需要进行分类" class="headerlink" title="输出需要进行分类"></a>输出需要进行分类</h5><p>我们的神经网络（还是最简单的）</p>
<p>Y &#x3D;W*X +B</p>
<p>根据input X的值，我们会得到Y值</p>
<p>所以我们需要一个函数可以对得到的Y值进行分类的</p>
<p>比如Y大于0 ，分类为1</p>
<p>小于0 ，分类为0</p>
<h5 id="输入可能特别大"><a href="#输入可能特别大" class="headerlink" title="输入可能特别大"></a>输入可能特别大</h5><p>对于神经网络Y&#x3D;W*X+B，我们需要算出输出误差error (output Y - target Y) 来更新权值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic3.zhimg.com/v2-b50b34f6c48a49968de2d7b6de79b7e6_b.jpg" alt="img"></p>
<p>如果输出X绝对值太大甚至无限大，那么输出Y会特别大，直接导致Error非常大，那么更新出来的权值没有意义或无法更新权值</p>
<h5 id="线性方程梯度与输入无关了"><a href="#线性方程梯度与输入无关了" class="headerlink" title="线性方程梯度与输入无关了"></a>线性方程梯度与输入无关了</h5><p>线性神经网络导数为常数，那么梯度gradient就与输入X无关了</p>
<p>在反向传播时候，梯度改变也变为常数，和输入的改变关联不上了</p>
<h4 id="激活函数-2"><a href="#激活函数-2" class="headerlink" title="激活函数"></a>激活函数</h4><p>解决上面的问题，就需要激活函数了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-17708ef17113fc120b045db3de3dbaac_b.jpg" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/32824193">CNN入门讲解：什么是激活函数（Activation Function） - 知乎 (zhihu.com)</a></p>
</blockquote>
<h3 id="dropout"><a href="#dropout" class="headerlink" title="dropout"></a>dropout</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/322324e9b7a0485b838b6376cb44aae1.png" alt="在这里插入图片描述"></p>
<p>为什么需要dropout：采样一个更薄的神经网络，减少神经元之间的共适应性，迫使学习更加鲁棒 的特征</p>
<p>产生DropOut的动机：使用DropOut训练的神经网络中的每个隐藏单元必须学会与随机选择的其他单元样本一起工作，这样会使得每个隐藏单元更加的健壮，并使得他们尽量自己可以创造有用的功能，而不是依赖其他隐藏单元。即按照论文的话来说：减少神经元之间复杂的共适应关系。</p>
<p>官方论文例子： 50个人，分十个组，每五个人完成一个小阴谋，可能比50个人正确扮演各自角色完成一个大的阴谋更容易，当然，在时间足够，各种条件没有改变的情况下，那么完成一个大阴谋是更适合的，但生活总是充满变数，大阴谋往往不太容易实现，这样小的阴谋发挥作用的机会就会更大。同样的，在训练集上，各个隐藏单元可以协同发挥作用，即可以在训练集上可以训练的很好，但是这并不是我们需要的，我们需要他们在新的测试集上可以很好的合作，这时候DropOut体现出了它的价值！</p>
<p>本质上看： DropOut通过使其它隐藏层神经网络单元不可靠从而阻止了共适应的发生。因此，一个隐藏层神经元不能依赖其它特定神经元去纠正其错误。因为dropout程序导致两个神经元不一定每次都在一个dropout网络中出现。这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况 。迫使网络去学习更加鲁棒的特征 ，这些特征在其它的神经元的随机子集中也存在。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42475060/article/details/128862411">https://blog.csdn.net/weixin_42475060/article/details/128862411</a></p>
</blockquote>
<h3 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h3><p>全连接层的作用主要就是实现分类（Classification）</p>
<p>训练完到最后一步：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/80/v2-ba7629e4fb2996750f870a1d85bca863_720w.webp" alt="img"></p>
<p>猫头猫尾…–&gt;猫</p>
<p>再往前可以做对子特征进行分类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/80/v2-671995a238e33a1c4e669340fed561f5_720w.webp" alt="img"></p>
<p>猫眼猫胡须…–&gt;猫头</p>
<p>这些细节特征哪来的呢？就是从前面的卷积层，下采样层来的。</p>
<p>二层全连接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic4.zhimg.com/80/v2-27e053826d9779ef8d8a6faba22a6b7b_720w.webp" alt="img"></p>
<p>全连接层对模型的影响因素：</p>
<ol>
<li>全连接层的总层数（长度）</li>
<li>单个全连接层的神经元数（宽度）</li>
<li>激活函数(作用：<strong>增加模型的非线性表达能力</strong>)</li>
</ol>
<p>如果全连接层宽度不变，增加<strong>长度</strong>(总层数)：</p>
<p><strong>优点</strong>：全连接层数加深，模型非线性表达能力提高。理论上都可以提高模型的学习能力。</p>
<p>如果全连接层长度不变，增加<strong>宽度</strong>(神经元个数)：</p>
<p><strong>优点</strong>：神经元个数增加，模型复杂度提升。理论上可以提高模型的学习能力。</p>
<p>难度长度和宽度都是越多越好？</p>
<p>肯定不是</p>
<p>（1）<strong>缺点</strong>：学习能力太好容易造成过拟合。</p>
<p>（2）<strong>缺点</strong>：运算时间增加，效率变低。</p>
<p>那么怎么判断模型学习能力如何？看Training Curve 以及 Validation Curve</p>
<p>在其他条件理想的情况下，如果Training Accuracy 高， Validation Accuracy 低，也就是过拟合 了，可以尝试去减少层数或者参数。</p>
<p>如果Training Accuracy 低，说明模型学的不好，可以尝试增加参数或者层数。至于是增加长度和宽度，这个又要根据实际情况来考虑了。</p>
<h2 id="编码器解码器"><a href="#编码器解码器" class="headerlink" title="编码器解码器"></a>编码器解码器</h2><p>encoder-decoder</p>
<p>表征学习，数据压缩，特征降维</p>
<p>编码器学习数据的特征，逐步压缩输入信息，目的是将所有必要信息编码到一个抽象的中间表达表示中</p>
<p> 解码器的任务是将编码器输出的内部表示转换为目标序列。解码器逐步生成输出序列，每一步都可能依赖于前一步的输出以及从编码器传递过来的上下文信息。在生成过程中，解码器逐渐解开编码器压缩的信息，将其转化为有意义的输出</p>
<p>在这个抽象， 可以给一些随机数，如果模型学习的好，应该能够出来一个和x相近的结果</p>
<p>输入数据要洗牌，从不同角度观察，保证多样性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/ShuPAXqGEWObrwF.png" alt="image-20240615101201760"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Encoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Encoder,self).__init__(**kwargs)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X,*args</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decoder</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,**kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(Decoder,self).__init__(**kwargs)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_state</span>(<span class="params">self,enc_outputs,*args</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forware</span>(<span class="params">self,X,state</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EncoderDecorder</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;编码器-解码器结构的基类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,encoder,decorder,**kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>(EncoderDecorder,self).__init__(**kwargs)</span><br><span class="line">        self.encoder=encoder</span><br><span class="line">        self.decoder=decoder</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,enc_X,dec_X,*args</span>): <span class="comment">#decoder结合一些其他输入</span></span><br><span class="line">        enc_outputs=self.encoder(enc_X,*args)</span><br><span class="line">        dec_state=self.decoder.init_state(enc_outputs)</span><br><span class="line">        outputs=self.decoder(dec_X,dec_state)</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>* </p>
<h1 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h1><p>推荐：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.d2l.ai/index.html">《动手学深度学习》 — 动手学深度学习 2.0.0 documentation (d2l.ai)</a></p>
</blockquote>
<h2 id="残差网络Resnet"><a href="#残差网络Resnet" class="headerlink" title="残差网络Resnet"></a>残差网络Resnet</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/306135761/answer/2491142607?utm_campaign=shareopn&utm_content=group3_Answer&utm_medium=social&utm_psn=1764665330822328320&utm_source=wechat_session">(32 封私信 &#x2F; 2 条消息) 为什么残差连接的网络结构更容易学习？ - 知乎 (zhihu.com)</a></p>
<p>解决层数增多两个问题：</p>
<ul>
<li>梯度消失或梯度爆炸</li>
<li>退化问题</li>
</ul>
<p>亮点：</p>
<ul>
<li>提出了residual残差结构，超深层数也能训练很好</li>
<li>使用batch normalization加速训练(丢弃dropout)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://zh.d2l.ai/_images/residual-block.svg" alt="../_images/residual-block.svg"></p>
<ul>
<li>identity mapping，就是弯弯的线 x</li>
<li>residual mapping，就是除了弯弯的线 f(x)-x</li>
</ul>
<h3 id="为什么有效果"><a href="#为什么有效果" class="headerlink" title="为什么有效果"></a>为什么有效果</h3><p>在 计算图 中经过了 如下的权重层导致有多条路径可以选择的结果。由于上述计算过程同时设计正向传播和反向传播会贯穿整个网络，导致网络越深，最后的梯度计算结果中前面乘上的权重系数也会越来越多。</p>
<p>结果是前面乘的权重系数会越来越多。因为不管是正向传播还是反向传播，每条路径经过一个权重因子都会乘上这个权重因子。随着层数的增加，路径变得越来越长，在这条路上走一走遇到的权重因子也会越来越多，梯度会整体的变小。</p>
<p>也就是说网络变深了，梯度虽然每层的相同但是整体变小了。如果网络足够深，每一层的梯度都变小到感受不到了。这也就是当初 Hinton 祖师爷虽然用 r e l u relurelu 这个神器解决了梯度分布不均匀的问题，但是却留下了一个更大的问题，权重分布是均匀了但是整体变小了-_-)?</p>
<p>ResNet 的解决方法非常粗暴，就是加入 shortcut 。这个 shortcut 在梯度计算图中相当于增加了一条可以跳过权重的层的路径。使得最终计算所得的权重处的梯度 <strong>加上一项 没有经过权重层衰减的梯度</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_40267373/article/details/105667134">https://blog.csdn.net/weixin_40267373/article/details/105667134</a></p>
</blockquote>
<h2 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h2><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ul>
<li><strong><u>Q</u>uery（查询）</strong>: 代表需要获取信息的请求。</li>
<li><strong><u>K</u>ey（键）</strong>: 与Query相关性的衡量标准。</li>
<li><strong><u>V</u>alue（值）</strong>: 包含需要被提取信息的实际数据。</li>
<li><strong>权重（Attention Weights）</strong>: 通过Query和Key的相似度计算得来，决定了从各个Value中提取多少信息</li>
</ul>
<p>举例说明<br>假设我们有一个简单的句子：“猫喜欢追逐老鼠”。如果我们要对“喜欢”这个词进行编码，一个简单的方法是只看这个词本身，但这样会忽略它的上下文。“喜欢”的对象是“猫”，而被“喜欢”的是“追逐老鼠”。在这里，“猫”和“追逐老鼠”就是“喜欢”的上下文，而注意力机制能够帮助模型更好地捕获这种上下文关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用PyTorch实现简单的点积注意力</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Query, Key, Value</span></span><br><span class="line">Q = torch.tensor([[<span class="number">1.0</span>, <span class="number">0.8</span>]])  <span class="comment"># Query 对应于 &quot;喜欢&quot; 的编码</span></span><br><span class="line">K = torch.tensor([[<span class="number">0.9</span>, <span class="number">0.1</span>], [<span class="number">0.8</span>, <span class="number">0.2</span>], [<span class="number">0.7</span>, <span class="number">0.9</span>]])  <span class="comment"># Key 对应于 &quot;猫&quot;, &quot;追逐&quot;, &quot;老鼠&quot; 的编码</span></span><br><span class="line">V = torch.tensor([[<span class="number">1.0</span>, <span class="number">0.1</span>], [<span class="number">0.9</span>, <span class="number">0.2</span>], [<span class="number">0.8</span>, <span class="number">0.3</span>]])  <span class="comment"># Value 也对应于 &quot;猫&quot;, &quot;追逐&quot;, &quot;老鼠&quot; 的编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算注意力权重</span></span><br><span class="line">d_k = K.size(<span class="number">1</span>)</span><br><span class="line">scores = torch.matmul(Q, K.transpose(<span class="number">0</span>, <span class="number">1</span>)) / (d_k ** <span class="number">0.5</span>)</span><br><span class="line">weights = F.softmax(scores, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算注意力输出</span></span><br><span class="line">output = torch.matmul(weights, V)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;注意力权重:&quot;</span>, weights)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;注意力输出:&quot;</span>, output)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意力权重: tensor([[<span class="number">0.4761</span>, <span class="number">0.2678</span>, <span class="number">0.2561</span>]])</span><br><span class="line">注意力输出: tensor([[<span class="number">0.9529</span>, <span class="number">0.1797</span>]])</span><br></pre></td></tr></table></figure>


<p>这里，“喜欢”通过注意力权重与“猫”和“追逐老鼠”进行了信息的融合，并得到了一个新的编码，从而更准确地捕获了其在句子中的语义信息。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/magicyangjay111/article/details/132634186">解码注意力Attention机制：从技术解析到PyTorch实战_attention代码pytorch-CSDN博客</a></p>
<h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>简单来说，tf包含架构就是输入，encoder，decoder，输出</p>
<p>只不过，一般encoder和decoder都会叠很多层</p>
<p>在encoder，包含self attention 和Feed Forward前馈网络，表示将输入赋不同权重关注度后拆解</p>
<p>在decoder，包含self attention， EncoderDecoder-attention和Feed Forward。这里的编解码-attention就是不仅要关注零件本身，还要考虑全局上下文关系。在翻译中，就是不仅要考虑已经翻译的内容，还要考虑上下文意思。</p>
<p>每个self-attention 分解为多个部分，也就是multi-head attention，多头注意力</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/5gYqcx3wmSeyKVp.png" alt="image-20240615103712661"></p>
<h3 id="QKV"><a href="#QKV" class="headerlink" title="QKV"></a>QKV</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Rn9Ta-V14Ch8j1ORsokDrA">https://mp.weixin.qq.com/s/Rn9Ta-V14Ch8j1ORsokDrA</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://i-blog.csdnimg.cn/blog_migrate/74504d15e04a04e08230739a333daa5a.png" alt="2"></p>
<p><code>Q</code>,<code>K</code>,<code>V</code>是由输入的词向量<code>x</code>经过线性变换得到的,其中各个矩阵<code>w</code>可以经过学习得到, 这种变换可以提升模型的拟合能力, 得到的<code>Q</code>,<code>K</code>,<code>V</code> 可以理解为<br><code>Q</code>: 要查询的信息<br><code>K</code>: 被查询的向量<br><code>V</code>: 查询得到的值</p>
<p>总结一下:<br>首先<code>Q</code>、<code>K</code>、<code>V</code>都源于输入特征本身，是根据输入特征产生的向量，但目前我们现在无需关注是如何产生这组向量的。<br><code>V</code>可以看做表示单个输入特征的向量。当我们直接把一组<code>V</code>输入到网络中进行训练，那这个网络就是没有引入Attention机制的网络。<br>但如果引入Attention，就需要将这组V分别乘以一组权重α ，那么就可以做到有重点性地关注输入特征，如同人的注意力一般。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Weary_PJ/article/details/123531732">transformer中QKV的通俗理解(渣男与备胎的故事)-CSDN博客</a></p>
</blockquote>
<h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><ol>
<li>自注意力机制</li>
</ol>
<p>每个字和序列中其他次都有一个权重，来表示关系重要程度，这解决了传统RNN面对长序列会遗忘掉关联信息地问题</p>
<ol start="2">
<li>位置编码</li>
</ol>
<p>输入数据首先进行词嵌入，即将词用一串数字表示，然后，每个字会有一个位置向量，添加到输入序列中</p>
<p>模型不仅能理解每个词意思，还知道它和上下文的关系，从而理解不同词的顺序</p>
<p>借助位置编码，就可以并行计算(因为已经知道每个词和序列的关系)，不像RNN按顺序依次处理文本(训练慢)</p>
<h3 id="Norm"><a href="#Norm" class="headerlink" title="Norm"></a>Norm</h3><p>在transformer中我们可以看到很多Add&amp;Norm操作，也就是说它是先将上一层的输出和当前层的输出相加之后，再进行的LayerNorm，这就属于PostNorm。如果我们像绿色箭头指向的那样，在X输入下一层之前现执行LayerNorm操作，然后传入下一层，同时在下一层只把Xt和Xt+1相加，那就是PreNorm。</p>
<p>也可以作如下总结：</p>
<p>是在Add操作后进行Norm操作，因此叫做Post-Norm。而Pre-Norm则是Norm之后再Add，所以叫Pre-Norm。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/80/v2-86e0168f79c1f23d3dd2c2fefe349771_720w.webp" alt="img"></p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/657659526">PreNorm&#x2F;PostNorm&#x2F;DeepNorm&#x2F;RMSNorm是什么 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://spaces.ac.cn/archives/8620">浅谈Transformer的初始化、参数化与标准化 - 科学空间|Scientific Spaces</a></p>
</blockquote>
<h1 id="迁移学习transfer-learning"><a href="#迁移学习transfer-learning" class="headerlink" title="迁移学习transfer learning"></a>迁移学习transfer learning</h1><h2 id="Domain-Adaptation"><a href="#Domain-Adaptation" class="headerlink" title="Domain Adaptation"></a>Domain Adaptation</h2><p>训练集是一个分分布，输入分布与训练是不同的，那么效果会变差很多</p>
<p>例如，训练时黑底白字（源域,source domain），测试是彩色底（目标域, target domain），彩色字</p>
<p>在现实应用中，这种情况非常需要解决，你训练的模型是否能够适应新的分布情况呢</p>
<h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><ul>
<li><p>目标域有标签的数据很少，那就可以用来回调源域的训练。</p>
<ul>
<li>因为目标域很少，避免overfit，迭代次数不要过多，避免过拟合少数据（学习率 减少）</li>
</ul>
</li>
<li><p>目标域数据很多，但是没有标注，符合真实场景。下面讲讲这种</p>
</li>
</ul>
<p>Basic idea如图，也就是找一个特征提取器，都提取两个域的特征，然后我们留下共性的部分来用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/07/04/PM29begvSp1jZLI.png" alt="image.png"></p>
<p>那么如何找到这个feature extractor呢</p>
<h3 id="域对抗训练-Damain-Aversival-Trainng"><a href="#域对抗训练-Damain-Aversival-Trainng" class="headerlink" title="域对抗训练 Damain Aversival Trainng"></a>域对抗训练 Damain Aversival Trainng</h3><p>一个基本的模型就是有输入-&gt;特征提取-&gt;标签预测-&gt;输出</p>
<p>不能直接把目标域丢进去，因为就算丢进去出来一个预测标签，因为原始数据中没有label，没有办法判断。</p>
<p>他们的用处就在于，丢进去后，在特征提取器之后拿出来看，我们希望它的feature和源域丢进去得到的feature分不出差异。也就是下图，蓝点和红点差异分不出</p>
<p>因此，问题就来到了如何涉及一个domain classifier。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/07/04/m2aBMO5E9UIz7Jr.png" alt="image.png"></p>
<p>domain classifier是一个二元分类器，他的作用就是判断我们拿到的feature是来自源域还是来自目标域。而feature extractor的任务就是学习如何骗过domain classifier，使得它分不出是来自哪个域的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/07/04/XZNytdnJFoOuxVw.png" alt="image.png"></p>
<p>它的结构和GAN很小，可以把feature extractor类比成generator，把domain classifier类比成discriminator </p>
<p>问题来了，如果feature每次都输出一个zero feature不就达到目的了吗</p>
<p>不行的，因为还要让label predictor判断出实际的label，所以不能耍赖。</p>
<h4 id="损失计算"><a href="#损失计算" class="headerlink" title="损失计算"></a>损失计算</h4><ul>
<li>在label predictor，因为知道真实标签和域标签，所以可以用cross entropy去算一个loss，记为L</li>
<li>在Domain  Classifier二元分类，计算Ld，越小越好，越能分出域</li>
<li>而Feature Extractor，则是要让L-Ld，越大越好，即能很好分出label，又能够让Domain Classifier分不出。</li>
</ul>
<h4 id="limitation"><a href="#limitation" class="headerlink" title="limitation"></a>limitation</h4><ul>
<li>目标域在boundary分布不同，下图，显然右边效果是我们期望看到的<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/07/04/tdyYeZjrBQMpbFD.png" alt="image.png"></li>
<li>解决办法就是离boundary越远越好，即输出的结果越集中在某个类别（DIRT-T 文献）</li>
</ul>
</li>
<li>目标域因为没有标签，他的类别可能会和源域不同（Universal domain adaptation 文章）</li>
</ul>
<p>DC强行拉直，可能损失latent space信息，并且DC的权重如果过高，LP的效果会很差，因此是不好训练的</p>
<p>当对目标域完全位置的时候，就变成Domain Generalization了。也就是训练是真实的，素描的狗，但是测试的是卡通的狗</p>
<p>又比如训练只有一个domain，测试有多个。这种一般就是先做数据增强（data augmentation），然后就变成上一步的问题</p>
<h1 id="BCI"><a href="#BCI" class="headerlink" title="BCI"></a>BCI</h1><h2 id="常见指标"><a href="#常见指标" class="headerlink" title="常见指标"></a>常见指标</h2><p>ITR信号传输率<br>$$<br>B&#x3D;log_2{N}+Plog_2{P}+(1-P)log_2[(1-P)&#x2F;(N-1)]<br>$$<br>N为可选目标数，P为目标识别准确率，T为响应时间，</p>
<p>上式B的单位为bit&#x2F;selection。</p>
<p>ITR值的大小代表了单位时间系统输出的信息量，计算公式如下<br>$$<br>ITR&#x3D;B*C<br>$$<br>C表示系统在单位时间内所能做出的决策次数<br>$$<br>C&#x3D;(60&#x2F;T),T&#x3D;t_s+t_b<br>$$</p>
<h1 id="图像生成"><a href="#图像生成" class="headerlink" title="图像生成"></a>图像生成</h1><h2 id="自监督学习"><a href="#自监督学习" class="headerlink" title="自监督学习"></a>自监督学习</h2><p>自监督学习（self-supervised learning）不需要人工标注的类别标签信息，直接利用数据本身作为监督信息，学习样本数据的特征表达，应用于下游的任务。自监督学习又可以分为对比学习(contrastive learning) 和 生成学习(generative learning) 两条主要的技术路线。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/81e7a450251b4071ac08d1b2e7f6ffb9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a2m5rij5rij5rij5rij5rij,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>对比学习首先学习未标记数据集上图像的通用表示形式，然后可以使用少量<strong>标记图像</strong>对其进行微调，以提升在给定任务(例如分类)的性能。</p>
<ul>
<li>简单地说，对比表示学习可以被认为是通过比较学习。</li>
<li>相对来说，生成学习(generative learning)是学习某些（伪）标签的映射的判别模型然后重构输入样本。</li>
</ul>
<h3 id="对比学习"><a href="#对比学习" class="headerlink" title="对比学习"></a>对比学习</h3><p>对比学习的核心思想是讲正样本和负样本在特征空间对比，学习样本的特征表示，难点在于如何构造正负样本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/4541162ce09144ad80eecc6fbd2e48e9.gif#pic_center" alt="在这里插入图片描述"></p>
<p>对比学习通过使用三个关键的元素（<strong>正样本、anchor、负样本的表征</strong>）来实现上述思想。为了创建一个正样本对，我们需要两个相似的样本，而当我们创建一个负样本对时，我们将使用第三个与两个正样本不相似的样本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/f951087e97d542c181108282f8ed1be7.gif#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42468475/article/details/121284458">自监督学习中的 Contrastive Learning 对比学习（持续更新）_对比学习和生成学习-CSDN博客</a></p>
</blockquote>
<h2 id="CLIP"><a href="#CLIP" class="headerlink" title="CLIP"></a>CLIP</h2><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CLIP&spm=1001.2101.3001.7020">CLIP</a>的英文全称是<strong>Contrastive Language-Image Pre-training</strong>，即一种<strong>基于对比文本-图像对的预训练模型</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_54338498/article/details/132419567">基础论文学习（4）——CLIP_clip text encoder-CSDN博客</a></p>
</blockquote>
<h2 id="扩散模型"><a href="#扩散模型" class="headerlink" title="扩散模型"></a>扩散模型</h2><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>正态分布：如果一个随机事件收很多随机因素影响，但没有任何一个决定性，那么概率分布密度函数就会呈现钟形曲线，即正态分布(高斯分布)</p>
<p>标准正态分布：N(0,1<sup>2</sup>)，0表示μ，即均值，1表示σ，即标准差</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/19be4e2c6ecdcc64e42ca7d50433c81b.png" alt="正态分布表怎么查表_一文搞懂“正态分布”所有需要的知识点-CSDN博客"></p>
<p>一组随机数，大部分接近均值0，小部分超出正负一个标准差的数，称为高斯噪声</p>
<h3 id="扩散模型-1"><a href="#扩散模型-1" class="headerlink" title="扩散模型"></a>扩散模型</h3><p>往水里滴一滴墨水，墨水在水中会扩散开了(布朗运动)。扩散指物质例子从高浓度往低浓度移动的过程</p>
<p>一堆花粉，足够长的时间扩散出一团，就是高斯分布，也就是正态分布</p>
<p>而扩散模型受此启发，通过往图片加入高斯噪声模拟这一过程，并通过逆向过程从随机的噪声中生成图片</p>
<blockquote>
<p>时光倒流</p>
</blockquote>
<p>时间往回推，就会更靠近初始位置一点，正向是无序的，但是反序就变回有序的（熵增删减），我们需要一个向量场(score function)，类似一个导航，指引杂乱无章的例子逐渐靠近源头。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/gE7t4iwO8oAPxdm.png" alt="image-20240622165154433"></p>
<p>这与图片生成有什么关系？</p>
<p>生成图片，本质就是让一堆无序的粒子，排成有序的队形。一个图片比</p>
<h4 id="前向加噪"><a href="#前向加噪" class="headerlink" title="前向加噪"></a>前向加噪</h4><p>RGB表示的图片，每个像素都一个rgb<br>$$<br>\mathbf{x}_t&#x3D;\sqrt{\bar{\beta}_t}\mathbf{x}_0+\sqrt{1-\bar{\beta}_t}\epsilon<br>$$<br>调整β，逐渐增加，使得加噪比例越来越大，e是服从标准正态分布重新采样的随机数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2024/09/24/2w4quzmNtyXI5i3.png" alt="image-20240622165741232"></p>
<p>不需要罗列，只需要两个序列方向匹配，不断平移对齐，分别计算出上下点数各组合的概率，求和就得到了响应总点数的概率，叫卷积</p>
<p>对两个概率分布进行卷积操作，实际上就是计算两个分布所有组合的情况，得到叠加后的概率分布。卷积后的概率密度仍符合正态分布</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16Z421n7fi/?spm_id_from=333.337.search-card.all.click&vd_source=8ecff66abb776707f111647a284db8d9">【硬核科普】清华AI博士教你AI是怎么生成图片和视频的_哔哩哔哩_bilibili</a></p>
</blockquote>
<p>如何理解通过Diffusion从文本到图像生成的过程？</p>
<blockquote>
<p>答：加入文本信息后，实际上最大的改变就是<strong>在<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%99%AA%E5%A3%B0%E9%A2%84%E6%B5%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22663557834%22%7D">噪声预测</a>的时候加入了一个新的输入</strong>，即文本。这里我们可以和条件GAN对比来理解。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-a6b23f105ae147a51adb0b9a9214f0bc_b.jpg" alt="img"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/663557834">关于Diffusion的问题和理解 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/v2-c09e733ac6f7017d055a66be6fb28199_b.jpg" alt="img"></p>
<p>损失函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-df32c3d7d99fe83915fec580ebe7e220_b.jpg" alt="img"></p>
<p>V(D,G)表示的是生成样本和真实样本的差异度，可以使用二分类（真、假两个类别）的交叉熵损失。</p>
<p>目的就是让生成的图片能够骗过判别器</p>
<h2 id="DALL-3"><a href="#DALL-3" class="headerlink" title="DALL 3"></a>DALL 3</h2><ul>
<li><p>DALL-E 2 原理</p>
</li>
<li><ul>
<li><strong>CLIP文本编码器</strong>将图像描述映射到表示空间；</li>
<li>然后扩散先验从CLIP文本编码映射到相应的CLIP图像编码；</li>
<li>最后，修改版的GLIDE生成模型通过反向扩散从表示空间映射到图像空间，生成众多可能图像中的一个</li>
<li>海量数据对</li>
</ul>
</li>
<li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic2.zhimg.com/80/v2-673e75aba5134ebaae0870adedc260e9_720w.webp" alt=" "></p>
</li>
<li><p>DALL-E 3 改进</p>
</li>
<li><ul>
<li>最大的改进，就是<strong>样本质量的提高</strong>，其次模型结构微调了（论文未披露），最后就是<strong>GPT加持提示词</strong>转化精度更高</li>
</ul>
</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/660733999">OpenAI发布DALL-E 3 | 原理简介 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><ul>
<li><code>dir()</code>函数，能让我们知道工具箱以及工具箱中的分隔区有什么东西。</li>
<li><code>help()</code>函数，能让我们知道每个工具是如何使用的，工具的使用方法。<ul>
<li><code>help(a)</code>或者<code>a??</code></li>
</ul>
</li>
</ul>
<p>三个区域编写代码：</p>
<ul>
<li>pycharm的python文件<ul>
<li>整体运行，python文件的块是所有行的代码，适用大型项目</li>
<li>每次都是整体运行</li>
</ul>
</li>
<li>pycharm的python 控制台<ul>
<li>以任意行为块(Shift+Enter)，变量属性在右边查看</li>
<li>出现错误可阅读性大大降低</li>
</ul>
</li>
<li>Jupyter notebook<ul>
<li>同python控制台，Shift+Enter执行块</li>
<li>可以直接修改块中的错误，阅读性加强</li>
<li>环境需要配置</li>
</ul>
</li>
</ul>
<h2 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h2><p>一堆数据–&gt;Dataset(提供一种方式去获取数据及其label)–&gt;Dataloader(为后面的网络提供不同的数据形式)</p>
<p>Dataset：</p>
<ul>
<li>如何获取每一个数据及其label</li>
<li>告诉我们总共有多少数据</li>
</ul>
<h3 id="数据的组织形式"><a href="#数据的组织形式" class="headerlink" title="数据的组织形式"></a>数据的组织形式</h3><ul>
<li>文件夹名就是一个label</li>
<li>ocr<ul>
<li>图片</li>
<li>对应图片的文字坐标信息</li>
</ul>
</li>
<li>图片名就是label</li>
</ul>
<p>实战案例：</p>
<p><a target="_blank" rel="noopener" href="http://github.com/JJuprising/upload-img/Snipaste_2022-09-24_23-31-33.png">image-Snipaste_2022-09-24_23-31-33</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir  <span class="comment"># 数据集文件夹</span></span><br><span class="line">        self.label_dir = label_dir  <span class="comment"># 数据集标签</span></span><br><span class="line">        self.path = os.path.join(root_dir, label_dir)  <span class="comment"># 拼接路径 这里正好文件夹名就是标签名</span></span><br><span class="line">        self.img_path = os.listdir(self.path)  <span class="comment"># 将文件夹下图片转换成列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):  <span class="comment"># idx是索引</span></span><br><span class="line">        img_name = self.img_path[idx]  <span class="comment"># 获取单张图片名字</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)  <span class="comment"># 拼接获得单张图的地址</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)  <span class="comment"># 图片读取</span></span><br><span class="line">        label = self.label_dir  <span class="comment"># 获取标签</span></span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)  <span class="comment"># 长度即数据集的列表长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;dataset/train&quot;</span>  <span class="comment"># 大路径</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span>  <span class="comment"># 蚂蚁标签</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span>  <span class="comment"># 蜜蜂标签</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)  <span class="comment"># 实例化蚂蚁</span></span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)  <span class="comment"># 实例化蜜蜂</span></span><br><span class="line"></span><br><span class="line">train_dataset = ants_dataset + bees_dataset  <span class="comment"># 拼接数据集</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io">https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io</a></p>
<h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>看模块的代码：按住Ctrl，点模块</p>
<p>打开窗口，不接<code>--port</code>默认打开6006端口的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007</span><br></pre></td></tr></table></figure>

<h4 id="add-scalar"><a href="#add-scalar" class="headerlink" title="add_scalar"></a>add_scalar</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from torch.utils.tensorboard import SummaryWriter</span><br><span class="line"></span><br><span class="line">writer=SummaryWriter(&quot;logs&quot;)</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    writer.add_scalar(&quot;标题&quot;,y轴,x轴)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<p>重新画删掉Logs文件下下的所有文件，在终端Ctrl+c结束后重新打开窗口</p>
<h4 id="add-image"><a href="#add-image" class="headerlink" title="add_image()"></a>add_image()</h4><p>opencv读取到的数据是numpy型</p>
<p>从PIL到numpy，需要在add_image()中指定shape中每一个数字&#x2F;维表示的含义，默认是CHW即通道-高度-宽度，如果导入图片是HWC就要加入说明，见案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">image_path = <span class="string">&quot;data/train/ants_image/0013035.jpg&quot;</span></span><br><span class="line">img_PIL = Image.<span class="built_in">open</span>(image_path)  <span class="comment"># 打开图片</span></span><br><span class="line">img_array = np.array(img_PIL)  <span class="comment"># 转成numpy型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(img_array))  <span class="comment"># 验证时numpy型</span></span><br><span class="line"><span class="built_in">print</span>(img_array.shape)  <span class="comment"># 检查图片的形状，发现是HWC，即高度-宽度-通道</span></span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;test&quot;</span>, img_array, dataformats=<span class="string">&quot;HWC&quot;</span>)  <span class="comment"># HWC对应图片的形状</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=2*x&quot;</span>,<span class="number">3</span>*i,i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>transform.py工具箱，有toTensor，resize等工具，用于处理图片输出想要的图片结果</p>
<ul>
<li>transform的使用</li>
<li>tensor数据类型</li>
</ul>
<p>在括号内Ctrl+P查看要输入的参数</p>
<h3 id="tensor数据类型"><a href="#tensor数据类型" class="headerlink" title="tensor数据类型"></a>tensor数据类型</h3><h3 id="ToTensor-amp-Normalize"><a href="#ToTensor-amp-Normalize" class="headerlink" title="ToTensor&amp;Normalize"></a>ToTensor&amp;Normalize</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span>  torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"></span><br><span class="line">writer=SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">img=Image.<span class="built_in">open</span>(<span class="string">&quot;dataset/val/ants/800px-Meat_eater_ant_qeen_excavating_hole.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(img)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ToTensor</span></span><br><span class="line">trans_totensor=transforms.ToTensor()</span><br><span class="line">img_tensor=trans_totensor(img) <span class="comment">#  转成tensor类型</span></span><br><span class="line">writer.add_image(<span class="string">&quot;ToTensor&quot;</span>,img_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  Normalize</span></span><br><span class="line"><span class="built_in">print</span>(img_tensor[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">trans_norm=transforms.Normalize([<span class="number">3</span>,<span class="number">0.5</span>,<span class="number">0.5</span>],[<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>]) <span class="comment">#  标准差</span></span><br><span class="line">img_norm=trans_norm(img_tensor)</span><br><span class="line"><span class="built_in">print</span>(img_norm[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">writer.add_image(<span class="string">&quot;Normalize&quot;</span>,img_norm,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>



<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#接上面代码</span></span><br><span class="line"><span class="comment"># Resize</span></span><br><span class="line"><span class="built_in">print</span>(img.size)  <span class="comment"># 原图的大小(800, 534)</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>, <span class="number">512</span>)) <span class="comment"># 改大小</span></span><br><span class="line"><span class="comment"># img PIL -&gt; resize -&gt; img_resize PIL</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"><span class="comment"># img_resize PIL -&gt; totensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize=trans_totensor(img_resize)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>,img_resize,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(img_resize)</span><br></pre></td></tr></table></figure>



<h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose()"></a>Compose()</h3><p><code>Compose()</code>中的参数需要一个列表。Python中，列表的表示形式为[数据1，数据2，…]。在<code>Compose</code>中，数据需要是<code>transforms</code>类型，所以得到的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compose([transforms参数<span class="number">1</span>,transforms参数<span class="number">2</span>,...])</span><br></pre></td></tr></table></figure>

<p>将几步打包成一步：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Compose - resize - 2</span></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>) <span class="comment"># 只改了宽 没改长</span></span><br><span class="line"><span class="comment"># PIL -&gt; PIL -&gt; tensor</span></span><br><span class="line">tran_compose = transforms.Compose([trans_resize_2, trans_totensor])</span><br><span class="line">img_resize_2 = tran_compose(img)</span><br><span class="line">writer.add_image(<span class="string">&quot;Resize&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>



<h3 id="RandomCrop"><a href="#RandomCrop" class="headerlink" title="RandomCrop()"></a>RandomCrop()</h3><p>随机裁剪出一部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trans_random = transforms.RandomCrop(<span class="number">512</span>) </span><br><span class="line"><span class="comment"># PIL -&gt; PIL -&gt; tensor</span></span><br><span class="line">tran_compose_2 = transforms.Compose([trans_random, trans_totensor])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>): <span class="comment"># 设置不同步数</span></span><br><span class="line">    img_crop=trans_compose_2(img)</span><br><span class="line">    writer.add_image(<span class="string">&quot;RandomCrop&quot;</span>, img_resize_2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>关注输入和输出</p>
</li>
<li><p>多看官方文档 <a target="_blank" rel="noopener" href="https://pytorch.org/">PyTorch</a></p>
</li>
<li><p>关注方法需要什么参数</p>
</li>
<li><p>不知道返回值的时候：</p>
<ul>
<li>&#96;&#96;&#96;python<br>print()<br>print(type())<br>调试<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">## torchvision数据集的使用</span><br><span class="line"></span><br><span class="line">官网文档的torchvision.datasets下有很多数据集可以使用</span><br><span class="line"></span><br><span class="line">torchvision.models提供训练好的模型</span><br><span class="line"></span><br><span class="line">torchvision.transform上面讲了</span><br><span class="line"></span><br><span class="line">torchvision.utils提供小工具</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import torchvision</span><br><span class="line"></span><br><span class="line">train_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/data1&quot;,train=True,download=True) # 下载训练集</span><br><span class="line">test_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/test1&quot;,train=False,download=True) # 下载测试集</span><br><span class="line"></span><br><span class="line">print(test_set[0]) # ( , )的形式，发现第一个是图片第二个是target</span><br><span class="line">print(test_set.classes) # 查看图片有哪些类型(调式看test_set有calsses属性)</span><br><span class="line"></span><br><span class="line">img,target=test_set[0] #接收( , )</span><br><span class="line">print(img)</span><br><span class="line">print(target)</span><br><span class="line">print(test_set.classes[target])</span><br><span class="line">img.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="和transform联动"><a href="#和transform联动" class="headerlink" title="和transform联动"></a>和transform联动</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset_transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) <span class="comment"># 设置transforms</span></span><br><span class="line">train_set=torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset/data1&quot;</span>,train=<span class="literal">True</span>,transform=dataset_transform,download=<span class="literal">True</span>) <span class="comment"># 加入transforms参数</span></span><br><span class="line">test_set=torchvision.datasets.CIFAR10(root=<span class="string">&quot;./dataset/test1&quot;</span>,train=<span class="literal">False</span>,transform=dataset_transform,download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">writer=SummaryWriter(<span class="string">&#x27;p10&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    img,target = test_set[i]</span><br><span class="line">    writer.add_image(<span class="string">&quot;test_set&quot;</span>,img,i)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io@main/images/image-20220927212823149.png" alt="image-20220927212823149"></p>
<h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备测试数据集</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset/test1&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor())</span><br><span class="line">test_loader = DataLoader(dataset=test_data, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据集中第一张照片及target</span></span><br><span class="line">img, target = test_data[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(img.shape)</span><br><span class="line"><span class="built_in">print</span>(target)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;dataloader&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">    imgs, targets = data  <span class="comment"># test_loader返回值是batch_size设定的一组图片打包的img和target</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;test_data&quot;</span>, imgs, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io@main/images/image-20220929211159838.png" alt="image-20220929211159838"></p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p><code>torch.nn</code>，Neural Network。</p>
<p><code>nn.Module</code>是所有神经网络的基类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">20</span>, <span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment"># 隐藏层</span></span><br><span class="line">        x = F.relu(self.conv1(x)) <span class="comment">#  经过一次卷积然后一次非线性 </span></span><br><span class="line">        <span class="keyword">return</span> F.relu(self.conv2(x)) <span class="comment"># 输出</span></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/04/qbmG4ki3yrdASMo.png" alt="image.png"></p>
<p><strong>各种参数</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/04/VfBkvFeRrU7QELC.png" alt="image.png"></p>
<p><strong>Stride</strong></p>
<p>Stirde&#x3D;1表示卷积核在输入图像上移动一格，对应格相乘得到数；从左到右，到边界回到最左向下移动Stride然后重复操作</p>
<p><strong>padding</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/04/qaZRfAUQYKLWIpH.png" alt="image.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                   [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">kernel=torch.tensor([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">                     [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                     [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape) <span class="comment"># 只有两个参数，不能直接放进卷积，要reshape</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>=torch.reshape(<span class="built_in">input</span>,(<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>)) <span class="comment"># 5X5矩阵</span></span><br><span class="line">kernel=torch.reshape(kernel,(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"><span class="built_in">print</span>(kernel.shape) <span class="comment"># 变成四个参数</span></span><br><span class="line"></span><br><span class="line">output=F.conv2d(<span class="built_in">input</span>,kernel,stride=<span class="number">1</span>,padding=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># torch.Size([5, 5])</span></span><br><span class="line"><span class="comment"># torch.Size([1, 1, 5, 5])</span></span><br><span class="line"><span class="comment"># torch.Size([1, 1, 3, 3])</span></span><br><span class="line"><span class="comment"># tensor([[[[ 1,  3,  4, 10,  8],</span></span><br><span class="line"><span class="comment">#           [ 7, 14, 14, 17,  9],</span></span><br><span class="line"><span class="comment">#           [ 9, 18, 18, 17,  9],</span></span><br><span class="line"><span class="comment">#           [15, 17, 14,  8,  7],</span></span><br><span class="line"><span class="comment">#           [14, 13,  9,  7,  4]]]])</span></span><br></pre></td></tr></table></figure>

<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p><code>nn.Conv1d</code>一维卷积，<code>nn.Conv2d</code>二维卷积层…</p>
<p>彩色图像一般是三通道</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="literal">True</span>, padding_mode=<span class="string">&#x27;zeros&#x27;</span>, device=<span class="literal">None</span>, dtype=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数表 输入通道数，输出通道数，卷积核大小，卷积操作步径大小，边缘填充，卷积核距离...后面都是默认参数</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md#convolution-animations">卷积层示例</a>(动图要梯子才能刷出来)</p>
<p><code>out_channels</code>设置为2时会生成两个卷积核，得到两个叠加的输出。(一般卷积操作会不断增加channels数)</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.datasets</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;/dataset/data2&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataLoader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Tudui, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">6</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myModule = MyModule()</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs2&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataLoader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = myModule(imgs)</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)</span><br><span class="line">    <span class="built_in">print</span>(output.shape)</span><br><span class="line">    <span class="comment"># torch.Size([64,3,32,32])</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    <span class="comment"># torch.Size([64,6,30,30]) -&gt; [xxx,3,30,30]</span></span><br><span class="line">    output = torch.reshape(output, (-<span class="number">1</span>, <span class="number">3</span>, <span class="number">30</span>, <span class="number">30</span>))  <span class="comment"># 原本输出通道数变两倍，这一步相当于切开放到一个</span></span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/05/bMqJYA612urv7FG.png" alt="image.png"></p>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p><strong>ceil_mode</strong></p>
<p>floor向下取整，ceiling向上取整。默认false不够对应不取值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/05/o5R7AdYrMSk8lwX.png" alt="image.png"></p>
<p>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大池化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                      [<span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                      [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=torch.float32)  <span class="comment"># 声明一下类型否则报错</span></span><br><span class="line"><span class="built_in">input</span> = torch.reshape(<span class="built_in">input</span>, (-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">        self.maxpool1 = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">False</span>) <span class="comment"># 注意ceil_mode</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,<span class="built_in">input</span></span>):</span><br><span class="line">        output=self.maxpool1(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">myModule = MyModule()</span><br><span class="line">output = myModule(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当ceilmode设置为false结果：</span></span><br><span class="line"><span class="comment"># torch.Size([1, 1, 5, 5])</span></span><br><span class="line"><span class="comment"># tensor([[[[2.]]]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当ceilmode设置为true结果：</span></span><br><span class="line"><span class="comment"># torch.Size([1, 1, 5, 5])</span></span><br><span class="line"><span class="comment"># tensor([[[[2., 3.],</span></span><br><span class="line"><span class="comment">#           [5., 1.]]]])</span></span><br></pre></td></tr></table></figure>



<p><strong>最大池化目的为了保持原先数据的特征同时减少数据量，加快训练速度。</strong>例如720p也能大致看明白1080p视频内容</p>
<p>例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大池化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;/dataset/data2&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataLoader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">        self.maxpool1 = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.maxpool1(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myModule = MyModule()</span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;Logs_maxpool&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataLoader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = myModule(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/05/9cvBhXPkQ6GEub3.png" alt="image.png"></p>
<p>可以看到输出图片变模糊了</p>
<h3 id="非线性激活-Non-linear"><a href="#非线性激活-Non-linear" class="headerlink" title="非线性激活 Non-linear"></a>非线性激活 Non-linear</h3><p>用到<code>ReLu()</code>或<code>Sigmoid()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Sigmoid, ReLU</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;/dataset/data2&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataLoader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">        self.relu = ReLU()</span><br><span class="line">        self.sigmoid1 = Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.sigmoid1(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MyModule = MyModule()</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_relu&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataLoader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, global_step=step)</span><br><span class="line">    output = MyModule(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, global_step=step)</span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/AkmqnhzTt5SQO4a.png" alt="image.png"></p>
<p><strong>主要目的在网络中引入更多非线性特征，才能训练出符合更多特征的模型。</strong></p>
<h3 id="线性层及其他层"><a href="#线性层及其他层" class="headerlink" title="线性层及其他层"></a>线性层及其他层</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLASS torch.nn.Linear(in_features,out_features,biass=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><code>biass</code>表示要不要设置偏振b</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/IFkEvmwWp1QL23z.png" alt="image.png"></p>
<p><code>flattten()</code>展平成一行</p>
<h3 id="CRAF10小实战及Sequential"><a href="#CRAF10小实战及Sequential" class="headerlink" title="CRAF10小实战及Sequential()"></a>CRAF10小实战及Sequential()</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/Pqjv75cuZ6fQVsU.png" alt="image.png"></p>
<p>1、由公式计算第一步卷积得到padding是2(默认设置stride为1)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/HVp1tdsRDFlgBXQ.png" alt="image.png"></p>
<p>通过对每一步的解析，我们建立出一个简单的模型，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myModule = MyModule()</span><br><span class="line"><span class="built_in">print</span>(myModule)</span><br><span class="line"><span class="built_in">input</span> = torch.ones((<span class="number">64</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>))  <span class="comment"># torch提供的一个假设的输入</span></span><br><span class="line">output = myModule(<span class="built_in">input</span>)</span><br><span class="line"><span class="built_in">print</span>(output.shape)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs_seq2&quot;</span>)</span><br><span class="line">writer.add_graph(myModule,<span class="built_in">input</span>)</span><br><span class="line">writer.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/U7kGqmLQAs2tJVo.png" alt="image.png"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">JJuprising</div><div class="post-copyright__author_desc">蓝天白云,花草树木</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://jjuprising.github.io/2022/09/27/Deep%20Learning/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://jjuprising.github.io/2022/09/27/Deep%20Learning/')">Deep Learning</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://jjuprising.github.io/2022/09/27/Deep%20Learning/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Deep Learning&amp;url=https://jjuprising.github.io/2022/09/27/Deep%20Learning/&amp;pic=/img/404.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://JJuprising.github.io" target="_blank">yjchen</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/python/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>python<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>深度学习<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/24/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-dbe054265f77076e47cc1bc80532b054_1440w.jpg?source=172ae18b" onerror="onerror=null;src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/10/07/XTCDJwhl5OKGyFW.png" onerror="onerror=null;src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2022/09/24/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="python学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://pic1.zhimg.com/v2-dbe054265f77076e47cc1bc80532b054_1440w.jpg?source=172ae18b" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2022-09-24</div><div class="title">python学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/./images/ava.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://bu.dusays.com/2021/01/15/8b962544da5c0.png" alt="status"/></div></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">JJuprising</h1><div class="author-info__desc">蓝天白云,花草树木</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/JJuprising" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.xiaohongshu.com/user/profile/62c441a0000000001b02791d" target="_blank" title="小红书"><i class="anzhiyufont anzhiyu-icon-fire"></i></a><a class="social-icon faa-parent animated-hover" href="https://www.zhihu.com/people/bo-yi-shu-qi-49" target="_blank" title="知乎"><i class="anzhiyufont anzhiyu-icon-box-archive"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2024/10/10/jSgFzEeKODwGCYQ.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">机器学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E9%82%BB%E8%BF%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">K邻近</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92"><span class="toc-number">1.1.2.</span> <span class="toc-text">逻辑回归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">1.1.3.</span> <span class="toc-text">线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">代价函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">逻辑损失函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">梯度下降</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.3.2.1.</span> <span class="toc-text">如何理解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%87"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">学习率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">1.1.4.</span> <span class="toc-text">多维线性回归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">多元特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A2%E9%87%8F%E5%8C%96-vectorization"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">矢量化 vectorization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">1.1.4.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">多层感知机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">激活函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">损失函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D-1"><span class="toc-number">1.5.</span> <span class="toc-text">梯度下降</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">什么是梯度下降</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D"><span class="toc-number">1.5.2.</span> <span class="toc-text">神经网络与梯度下降</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8F%82%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">超参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%87-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">学习率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%B0%83%E6%95%B4%E5%AD%A6%E4%B9%A0%E7%8E%87"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">如何设置和调整学习率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">优化器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.8.</span> <span class="toc-text">卷积神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF"><span class="toc-number">1.8.1.</span> <span class="toc-text">卷积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%B1%82-%E6%B1%A0%E5%8C%96%E5%B1%82%EF%BC%8Cpooling"><span class="toc-number">1.8.2.</span> <span class="toc-text">采样层(池化层，pooling)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B1%A0%E5%8C%96"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">最大池化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">如何进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">池化的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">激活函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B"><span class="toc-number">1.8.3.1.</span> <span class="toc-text">线性方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%85%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.3.2.</span> <span class="toc-text">待解决问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7"><span class="toc-number">1.8.3.2.1.</span> <span class="toc-text">非线性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.8.3.2.2.</span> <span class="toc-text">输出需要进行分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%AF%E8%83%BD%E7%89%B9%E5%88%AB%E5%A4%A7"><span class="toc-number">1.8.3.2.3.</span> <span class="toc-text">输入可能特别大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E6%A2%AF%E5%BA%A6%E4%B8%8E%E8%BE%93%E5%85%A5%E6%97%A0%E5%85%B3%E4%BA%86"><span class="toc-number">1.8.3.2.4.</span> <span class="toc-text">线性方程梯度与输入无关了</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-2"><span class="toc-number">1.8.3.3.</span> <span class="toc-text">激活函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dropout"><span class="toc-number">1.8.4.</span> <span class="toc-text">dropout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="toc-number">1.8.5.</span> <span class="toc-text">全连接层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.9.</span> <span class="toc-text">编码器解码器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">深度学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%8B%E5%B7%AE%E7%BD%91%E7%BB%9CResnet"><span class="toc-number">2.1.</span> <span class="toc-text">残差网络Resnet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%88%E6%9E%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text">为什么有效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">注意力机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transformer"><span class="toc-number">2.3.</span> <span class="toc-text">Transformer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QKV"><span class="toc-number">2.3.1.</span> <span class="toc-text">QKV</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">关键点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Norm"><span class="toc-number">3.0.1.</span> <span class="toc-text">Norm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0transfer-learning"><span class="toc-number">4.</span> <span class="toc-text">迁移学习transfer learning</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Domain-Adaptation"><span class="toc-number">4.1.</span> <span class="toc-text">Domain Adaptation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">4.1.1.</span> <span class="toc-text">适用环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83-Damain-Aversival-Trainng"><span class="toc-number">4.1.2.</span> <span class="toc-text">域对抗训练 Damain Aversival Trainng</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%9F%E5%A4%B1%E8%AE%A1%E7%AE%97"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">损失计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limitation"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">limitation</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BCI"><span class="toc-number">5.</span> <span class="toc-text">BCI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%8C%87%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">常见指标</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%94%9F%E6%88%90"><span class="toc-number">6.</span> <span class="toc-text">图像生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.1.</span> <span class="toc-text">自监督学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.1.1.</span> <span class="toc-text">对比学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CLIP"><span class="toc-number">6.2.</span> <span class="toc-text">CLIP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">扩散模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83"><span class="toc-number">6.3.1.</span> <span class="toc-text">正态分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">扩散模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E5%8A%A0%E5%99%AA"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">前向加噪</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GAN"><span class="toc-number">6.4.</span> <span class="toc-text">GAN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DALL-3"><span class="toc-number">6.5.</span> <span class="toc-text">DALL 3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Pytorch"><span class="toc-number">7.</span> <span class="toc-text">Pytorch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">7.1.</span> <span class="toc-text">加载数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">数据的组织形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tensorboard"><span class="toc-number">7.2.</span> <span class="toc-text">Tensorboard</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-scalar"><span class="toc-number">7.2.0.1.</span> <span class="toc-text">add_scalar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-image"><span class="toc-number">7.2.0.2.</span> <span class="toc-text">add_image()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transform"><span class="toc-number">7.3.</span> <span class="toc-text">Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tensor%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.1.</span> <span class="toc-text">tensor数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ToTensor-amp-Normalize"><span class="toc-number">7.3.2.</span> <span class="toc-text">ToTensor&amp;Normalize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize"><span class="toc-number">7.3.3.</span> <span class="toc-text">resize()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compose"><span class="toc-number">7.3.4.</span> <span class="toc-text">Compose()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RandomCrop"><span class="toc-number">7.3.5.</span> <span class="toc-text">RandomCrop()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.3.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8Ctransform%E8%81%94%E5%8A%A8"><span class="toc-number">7.3.7.</span> <span class="toc-text">和transform联动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataLoader"><span class="toc-number">7.4.</span> <span class="toc-text">DataLoader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">7.5.</span> <span class="toc-text">神经网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">7.5.1.</span> <span class="toc-text">卷积操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B7%E7%A7%AF%E5%B1%82"><span class="toc-number">7.5.2.</span> <span class="toc-text">卷积层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%A0%E5%8C%96%E5%B1%82"><span class="toc-number">7.5.3.</span> <span class="toc-text">池化层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BF%80%E6%B4%BB-Non-linear"><span class="toc-number">7.5.4.</span> <span class="toc-text">非线性激活 Non-linear</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%B1%82%E5%8F%8A%E5%85%B6%E4%BB%96%E5%B1%82"><span class="toc-number">7.5.5.</span> <span class="toc-text">线性层及其他层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRAF10%E5%B0%8F%E5%AE%9E%E6%88%98%E5%8F%8ASequential"><span class="toc-number">7.5.6.</span> <span class="toc-text">CRAF10小实战及Sequential()</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/13/Energy/" title="Energy"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/default_cover.jpg" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="Energy"/></a><div class="content"><a class="title" href="/2024/11/13/Energy/" title="Energy">Energy</a><time datetime="2024-11-13T09:17:15.000Z" title="发表于 2024-11-13 17:17:15">2024-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/25/LLM-and-Agent/" title="LLM and Agent"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://th.bing.com/th/id/OIP.xrX90o6umInaSd-VYdeR7wHaD4?rs=1&amp;pid=ImgDetMainPr" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="LLM and Agent"/></a><div class="content"><a class="title" href="/2024/10/25/LLM-and-Agent/" title="LLM and Agent">LLM and Agent</a><time datetime="2024-10-25T07:16:33.000Z" title="发表于 2024-10-25 15:16:33">2024-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/10/Reinforcement-Learning/" title="Reinforcement Learning"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/20210320145602494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMzAyMDA0,size_16,color_FFFFFF,t_70" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="Reinforcement Learning"/></a><div class="content"><a class="title" href="/2024/10/10/Reinforcement-Learning/" title="Reinforcement Learning">Reinforcement Learning</a><time datetime="2024-10-10T06:50:30.000Z" title="发表于 2024-10-10 14:50:30">2024-10-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/25/Redis-MySQL/" title="SpringCloud+Nginx+Redis+MySQL"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/56cffe7dbf42c200024f3f6d1bb2aab0.png" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="SpringCloud+Nginx+Redis+MySQL"/></a><div class="content"><a class="title" href="/2024/06/25/Redis-MySQL/" title="SpringCloud+Nginx+Redis+MySQL">SpringCloud+Nginx+Redis+MySQL</a><time datetime="2024-06-25T01:16:01.000Z" title="发表于 2024-06-25 09:16:01">2024-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/23/CVPR-2024-Best-Paper/" title="CVPR 2024 Best Paper"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://th.bing.com/th/id/R.57d22888aa8215c9f7c1f0e1e4d3ffc4?rik=uOe4sZz4A3tA4A&amp;riu=http%3a%2f%2fwww.dfad.unimore.it%2fmedia%2fimages%2fuploads%2f2024%2f01%2f21%2f29994fb078-CVPR_LogoSeattle_2024_Primary.jpg&amp;ehk=lBf0F17TAQOOcXi23ChDDJLgkskHjXyKlXjChREBOKY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg'" alt="CVPR 2024 Best Paper"/></a><div class="content"><a class="title" href="/2024/06/23/CVPR-2024-Best-Paper/" title="CVPR 2024 Best Paper">CVPR 2024 Best Paper</a><time datetime="2024-06-22T16:38:45.000Z" title="发表于 2024-06-23 00:38:45">2024-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="JJuprising" target="_blank">JJuprising</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://jjuprising.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;https://www.itra.co.jp/uploads/media/2019/05/20190528205238_1.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cv/cyj_CV.pdf"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> CV</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>1</sup></a><a href="/tags/DL/" style="font-size: 0.88rem;">DL<sup>1</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>2</sup></a><a href="/tags/c/" style="font-size: 0.88rem;">c++<sup>1</sup></a><a href="/tags/html/" style="font-size: 0.88rem;">html<sup>2</sup></a><a href="/tags/javascript/" style="font-size: 0.88rem;">javascript<sup>1</sup></a><a href="/tags/minecraft/" style="font-size: 0.88rem;">minecraft<sup>1</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>2</sup></a><a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">云服务器<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>1</sup></a><a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.88rem;">小程序<sup>1</sup></a><a href="/tags/%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">教程<sup>2</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>2</sup></a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 0.88rem;">服务器<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">深度学习<sup>1</sup></a><a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 0.88rem;">笔记<sup>8</sup></a><a href="/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" style="font-size: 0.88rem;">经验分享<sup>1</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>6</sup></a><a href="/tags/%E8%84%91%E7%94%B5/" style="font-size: 0.88rem;">脑电<sup>1</sup></a><a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 0.88rem;">项目<sup>5</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 JJuprising 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>