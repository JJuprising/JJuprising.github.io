{"posts":[{"title":"2022web大作业","text":"最初想法是copy spsspro 可惜临近期末时间太赶了，而且发现还有好多前端知识还没学懂弄会，比如变量生存期、请求的顺序、解析后数据的存储形式等。 大作业要求： 说明文档","link":"/2022/07/01/2022web%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing 1234$ hexo clean //清除缓存$ hexo g //生成静态文件$ hexo s //启动本地服务$ hexo d //上传 Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/03/02/hello-world/"},{"title":"Java学习笔记","text":"main函数当作类外的函数来看待 1、包内访问权限和protected有何不同？(p98) 包内访问权限介于private和protected之间 包外的派生类，可以在派生类内部调用基类的protected成员 包外的派生类，无法在派生类内部调用基类的包内访问成员 当两个包在同一个项目之中时，可以通过完整类目继承包外的基类访问 1234package Lab2;class newClass extends Lab1.myClass{//包名.类名 } 当两个包在不同的项目之中时，将基类项目导出为.jar，将该.jar文件复制到派生类所在的项目文件夹中，然后右键点击选择”add building path”添加到构建路径，然后代码与上面相同。 2、所有数组都能排序吗？ 错误。排序要有一定依据，没有指定依据无法排序。如类型为类的数组，可比较的属性不止一种（implements比较器)。 3、接口 接口的本质是标准，是设计者、实现者，调用者之间的桥梁 类内实现的可比较器Comparable，由被比较的类implements实现，重写compareTo函数 类外实现的可比较器Comparator，由另外一个类implements实现，重写compare函数 如果是一次性的考虑用匿名内部类来实现比较器。否则这个只用一次的有名字的类可能会对代码理解造成困扰。 基本输入输出范例代码1234Scanner sc=new Scanner(System.in);int n=sc.nextInt();String str1=sc.next();System.out.println(&quot;欢迎&quot;+n+&quot;号同学&quot;+str1); 第四章 流程控制循环语句foreach语句123for(元素类型x:遍历对象obj){ 引用了x的java语句;} 例子：遍历一维数组 1234567891011121314151617public class Repetition{ public static void main(String args[]){ int arr[]={5,13,96}; System.out.println(&quot;一维数组中的元素分别为：&quot;); //x的类型与arr元素的类型相同 。for循环依次取出arr中的值并赋给x for(int x:arr){ System.out.println(x); } }}/*输出结果：一维数组中的元素分别为：51396*/ 第五章 数组数组的基本操作数组排序 Arrays.sort(arr); Arrays.parallelSort(arr);多线程排序，数据量大于一百万 复制数组copyof()方法语法：int a[]=Arrays.copyOf(arr,int newlength); newlength：复制后新数组的长度 ！注：不能直接a=b，数组名是指针常量（常指针） 第六章 类和对象面向对象概述封装 避免外部操作对内部数据的影响，提高程序的可维护性 提高工作效率，把无需调用者关心的内容隐藏，简化编程，知道面对外部的接口能调用即可 类对于人来说， public：学历、知识（别人抢不走的） protected：身体等 public：很多 protected同包其他类或子类(继承)可见，其他包的类或子类不可见；private都不可见，只有本类可见。 this 关键字this关键字用于表示本类当前的对象，只能在本类中使用。 123public void setName(String name){//定义一个setName()的方法 this.name=name;//将参数值赋予类中的成员变量} 类的构造方法 Java类内的属性值不支持默认值，不能直接定义 int count=0 应使用默认构造函数初始化 12345678910public class eggCake{ int eggCount; public EggCake(int eggCount){//有参构造 this.eggCount=eggCount; } public EggCake(){ //设置鸡蛋灌饼里蛋的个数为1 this(1); }} 静态12345678910public class Lab2_1{ public static void main(String[] args){ new Lab2_1().show();//临时无名对象 //如果是show.()直接调用会报错，除非把show 声明为静态函数，说这是上面的方法，调用类内成员函数 } void show(){ System.out.println(&quot;Hello!&quot;) }} 类内静态成员共用一份空间 如果函数 对象对象的销毁12345678910public class Lab2_1{ public static void main(String[] args){ Lab2_1 l2=new Lab2_1(); //l2=null; 销毁对象 之后如果是l2.show();那么会报错NullPointerException }//超过作用域 对象l2销毁 void show(){ System.out.println(&quot;Hello!&quot;) }} 第七章 继承、多态、抽象类与接口类的继承extends 关键字语法：CHild extends Parents super 关键字Object 类Object类是一切类的基类，隐含的继承 如果没声明，toString()一定是调用自Object类，输出是字符编号。 输出字符串自动会调用toString()函数，应当重写以达到需要的输出目的。 重写只能保持或扩大访问权限，如原本是Public不能改成Private。 123456789101112131415161718public class Student{ String name; int age; public Student(String name,int age){ this.name=name; this.age=age; } @Override//加这个帮助检查重写的函数名是否正确 public String toString(){ return &quot;我叫&quot;+name+&quot;,今年&quot;+age+&quot;岁。&quot;; } public static void main(String[] args){ Student s1=new Student(&quot;张三&quot;,16); System.out.println(s1);//就是System.out.println(s1.toString()); }} 对象的类型转换需要基类对象的任何地方，都可以用派生类对象替代 向上转型向下转型instanceof关键字判断对象类型方法的重载 函数的返回值类型不属于重载的依据 final 关键字最终的、终态 多态抽象类与接口抽象类 只要类中有一个抽象方法，此类就是抽象类 抽象类不能实例化，抽象类存在的目的就是为了被继承 c++中全是抽象方法就叫纯虚类 接口 只能声明，不能实现 第9章 异常处理异常与错误： 一个不好的问题发生了，如果对该问题提前有应对措施，就是异常处理； 如果没有任何准备，就是错误。 12345678910try{ //想要正确执行，但是不可控的语句段 //数据输入输出、网络连接、文件读写、数据库连接访问}catch(Exception e){ //可以有多个catch语句，捕获不同的异常 //必须是小范围异常(异常类)在前，Exception必须放在最后，Exception是所有异常的基类，范围最大}finally{ //不管是否有捕获异常，都想要执行的代码} 第10章 字符串String类，字符常量存储。 创建12char a[]={'g','o','o','d'};String s = new String(a);//相当于String s = new String(&quot;good&quot;) 截取 12char a[]={'g','o','o','d'};String s = new String(a,1,2);//相当于String s = new String(&quot;oo&quot;) 字符串连接int+''把int转为String类型 获取字符串信息12System.out.println(s[0]);//是错误的System.out.println(s.charAt[0]);//才对 字符串的查找indexOf(String s) 区分大小写 123String str=&quot;We are students&quot;;int size=str.indexOf(&quot;a&quot;);int size2=str.toLowerCase().indexOf(&quot;a&quot;);//转为小写再查找，这个toLowerCase()或toUpperCase()是生成新的字符串对象，不会修改原来的字符串 字符串操作获取字符串substring(int beginIndex) 12String str=&quot;Hello World&quot;;String substr=str.substring(3); 字符串替换replace() replaceAll()支持正则表达式 判断相等equals()而不是用== 123456String s1=&quot;abc&quot;;String s2=&quot;abc&quot;;String s3=new String(&quot;abc&quot;);String s4=new String(&quot;abc&quot;);System.out.println(s1==s2);//结果是trueSystem.out.println(s3==s4);//结果是false 如果直接等号赋值，就是基本数据类型，用==可以判断；当用new，把变量当对象来看待，两个对象不可能相等，因此只能用equals()来判断相等。 正则表达式12String regex1=&quot;[a-zA-Z_$]+[a-zA-Z_$]*&quot;;//String regex2=&quot;[1-9][0-9]{4,10}*&quot;;//qq号码规则 使用： 12345678910111213141516171819202122232425262728293031323334353637package lesson5;import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegExp { public static void main(String[] args) { // TODO 自动生成的方法存根 String contentString=&quot;1998,1239,12,144&quot;; //1.\\\\d表示一个任意的数字 String regString=&quot;\\\\d\\\\d\\\\d\\\\d&quot;;//找四个连续的数字,分组的话是(//d)(//d) //2.创建模式对象[即正则表达式对象] Pattern pattern=Pattern.compile(regString); //3.创建匹配器 //说明：创建匹配器matcher，按照正则表达式的规则去匹配content字符串 Matcher matcher=pattern.matcher(contentString); //4.开始匹配 /* * match.find()完成的任务 (考虑分组，如(//d//d)(//d//d)) * 1. 根据给定的规则，定位满足规则的字符串（如1999,分组即(19)(99)) * 2. 找到时，将字符串的开始的索引记录到matcher对象的属性 int[] groups; * 2.1groups[0]=0，把该子字符串的结束的索引+1的值记录到group[1]=35,+1是因为取字符串左闭右开 * 2.2 记录第一组()匹配的字符串的区间group[2]=0,group[3]=2 * 2.3 记录第二组()匹配的字符串的区间group[4]=2,group[5]=4 * 2.4 如果有更多分组以此类推 * 3. 同时记录oldLast的值为子字符串的结束的索引+1的值即5，那下一次执行find时，从5开始匹配 */ while(matcher.find()) { System.out.println(&quot;找到：&quot;+matcher.group(0));//group(0)记录找到的字符串开头,同时可以找到结尾 System.out.println(&quot;第一组()的值： &quot;+matcher.group(1));//19 System.out.println(&quot;第二组()的值： &quot;+matcher.group(2));//99 } }} 元字符检索特殊字符要用转义符号\\\\，在java的正则表达式中两个\\\\代表其他语言一个\\ 字符匹配符 符号 含义 实例 说明 匹配输入 [ ] 匹配任意一个 [efgh] e,f,g,h任意一个 e,f,g,h [^ ] 排除 [^abc] 除了abc之外的任意一个字符包括数字和特殊符号 d,f,p . 匹配除\\n以外的任何字符 a..b a开头b结尾中间任意两个字符 aaab,a#*b \\\\d 匹配单个数字字符相当于{0-9} \\\\d{3}{\\\\d}? 包含3个或4个数字的字符串 123,9876 \\\\D 匹配单个非数字字符，相当于[^0-9] \\\\D{\\\\d}* 以单个非数字字符开头后接任意个数字的字符串 a,A342 \\\\w 匹配单个数字、大小英文写字母，下划线，相当于[0-9a-zA-Z_] \\\\d{3}\\\\w{4} 以3个数字字符开头的任意长度为7的数字字母字符串 234abcd、1234Pe \\\\W 匹配单个非数字、大小写字母和下划线字符，相当于[^0-9a-zA-Z_] \\\\W+\\\\d{2} 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 \\\\s 匹配任何空白字符(空格，制表符等) \\\\S 匹配任何非空白字符 \\\\. 匹配除\\n之外的所有字符 区分大小写 默认区分大小写，如模式串写&quot;abc&quot;匹配出来abc而(?i)abc表示不区分大小写,a(?i)bc是bc不区分大小写 常用类库Integer类能在int类型和String类型之间互相转换。 123int num = Integer.parseInt(&quot;456&quot;);//返回包含在由str指定的字符串中的数字的等价整数值Integer iNum=Integer.valueOf(&quot;456&quot;);//返回保存指定的String值的Integer对象iNum.equal(num);//比较，返回值是true Double类是Number类的子类，都是对浮点数进行操作。Double类在对象中包装一个基本类型为double的值，每个Double类的对象都包含一个double类型的字段。可将String和double相互转换。 123Double dNum=Double.valueOf(&quot;3.14&quot;);Double.isNaN(dNum.doubleValue());//是否返回非数字(NaN)值dNum.intValue();//转为int类型 Boolean类当 String 的参数值在不区分大小写的时候等于 “true” ，则 Boolean.valueOf(String) 返回值为 true； 1234Boolean b1=Boolean.valueOf(&quot;true&quot;);Boolean b2=Boolean.valueOf(&quot;ok&quot;);b1.booleanValue();//将Boolean对象的值以对应的boolean值返回，值为trueb2.booleanValue();//值为false Character类字符大小转小写 1234Character mychar1=Character.valueOf('A');//返回保存指定char值的Character对象Character.isUpperCase(mychar1);//判断是否为大写字母Character.toUpperCase(mychar1);//转为大写Character.toLowerCase(mychar1);//转小写，不改变原来字符串 第12章 集合类1Collection&lt;类名&gt; list=new ArrayList&lt;&gt;();//尖括号只能呢是类，比如不能放int要放integer 遍历集合通过迭代器(Iterator)来实现，只读且向前。可以用foreach，可读可写，但是不能break，除非抛出异常。遍历修改迭代器(ListIterator) 12345678910111213import java.util.*;public class Muster{ public static void main(String args[]){ Collection&lt;String&gt; list=new ArrayList(); list.add(&quot;《Java从入门到精通》&quot;); list.add(&quot;《java实战》&quot;); lterator&lt;Sting&gt; it=list.iterator(); while(it.hasNext()){ String str=(String)it.next(); System.out.printLn(Str); } }} Set集合Set集合传入的Collection对象不能有重复值 1Set&lt;类名&gt; set=new TreeSet&lt;&gt;(); 必须可比较，传入的对象的类必须是包装类(默认字典顺序)或者实现comparable接口的类 问：在定义对象类型时，应该定义为基类或接口的类型，还是派生类的类型？ 创建的时候类型不确定，先定义为基类；或如果定义为接口给别人调用就声明为基类。要专门调用派生类具有的功能直接声明为派生类。 但是定义为基类无法调用子类特有的成员，如subSet()是TresSet特有的，定义为基类时无法调用，除非强制转型为子类。 12Set&lt;Integer&gt; set=new TreeSet&lt;&gt;();TreeSet set2=((TreeSet&lt;Interger&gt;)set.)subSet(3,10); Map类每个对象是键值(&lt;key,value&gt;)的形式，类得可比较 12Map&lt;String,String&gt; map=new HashMap();map.put(&quot;1001&quot;,&quot;java从入门到精通&quot;); 如果key传入的是像Integer，String这样本身有序的，就会按字典序排列，而不是按哈希码。 原理：add()时用hashcode找哈希地址，用equal()看是否有存东西。如果是false就先并排放；若是true说明有了不用重复存。取值的时候找哈希地址，如果存在多个用equal()取具体的那一个。以上哈希码相同的情况为哈希冲突，同一个哈希地址可以存放多个不同对象。 优点：不用全部遍历，找到哈希地址再判断哪个是需要的取出即可。 第13章 枚举类型与泛型将“填空题”变为“选择题” 12345678910111213141516171819202122232425262728//声明为int/String类型方便switch case用//接口interface SeasonInterface{ int Spring=1,SUMMER=2,AUTUMN=3,WINTER=4; //开头隐含的public static final}//枚举enum SeasonEnum{ SPRING,SUMMER,AUTUMN,WINTER}public class SeasonDemo{ public static void printSeason1(int season){ switch(season){ case SeasonInterface.SPRING: System.out.println(&quot;这是春季&quot;); break; case SeasonInterface.SUMMER: System.out.println(&quot;这是夏季&quot;); break; case SeasonInterface.AUTUMN: System.out.println(&quot;这是秋季&quot;); break; case SeasonInterface.WINTER: System.out.println(&quot;这是冬季&quot;); break; } }} 问：接口和枚举如何选择？ 接口一般是给别人来实现，功能可以更强大，如果不需要实现直接用枚举就行。 枚举优点：简单，运行效率高，类型安全 枚举类型中的构造方法在枚举类型中，可以添加构造方法，但是规定这个构造方法必须被private修饰符所修饰。用于提示枚举值更加详细的含义、 泛型向上向下转型123父类 a=new 子类();//向上转型子类 b=(子类)a;//向下转型子类 b=new 父类();//！这是不可行的！ 例子： 1234567891011121314151617public class Test{ private Object b; public Object getB(){ return b; } public void setB(Object b){ this.b=b; } public static void main(String[] args){ Test t=new Test(); t.setB(Boolean.valueOf(true));//向上转型 System.out.println(t.getB()); t.setB(Float.valueOf(&quot;12.3&quot;)); Float f=(Float)t.getB();//向下转型 System.out.println(f); }} 定义泛型类Object类为最上层的类，为了通用通常使传入的值与返回的值都以Object类型为主(Object太大了，不能统统用Object类)。当需要使用这些实例时，必须正确地将该实例转换为原来的类型，否则运行时将会发生ClassCaseException为了预防，Java提供泛型机制： 1类型&lt;T&gt; 高级用法泛型限制对泛型类的实例类型做了限制 12345678public class LimitClass&lt;T extends List&gt;{ public static void main(Stirng[] args){ //可以实例化已经实现List接口的类 LimitClass&lt;ArrayList&gt; l1=new LimitClass&lt;ArrayList&gt;(); //这句是错误的，因为HashMap类没有实现List()接口 LimitClass&lt;HashMap&gt; l3=new LimitClass&lt;HashMap&gt;(); }} &lt;T extends Serializable&gt; 序列化，泛型必须是Serializable的子类，可传Integer或String 泛型通配符123A&lt;?&gt; a;A&lt;? extends anyClass&gt; a;A&lt;?&gt; a= new List&lt;&gt;;//这样是不可以的，实例化需要要具体的类型 第14章 lambda表达式与流处理将lambda表达式用来简化表示匿名函数，也就是没有名字的函数，提高开发效率。 例子： 1234567891011121314//函数式接口interface A{ void action();}//使用匿名类创建对象A a=new A(){ public void action(){ System.out.println(&quot;创建了接口的匿名对象&quot;); }};//使用lambda表达式创建A a=()-&gt;{ System.out.println(&quot;创建了接口的匿名对象&quot;);}; lamba表达式： 1234()-&gt;结果表达式参数-&gt;结果表达式//多形参(参数1,参数2,...,参数n)-&gt;结果表达式 例子： 1234567891011121314151617//函数式接口interface AdditionInterface{ int add(int a,int b);}public class ParamterDemo{ public static void main(String[] args){ //lamba 表达式实现加法接口，返回参数相加的值(自动加return) AdditionInterface np=(x,y)-&gt;x+y; int result=np.add(15,26);//调用接口方法 System.out.println(&quot;相加结果：&quot;+result);//输出相加结果 //而同一个接口可以实现不同的方法,关键在于接口的实现方式 AdditionInterface np2=(a,b)-&gt;a*b; result=np2.add(a,b); System.out.println(&quot;相乘结果：&quot;+result);//输出相乘结果 }} 注意： lamba表达式不能修改局部变量的值，只能使用 方法的引用引用静态方法(复制一个已有的函数实现接口，甚至可以不需要这个已有函数内部是如何实现的) 类名::静态方法名 1234interface StaticMethodInterface{ int method(int a,int b);}public class StaticM Function接口Function&lt;T,R&gt;,T:被操作的类型，可以理解为方法的参数类型；R：操作结果类型，方法的返回类型。 Iterator&lt;T&gt;只读！ ListIterator&lt;T&gt;才能修改list的元素 流处理Stream流只能被消费一次，之后失效 数据过滤12345678910111213//数据转化为流public class FilerDemo{ public static void main(String[] args){ List&lt;Employee&gt; list=Employee.getEmpList(); Stream&lt;Employee&gt; stream=list.stream(); stream=stream.filter(people-&gt;people.getAge()&gt;30);//过滤出符合条件的数据 List&lt;Employee&gt; result=stream.collect(Collectors.toList());//将流对象重新封装成一个List集合 List&lt;Employee&gt; result2=list.stream().filter(p-&gt;p.getDept().equals(&quot;开发部&quot;)).peek(p-&gt;p.setSalary(p.getSalary()*10)).collect(Collect.toList());//过滤得到符合的让其工资翻十倍 for(Employee emp:result){ System.out.println(emp);//输出员工信息 } }} filter(predicate类)用lamba表达式不需要管类型，直接放进去 peek(consumer类型)和map()一个里面不用返回值，一个需要。 collect() 收集重新归类。 第15章 I/O(输入与输出)File类File类是java.io包中唯一代表磁盘文件本身的类。因为是代表磁盘，操作要用try catch语句 三种构造方式： 123File(String pathname)File(String parent,String child)File(File f,String child) 1234File file=new File(&quot;word.txt&quot;)//相对路径，是在项目目录下创建而不是在所在包类,此时是在内存中创建对象try{ file.createNewFile();//这一步才真正在磁盘中创建文件} 除了在内存中的操作，其他都是不保证成功的， 文件输入/输出流文件输入流是从硬盘读取，输出是写到硬盘 FileInputStream与FileOutputStream类是字节流 BufferedReader与BufferedWriter类以行为单位进行输入/输出 读取文件过程： 文件–&gt;InputStream–&gt;InputStreamReader–&gt;BufferedReader–&gt;字符数据 在使用BufferedWriter类的Writer()方法时，数据首先进入缓存区，没有立刻被写入输出流。如果想立即讲缓存区中的数据写入输出流，一定要调用flush() 1BufferedReader br = new BufferedReader(new FileReader(file));//缓存输入流 第16章 反射与注释实现访问、检测和修改描述Java对象本身信息的功能。 getCLass()是Object类定义的，任何类都可以用，获取类信息 12345678910Class newC=hashSet.getClass();//获取hashSet的描述信息，假设hashSet是一本书，那newC是书的目录，作者等等基本信息但不包括内容//查构造方法Constructor[] constructors=mewC.getDeclaredConstructor;for(Constructor constructor:constructors){ System.out.println(constructor);//找到构造函数foreach遍历显示}declarednewC=newC.getDeclaredConstructors(); 1234Field[] declaredFields=demClass.getDeclaredFields(); for(Field field:declaredFields) { System.out.println(field); } 1234567891011121314151617181920212223242526272829//查成员方法 用户输入参数Method[] declaredMethods=demClass.getDeclaredMethods(); for(Method method:declaredMethods) { System.out.println(method); } Scanner scanner=new Scanner(System.in); String key=scanner.next(); for(Method method:declaredMethods) { if(key.equals(&quot;size&quot;)&amp;&amp;key.equals(method.getName())) { try { System.out.println(method.invoke(hashSet)); } catch (Exception e) { e.printStackTrace(); } } if (key.equals(&quot;add&quot;) &amp;&amp; key.equals(method.getName())) {//作判断才知道用户要做那个 String addString = scanner.next(); try { System.out.println(method.invoke(hashSet, addString)); for (String hash : hashSet) { System.out.print(hash+&quot; &quot;); } } catch (Exception e) { e.printStackTrace(); } } } scanner.close();","link":"/2022/09/29/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"C++语言程序设计","text":"第一章 绪论 机器语言与汇编语言 由计算机硬件系统可以识别的二进制指令组成的语言称为机器语言。 汇编语言将机器指令映射为一些可以被人读懂的助记符，如ADD、SUB等。 高级语言 高级语言屏蔽了机器的细节，提高了语言的抽象层次，程序中可以采用具有一定含义的数据命名和容易理解的执行语句。这使得在书写程序时可以联系到程序所描述的具体事物。 面向对象的语言 出发点：更直接地描述客观世界中存在的事物(对象)以及它们之间的关系。 特点： 是高级语言。 将客观事物看作具有属性和行为的对象 通过抽象找出同一类对象的共同属性和行为，形成类。 通过类的继承与多态实现代码重用 优点：使程序能够比较直接地反映问题域的本来面目，软件开发人员能够利用人类认识事物所采用的一般思维方法来进行软件开发。 面向对象的方法 将数据及对数据的操作方法封装在一起，作为一个相互依存、不可分离的整体——对象。 对同类型对象抽象出其共性，形成类。 类通过一个简单的外部接口，与外界发生关系。 对象与对象之间通过消息进行通信。 计算机中的信息 数据信息——计算机程序加工的对象 控制信息——指挥计算机操作 信息的存储单位 位(bit，b)：度量数据的最小单位，表示一位二进制信息。 字节(byte，B)：由八位二进制数字组成(1 byte = 8 bit)。 千字节 1 KB = 1024 B 兆字节 1 MB = 1024 K 吉字节 1 GB = 1024 M 进制转换 第二章 C++简单程序设计I/O流 在C++中，将数据从一个对象到另一个对象的流动抽象为“流”。流在使用前要被建立，使用后要被删除。 从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。 数据的输入与输出是通过I/O流来实现的，cin和cout是预定义的流类对象。cin用来处理标准输入，即键盘输入。cout用来处理标准输出，即屏幕输出。 第三章 函数static_cast是一个强制类型转换操作符 12double a = 1.999;int b = static_cast&lt;double&gt;(a); //相当于a = b ; 函数的声明的实现123void func(int);//函数的声明，可以没有形参名，没有大括号void func(int){}//函数的实现必须要有{}，类构造函数用初始化列表容易忘加{} 函数的参数传递 在函数被调用时才分配形参的存储单元 实参可以是常量、变量或表达式 实参类型必须与形参相符或可隐式转换为形参类型 值传递传递参数值，即单向传递 引用传递可以实现双向传递 常引用作参数可以保障实参数据的安全 内联函数 声明时用关键字 inline 规模小、功能简单使用频繁的函数。编译时在调用处嵌入函数体，节省了参数传递、控制转移等开销 注意 内联函数体内不能有循环语句和switch语句 内联函数的定义必须出现在内联函数第一次被调用之前 对内联函数不能进行异常接口声明 函数高级1.默认参数 默认参数，如果我们自己传入数据，就用自己的数据，如果没有，那么用默认值。 注意事项： 有默认参数的要放在最后面。int fun(int a,int b,int d=1){}; 如果函数声明有默认参数，函数实现就不能有默认参数。因为声明时已经定义过了，两个有就冲突了。声明和实现只能有一个有默认参数 2.占位参数返回值参数 函数名(数据类型){} void func(int a, int);后面的int就是占位参数，只有传两个才能正常执行。 占位参数也能有默认默认参数，这时候就可以不传这个占位参数了。 3.函数重载作用：函数名可以相同，提高复用性 满足条件 同一作用域下 函数名称相同 函数参数类型不同 或者 个数不同 或a 顺序不同 对返回值没有规定 123456int sumOfSquare(int a,int b){ return a*a+b*b;}double sumOfSquare(double a,double b){ return a*a+b*b;} 注意： 函数的返回值和形参名不可以作为函数重载的条件 函数重载碰到默认参数会出现二义性，尽量避免这种情况。 引用 引用相当于给变量取别名。语法：数据类型 &amp;别名=原名; 引用声明时就必须初始化，int &amp;c;是错误的 在声明一个饮用后，不能再使之作为另一变量的引用（指向不可修改） 引用作为重载的条件。 通过引用参数产生的效果同按地址传递是一样的，引用的语法更加清楚简单，简化指针修改实参。 123456789101112131415161718//指针作参数void swap1(int *a,int *b){ int temp=*a; *a=*b; *b=temp;}//引用作参数void swap2(int &amp;a,int &amp;b){ int temp=a; a=b; b=temp;}int main(){ int a=10; int b=20; swap1(&amp;a,&amp;b);//指针参数函数的调用，地址传递 swap2(a,b);//引用传递} void func(int &amp; a);void func(const int &amp; a);当func(a)时走第一个，当func(10)走第二个。const是只读状态，相当于创建块区域，然后引用的指向它。注意int &amp;a=10;是不合法的，10是一个常量，故不会走第一个。 1234567891011121314151617181920212223// 声明简单的变量 int i; double d; // 声明引用变量 int&amp; r = i; double&amp; s = d; i = 5; cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r &lt;&lt; endl; d = 11.7; cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s &lt;&lt; endl; return 0; 结果： 1234Value of i : 5Value of i reference :5Value of d : 11.7Value of d reference :11.7 引用做函数的返回值 不要返回局部变量的引用 函数的调用可以作为左值存在 12345678910int &amp; test02(){ static int a=10;//一定要加static关键字，表示静态变量，存放在全局区，全局区上的数据在程序结束后系统释放。 //如果是int a;那就是返回局部变量的引用了 return a;}int main(){ int &amp;ref=test02();//ref结果为10，ref是a的别名 test02=1000;//函数的调用作为左值做赋值操作，看成是a的别名，此时ref的结果变为1000 return 0;} 第四章 类和对象类和对象C++面向对象的三大特性为：封装、继承、多态。万事万物都皆为对象，对象上有其属性和行为 具有相同性质的对象，我们可以抽象为类。 封装 class代表设计一个类，类后面紧跟着的是类的名称 1234567891011121314151617181920class Circle{//访问权限public: //属性：半径int m_r;//行为：获取圆的周长 double caculate(){//这里的行为是个函数 double c=PI*m_r*2; return c; }} 实例化：通过类创建一个具体对象。通过”.”来访问，可以给属性赋值 12345Circle p1;//和结构体类似p1.m_r=3;//赋值半径cout&lt;&lt;p1.caculate();//输出周长 类中的属性和行为统称为 成员。属性： 成员属性/成员变量。行为： 成员函数/成员方法。 访问权限: 公共权限 public 成员 类内(class大括号内)可以访问 类外也可以访问 保护权限 protected 成员 类内可以访问 类外不可以访问 儿子可以访问父亲的保护内容 私有权限 private 成员 类内可以访问 类外不可以访问 儿子不可以访问父亲的私有内容 struct和class区别 唯一区别：默认的访问权限不同。struct 默认是公共public，class默认是私有private 建议成员属性设置为私有。 原因：1.可以自己控制读写权限 2.对于写可以检测数据的有效性 可以通过public里的行为对private里的属性进行修改，实现只读、可读可写、只写。 读 12345string getlover(){return m_lover;} 写： 12345void setlover(string lover){m_lover=lover} 检测有效性: 123456789101112131415//经过检测才能修改到，不至于直接修改private的属性造成麻烦void setAge(int age){if(age&gt;=150||age&lt;=0){m_age=0;cout&lt;&lt;&quot;年龄有问题&quot;;return;} 在类中可以让另一个类作为 本类中的成员 作用域::成员函数 类的声明.h,需要#pragma once 和#include&lt;iostream&gt;和using namepace,如果这个类中还用到另一个类，需要引用另一类的头文件然后加作用域 。 类的实现.cpp需要#include &quot;_.h&quot;以及在函数名前加作用域，不需要外部的class和public和private的属性。 对象特性 构造函数(对象初始化)和析构函数(对象清理) 构造函数和析构函数构造函数语法：类名(){} 构造函数，没有返回值也不写void 函数名称与类名相同 构造函数可以有参数，因此可以发生重载 程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次 析构函数语法：~类名(){} 析构函数，没有返回值也不写void 函数名称与类名相同，在名称前加符号~ 析构函数不可以有参数，因此不可以发生重载 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次 以上两个都是必须有的实现，如果不提供，编译器会提供，不过是空实现。 构造函数的分类及调用 两种分类方法 按照参数分类 无参构造（默认构造，编译器提供的）和有参构造 按照类型分类 普通构造和复制构造函数 复制构造函数写法 123Person(const Person &amp;p){//将传入的人身上的属性复制到我身上；} 三种调用方法​ 1.括号法 Person p1; //默认构造函数调用 Person p2(10); // 有参构造函数 Person p3(p2); //拷贝构造函数 注意事项1：默认构造函数调用时不要加(),编译器会误认为函数的声明 ​ 2.显示法 Person p1;//不需要加括号写成Person p1() Person p2 = Person(10); //有参构造 Person p3 = Person(p2); //拷贝构造 person(10); //是匿名对象 特点:当前行执行结束后，系统会立即回收匿名对象 注意事项2：不要利用拷贝构造函数 初始化匿名对象，如person(p3);编译器会识别出person p3; ​ 3.隐式转换法，直接写 123Person p4 = 10; //相当于写了 Person p4 = Person(10); Person p5 = p4; //拷贝构造 拷贝构造函数的调用时机1.使用一个已经创建完毕的对象来初始化一个新对象 123Person p1;Person p2(p1); ​ 2.值传递的方式给函数传值 1void fun1(Person p){} 3.以值方式返回局部对象 1234567Person doword(){Person p1;return p1;} 构造函数的调用规则默认情况下，编译器至少给一个类添加三个函数 默认构造函数（无参，函数体为空） 默认析构函数（无参，函数体为空） 默认拷贝构造函数，对属性进行值拷贝 如果写了有参构造函数，编译器就不提供默认构造，但仍提供拷贝构造 如果写了拷贝构造函数，编译器就不提供其他函数 归纳1234567891011121314151617181920212223242526//构造函数 可分为无参构造（默认构造）和有参构造;或者分成普通构造和拷贝构造Class Clock{public: Clock();//默认构造函数的声明，不用加{} Clock(int newH,int newM,int newS);//构造函数的声明 Clock(Clock &amp;c1);//复制构造函数的声明 ~Clock(){}//析构函数private: int hour,minute,second; };Clock::Clock():hour(0),minutes(0),second(0){}//默认构造函数的实现Clock::Clock(int newH,int newM,int newS):hour(newH),minute(newM),second(newS){}//构造函数的声明Clock::Clock(Clock &amp;c1){//复制构造函数的实现 hour=c1.hour; minute=c1.minute; second=c1.second;}int main(){ Clock c;//调用无参数的构造函数即默认构造，且设置初始化为(0,0,0) Clock c1(21,10,10);//调用有参数的构造函数 Clock c2(c1);//调用复制构造函数 //程序结束前会执行析构函数 return 0;} 构造与析构顺序123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;class A{public: A(){ cout&lt;&lt;&quot;A类的构造函数调用&quot;&lt;&lt;endl; }; ~A(){ cout&lt;&lt;&quot;A类的析构函数调用&quot;&lt;&lt;endl; }};class B{public: B(){ cout&lt;&lt;&quot;B类的构造函数调用&quot;&lt;&lt;endl; } A a;//B类的成员是另一个类的对象，称为对象成员 ~B(){ cout&lt;&lt;&quot;B类的析构函数调用&quot;&lt;&lt;endl; }};int main(){ B b;}//结果/*A类的构造函数调用B类的构造函数调用B类的析构函数调用A类的析构函数调用*/ B类中有对象A作为成员，A为对象成员 当创建B对象是，会先调用对象成员A的构造函数，再调用B的构造函数 而析构顺序相反，先析构B再析构A，所谓先构造后析构，后构造先析构 深拷贝与浅拷贝浅拷贝：编译器的默认的简单的复制拷贝操作 深拷贝：在堆区重新申请空间(new)，进行拷贝操作 浅拷贝的问题（类中有指针，释放的时候同一块地方被两个类释放两次，非法）要用深拷贝解决 1234567891011//拷贝函数Person(const Person &amp;p){ m_Age=age; m_Height=new int(*p.m_Height)} 如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题 初始化列表 作用：初始化属性 语法：构造函数():属性1(值1),…{ } 类对象作为类成员 暂时用列表传参 C++运算符的重载 运算符重载的概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型 加法运算符的重载 第五章 数据的共享与保护作用域局部作用域 对象生存期静态生存期 这种生存期与程序的运行期相同 在文件作用域中声明的对象具有这种生存期 在函数内部声明静态生存期对象，要冠以关键字static 动态生存期 在局部作用域中声明的具有动态生存期的对象，习惯上也被称为局部生存期对象 局部生存期对象诞生于声明点，结束于声明所在的块执行完毕之时 常对象常对象必须进行初始化，且不能被更新 语法：const 类型说明符 对象名; 1234567class A{ ...}const A a(3,4);//a是常对象，不能被更新const int n=10;//正确，用10对常量n进行初始化n=20;//错误，不能对常量赋值 用const修饰的类成员常成员函数声明格式：类型说明符 函数名(参数表)const; 注意： 函数定义的时候也要加上const 常成员函数调用期间不能更新(修改)对象的数据成员，也不能常成员函数中调用没有用const修饰的成员函数 常数据成员使用const说明的数据成员为常数据成员，初始化后不能修改。构造函数对该数据成员进行初始化就只能通过初始化列表 1234567891011class A{public: A(int i);private: const int a;//常数据成员 static const int b;//静态常数据成员 }const int A::b=10;//静态常数据成员在类外说明和初始化//常数据成员只能通过初始化列表来获得初值A::A(int i):a(i){} 常引用12int &amp;a=b;//相当于int*const a=b，指向不可改变，指针常量const int &amp;a=b;//常引用，相当于const int * const a=b,指向的空间不可修改 使得引用的对象只读，不能通过a来改变b的值 静态变量与静态函数（存在于全局，并不属于特定的哪个对象）静态数据成员静态数据成员：使得一个类的所有对象具有相同的属性，对于任何对象实例，它的属性值相同，不属于任何一个对象。(具体看例子) 注意： 由于静态数据成员不属于任何一个对象，因此可以通过类名对他访问，一般用法：类名::标识符 静态数据成员需要在类定义之外再加以定义。原因：以此来专门为它们分配空间。非静态数据成员无须，因为他们的空间是与他们所属对象的空间同时分配的 12345678910111213141516171819202122class Point{public: Point(int x=0,int y=0):x(x),y(y){//构造函数 //在构造函数中对count累加，所有对象共同维护同一个count } Point(Point &amp;p){ x=p.x; y=p.y; count++; } ~Point(){count--;} int getX(){return x;} int getY(){return y;} void showCount(){//输出静态数据成员 cout&lt;&lt;&quot; Object count=&quot;&lt;&lt;count&lt;&lt;endl; }private: int x,y; static int count;//静态数据成员声明，用于记录点的个数}int Point::count=0;//静态数据成员定义和初始化，使用类名限定 创建不同Point类对象a和b可以分别调用showCount函数输出同一个count在不同时刻的数值，实现了a,b之间直接的数据共享。 静态函数成员 静态成员函数可以访问静态成员变量 静态成员函数不可以访问非静态成员变量 ，无法区分到底是哪个对象的 访问可以通过成员也可以通过类名Person::func();这样就不需要创建一个对象然后通过对象的成员函数来访问成员了。 在静态成员函数中没有this指针，因为它属于整个类而不是具体的哪个对象，this指向的是具体的对象 12345678910111213//上面的例子做些修改class Point{public: ... static void showCount(){//金泰成员函数 ... }}int main(){ Point a(1,3); Point b(a); Point::showCount();//这是想要输出count直接类名访问，因为当为非静态时，a.showCount()和b.showCount()是一个意思} 成员变量 和 成员函数 是分开存储的 空对象占用的内存空间为1字节，为了区分不同的空对象占用的空间 非静态成员变量 属于类的对象上，而静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上。 123456789101112131415161718192021class Person{};class Phone{int price;//void func();//static int p;};Person p1;Phone pp1;sizeof(p1);----1sizeof(pp1);---4 //就算里面有func和static，sizeof(pp1)都是int的4 this指针 this指针概念 成员函数和成员变量分开存储，每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码，那么这一块代码是如何区分是哪个对象调用自己呢？ this指针指向被调用的成员函数所属的对象不需要定义，直接用 解决名称冲突 1234567Person(int age){//age=age;编译器不知道哪个是哪个this-&gt;age=age;} 返回对象本身用return *this 空指针调用成员函数.如果要用的话，成员函数里面不能有属性，否则报错，因为传入空指针，this是NULL，或者是成员函数里前面加个 12if(this==NULL) return; const修饰成员函数this指针本质是一个指针常量，不能修改指向 ： 12Person * const this;//指向不能改。const Person * const this;//指向不能改，指向的内容也不能改。 常函数 12345void showp() const{} 成员函数后加const称为常函数 常函数内不可修改成员属性 在成员函数后面加const修饰的是this指针，让指针指向的值也不能改，相当于这个函数加了const就是承诺不修改this指向的属性。 mutable int m_B;加上关键字mutable就是特殊变量，在常函数中可以修改 常对象 1const Person p;//在对象前加const，变为常对象，一般的成员变量不能改 同理加了mutable就可以改 常对象只能调用常函数,防止你用常对象调用普通函数来修改里面的属性 常数据成员 常数据成员只能通过初始化列表来获得初值 1234567891011class A{ public: A(int i);private: const a;}A::A(int i):a(i){} 常引用：即只读状态 1void dist(const Point &amp;a); const型数据小结 形式 含义 Point const t1 t1是常对象，其值在任何情况下都不能改变 void Point::func() const func()是Point类中的常成员函数，可以引用，但不能修改成员 Point * const p p是指向Point类对象的常指针，p的值不能改变，即指向不能变 const Point *p p是指向Point类常对象的指针，其指向的类对象的值不能通过指针来改变 Point &amp;t1=t; t1是Point类对象t的引用，二者指向同一段内存空间 友元让一个函数或者类访问另一个类中私有成员和保护成员 注意: 友元的关系是单向的而不是双向的 友元的关系不能传递 全局函数作右元 12345678910class Room{friend void visit(Room &amp;room);//相当于把函数声明放到类里头开头加上friend，结尾加&quot;;&quot;}void visti(Room &amp;room){//全局函数的实现} 类做友元 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Building;class goodgay {//做友元public: goodGay(); void visit;private: Building *building;};class Building {//告诉编译器 goodgay类是Building类的好朋友，可以访问到Building类中私有内容friend class goodGay;public: Building();public: string m_SittingRoom;//客厅private: string m_BedRoom;};Building::Building() { this-&gt;m_SittingRoom = &quot;客厅&quot;; this-&gt;m_BedRoom = &quot;卧室&quot;;}goodGay::goodGay() { building = new Building;}void goodGay::visit() { cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl; cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;}void test01() {} 另一个类的成员函数做友元 实操经验：如果是一个A类的成员变量想做B类的友元，那么B类里要声明友元，格式 :friend 函数类型 A::函数名(); 同时，B类的声明要放在A类之后，否则编译器找不到A::函数名()这个东西 friend声明友元函数，友元函数却依旧无法访问该类的私有属性”的解决一次C++作业题, 搞了很久弄明白了, 虽然成功了, 但VS2015依旧有红线提示错误, 不过不影响编译、运行, 这似乎是VS自身的一个BUG。解决：友元类方法小结： 包含声明”friend”的类，必须在((包含其声明的友元函数)的那个类)之前事先声明下————因为在Employer类中用到”Employee&amp;”,不然无法访问该引用的私有成员。 被声明为友元的函数，必须在类内声明，然后在将其声明为友元函数的类的后面定义。 还有一个我个人犯的低级错误——在声明友元函数时，忘记加该函数的作用域了。。。 作业代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940 #include &lt; iostream &gt; #include &lt; string &gt;using namespace std;class Employee;//先声明，因为在Employer中会用到，否则不给友元函数访问Employer的私有class Employer{public: Employer(string a) { Name = a; }; void editEmployee(Employee &amp; person, double salary, string post);private: string Name;};class Employee {public:Employee(int a, string b, double c, string d) { ID = a; Name = b; Salary = c; Post = d;} friend void Employer::editEmployee(Employee &amp; person, double salary, string post); void printInf() { cout &lt;&lt; &quot;ID:&quot; &lt;&lt; ID &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Name:&quot; &lt;&lt; Name &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Salary:&quot; &lt;&lt; Salary &lt;&lt; &quot;\\t&quot; &lt;&lt; &quot;Post:&quot; &lt;&lt; Post &lt;&lt; endl; }protected:private: int ID; string Name; double Salary; string Post;};void Employer::editEmployee(Employee &amp; person, double salary, string post) { person.Salary = salary; person.Post = post;}; 第六章 数组 指针与字符串数组是具有一定顺序关系的若干相同类型变量的集合体，组成数组的变量称为该数组的元素。 数组二维数组初始化 将所有初值写在一个{}内，按顺序初始化 例如：static int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; 分行列出二维数组元素的初值 例如：static int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; 可以只对部分元素初始化 例如：static int a[3][4]={{1},{0,6},{0,0,11}}; 列出全部初始值时，第1维下标个数可以省略 例如：static int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12};或：static int a[][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; 注： 如果不作任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0 如果只对部分元素初始化，剩下的未显式初始化的元素，将自动被初始化为零 对象数组初始化1Point a[2]={Point(1,2),Point(3,4)}; 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象 元素所属的类不声明构造函数，则采用默认构造函数。 当数组中每一个对象被删除时，系统都要调用一次析构函数。 指针内存空间的访问方式 通过变量名访问 通过地址访问 指针的概念 指针：内存地址，用于间接访问内存单元 指针变量：用于存放地址的变量 指针名=地址 C++11使用nullptr关键字，是表达更准确，类型安全的空指针 指向常量的指针和指针类型的常量指向常量的指针（常指针）声明时const在最前面。不能通过指针来改变指向对象的值，但是指针本身指向可以改变 123456int a;const int *p1 = &amp;a; //p1是指向常量的指针int b;p1 = &amp;b; //正确，p1本身的值可以改变*p1 = 1; //编译时出错，不能通过p1改变所指的对象 指针类型的常量（指针常量）const在*后，指向不可改变。 1234int a;int * const p2 = &amp;a; int b;p2 = &amp;b; //错误，p2是指针常量，值不能改变 指针类型的算术运算 指针p加上或减去n 其意义是指针当前指向位置的前方或后方第n个数据的起始位置。 指针的++、–运算 意义是指向下一个或前一个完整数据的起始。 运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置。 当指针指向连续存储的同类型数据时，指针与整数的加减和自增自减算才有意义。 指针与数组指针名加了整数再用*解引用得到所指对象的值。 定义指向数组元素的指针 定义与赋值 1234int a[10], *pa;pa=&amp;a[0]; //或 pa=a;数组名a地址也是数组第一个元素a[0]的地址*pa就是a[0]，*(pa+1)就是a[1]，... ，*(pa+i)就是a[i].a[i], *(pa+i), *(a+i), pa[i]都是等效的。 注意：不能写 a++，数组名不能自加自减，因为a是数组首地址、是常量。 字符串字符数组用于存放字符串的数组其元素个数应该不小于字符串的长度(即字符个数)加1，因为要在末尾放置一个’\\0’。 1234567char str[8]={'p','r','o','g','r','a','m'};char str[8]=&quot;program&quot;;char str[]=&quot;program&quot;;//这三种写法等价char s1[3]=&quot;xyz&quot;;//错误！char s2[2][3]={&quot;xyz&quot;,&quot;mnp&quot;};//错误！char s3[][3]={'a','x','y'};//正确 动态内存分配目的：保证程序在运行过程中按照实际需要申请适量的内存，使用结束后还可以释放。 在C++程序中建立和删除堆对象使用两个运算符，new和delete new new的功能是动态分配内存，语法：new 数据类型 (初始化参数列表) 创建一维数组：new 类型名 [数组长度]; 如果内存申请成功，new运算便返回一个指向新分配内存首地址的类型的指针，可以通过这个指针对堆对象进行访问 new T和new T()效果相同，都会调用这个默认构造函数 12345678int *point;point=new int(2);//初值设置为int *point=new int;//不设置初值，直接去括号int *point=new ();//括号里不写，表示用0初始化int *p=new int[10]();//用0初始化数组 delete 释放指针所指向的内存空间，语法：delete 指针名; 删除数组要在指针名前面加”[]”：delete []指针名; 如果是对象，会调用对象的析构函数 对于用new建立的对象只能执行一次delete删除操作 12delete point;delete []p;//一定是指针名，根据指针，去找对应地址的内存空间 内存四区代码区 全局区 栈区 堆区 c++中在程序运行前分为全局区和代码区 代码区 特点是共享和只读。共享目的是对于频繁被执行的程序只需要保存一份代码即可 全局区 全局变量、静态变量、字符串常量、const修饰的全局变量存放在全局区 局部修饰的都不在全局区里 常量分为字符串常量和const修饰的变量，const修饰的变量有全局也有局部 栈区 有编译器自动分配释放，存放函数的参数值、局部变量等 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放 堆区 由程序员分配释放，程序结束时由操作系统回收 在c++中用关键字new将数据开辟到堆区，返回值是地址，如 new int(10),将10放到堆区里，可指针接。在程序运行时，10一直存在。 释放利用delete指向该区域的指针。 12int *p=new int(10);delete p; 常见一个数组用中括号:int *arr=new int[10]; 上面的()表示只有一个元素 释放 delete[] arr; 第七章 类的继承基类和派生类1234567891011graph TD; 交通工具--&gt;火车 交通工具--&gt;汽车 交通工具--&gt;飞机 交通工具--&gt;轮船 汽车--&gt;卡车 汽车--&gt;旅行车 汽车--&gt;小汽车 小汽车--&gt;工具车 小汽车--&gt;轿车 小汽车--&gt;面包车 从已有类产生新类的过程就叫类的派生 派生类(子类)包含了基类(父类)特征，同时可以加入自己所特有的新特征 一个派生类同时有多个基类的情况称为多继承(有多个爹)，只有一个直接基类叫做单继承 在类族中，直接参与派生出某类的基类称为直接基类(爸爸辈)，跨层的基类称为间接基类(爷爷辈及以上)。如图中汽车是卡车、旅行车、小汽车的直接基类，而交通工具是旅行车的间接基类 派生类构造函数和析构函数构造函数例题 1234567891011121314151617181920212223242526272829//例7-4.cpp#include&lt;iostream&gt;using namespace std;class Base1 {//基类Base1,构造函数有参数public: Base1(int i) { cout &lt;&lt; &quot;Constructing Base1 &quot; &lt;&lt; i &lt;&lt; endl; }};class Base2 {//基类Base2,构造函数有参数public: Base2(int j) { cout &lt;&lt; &quot;Constructing Base2 &quot; &lt;&lt; j &lt;&lt; endl; }};class Base3 {//基类Base3,构造函数有参数public: Base3() { cout &lt;&lt; &quot;Constructing Base3 * &quot; &lt;&lt;endl; }};class Derived :public Base2, public Base1, public Base3 {//派生新类Derived，注意基类名的顺序public: Derived(int a,int b,int c,int d):Base1(a),member2(d),member1(c),Base2(b){}//注意基类名的个体与顺序，注意成员对象名的个体与顺序private://派生类的私有成员对象 Base1 member1; Base2 member2; Base3 member3;};int main() { Derived obj(1, 2, 3, 4); return 0;} 输出结果 构造函数的调用顺序：先调用基类的构造函数，然后调用内嵌对象的构造函数 ①基类构造函数的调用顺序是按照派生类定义时继承的顺序，如例题 123class Derived :public Base2, public Base1, public Base3{ ...} 因此是先Base2,再Base1,最后Base3. ②而内嵌对象的构造函数调用顺序应该是按照成员在类中声明的顺序 1234private://派生类的私有成员对象 Base1 member1; Base2 member2; Base3 member3; 应该是先Base1,再Base2,最后Base3. 因此结果顺序是2-1-3-1-2-3 析构函数语法：~类名(){} 析构函数不接受任何参数 如果不显式说明，系统会自动生成 上个例题的析构结果是： 析构函数顺序和构造函数是严格相反的，因此会先对派生类新增的类类型的成员对象进行清理，最后对所有从基类继承来的成员进行清理 三种继承方式 公有继承，基类的公有和保护成员的访问属性在派生类中不变，私有的在类外无法直接访问 私有继承，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问。经过多轮私有继承之后，所有的基类成员都成为派生类的私有成员或不可直接访问成员，基类的成员无法发挥作用，相当于终止了派生，使用较少 保护继承，基类中的公有成员和保护成员都以保护成员身份出现在派生类中，而基类的私有成员不可直接访问。派生类的其他成员就可以直接访问从基类继承来的公有和保护成员，但在类外部通过派生类无法直接访问它们。与私有继承差别就是基类的保护成员可能被它的派生类访问(不至于无法发挥作用)，同时保证其绝对不可能被其他外部使用者访问。(某些需要被保护起来的成员对子孙有用时可以被用到) 类型兼容规则 派生类的对象可以隐含转换为基类对象，即可以用派生类对象赋值给基类对象。 派生类的对象可以初始化基类的引用 派生类的指针可以隐含转换为基类的指针 以上称为向上转型。 不要重新定义同名的非虚函数，因为此时派生类调用重新定义的非虚函数时都只能访问到从基类继承来的那个最原始的成员。 不能被继承C++中，不能被派生类继承的是： 构造函数 私有继承调用基类123456789101112131415161718192021222324252627282930313233343536373839404142//7-8.cpp#include&lt;iostream&gt;using namespace std;class Base {public: Base():x(0),y(0){} void initBase(int x,int y){ this-&gt;x = x; this-&gt;y = y;//需要加this不然分不清 } void fun1() { cout &lt;&lt; x &lt;&lt; endl; } void fun2() { cout &lt;&lt; y &lt;&lt; endl; }private: int x, y;};class Derived :private Base {//私有继承public: Derived() {} void initDerived(int x, int y) { initBase(x, y);//通过成员函数调用基类成员 } void getX() { fun1(); } void getY() { fun2(); }};int main() { Derived son; son.initDerived(3, 4); cout &lt;&lt; &quot;调用基类的fun1()返回的到x值：&quot;; son.getX(); cout &lt;&lt; &quot;调用基类的fun2()返回的到y值：&quot;; son.getY(); return 0;} 派生类成员的标识与访问作用域分辨符当某派生类的多个基类拥有同名的成员时，调用同名成员必须通过基类名和作用域分辨符“:”来标识成员 123456789101112int main(){ Derived d; Derived *p=&amp;d; d.Base1::var=2;//作用域分辨符在同名成员前加 d.Base1::fun(); p-&gt;Base2::var=1;//作用域分辨符在同名成员前加 p-&gt;Base2::fun(); return 0;} 虚基类 virtual同名的数据成员在内存中拥有多个副本，需要使用作用域分辨符来唯一标识并访问它们。将共同基类设置为虚基类，这时从不同的路径继承过来的同名数据成员在内存中就只有一个，同一个函数名也只有一个映射，避免冗余。 语法形式：class 派生类名：virtual 继承方式 基类名 上述语句声明基类为派生类的虚基类，一起维护同一个内存数据 在类Derived中d.Base1::var0和d.Base2::var0是一个对象，造成冗余 虚继承： 123456class Base1: virtual public Base0{//类Base1是类Base0的公有派生类，Base0是Base1的虚基类 };class Base2: virtual public Base0{ }; 因此访问呢只需d.var0 最远派生类就是最年轻的那个子孙，后面没有再派生了 最远基类最老的那个基类 虚基类及其派生类构造函数 如果最远虚基类中没有默认构造但是有有参构造，那么它的每一个子孙都必须在构造函数的成员初始化列表中为最远虚基类的构造函数列出参数。如果未列出表示调用虚基类默认构造函数，又因为没定义，所以会报错 如果最远派生类构造函数调用虚基类的构造函数，那么其他类对虚基类构造函数的调用将被忽略 例： 注意：如果不可预估此基类会派生多少子类，那没必要用虚继承。同时多继承非必要不使用，来避免冗余。 第八章 多态性多态：指同样的消息被不同类型的对象接收时导致不同的行为，即调用了不同的函数 多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数 多态分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名 动态多态：派生类和虚函数实现运行时多态 虚函数什么是虚函数？ 在基类用virtual声明成员函数为虚函数 虚函数的作用： 虚函数的作用是允许在派生类中重新定义与基类同名的函数(且能同时存在)，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。 而对于派生类的同名函数来说，它覆盖了继承来的基类的同名函数，发挥自己的功能，解决了在第七章类型兼容规则中的问题 使用方法： 基类声明成员函数前加关键字virtual，实现时不用加virtual 在派生类中重新定义此函数，要求函数名、函数类型、函数参数个数和类型全部与基类的虚函数相同，并根据派生类的需要重新定义函数体 C++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都 自动成为虚函数，可以不加virtual 上面例题是想通过基类的指针指向派生类的对象，并访问某个与基类同名的成员，那么首先在虚类中将这个同名函数说明为虚函数。 多态满足的条件： 有继承关系 子类重写父类中的虚函数 初识虚函数 用virtual 关键字说明的函数 动态绑定的函数 不能是内联，要在类外实现，因为对内联函数的处理是静态的 虚表 在Derived中新定义了f(),会覆盖Base::f,其实就是重新开一个新函数；**没有定义g()来覆盖基类，故在虚表中查找g()会指向基类的g()**。 virtual关键字 如果基类函数是虚函数，派生类有同名的函数，默认为虚函数可以不用加virtual,自动覆盖基类同名函数。 想要覆盖基类同名函数，习惯添加virtual，增加可读性 哪些成员函数可以是虚函数 一般非静态成员函数可以是 构造函数不具有多态功能，不能是 析构函数可以是 纯虚函数纯虚函数是在声明虚函数是被“初始化”为0的函数，没有定义具体的操作内容，甚至没有函数体。要求各派生类根据实际需要定义自己的版本。声明格式 1virtual 函数类型 函数名(参数表) = 0; 纯虚函数没有函数体，不需要实现，即没有{} 最后面的=0并不表示函数返回值为0，它只是告诉编译器这是纯虚函数 用途是当基类不知道或者不需要这个函数有具体的意义无法实现但是派生类可以进行实现 抽象类带有纯虚函数的类是抽象类。有函数但是不实现。用于初步设计，信息抽象暂时不实现。 抽象类只能是基类 1234class 类名{ virtual 类型 函数名(参数表)=0; //其他成员...} 凡是包含纯虚函数的类都是抽象类 一个基类如果包含一个或一个以上纯虚函数，就是抽象基类 抽象类不能实例化，即不能定义一个抽象类的对象 运算符重载c++中有以下五个运算符不能重载 成员访问运算符 成员指针访问运算符 域运算符 长度运算符 条件运算符 . .* :: sizeof ?： 重载运算符规则： 重载不能改变运算符运算对象(即操作数)的个数 重载不能改变运算符的优先级别 重载不能改变运算符的结合性 重载运算符的函数不能有默认的参数，否则就改变了运算符参数的个数，与1矛盾 重载运算符必须和用户定义的自定义类型的对象一起使用，其参数至少应有一个是类对象。也就是说，参数不能全部是C++的标准类型，以防止用户修改用于标准类型数据的运算符的性质 运算符重载函数可以是类的成员函数，也可以是类的友元函数，还可以是既非类的成员函数也不是友元函数的普通函数。 单目运算符 当使用重载运算符c1+c2就相当于是c1.operator+(c2),重载+左操作数就是本类。 双目目标：经过重载后，相当于oprd1.operator 运算符(oprd2),oprd1要是随意的一个类而不像单目那样是本类。 重载++，– 前置单目运算符，重载函数没有形参 后置运算符，重载函数需要一个int形参（为了区分，加一个形参） 编译器编译成oprd.operator ++ (0) 前置运算符重载函数类型是引用，返回的是*this 后置运算符重载函数类型是类，返回值是一个局部类变量。如果此时函数类型错写成引用，试想一下引用指向的是一个即将消亡的局部变量…… 第九章 模板与全体数据模板函数模板函数体是一样的，定义形式 1234template&lt;模板参数类型&gt;类型名 函数名(参数表){ 函数体的定义} template，声明创建模板 typename，表明其后面的符号是一种数据类型，可以用class代替 T，通用的数据类型，名称可以替换，通常为大写字母 编译器通过实参类型推导函数模板的类型参数，以模板生成一个函数，称为函数的实例化 注意： 一个函数模板并非自动可以处理所有类型的数据，只有能够进行函数模板中运算的类型，可以作为类型实参 函数模板只适用于函数体相同、函数的参数个数相同而类型不同的情况，如果参数的个数不同，则不能用函数模板 自定义的类需要为该类重载模板中的运算符，才能作为类型实参 123456789101112131415//求绝对值template&lt;typename T&gt;T abs(T x){ return x&lt;0?-x:x;}int main(){ int n=-5; double d=-5.5; cout&lt;&lt;abs(n)&lt;&lt;endl; cout&lt;&lt;abs(d)&lt;&lt;endl;}/*结果55.5*/ 类模板 把T做替换成传入的参数 注意使用模板要加上尖括号和实参 类名&lt;&gt;看作整体类名来用 例： 1234567891011121314151617181920212223242526272829//9_2template &lt;class T&gt;class Store{private: T item;//存放任意数据类型的数据 bool haveValue;//标记item是否被存入内容public: Store();//缺省形式的构造函数 T &amp;getElem();//提取数据函数 void putElem(const T &amp;x);//存入数据函数}//成员函数的实现template &lt;class T&gt;//缺省构造函数的实现Store&lt;T&gt;::Store():haveValue(false){}template &lt;class T&gt;//提取数据函数的实现T &amp;Store&lt;T&gt;::getElem(){//&amp;看作是类型的一部分，放在前面 if(!haveValue){ cout&lt;&lt;&quot;No item present!&quot;&lt;&lt;endl; exit(1);//异常退出 } return item;}template &lt;class T&gt;void Sotre&lt;T&gt;::putElem(const T &amp;x){ haveValue=true;//表示item中已存入数值 item=x;//存入x} 结构体成员快速初始化 大括号 群体线性群体直接访问的线性群体——数组 动态数组如vector元素个数可以在程序运行时改变 顺序访问的线性群体——链表 上图例子了两个版本的[]运算符重载，const的为了能修改常对象。返回的常引用对象(函数名前有const)只能读不能写。不能写参数和返回值 类内数组深层复制一般需要重载“=”运算符 避免自身复制 if(&amp;rhs!=this) 比较数组大小是否相同，new（不相同则删除原有，重新分配 遍历数组一个一个复制 return *this 链表概念：链表是一种动态数据结构，可以用来表示顺序访问的线性群体。链表是由系列结点组成的，结点可以在运行时动态生成。每个结点包括数据域和指向链表中下一个结点的指针(即下一个结点的地址)。如果链表每一个结点中只有一个指向后继结点的指针，则该链表称为单链表。 如果每个结点中有两个用于连接其他结点的指针，一个指向前趋结点(称前趋指针)，另一个指向后继结点(称后继指针)，则构成双向链表。链表中的第一个结点称为头结点，最后一个结点称为尾结点，尾结点的后继指针为空。 插入结点 data1的结点存放着data2节点的地址，要先把data2结点的地址给新节点然后再把新结点的地址给data1结点，顺序不能乱。 删除结点 要看是不是最后的结点 实现起来还要加一个前驱节点的地址，只有用前一个previous结点才能删除现在遍历到的current结点。 栈概念：生活中的例子，假设餐厅里有一摞盘子，如果我们要从中拿取盘子，只能从上面一个开始拿，当我们要放上一个盘子是也只能放在最上面。栈的结构正是如此，每个盘子相当于栈中的一个数据，数据只能从栈的一端存入(“压入栈”)，并且只能从栈的同一端取出(“弹出栈”)，这一端叫栈顶，而栈的另一端叫作栈底。栈中的数据的添加和删除操作具有”后进先出“(LIFO)的特性，也就是说，栈中的所有数据，越早被压入的(接近栈底的)，就越晚被弹出。 表达式处理 读取输入流，左边放数值，右边放运算符，运算符入栈的时候如果优先级低（如a-b加号优先级低于/)，那么不能入栈，这时弹出栈中运算符(如/)同时弹出对应操作数的数值进行运算，结果重新放回数值栈中，重复操作。 栈的基本操作 初始化 入栈 出栈 清空栈 把栈顶top置为-1 访问栈顶元素 检查栈的状态（满、空） 队列概念：柜台前、收款机前排队。队列是只能向一端添加元素，从另一端删除元素的线性群体，在队尾添加元素，在队头删除元素。在队头位置的标记成为队头指针，对队尾位置的标记称为队尾指针。向队尾添加元素称为”入队”，删除队头元素称为”出队”。”先进先出”(FIFO)，最早入队的最先出队。 排序与查找插入排序(从后往前检索)比较的时候如果不满足停止条件，需要给key元素腾出空间，找到之后可以直接插入 123456789101112131415161718192021//用直接插入排序法对数组A中的元素进行升序排列template &lt;class T&gt;void insertionSort(T a[], int n) { int i, j; T temp; //将下标为1～n-1的元素逐个插入到已排序序列中适当的位置 for (int i = 1; i &lt; n; i++) { //从a[i - 1]开始向a[0]方向扫描各元素,寻找适当位置插入a[i] int j = i; T temp = a[i]; while (j &gt; 0 &amp;&amp; temp &lt; a[j - 1]) { //逐个比较，直到temp &gt;= a[j - 1]时，j便是应插入的位置。 //若达到j == 0，则0是应插入的位置。 a[j] = a[j - 1]; //将元素逐个后移，以便找到插入位置时可立即插入。 j--; } //插入位置已找到，立即插入。 a[j] = temp; }} 选择排序 12345678910111213141516171819//辅助函数：交换x和y的值template &lt;class T&gt;void mySwap(T &amp;x, T &amp;y) { T temp = x; x = y; y = temp;}//用选择法对数组a的n个元素进行排序template &lt;class T&gt;void selectionSort(T a[], int n) { for (int i = 0; i &lt; n - 1; i++) { int leastIndex = i; //最小元素之下标初值设为i for (int j = i + 1; j &lt; n; j++) //在元素a[i + 1]..a[n - 1]中逐个比较显出最小值 if (a[j] &lt; a[leastIndex]) //smallIndex始终记录当前找到的最小值的下标 leastIndex = j; mySwap(a[i], a[leastIndex ]); //将这一趟找到的最小元素与a[i]交换 }} 交换排序每一轮沉底一个最大元素，n个元素最多排序n-1次，即沉底n-1个元素。 一轮循环结束后lastExchangeIndex其实就是沉好底的元素最上面那个还没排的元素的索引 1234567891011121314151617181920212223242526272829//辅助函数：交换x和y的值template &lt;class T&gt;void mySwap(T &amp;x, T &amp;y) { T temp = x; x = y; y = temp;}//用起泡法对数组A的n个元素进行排序template &lt;class T&gt;void bubbleSort(T a[], int n) { int i = n - 1; // i是下一趟需参与排序交换的元素之最大下标 while (i &gt; 0) { //持续排序过程，直到最后一趟排序没有交换发生，或已达n - 1趟 int lastExchangeIndex = 0; //每一趟开始时，设置交换标志为0（未交换） for (int j = 0; j &lt; i; j++) //每一趟对元素a[0]..a[i]进行比较和交换 if (a[j + 1] &lt; a[j]) { //如果元素a[j + 1] &lt; a[j]，交换之 mySwap(a[j], a[j + 1]); lastExchangeIndex = j; //记录被交换的一对元素中较小的下标，下一步j++ } i = lastExchangeIndex; //将i设置为本趟被交换的最后一对元素中较小的下标 } //一般方法 for(i=0;i&lt;n-1;i++) for(j=0;j&lt;n-i-1;j++){//注意索引 if(a[j]&gt;a[j+1]) mySwap(a[j],a[j+1]); }} 二分查找当找不到数，注意结束的条件（左边界要是中间数加一，右边界是中间数减一） 12345678910111213141516/用折半查找方法，在元素呈升序排列的数组list中查找值为key的元素template &lt;class T&gt;int binSearch(const T list[], int n, const T &amp;key) { int low = 0; int high = n - 1; while (low &lt;= high) { //low &lt;= high表示整个数组尚未查找完 int mid = (low + high) / 2; //求中间元素的下标 if (key == list[mid]) return mid; //若找到,返回下标 else if (key &lt; list[mid]) high = mid - 1; //若key &lt; midvalue将查找范围缩小到数组的前一半 else low = mid + 1; //否则将查找范围缩小到数组的后一半 } return -1; //没有找到返回-1} 第十章 泛型程序设计与C++语言标准模板库面向对象三个特性：封装、继承、多态 STL 标准模板库 六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器 容器可以嵌套容器，里面的叫元素，分为序列式容器和关联式容器： ​ 序列式容器：强调值的顺序，有固定顺序 ​ 关联式容器：二叉树结构，各元素之间没有严格的物理上的顺序关系 迭代器，用来遍历元素的指针。实际上迭代器是一个类，这个类封装了一个指针 算法，通过有限的步骤，解决问题。 ​ 质变算法：运算过程中改变区间内元素内容，如拷贝替换查找。 ​ 非质变算法：不更改内容，如查找、计数、遍历 仿函数，行为类似函数，可作为算法的某种策略。 适配器，一种用来修饰容器或者仿函数活迭代器接口的东西 空间适配器，负责空间的配置与管理 迭代器是算法和容器的桥梁，使算法能够作用到容器。理解为提供给算法函数的指针参数。 容器算法迭代器初识vector容器存放内置数据类型创建： 1vector&lt;int&gt;v; 向容器尾部插入数据： 1v.push_back(10); 通过迭代器访问容器中的数据： 12vector&lt;int&gt;::iterator itBegin=v.begin();//起始迭代器，指向容器中第一个元素vector&lt;int&gt;::iterator itEnd=v.end();//结束迭代器，指向容器中最后一个元素的下一个位置,所以*itEnd是错误的 第一种遍历方式： 1234while(itBegin!=itEnd){ cout&lt;&lt; *itBegin&lt;&lt;endl; itBegin++;} 第二种遍历方式（常用）： 123for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++){ cout&lt;&lt; *it&lt;&lt; endl;//*it解出来的类型对应vecotr&lt;&gt;尖括号里的类型} 第三种用算法库： 123456//需要加#include&lt;algorithm&gt;void myPrint(int val){ cout&lt;&lt;val&lt;&lt;&quot; &quot;;}for_each(v.begin(),v.end(),myPrint);//在for_each(,,func())中需要调用到第三个参数，是一个函数，在内部会执行func(*first)传递迭代器的指向的值，这是只需拿到这个数执行回调函数输出即可。 vector存放自定义数据存放指针类型 123vector&lt;Person*&gt;v;//Person是一个类，存放Person类型的指针Person p1;v.push_back(&amp;p1);//注意是取地址，存放指针类型的 遍历 123for(vector&lt;Person*)::iterator it=v.begin();it!=v.end();it++){ cout&lt;&lt;it-&gt;name;//或者是*it.name} 存放容器类型，容器嵌套 1234vector&lt;int&gt;v;vector&lt; vector&lt;int&gt;&gt;V;v.push_back(10);V.push_back(v); 遍历，需要两层循环 123456for(vector&lt; vector&lt;int&gt;::iterator it=V.begin();it!=V.end();it++){ //此时it类型指向vector&lt;int&gt;类型的指针 for(vector&lt;int&gt;::iterator vit=(*it).begin();vit!=(*it).end();vit++){ cout&lt;&lt;*vit; }} string容器基本概念string是一个类，封装了一个char*来维护，是一个char*容器 1234string s1;string(const char* s);//使用字符串s初始化string(const string&amp; str);//使用一个string对象初始化另一个string对象string(int n,char c);//使用n个字符c初始化，如string s4(10,'c')，则s4=&quot;ccccccccc&quot; vector容器单端数组，可动态扩展 动态拓展：并不是在原空间之后来连续接新空间，而是找更大的内存空间，然后将原数据拷贝到新空间，释放原空间 set容器概念set不允许插重复的，multiset可以。实现自动升序排序 1234567891011121314#include&lt;set&gt;set&lt;int&gt;s1;//构造函数set&lt;int&gt;s2(s1);//拷贝构造s1.insert();//插入数据只有insert方式，而没有push_backprintSet(s1);//遍历输出函数自己写//遍历输出void printSet(set&lt;int&gt;&amp;s){ for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++){ cout&lt;&lt;*it&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl;} set大小和交换函数原型123size();//大小，set没有resize()重新设置大小的操作，因为当扩大时其余未设定的会补0导致重复s1.empty();//判断是非为空s1.swap(s2);//交换容器s1和s2 set插入和删除函数原型1234s1.insert();//插入s1.erase();//删除，可以放指针如s1.begin(),也可以放数值s1.clear();//清空s1.insert(st).second;//若插入重复则该返回值为false set查找和统计map容器map中所有元素都是pair pair中第一个元素为key（键值），第二个元素为value（实值） 所有元素都会根据元素的键值自动排序 本质属于关联式容器，底层结构二叉树实现 优点：可以通过key快速找到value值 map容器构造和赋值1234567891011map&lt;int,int&gt;m;//创建需要两个参数，对组pair元素m.insert(pair&lt;int,int&gt;(1,10));//插入要对组pair//输出void printMap(map&lt;int,int&gt;&amp;m){ for(map&lt;int,int&gt;::iterator it=s.begin();it!=begin();it!=m.end();it++){ cout&lt;&lt;&quot;key=&quot;&lt;&lt;(*it).first&lt;&lt;&quot;value=&quot;&lt;&lt;it-&gt;second&lt;&lt;endl; } cout&lt;&lt;endl;}map&lt;int,int&gt;m2(m1);//拷贝构造m2=m1;//赋值 总结：map中所有元素都是成对出现，输入数据时需要使用对组 map容器大小和交换123size();//大小empty();//判断为空swap(st);//交换 函数对象函数对象（仿函数）本质是个类，而不是一个函数 谓词仿函数 返回值类型是bool数据类型，称为谓词 一元谓词如果operator()接受一个参数，那么叫做一元谓词，两个参数叫二元谓词 12345678find_if(v.begin(),v.end(),查询条件);//返回值是v相同类型的迭代器，没找到返回的是v.end()class Mycompare{ public: bool operator()(int val1,int val2){ return val1&gt;val2; }}//二元谓词的匿名函数find_if(v.begin(),v.end(),Mycompare());//类要加上括号 第十一章 流类库与输入输出输出流概述最重要的三个输出流ostream,ofstream,ostringstream 预先定义的ostream类对象用来完成向标准设备的输出： cout是标准输出流 cerr是标准错误输出流，没有缓冲，发送给它的内容立即被输出 clog类似cerr ofstream类支持磁盘文件输出 使用width控制输出宽度123456789101112131415161718#include &lt;iostream&gt;using namespace std; int main() { double values[] = { 1.23, 35.36, 653.7, 4358.24 }; for(int i = 0; i &lt; 4; i++) { cout.width(10); cout &lt;&lt; values[i] &lt;&lt; endl; } return 0;}输出结果: 1.23 35.36 653.7 4358.24//加上左边的空格正好十个宽度，右对齐 使用setw操纵符指定宽度1234567891011121314151617181920//11_2.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std; int main() { double values[] = { 1.23, 35.36, 653.7, 4358.24 }; string names[] = { &quot;Zoot&quot;, &quot;Jimmy&quot;, &quot;Al&quot;, &quot;Stan&quot; }; for (int i = 0; i &lt; 4; i++) cout &lt;&lt; setw(6) &lt;&lt; names[i] &lt;&lt; setw(10) &lt;&lt; values[i] &lt;&lt; endl; return 0;}输出结果: Zoot 1.23 Jimmy 35.36 Al 653.7 Stan 4358.24//setw(n)指定了后面输出的内容宽度在n个宽度内，右对齐 设置对齐方式123456789101112131415161718192021//11_3.cpp#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;string&gt;using namespace std; int main() { double values[] = { 1.23, 35.36, 653.7, 4358.24 }; string names[] = { &quot;Zoot&quot;, &quot;Jimmy&quot;, &quot;Al&quot;, &quot;Stan&quot; }; for (int i=0;i&lt;4;i++) cout&lt;&lt;setiosflags(ios_base::left)//左对齐 &lt;&lt;setw(6)&lt;&lt;names[i]&lt;&lt;resetiosflags(ios_base::left)&lt;&lt;setw(10)&lt;&lt;values[i]&lt;&lt;endl; return 0;}//这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。输出结果:Zoot 1.23Jimmy 35.36Al 653.7Stan 4358.24 向二进制文件输出1234567891011121314//11_5.cpp#include &lt;fstream&gt;using namespace std;struct Date { int mon, day, year; };int main() { Date dt = { 6, 10, 92 }; ofstream file(&quot;date.dat&quot;, ios_base::binary); file.write(reinterpret_cast&lt;char *&gt;(&amp;dt),sizeof(dt));//write函数是把内存中的一块内容写到一个文件输出流中 file.close(); return 0;} 向字符串输出12345678910111213141516171819//11_6.cpp#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;string&gt;using namespace std;template &lt;class T&gt;inline string toString(const T &amp;v) { ostringstream os; //创建字符串输出流 os &lt;&lt; v; //将变量v的值写入字符串流 return os.str(); //返回输出流生成的字符串} int main() { string str1 = toString(5); cout &lt;&lt; str1 &lt;&lt; endl; string str2 = toString(1.2); cout &lt;&lt; str2 &lt;&lt; endl; return 0;} 输入流重要的输入流类： istream类最适合用于顺序文本模式输入。cin是其实例。 ifstream类支持磁盘文件输入。 istringstream 构造输入流对象 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。 1ifstream myFile(&quot;filename&quot;); 在调用默认构造函数之后使用open函数来打开文件 12ifstream myFile;//建立一个文件流对象myFile.open(&quot;filename&quot;);//打开文件“filename” 打开文件时可以指定模式 1ifstream myFile(&quot;filename&quot;,ios_base::in|ios_base::binary); 相关函数open函数把该流与一个特定磁盘文件相关联。get函数的功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包括空白字符。（第6章介绍过）getline的功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。（第6章介绍过）read成员函数从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。seekg函数用来设置文件输入流中读取数据位置的指针。tellg函数返回当前文件读指针的位置。close函数关闭与一个文件输入流关联的磁盘文件。 输入流举例应用为输入流指定一个终止字符利用getline函数 123456789101112//11_8.cpp#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string line; cout &lt;&lt; &quot;Type a line terminated by '\\t' &quot; &lt;&lt; endl; getline(cin, line, '\\t'); cout &lt;&lt; line &lt;&lt; endl; return 0;} istringstream将字符串转换为数值1234567891011121314151617181920//11_12.cpp, 头部分省略template &lt;class T&gt;inline T fromString(const string &amp;str) { istringstream is(str); //创建字符串输入流 T v; is &gt;&gt; v; //从字符串输入流中读取变量v return v; //返回变量v} int main() { int v1 = fromString&lt;int&gt;(&quot;5&quot;); cout &lt;&lt; v1 &lt;&lt; endl; double v2 = fromString&lt;double&gt;(&quot;1.2&quot;); cout &lt;&lt; v2 &lt;&lt; endl; return 0;}输出结果：51.2 两个重要的输入/输出流 一个iostream对象可以是数据的源或目的。 两个重要的I/O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。 fstream类 fstream类支持磁盘文件输入和输出。 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个fstream对象。 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出 stringstream类 stringstream类支持面向字符串的输入和输出 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成 第十二章 异常处理异常处理的语法 若有异常则通过throw创建一个异常对象并抛掷 将可能抛出异常的程序段嵌在try块之中。通过正常的顺序执行到达try语句，然后执行try块内的保护段 如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后的最后一个catch子句后面的语句继续执行 catch子句按其在try块后出现的顺序被检查。匹配的catch子句将捕获并处理异常（或继续抛掷异常）。 如果匹配的处理器未找到，则库函数terminate将被自动调用，其默认是调用abort终止程序。","link":"/2022/07/01/C-%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"js导出json文件","text":"12345678910111213141516171819202122232425262728293031323334function saveJSON(data, filename) { if (!data) { alert(&quot;保存的数据为空&quot;); return; } if (!filename) filename = &quot;json.json&quot;; if (typeof data === &quot;object&quot;) { data = JSON.stringify(data, undefined, 4); } var blob = new Blob([data], { type: &quot;text/json&quot; }), e = document.createEvent(&quot;MouseEvents&quot;), a = document.createElement(&quot;a&quot;); a.download = filename; a.href = window.URL.createObjectURL(blob); a.dataset.downloadurl = [&quot;text/json&quot;, a.download, a.href].join(&quot;:&quot;); e.initMouseEvent( &quot;click&quot;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null ); a.dispatchEvent(e);} BlobBlob，Binary Large Object的缩写，代表二进制类型的大对象。通俗点说，就是Blob对象是二进制数据，但它是类似文件对象的二进制数据，因此可以像操作File对象一样操作Blob对象，实际上，File继承自Blob。 从字符串创建 Blob12let myBlobParts = ['&lt;html&gt;&lt;h2&gt;Hello Semlinker&lt;/h2&gt;&lt;/html&gt;']; // an array consisting of a single DOMStringlet myBlob = new Blob(myBlobParts, {type : 'text/html', endings: &quot;transparent&quot;}); // the blob 从类型化数组和字符串创建 Blob12let hello = new Uint8Array([72, 101, 108, 108, 111]); // 二进制格式的 &quot;hello&quot;let blob = new Blob([hello, ' ', 'semlinker'], {type: 'text/plain'}); 鼠标事件Document.createEvent()创建一个指定类型的事件。其返回的对象必须先初始化并可以被传递给element.dispatchEvent 语法1var event = document.createEvent(type); event 就是被创建的 Event 对象。 type 是一个字符串，表示要创建的事件类型。事件类型可能包括&quot;UIEvents&quot;, &quot;MouseEvents&quot;, &quot;MutationEvents&quot;, 或者 &quot;HTMLEvents&quot;。 MouseEvent.initMouseEvent()已弃用的特性，建议查阅相关文档改进 MouseEvent.initMouseEvent() - Web API 接口参考 | MDN (mozilla.org) EventTarget.dispatchEvent向一个指定的事件目标派发一个事件, 并以合适的顺序同步调用目标元素相关的事件处理函数。标准事件处理规则 (包括事件捕获和可选的冒泡过程) 同样适用于通过手动的使用dispatchEvent()方法派发的事件。 语法1cancelled = !target.dispatchEvent(event) 参数 event 是要被派发的事件对象。 target 被用来初始化事件和决定将会触发目标。","link":"/2022/09/06/js%E5%AF%BC%E5%87%BAjson%E6%96%87%E4%BB%B6/"},{"title":"my-first-blog","text":"这是我的第一个博客文章","link":"/2022/03/03/my-first-blog/"},{"title":"python学习笔记","text":"部分来源：廖雪峰的官方网站 函数函数的参数使用默认参数解决调用时缺少实参问题,一定必选参数在前，默认参数在后 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 12&gt;&gt;&gt; power(5)25 定义默认参数要牢记一点：默认参数必须指向不变对象！ 如： 123def add_end(L=[]): L.append('END')#向list尾插入 return L 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 可变参数可变参数就是传入的参数个数是可变的 我们把函数的参数改为可变参数： 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数： 1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0 123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)14 *nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。 模块创建模块 新建一个.py文件，不要和python自带重名 导入模块12import 模块名称 [as别名]from 模块名称 import 函数/变量/类 例子： 1234567#导入整个import mathprint(math.pi)#导入部分from math import piprint(pi) 导入自定义模块要先将自定义模块所在文件下设置为源文件夹（Sources Root） 第三方模块123pip install 模块名 #在小黑窗在线安装import 模块名 #在python文件使用 例子： 12345678910import scheduleimport timedef job(): print(&quot;hhh&quot;)schedule.every(3).seconds.do(job)#每三秒执行一次while True: schedule.run_pending()#启动 time.sleep(1)#停一秒 以主程序运行12if __name__=='__main__': pass 例子： 1234567#calc2.pydef add(a,b) return a+bif __name__=='__main__' printf(add(10,20))#只有当运行calc2.py时才会输出，当其作为模块引入到其他文件执行时不输出 包python程序结构： 12345678graph LRA(Python程序)--&gt;B(包1)A--&gt;C(包2)A--&gt;D(包3)B--&gt;E(模块A)B--&gt;F(模块B)C--&gt;G(模块A)C--&gt;H(模块B) 包与目录的区别 包(package)包含_init_.py文件 目录(directory)里通常不包含_init_.py文件 导入同目录下的包里的模块： 12import package.module_A as ma #别名print(ma.a) 使用import导入时只能跟包名和模块名 想要导入变量用from: 1from package.moudle_A import a 1234567891011graph LRA(模块与包)--&gt;B(模块)A--&gt;C(包)B--&gt;D(避免函数名/变量名重名)B--&gt;E(自定义模块)B--&gt;F(第三方模块)E--&gt;G(一个.py文件称为一个模块)F--&gt;H(安装:pip install 模块名)F--&gt;I(使用:from ...import 模块名)C--&gt;J(避免模块名重名)C--&gt;K(包含__init__.py文件) 面向对象类和实例12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 注意：特殊方法“__init__”前后分别有两个下划线！！！ 注意到__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 继承和多态继承我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印： 123class Animal(object): def run(self): print('Animal is running...') 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承： 12345class Dog(Animal): passclass Cat(Animal): pass 在括号放父类 多态在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行： 123&gt;&gt;&gt; b = Animal()&gt;&gt;&gt; isinstance(b, Dog)False 例子： 1234567891011def run_twice(animal): animal.run() animal.run() &gt;&gt;&gt; run_twice(Animal())Animal is running...Animal is running...&gt;&gt;&gt; run_twice(Dog())Dog is running...Dog is running... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类； 对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 获取对象信息使用type()首先，我们来判断对象类型，使用type()函数： 基本类型都可以用type()判断： 123456&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type('str')&lt;class 'str'&gt;&gt;&gt;&gt; type(None)&lt;type(None) 'NoneType'&gt; 使用isinstance()对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。 我们回顾上次的例子，如果继承关系是： 1object -&gt; Animal -&gt; Dog -&gt; Husky 那么，isinstance()就可以告诉我们，一个对象是否是某种类型。先创建3种类型的对象： 12&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; h = Husky() 然后，判断： 1234&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Animal)True 使用dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list，比如，获得一个str对象的所有属性和方法： 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill'] 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法，所以，下面的代码是等价的： 1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; 'ABC'.__len__()3 我们自己写的类，如果也想用len(myObj)的话，就自己写一个__len__()方法： 1234567&gt;&gt;&gt; class MyDog(object):... def __len__(self):... return 100...&gt;&gt;&gt; dog = MyDog()&gt;&gt;&gt; len(dog)100","link":"/2022/09/24/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"pytorch深度学习笔记","text":"dir()函数，能让我们知道工具箱以及工具箱中的分隔区有什么东西。 help()函数，能让我们知道每个工具是如何使用的，工具的使用方法。 help(a)或者a?? 三个区域编写代码： pycharm的python文件 整体运行，python文件的块是所有行的代码，适用大型项目 每次都是整体运行 pycharm的python 控制台 以任意行为块(Shift+Enter)，变量属性在右边查看 出现错误可阅读性大大降低 Jupyter notebook 同python控制台，Shift+Enter执行块 可以直接修改块中的错误，阅读性加强 环境需要配置 加载数据一堆数据–&gt;Dataset(提供一种方式去获取数据及其label)–&gt;Dataloader(为后面的网络提供不同的数据形式) Dataset： 如何获取每一个数据及其label 告诉我们总共有多少数据 数据的组织形式 文件夹名就是一个label ocr 图片 对应图片的文字坐标信息 图片名就是label 实战案例： image-Snipaste_2022-09-24_23-31-33 1234567891011121314151617181920212223242526272829303132from torch.utils.data import Datasetfrom PIL import Imageimport osclass MyData(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir # 数据集文件夹 self.label_dir = label_dir # 数据集标签 self.path = os.path.join(root_dir, label_dir) # 拼接路径 这里正好文件夹名就是标签名 self.img_path = os.listdir(self.path) # 将文件夹下图片转换成列表 def __getitem__(self, idx): # idx是索引 img_name = self.img_path[idx] # 获取单张图片名字 img_item_path = os.path.join(self.root_dir, self.label_dir, img_name) # 拼接获得单张图的地址 img = Image.open(img_item_path) # 图片读取 label = self.label_dir # 获取标签 return img, label def __len__(self): return len(self.img_path) # 长度即数据集的列表长度root_dir = &quot;dataset/train&quot; # 大路径ants_label_dir = &quot;ants&quot; # 蚂蚁标签bees_label_dir = &quot;bees&quot; # 蜜蜂标签ants_dataset = MyData(root_dir, ants_label_dir) # 实例化蚂蚁bees_dataset = MyData(root_dir, bees_label_dir) # 实例化蜜蜂train_dataset = ants_dataset + bees_dataset # 拼接数据集 https://cdn.jsdelivr.net/gh/JJuprising/JJuprising.github.io Tensorboard看模块的代码：按住Ctrl，点模块 打开窗口，不接--port默认打开6006端口的 1tensorboard --logdir=logs --port=6007 add_scalar12345678from torch.utils.tensorboard import SummaryWriterwriter=SummaryWriter(&quot;logs&quot;)for i in range(100): writer.add_scalar(&quot;标题&quot;,y轴,x轴)writer.close() 重新画删掉Logs文件下下的所有文件，在终端Ctrl+c结束后重新打开窗口 add_image()opencv读取到的数据是numpy型 从PIL到numpy，需要在add_image()中指定shape中每一个数字/维表示的含义，默认是CHW即通道-高度-宽度，如果导入图片是HWC就要加入说明，见案例： 1234567891011121314151617import numpy as npfrom torch.utils.tensorboard import SummaryWriterfrom PIL import Imagewriter = SummaryWriter(&quot;logs&quot;)image_path = &quot;data/train/ants_image/0013035.jpg&quot;img_PIL = Image.open(image_path) # 打开图片img_array = np.array(img_PIL) # 转成numpy型print(type(img_array)) # 验证时numpy型print(img_array.shape) # 检查图片的形状，发现是HWC，即高度-宽度-通道writer.add_image(&quot;test&quot;, img_array, dataformats=&quot;HWC&quot;) # HWC对应图片的形状for i in range(100): writer.add_scalar(&quot;y=2*x&quot;,3*i,i)writer.close() Transformtransform.py工具箱，有toTensor，resize等工具，用于处理图片输出想要的图片结果 transform的使用 tensor数据类型 在括号内Ctrl+P查看要输入的参数 tensor数据类型ToTensor&amp;Normalize123456789101112131415161718192021from PIL import Imagefrom torch.utils.tensorboard import SummaryWriterfrom torchvision import transformswriter=SummaryWriter(&quot;logs&quot;)img=Image.open(&quot;dataset/val/ants/800px-Meat_eater_ant_qeen_excavating_hole.jpg&quot;)print(img)#ToTensortrans_totensor=transforms.ToTensor()img_tensor=trans_totensor(img) # 转成tensor类型writer.add_image(&quot;ToTensor&quot;,img_tensor)# Normalizeprint(img_tensor[0][0][0])trans_norm=transforms.Normalize([3,0.5,0.5],[0.5,0.5,0.5]) # 标准差img_norm=trans_norm(img_tensor)print(img_norm[0][0][0])writer.add_image(&quot;Normalize&quot;,img_norm,1)writer.close() resize()12345678910#接上面代码# Resizeprint(img.size) # 原图的大小(800, 534)trans_resize = transforms.Resize((512, 512)) # 改大小# img PIL -&gt; resize -&gt; img_resize PILimg_resize = trans_resize(img)# img_resize PIL -&gt; totensor -&gt; img_resize tensorimg_resize=trans_totensor(img_resize)writer.add_image(&quot;Resize&quot;,img_resize,0)print(img_resize) Compose()Compose()中的参数需要一个列表。Python中，列表的表示形式为[数据1，数据2，…]。在Compose中，数据需要是transforms类型，所以得到的： 1Compose([transforms参数1,transforms参数2,...]) 将几步打包成一步： 1234567# Compose - resize - 2trans_resize_2 = transforms.Resize(512) # 只改了宽 没改长# PIL -&gt; PIL -&gt; tensortran_compose = transforms.Compose([trans_resize_2, trans_totensor])img_resize_2 = tran_compose(img)writer.add_image(&quot;Resize&quot;, img_resize_2, 1)writer.close() RandomCrop()随机裁剪出一部分 12345678trans_random = transforms.RandomCrop(512) # PIL -&gt; PIL -&gt; tensortran_compose_2 = transforms.Compose([trans_random, trans_totensor])for i in range(10): # 设置不同步数 img_crop=trans_compose_2(img) writer.add_image(&quot;RandomCrop&quot;, img_resize_2, 1)writer.close() 总结 关注输入和输出 多看官方文档 PyTorch 关注方法需要什么参数 不知道返回值的时候： ```pythonprint()print(type())调试12345678910111213141516171819202122232425262728 # torchvision数据集的使用官网文档的torchvision.datasets下有很多数据集可以使用torchvision.models提供训练好的模型torchvision.transform上面讲了torchvision.utils提供小工具```pythonimport torchvisiontrain_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/data1&quot;,train=True,download=True) # 下载训练集test_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/test1&quot;,train=False,download=True) # 下载测试集print(test_set[0]) # ( , )的形式，发现第一个是图片第二个是targetprint(test_set.classes) # 查看图片有哪些类型(调式看test_set有calsses属性)img,target=test_set[0] #接收( , )print(img)print(target)print(test_set.classes[target])img.show() 和transform联动1234567891011121314import torchvisionfrom torch.utils.tensorboard import SummaryWriterdataset_transform=torchvision.transforms.Compose([torchvision.transforms.ToTensor()]) # 设置transformstrain_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/data1&quot;,train=True,transform=dataset_transform,download=True) # 加入transforms参数test_set=torchvision.datasets.CIFAR10(root=&quot;./dataset/test1&quot;,train=False,transform=dataset_transform,download=True)writer=SummaryWriter('p10')for i in range(10): img,target = test_set[i] writer.add_image(&quot;test_set&quot;,img,i)writer.close() 结果： DataLoader12345678910111213141516171819202122import torchvisionfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriter# 准备测试数据集test_data = torchvision.datasets.CIFAR10(&quot;./dataset/test1&quot;, train=False, transform=torchvision.transforms.ToTensor())test_loader = DataLoader(dataset=test_data, batch_size=64, shuffle=True, num_workers=0, drop_last=True)# 测试数据集中第一张照片及targetimg, target = test_data[0]print(img.shape)print(target)writer = SummaryWriter(&quot;dataloader&quot;)step = 0for data in test_loader: imgs, targets = data # test_loader返回值是batch_size设定的一组图片打包的img和target writer.add_images(&quot;test_data&quot;, imgs, step) step = step + 1writer.close() 神经网络torch.nn，Neural Network。 nn.Module是所有神经网络的基类 123456789101112131415import torchimport torch.nn as nnimport torch.nn.functional as Fclass Model(nn.Module): def __init__(self): super().__init__() self.conv1 = nn.Conv2d(1, 20, 5) self.conv2 = nn.Conv2d(20, 20, 5) def forward(self, x): # 隐藏层 x = F.relu(self.conv1(x)) # 经过一次卷积然后一次非线性 return F.relu(self.conv2(x)) # 输出 卷积操作 各种参数 Stride Stirde=1表示卷积核在输入图像上移动一格，对应格相乘得到数；从左到右，到边界回到最左向下移动Stride然后重复操作 padding 123456789101112131415161718192021222324252627282930313233import torchimport torch.nn.functional as Finput=torch.tensor([[1,2,0,3,1], [0,1,2,3,1], [3,2,3,1,1], [5,2,3,1,1], [2,1,0,1,1]])kernel=torch.tensor([[1,2,1], [0,1,0], [2,1,0]])print(input.shape) # 只有两个参数，不能直接放进卷积，要reshapeinput=torch.reshape(input,(1,1,5,5)) # 5X5矩阵kernel=torch.reshape(kernel,(1,1,3,3))print(input.shape)print(kernel.shape) # 变成四个参数output=F.conv2d(input,kernel,stride=1,padding=1)print(output)# 输出# torch.Size([5, 5])# torch.Size([1, 1, 5, 5])# torch.Size([1, 1, 3, 3])# tensor([[[[ 1, 3, 4, 10, 8],# [ 7, 14, 14, 17, 9],# [ 9, 18, 18, 17, 9],# [15, 17, 14, 8, 7],# [14, 13, 9, 7, 4]]]]) 卷积层nn.Conv1d一维卷积，nn.Conv2d二维卷积层… 彩色图像一般是三通道 123CLASS torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', device=None, dtype=None)# 参数表 输入通道数，输出通道数，卷积核大小，卷积操作步径大小，边缘填充，卷积核距离...后面都是默认参数 卷积层示例(动图要梯子才能刷出来) out_channels设置为2时会生成两个卷积核，得到两个叠加的输出。(一般卷积操作会不断增加channels数) 例子： 12345678910111213141516171819202122232425262728293031323334353637import torchimport torchvision.datasetsfrom torch import nnfrom torch.nn import Conv2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(Tudui, self).__init__() self.conv1 = Conv2d(in_channels=3, out_channels=6, kernel_size=3, stride=1, padding=0) def forward(self, x): x = self.conv1(x) return xmyModule = MyModule()writer = SummaryWriter(&quot;logs2&quot;)step = 0for data in dataLoader: imgs, targets = data output = myModule(imgs) print(imgs.shape) print(output.shape) # torch.Size([64,3,32,32]) writer.add_images(&quot;input&quot;, imgs, step) # torch.Size([64,6,30,30]) -&gt; [xxx,3,30,30] output = torch.reshape(output, (-1, 3, 30, 30)) # 原本输出通道数变两倍，这一步相当于切开放到一个 writer.add_images(&quot;output&quot;, output, step) step = step + 1 池化层ceil_mode floor向下取整，ceiling向上取整。默认false不够对应不取值 实现： 123456789101112131415161718192021222324252627282930313233343536# 最大池化import torchfrom torch import nnfrom torch.nn import MaxPool2dinput = torch.tensor([[1, 2, 0, 3, 1], [0, 1, 2, 3, 1], [1, 2, 1, 0, 0], [5, 2, 3, 1, 1], [2, 1, 0, 1, 1]], dtype=torch.float32) # 声明一下类型否则报错input = torch.reshape(input, (-1, 1, 5, 5))print(input.shape)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=False) # 注意ceil_mode def forward(self,input): output=self.maxpool1(input) return outputmyModule = MyModule()output = myModule(input)print(output)# 当ceilmode设置为false结果：# torch.Size([1, 1, 5, 5])# tensor([[[[2.]]]])# 当ceilmode设置为true结果：# torch.Size([1, 1, 5, 5])# tensor([[[[2., 3.],# [5., 1.]]]]) 最大池化目的为了保持原先数据的特征同时减少数据量，加快训练速度。例如720p也能大致看明白1080p视频内容 例子： 12345678910111213141516171819202122232425262728293031323334353637# 最大池化import torchimport torchvisionfrom torch import nnfrom torch.nn import MaxPool2dfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.maxpool1 = MaxPool2d(kernel_size=3, ceil_mode=True) def forward(self, input): output = self.maxpool1(input) return outputmyModule = MyModule()writer = SummaryWriter(&quot;Logs_maxpool&quot;)step = 0for data in dataLoader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, step) output = myModule(imgs) writer.add_images(&quot;output&quot;, output, step) step = step + 1writer.close() 可以看到输出图片变模糊了 非线性激活 Non-linear用到ReLu()或Sigmoid() 1234567891011121314151617181920212223242526272829303132333435import torchimport torchvisionfrom torch import nnfrom torch.nn import Sigmoid, ReLUfrom torch.utils.data import DataLoaderfrom torch.utils.tensorboard import SummaryWriterdataset = torchvision.datasets.CIFAR10(&quot;/dataset/data2&quot;, train=False, transform=torchvision.transforms.ToTensor(), download=True)dataLoader = DataLoader(dataset, batch_size=64)class MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.relu = ReLU() self.sigmoid1 = Sigmoid() def forward(self, input): output = self.sigmoid1(input) return outputMyModule = MyModule()writer = SummaryWriter(&quot;logs_relu&quot;)step = 0for data in dataLoader: imgs, targets = data writer.add_images(&quot;input&quot;, imgs, global_step=step) output = MyModule(imgs) writer.add_images(&quot;output&quot;, output, global_step=step) step += 1writer.close() 主要目的在网络中引入更多非线性特征，才能训练出符合更多特征的模型。 线性层及其他层1CLASS torch.nn.Linear(in_features,out_features,biass=True) biass表示要不要设置偏振b flattten()展平成一行 CRAF10小实战及Sequential() 1、由公式计算第一步卷积得到padding是2(默认设置stride为1) 通过对每一步的解析，我们建立出一个简单的模型，代码如下： 123456789101112131415161718192021222324252627282930313233343536import torchfrom torch import nnfrom torch.nn import Conv2d, MaxPool2d, Flatten, Linear, Sequentialfrom torch.utils.tensorboard import SummaryWriterclass MyModule(nn.Module): def __init__(self): super(MyModule, self).__init__() self.model1 = Sequential( Conv2d(3, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 32, 5, padding=2), MaxPool2d(2), Conv2d(32, 64, 5, padding=2), MaxPool2d(2), Flatten(), Linear(1024, 64), Linear(64, 10) ) def forward(self, x): x = self.model1(x) return xmyModule = MyModule()print(myModule)input = torch.ones((64, 3, 32, 32)) # torch提供的一个假设的输入output = myModule(input)print(output.shape)writer = SummaryWriter(&quot;logs_seq2&quot;)writer.add_graph(myModule,input)writer.close()","link":"/2022/09/27/pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"中华文化酷！小程序","text":"自从报名了icode比赛之后的几个月就再也没有理过这个东西了（事情多得有点忙乱，中途还要弄团委项目，当然我这个组长肯定要负主要责任）。还有半个月才和火蛋急忙开工，当时也没想那么多就想着既然参加了就起码得完成吧，意外的是最后还获得三等奖（五月份的事了）。这次的经历出现了一些问题也让我获得除了开发小程序以外的收获。 策略方面首先就是一定要提前准备，确定好主题，做好长期的规划安排。其次是多和组员交流开会，带动一下整个团队。队长就是整个团队的核心和关键，需要有较强的内驱力和领导力。最后就是要做好调研调查，进度估计。了解好项目的大致框架和可能涉及到的技术栈。 技术方面这个小程序也是相当简易的，涉及到的都是一些简单的程序指令，没有高端的算法之类的，这也是我们不愿在答辩时过多呈现技术方面的原因呵呵（因为师兄师姐的技术都太过硬核了）。 总结这次作品主要有两点亮点吧，一是主题，二是UI界面。自从发现时间紧迫，在技术上不会有太大的造诣。于是每晚下工后躺在床上我都在想怎么包装这个作品。页面是参考的某学习app。而主题我们本打算就以传统文化为内容，但是后来我突然想起高中语文写的那么多作文都提到创新的中华文化。于是我就想以此为内容会不会更好，并定下了一个具有双关意味的名字。 当然也存在很多缺陷。一是前端基础不牢，运行时存在很多bug，不进行改进是绝对不能上线的。二是选题问题。答辩时师兄提了很好的问题，他说为什么不能用抖音这些平台来宣传呢？意思就是让我们思考这个软件凭什么让别人来使用你，如果只是单纯传播一些帖子，网上有很多流量更大的平台可以利用。师兄还建议我们可以增加一些相关活动信息的发布，来提升实用性。三当然就是技术的硬核程度了，要多注重技术方面才能拿得出手，这也是我在接下来要重点加强学习的。 最后附上我深夜爆肝的花里胡哨说明文档以及答辩ppt。 中华文化酷！说明文档2022/4/24 中华文化酷！答辩ppt2022/5/15 鸣谢：Fire_egg","link":"/2022/07/01/%E4%B8%AD%E5%8D%8E%E6%96%87%E5%8C%96%E9%85%B7%EF%BC%81%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"云服务器搭建mc服务器经验总结","text":"首先​ 我的云服务器是轻量化服务器2核4G，ubuntu，指令不同就是yum要改成apt hhh 刚开始照这网上做就是因为这个导致一开始就失败哈啊哈哈哈。 温馨提示：以下只是很粗糙的总结，如果真要动手的话建议还是直接到文章最下面去看看一些大佬的教程 配置一下服务器叭1.密钥、密码设置好 2.添加一个端口25565（阿里云是没有开这个的） 3.重启 下几个软件连接服务器​ 我这边用的是Xshell 6和FlashFXP 5。通过服务器公网ip和账号密码连接上就可以了 安装JAVA 17.0.1这里千万注意！ 1.装的是linux的，不要把自己电脑windows的放上去啊 2.版本！Linux x64 Compressed Archive 否则：unable to access jarfile 3.我是在电脑下载好安装包，用flashxp放上去根目录然后在Xshell解压 ​ tar -zxvf [文件名加.gz] 直接把自己原来的整个服务端文件打包上传上去如果你用过自己的电脑开过服的就很方便了，因为启动脚本全部已经都写好了（ 比如start.sh ）！利用FlashFXP上传文件到服务器里。（但是要开放执行权限！！！）上传后–文件右键–属性 权限全部勾上简单粗暴 开搞！装screen,后台运行用 apt install screen 然后开窗口 screen -S [自定义窗口名] cd到start.sh的文件夹下 ./start.sh 这里有可能会遇到打不开的问题：bad interpreter 这就需要把start.sh的doc改成unix。怎么改网上都有 然后重新 ./start.sh 看到Done!就搞定了！ 在mc多人游戏里直接连接-输入ip就能成功连接了！ 这里screen还是有一些其他指令的，比如 screen -ls 可以查看现在在运行的指令。 连接screen 其他的上网查查看吧 【参考资料】 1.零基础！使用云服务器搭建Minecraft服务器 - 哔哩哔哩 (bilibili.com) 2.【MC开服教程】十分钟手把手教你怎么用白嫖来的阿里云ECS搭建一台mc服务器|Linux搭建mc服务器_哔哩哔哩_bilibili 3.我的世界百分百成功搭建 阿里云 百度云 腾讯云服务器教程，超简单！！！！_哔哩哔哩_bilibili","link":"/2022/03/04/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAmc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"},{"title":"如何写申报书和管理项目","text":"计划类文档的体例和内容关系简介/摘要 研究背景 现存问题 主要研究内容 创新点 实验结果/核心成果 项目背景问题的背景(技术的应用场景？系统的使用环境？)–&gt;对核心问题的凝练表述(一个词组/一句话)–&gt;理论重要性(问题本身在理论上未能完善解决)、社会意义、应用价值(如能完善，可能获得的收益) 相关工作调研(角度:研究领域、产业领域；国内、国外；论文、产品、专利；) 解决项目拟研究问题的核心技术(不止一个)的发展沿革及现状 应用要素本身如有与核心技术配合构成系统的情况(从系统角度对相关研究发展加以概述) 核心技术有没有已经做了或用别的技术来解决了这个问题的 你这么做又可以解决什么其他的问题 问题描述/拟研究问题 选择合适的套路：(数学模型法、场景描述法、系统构成法(功能需求、性能需求)) 严谨、准确、无歧义的描述(独立于解决方案) 留扣子:将问题解决的核心方法要素/需求进行解构分析(–&gt;潜移默化地催眠读者，尽可能使之对后续的研究内容、技术路线有顺理成章的认同感) 研究内容(总分总结构)从技术面对问题解决方案进行结构，逐一分析 技术方案(路线、重点、难点)(与主要研究内容的区别是：研究内容着重讲做什么；技术路线着重讲怎么做) 重点：如果实现了，至少基本解决了提出的问题(保底) 难点：如果实现了，能较好地解决提出的问题(锦上添花) 可行性分析理论可行性 (类比：核心技术在其他领域的应用，从功能和性能上，是否与拟研究应用的要求相吻合) (着重方案合理性/避重就轻) 条件可行性 (研究基础、物质条件、非物质条件) 研究计划/进度安排研究内容的逻辑理论、研究路线的细节理清–&gt;每季度的进度规划(+阶段性成果或进度检验标准) 甘特图 预期成果研究生：专利+论文 本科生：软著/专利+比赛作品/论文 经费资料费、软著费、专利费 申报书印象分加分技巧： 排版有条理(分点罗列、层次清晰) 适当加粗/高亮显示一些关键词句 主次分明、详略得当 图表化展示核心概念、思路、方法、过程、原理 切记直接挪用CSDN、知乎、百度百科等(带水印) 风格要统一 参考文献统一国标标准 工作量(字数和内容) 字数一万多差不多得了，内容要精妙 从申报书到论文/作品： ​ 申报书(体例框架、基本图、表等素材)–&gt;引言、相关工作、问题描述(迭代优化)–&gt;解决方案、实验验证 以上笔记来自杨欢老师的线上课堂，向杨欢老师致谢。 本科申报书格式是本人参考之前的活动策划案、师兄师姐的申报书自己设定的一个格式。 大标题如国内外研究现状：黑体、四号、一倍行距 正文：中文宋体、小四，英文TImes New Roman 标题序号：1.-&gt;1.1-&gt;(1)-&gt;缩进两个，1)-&gt;① 行距：除了大标题，图片嵌入性单倍行距，正文固定值20磅，段前段后0.5行","link":"/2022/11/03/%E5%A6%82%E4%BD%95%E5%86%99%E7%94%B3%E6%8A%A5%E4%B9%A6%E5%92%8C%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/"},{"title":"离散数学","text":"第一章 命题逻辑的基本概念1.1 命题与连接词 非真即假的陈述句称作命题 作为命题，是否知道它的真值并不重要，重要的是它有唯一的真值。如2050年的元旦下大雪 用小写英文(p,q,r,s…至少从p开始往后数)表示命题 否定式“非p”﹁p是复合命题；∧合取 ∨析取 相容或和排斥或 相容或，即它联结的两个命题可以同时为真。如小明爱打球或跑步这两个命题可以同时为真，相容或 排斥或，只有当一个为真，另一个为假时，才为真。但是这个形式化有两种情况。 ①”只能“，小芳只能挑选跳舞课或羽毛球课 这里p:小芳挑选跳舞课 q:小芳挑选羽毛球课,结果并不能单纯用p∨q表示，因为当p，q同真时结果也是真，即小芳既选了跳舞可，又选了羽毛球课，不满足”只能“。此复合命题为真应该时当且仅当p、q其中一个为真，另一个为假时才成立。（这里我们容易联想到”异或“关系）如何用形式化表达呢？不如我们表示得详细一点：小芳挑选跳舞课但不挑选羽毛球课或小芳挑选羽毛球课但不挑选跳舞课。于是用符号化表示：**(p∧﹁q)∨(﹁p∧q)** ②不能同时为真的。小芳是江西人或安徽人 这里既可以用**(p∧﹁q)∨(﹁p∧q)** 表示，又可以用p∧q表示，因为小芳不可能既是江西人又是安徽人，即p、q不能同时成立。 p→q称为p蕴涵q;规定p→q为假当且仅当p为真q为假。当p为假时无论q真假p→q都是真。 p q p→q 0 0 1 0 1 1 1 0 0 1 1 1 除非和否则。除非小王穿毛衣，否则天不冷 将”否“和”则“断开，否掉除非后的命题，改成如果小王不穿毛衣，则天不冷 这样就好判断蕴涵关系了。 只有天冷，小王才穿毛衣 是q→p，只有……才……后面推前面。小王穿了毛衣说明天冷了。 (p→q)∧(q→p)与p↔q的逻辑关系完全一样，都表示p与q互为充分必要条件。 优先顺序：”( )” &gt; “﹁” &gt; “∧” = “→” = “↔” 命题的中文说法与符号化 ﹁p “非p” p∧q “p并且q” p∨q “p或q” p→q “如果p，则q” p↔q ”p当且仅当q“ 1.2 命题公式及其赋值 真值可以变化的陈述句叫命题变项，命题变项不是命题。命题变项用符号联结起来的符号称为合式公式，简称公式。命题用符号联结起来就是复合命题。区分：如果题目只有符号p之类的，就是命题变项；如果是p:简单命题那就是命题常项 公式的层数。单个命题变项算0层，﹁算1层，其他的就是max(i,j) 解释或赋值：用命题常项代替公式中的命题变项然后各指定一个真值0或1（不关心命题内容，只关心真假） 三种命题公式（设A为任一命题公式） 重言式，A在它各种赋值下取值均为真，全为成真赋值。 矛盾式，A在它各种赋值中取值均为假，全为成假赋值。 非重言式的可满足式,A既有成真赋值又有成假赋值。（可满足式：不是矛盾时就是可满足式，至少有一个成真赋值。） 第二章 命题逻辑等值演算2.1等值式 等值：在所有扶植下，A和B的真值都相同，则称A与B是等值的，记作 等值式模式 比较重要的等值式模式：1双重否定律、6德摩根律、8零律、9同一律、10排中律、11矛盾律 等值演算法做题顺序： ​ 1.消→，↔ （蕴涵等值式、等价等值式） ​ 2.消﹁( ) （德摩根律） ​ 3.消双重否定（双重否定律） 2.2 析取范式与合取范式 命题变项及其否定统称作文字。仅由有限个文字构成的析取式（合取式）称作简单析取式（简单合取式）。 注意：p,﹁p,q,﹁q就即是简单析取式又是简单合取式。（单个文字析取0或者合取1，也是本身） 由有限个简单合取式的析取构成的命题公式称作析取范式，由有限个简单析取式做合取构成的命题公式称作**合取范式,**统称为范式。 注意有些命题公式名字不唯一：p∧q∧r 即是由三个简单析取式做合取构成的合取范式，又是由一个简单合取式构成的析取范式（理解成 (p∧q∧r)∨1) )。 析取范式容易求成真赋值，合取范式容易求成假赋值 （范式存在定理）任一命题公式都存在与之等值的析取范式与合取范式。这就意味着我们可将所有的命题公式运用等值演算法转化为析取范式或合取范式的形式，方便求得赋值。 在含有n个命题变项的简单合取式（简单析取式）中，若每个命题变项和它的否定式恰好出现一个且仅出现一次[全部齐全]，而且命题变项或它的否定式按照下标从小到大或按照字典序排列，称这样的简单合取式（简单析取式）为极小项（极大项） 简单合取出极小项，简单析取出极大项。 由于命题变项还有否定形式，所以n个命题变项可以组成2^n个不同的极小项（极大项同理2n个）。每个极小项都有且仅有一个成真赋值，每个极大项也只有一个成假赋值，且不同的极小项（极大项）有不同的成真（成假）赋值。说明一个极小项可以提供一个成真赋值，一个极大项可以提供一个成假赋值。 讲极小项的成真赋值对应的二进制数等于十进制i，将这个极小项记作mi.例如p∨q∨r这个极小项成真赋值为111，对应十进制7，那么这个极小项记作m7;极大项同理，记作Mi。 ﹁mi⇔Mi , ﹁Mi⇔mi 主析取范式（主合取范式）：全部由极小项（极大项）构成的析取范式（合取范式）。 主析取范式是简单合取式的极小项做析取，直接看出所有成真赋值；主合取范式是简单析取式的极大项做合取，直接看出所有成假赋值。 任何命题公式都存在与之等值的主析取范式和主合取范式，并且是唯一的。我将其称之为主范式存在定理，这条定理为我们转化范式提供依据。 简单合取式转化为极小项的步骤，如： 少了一个命题变项的 p∧q⇔(p∧q)∧1 (同一律) ⇔(p∧q)∧(r∨﹁r) (排中律，置换规则) ⇔(p∧q∧r)∨(p∧q∧﹁r) (分配律) ⇔m7∨m6 这样就变成了两个极小项做析取。 少了两个命题变项的 p⇔p∧1 (同一律) ⇔p∧(q∨﹁q) (排中律，置换规则) ⇔(p∧q)∨(p∧﹁q) (分配律) ⇔((p∧q)∨(p∧﹁q))∨1 (同一律) ⇔((p∧q)∨(p∧﹁q))∧(r∨﹁r) (排中律，置换规则) ⇔(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r) (分配律) 简单析取式转化为极大项的步骤，如： 少了一个命题变项的： p∨q⇔(p∨q)∨0 (同一律) ⇔(p∨q)∨(r∧﹁r) (矛盾律)//这一步和简单合取式变极小项不一样，前后的步骤基本一致,结果符号调换 …… ⇔(p∨q∨r)∧(p∨q∨﹁r) (分配律) 少两个命题变项的 p⇔p∨0 …… ⇔(p∨q∨r)∧(p∨﹁q∨r)∧(p∨q∨﹁r)∧(p∨﹁q∨﹁r) (分配律) **总结简单合（析）取式转化为极大（小）项基本步骤**： 缺少哪个变项就添加同时添加那个变项的原形和否定式，缺少多个就做排列组合 如p∧q最后变成(p∧q∧r)∨(p∧q∧﹁r) ，p变成(p∧q∧r)∨(p∧﹁q∧r)∨(p∧q∧﹁r)∨(p∧﹁q∧﹁r)，原本是合取式加上后各部分做析取，原本析取的加上后各部分做合取 出现重复的命题变项或极小项或矛盾式应消去，如，p∧p⇔p，mi∨mi⇔mi，用0代替矛盾式 A是一个有3个命题变项的公式，假设主析取范式为 m2∨m5∨m7，说明它的成假赋值有三个，010,101,111，那么剩下的23-3=5个就是它的成真赋值了，则它的主合取范式为M0∧M1∧M3∧M4∧M6，相当于把真值表分为成真和成假，成真赋值压缩到主合取范式，成假赋值压缩到主析取范式，一眼就可以看出来。 第三章 命题逻辑的推理理论3.2 自然推理系统常用的推理定理： 假言推理 (A→B)∧A⇒B 拒取式 (A→B)∧﹁B⇒﹁A 析取三段式 (A∨B)∧﹁B⇒A 假言三段式 (A→B)∧(B→C)⇒(A→C) 前提： 结论： 推理证明的两个技巧： 附加前提证明法。如结论是A→B，就可以把A作附加前提引入推出B。 归谬法，将结论的否定式作为附加前提引入并推出矛盾式。如结论是﹁q，就把q作结论的否定引入最终推出矛盾式。 第六章 集合代数6.1 集合的基本概念子集 ⊆空集 ∅空集的符号化表示为：∅={x|x≠x} n元集含有n个元素的集合简称n元集，它的含有m(m≤n)个元素的子集称作它的m元子集 对于A={1,2,3},0元子集：∅；1元子集：{1},{2},{3}；2元子集：{1,2},{2,3},{1,3}；3元子集：{1,2,3} 幂集 P(A)定义：把集合A的全体子集（包括空集）构成的集合称为A的幂集 其中，P(∅)={∅}（空集是任何集合的子集），P({∅})={∅,{∅} }（想不通就把{∅}换成一个具体的数如{1} 例：A={1,2,3} ​ P(A)={∅,{1},{2},{3},{1,2},{1,3},{2,3},{1,3},{1,2,3} }； ​ P(A)中有2n个元素，表示成|P(A)|=2n 例题：设A={ {∅},{ {∅} } },计算 P(A) ​ ✔正确答案：P(A)={∅,{ {∅} },{ { {∅} } },{ {∅},{ {∅} } } } ​ ❌易错答案：P(A)={∅,{∅},{ {∅} },{ {∅},{ {∅} } } } ​ 自己是个集合，因此A中元素外边还要加一层{} 6.2 集合的运算并集 ∪交集 ∩相对补集 B-AB-A={x|x∈B∧x∉A} 对称差集 ⊕A⊕B=(A—B)∪(B—A) 或者A⊕B=(A∪B)-(A∩B) 绝对补集 ~给定了全集A，~A=E-A={x|x∈E∧x∉A} 广义并∪ 广义交∩ 广义运算可以转化为初级运算： 实例： 注意： ∪{ {a} }={a},∩{ {a} }={a} 集合的运算规则一类运算：广义运算、幂集和~运算， ​ 运算由右向左进行 二类运算：初级运算∪、∩、—、⊕ ​ 优先顺序由括号确定 混合运算：一类运算优先于二类运算 6.3有穷集的计数（21年不考）文氏图/韦恩图包容排斥原理 |A1∪A2|=|A1|+|A2|-|A1∩A2| 下面这一条不用记，等于|S|-|A1∪A2∪…∪An|，将上面公式代入即可 6.4 集合的恒等式P101 第七章 二元关系7.1 有序对和笛卡尔积有序对 &lt;x,y&gt;&lt;x,y&gt; 笛卡尔积 AXB定义：A,B为集合，用A中元素为第一元素，B中元素为第二元素构成的所有有序对组成的集合称为A和B的笛卡尔积 AXB={&lt;x,y&gt;|x∈A∧y∈B} 特别强调： (4)空集中取不出元素 A=B且C=D的必要条件是AXC=BXD，后不能推前。例如A={1},B={2},C=∅,D=∅ 7.2 二元关系二元关系定义：一个集合满足①集合非空，且它的元素都是有序对 或者②集合是空集 二元关系都可看作是某个笛卡尔集的子集 定义2A,B是集合，AXB的任何子集所定义的二元关系称作从A到B的二元关系(表示顺序)，特别当A=B是称作A上的二元关系 对于任一集合A定义 空关系 ∅对于任何集合A，空集∅是AXA的子集，称作A上的空关系 全域关系EAEA={&lt;x,y&gt;|x∈A∧y∈A}=AXA 恒等关系IAIA={&lt;x,x&gt;|x∈A} 单位阵（第一元素作行，第二元素作列） 小于等于关系LALA={&lt;x,y&gt;|x,y∈A,x≤y} 上三角矩阵 整除关系DADA={&lt;x,y&gt;|x,y∈A,x|y} x|y,即x是y的因子 包含关系R⊆R⊆={&lt;x,y&gt;|x,y∈A,x⊆y} 例如：A={∅,{a},{a,b} } R⊆={&lt;∅,∅&gt;,&lt;∅,{a}&gt;,&lt;∅, {a,b} &gt;,&lt;{a},{a}&gt;,&lt;{a},{a,b}&gt;,&lt;{a,b},{a,b}&gt;} 关系矩阵关系矩阵行表示第一元素，列表示第二元素，若xiRxj则是1，否则是0 关系图&lt;xi,xj&gt;，从xi到xj的有向边 7.3关系的运算定义域 domR第一元素的集合 值域 ranR第二元素的集合 域 fldR定义域和值域的并集，即第一元素和第二元素的集合 逆关系 R-1R-1={&lt;x,y&gt;|&lt;y,x&gt;∈R} 合成运算看作矩阵的乘法 限制取第一元素在A中的有序对。 xRy: 如果&lt;x,y&gt;∈R，记作xRy 像取限制的值域（第二元素的集合） 定理合成满足结合律；第二条看作矩阵的逆 IA看作单位阵 定理 7.4 合成运算与并满足分配律，但是和交运算不满足分配律，用包含于连接 定理 7.5 限制与交、并满足分配律；像与并满足分配律，与交不满足分配律 n次幂Rn的定义定义设R为A上的关系，n为自然数，则R的n次幂Rn定义为 1）R0={&lt;x,x&gt;|x∈A}=IA} 2）Rn+1=Rn∘R 注意：由定义1)我们可知∅0结果也是IA 关系矩阵有： 1）MR1∘R2=MR1MR2 2）MRn=MRn 注意：这里M带角标R表示的是R的关系矩阵 Rn重复性定理定理： 设A为n元集，R是A上的关系，则存在自然数s和t，使得Rs=Rt 理解 因为R是A上的关系，对于任何自然数k，Rk都是AXA的子集（二元关系都可以看作是某个笛卡尔积的子集）.又|AXA|=n2（A是n元集），所以其子集总数为2n2个。因此可知，Rk的取值情况是有限的，最多也就2n2个不同的值，然而R的幂是无穷多的，因此必有重复的 Rn关系图的规律 由定义可知R2=R∘R,这里假设等号右边取&lt;a,b&gt;,&lt;b,c&gt;,结果是&lt;a,c&gt;。此时在R和R2的关系图中我们可以看到R这边从第一个元素a走到b走了一步，b到c又走了一步一共走了两步对应到了R2中的a→c。而R上所有第一元素能走三步到另外一个元素的情况就构成了**R3**的关系图。 7.4 关系的性质自反与反自反 例题： 这里注意R2既不是自反，也不是反自反。因为定义中要求是对于任意的x而当x取1、2的时候在R2中都有对应的&lt;x,x&gt;。两个条件都不满足，故既不是自反，也不是反自反。 一个关系不可以既是自反又是反自反。 对称与反对称 例题： 这里R3是反对称因为前件为假，蕴含式结果为真而空集即是对称也是反对称也是前件为假的原因。 对称也就是说如果我R里面的有序对的元素是A的元素那么这些有序对的一二元素交换也得是我R里的元素 判断反对称只需要找x≠y的关系，如果有&lt;x,y&gt;那么&lt;y,x&gt;必不能在，对于所有的都满足那么就有是反对称的 传递 也就是说若R中有能合成的有序对，那么其结果也在R内。 关系性质的充分必要条件设R为A上的关系，则 五种性质：自反性、反自反性、对称性、反对称性、传递性 注意： 自反性是对于任意的x而言的，也就是说所有的&lt;x,x&gt;都应该在R里！反自反同理，即不能够出现&lt;x,x&gt;！ 一个关系不能既是自反的又是反自反的 一个关系可以既是对称的也是反对称的 例: A={1,2,3},R是A上的关系，R1={&lt;1,1&gt;,&lt;2,2&gt;}，R2={&lt;1,1&gt;,&lt;2,2&gt;,&lt;3,3&gt;,&lt;1,2&gt;}，R3={&lt;1,3&gt;} 答：R1具有对称性、反对称性，既不是自反也不是反自反；R2具有自反性；R3是反自反的。 用关系矩阵记忆：自反性则主对角线全是1，反自反性则主对角线上全是0，对称性矩阵是对称矩阵，反对称性若rij为1则rij为0，传递性，M2中1所在的位置对应M上也是1. 7.5 关系的闭包闭包就是最少的添加 闭包的关系图设关系R, r(R), s(R), t(R)的关系图分别记为 G ，Gr ， Gs ，Gt ,，则 Gr ，Gs ，Gt 的顶点集与 G 的顶点集相等. 除了 G 的边以外, 以下述方法添加新的边： (1) 考察G 的每个顶点, 若没环就加一个环，得到 Gr (2) 考察 G 的每条边, 若有一条xi 到 xj 的单向边, i≠j, 则在 G 中加一条xj 到 xi 的反向边, 得到 Gs (3) 考察 G 的每个顶点 xi , 找 xi 可达的所有顶点 xj (允许i=j )， 如果没有从 xi 到 xj 的边, 就加上这条边, 得到图 Gt tsr(R)=t(s(r(R)))，表示R的自反、对称、传递闭包，从里到外。 7.6 等价关系与划分等价关系设R为非空集合A上的关系。如果R是自反的、对称的和传递的，则称R为A上的等价关系。（对角线全为1，且是对称矩阵，M2的1对应M也是1） 等价类x的等价类 [x]R={y|y∈A∧xRy} 通俗来说就是R中哪些第一元素是x就把第二元素拿出来 商集设R为非空集合A上的等价关系，以R的所有等价类作为元素（不同块的集合）的集合成为A关于R的商集，记作A/R，即 A/R={[x]R|x∈A} 例如： 其中的等价类有：[1]=[4]=[7]={1,4,7}，[2]=[5]=[8]={2,5,8}，[2]=[6]={3，6} 商集为：{ {1,4,7}，{2,5,8}，{3,6} } 划分满足条件： 是A子集的构成的集合 空集不存在里面 子集的交集是空集 这个子集族π(A的子集构成的集合，π⊆P(A))的并集就是A 则称π是A的一个划分，称π中的元素为A的划分块。 例：A={a,b,c,d}，给定π1={ {a}，{a,b,c,d} }，π2={∅，{a,b}，{c,d} }，π3={ {a,b}，{c}，{d} }，则*π1和π2都不是A的划分，π3*是A的划分（可以不止一个划分）。 在等价关系中，划分就是商集，划分块就是等价类。 7.7 偏序关系小于等于设R为非空集合A上的关系。如果R是自反的、反对称的和传递的，则称R为A上的偏序关系，记为≼。设≼为偏序关系，如果&lt;x,y&gt;∈≼，则记作x≼y，读作x”小于等于“y。 注意：这里的”小于等于“（也可理解为大于等于）不是指数的大小，而是指在偏序关系中的顺序性。依照不同定义的序，x排在y的前边或者x就是y。 三种符号： xRy：&lt;x,y&gt;∈R x~y：&lt;x,y&gt;∈R且R是等价关系 x≼y：&lt;x,y&gt;∈R且R是偏序关系 例如，恒等关系IA，小于等于关系LA、整除关系DA和包含关系R⊆都是相应集合上的偏序关系。一般全域关系EA不是A上的偏序关系 定义： 若x≼y ∧ x ≠ y , 则记作x≺y,读作x小于y。 （x≺y说明&lt;x,y&gt;∈R∧x≠y） x与y可比有三种情况：x=y，x≺y，y≺x 例如，A={1,2,3}，≼是A上的整除关系，则有1≺2，1≺3；1=1，2=2，3=3；2和3不可比（不满足整除） 全序关系设R为非空集合A上的偏序关系，如果∀x,y∈A，x与y都是可比的，则称R为A上的全序关系 偏序集集合A和A上的偏序关系一起叫做偏序集≼，记作&lt;A,≼&gt;。 覆盖x≺y且 x，y 之间没别的元素，则称 y 覆盖 x。 哈斯图只连覆盖关系，y覆盖x则把y画在x上方 例：偏序集&lt;{1,2,3,4,5,6,7,8,9}，整除关系&gt;和&lt;P({a,b,c},R⊆)的哈斯图 最小元、最大元、极小元、极大元&lt;A,≼&gt;为偏序集，B⊆A，y∈B 最小(大)元：y小于(大于)等于B中的任何一个元素 极小(大)元：B中没有其他元素小于(大于)我 例：A={1,2,…,36}上的整除关系，B={2,3,4,12} 最小元：无（不会是2，因为2没办法整除3，不满足y小于等于B中的任何一个元素） 最大元：12（12可以大于等于2,3,4） 极小元：2，3（没有再可以整除2和3的了，有两个） 极大元：12（没有12能整除的数了） 上界、下界&lt;A,≼&gt;为偏序集，B⊆A，y∈A（y不同于上面的定义，这个范围更大） 上界和下界定义和最大元和最小元相同，不同的是y的范围。 C={y|y为B的上界}，则称C的最小元为B的最小上界或上确界。（上界中的最小） D={y|y为B的下界}，则称D的最大元为B的最大下界或下确界。（下界中的最大） 注意： B的上界、下界、最小上界、最大下界都可能不存在 如果存在，最小上界与最大下界是唯一的，而上下界不一定唯一 集合中如果存在最小元，那么这个最小元就是其最大下确界；最大元是上确界 画出哈斯图一般会有利于判断 例：A={1,2,…,36}整除关系，B={6,12,18}，C={4,6,12} B的最小元是6，下界是1,2,3,6。下确界即为最小元6 B的最大元没有，上界是36，上确界为36 C的最小元没有，下界是1,2，下确界为2 C的最大元为12，上界为12,24,36，上确界为最大元12 第十四章 图的基本概念14.1 图无序积：{ {a,b}|a∈A∧b∈B}，记作A&amp;B 无序积中的无序对记作(a,b) 二元组一个无向图G是一个有序的二元组&lt;V,E&gt;，其中 V是一个非空有穷集，称作顶点集，其元素称作顶点或结点 E是一个无序积V&amp;V的有穷多重子集(可重复)，称为边集，其元素称作无向边，简称为边 而有向图的二元组中的E的元素为有向边 图 图，有向图和无向图的统称 阶，顶点数称作图的阶，n个顶点的图称作n阶图 零图，一条边也没有的图；平凡图，1阶零图称作平凡图，只有一个顶点，没有边 定义中V要是非空的，但是运算中可能会出现顶点集为空集的情况，规定顶点集为空集的图为空图，记作∅ 如果给每一个顶点和每一条边指定一个符号，称这样的图为标定图，否则非标定图 相邻对于无向图，若两个顶点 vi 与 vj 之间有一条边连接，则称这两个顶点相邻。若两条边至少有一个公共端点，则称这两条边相邻 对于有向图，顶点之间有一条有向边则相邻，两条边一条的终点是另一条的起点，则两条边相邻 没有边关联的顶点称作孤立点 无向图G=&lt;V,E&gt;中， 邻域是所有与我相邻的点，不包括我自己 闭领域是邻域并上子集 关联集是所有与我关联的无向边(环那条也算) 有向图D=&lt;V,E&gt;中， 有向图的先驱元集和后继元集的定义中&lt;u,v&gt;,u不等于v，即不能是自己(环的情况) 邻域是先驱元集和后继元集的并 闭邻域即邻域加上自己 平行边无向图中，关联一对顶点的两条或以上的边为平行边 有向图中，关联一对顶点的有向边多于1条，称为平行边 简单图含平行边的图称作多重图(存在相同的无序对) 既不含平行边也不含环的图称作简单图 度数无向图中，v作为边的端点的次数称为度数，记为d(v) 有向图中，v作为边的始点的次数为v的出度，记为d+(v)；作为边的终点的次数为v的入度，记为d-(v) 度数列就是把各个顶点的度数列出来d(v1)= ,d(v2)=,… 最大度Δ(G)最小度(G)握手定理在任何无向图中，所有顶点的度数之和等于边数的2倍 可图化 给定的非负整数列d=(d1,d2,..,dn)，若存在以V={v1,v2,…,vn}为顶点集的n阶无向图G，使得d(vi)=di，则称d是可图化的（即每个顶点度数要够） 可简单图化：若得到的图是简单图，则d是可简单图化的 判断方法：非负整数列d=(d1,d2,..,dn)是可图化的当且仅当奇数度顶点个数为偶数 例：(3,3,2,1)和(3,2,2,1,1)奇数度顶点个数为3，不是偶数，不是可图画的。而(3,3,2,2)和(3,2,2,2,1)画一下图发现满足，是可图化的 完全图 n阶完全图，G中每个顶点均与其余的n-1个顶点相邻称为n阶无向完全图，简称n阶完全图 n阶有向完全图，有向图D中每个顶点都邻接到其余的n-1个顶点 n阶竞赛图，基图为Kn的有向简单图 14.2 通路与回路G为无项标定图，，G中顶点与边交替的序列Г=vi0ej1vi1ej2…ejlvil称为从起点vi0到终点vil的通路，Г中边的条数称为它的长度。 回路若起点和终点相同，则称Г为回路。 简单通路、简单回路若Г所有边各异，则称Г为简单通路；若简单回路的起点和终点相同，则称为简单回路。 初级通路、初级回路（圈）若所有顶点各异（除起点和终点可能相同外），所有边也各异，则称Г为初级通路；若又有起点和终点相同，则称为初级回路或圈 注意 初级包含于简单，简单回路包含于简单通路，但是初级回路和初级通路在应用中完全分开。 长为1的圈（初级回路）只能由环生成，长为2的圈只能由平行边生成；而在简单无向图中，圈的长度至少为3，因为简单无向图中没有环和平行边。 14.3 图的连通性距离d(u,v)无向图G中u,v之间长度最短的通路为u,v之间的短程线，短程线的长度成为u,v之间的距离，记作d(u,v)。 点割集、边割集全部拿掉后，连通分支数增加、只拿掉其中一部分不影响。 割点、桥点割集{v}，则v是割点，同理的边成为桥（割边）。 无向连通图不一定有点割集（如Kn），但一定有边割集（只要去掉足够多的边，一定会有点连不上） 点连通度k(G)、边连通度λ(G)想把我从连通图变为非连通图，则至少删去k个顶点/边 短程线、距离d&lt;vi,vj&gt; 短程线，最短的通路；短程线的长度称为距离 连通图、单向连通图、强连通图定义若有向图D的基图是连通图，则称D为弱连通图，简称为连通图。（一眼看上去是一个整体） 若∀vi,vj∈V,vi→vj与vj→vi至少成立其一，则称D为单向连通图。 若∀vi,vj∈V,均有vi↔vj，则称D为强连通图。（任意两点相互可达） 连通图⇒单向连通图⇒强连通图，条件要求越来越高 判别定理定理 14.8 有向图D=&lt;V,E&gt;是强连通图当且仅当D中存在经过每个顶点至少一次的回路。 定理 14.9 有向图D是单向连通图当且仅当D中存在经过每个顶点至少一次的通路。（只需证vi可达vj或vj可达vi） 二部图将无向图划分成两部分V1和V2，使得每条边的两个端点都是一个属于V1，一个属于V2，则称无向图G为二部图。（环一定不是） 若G是简单二部图且V1中的每个顶点与V2中所有顶点相邻（有一条边相连），则称G为完全二部图，记为Kr,s,其中r=|V1|,s=|V2|。 注意：n(n≥2)阶零图为二部图 将图按如下方式尝试分成两部分，判断(a)为二部图 （e)为完全二部图，上面r个点，下面s个点，共有rxs条边，点连通度为min{r,s}，即拿掉少的部分的所有点；边连通度也为min{r,s}，即拿掉一个点的所有边。 14.4 图的矩阵表示关联矩阵M(G)关联矩阵表示的是顶点和边的关系，行是各点，列是各边，记录关联次数（注意无向图中环的点边关联次数为2） 有向图中无环的关联矩阵中，用1表示这个点是这条边的始点，0表示不关联，-1表示这个点是这条边的终点 邻接矩阵A(D) (有向图)有向图，表示从顶点vi邻接到顶点vj有多少条边，行和列都是点。 vi指向vj才加1，环自身加1 邻接矩阵A和Al反应的几个信息： aij(l)为D中vi到vj长度为 l 的通路数 对角线上的aii(l)表示到自身长度为 l的回路数 矩阵所有元素之和表示D中长度为 l 的通路（含回路）总数 其中对角线元素之和表示长度为 l 的回路总数 可达矩阵P(D) (有向图)首先首先，对角线先全标上1，自己可达自己 vi可达vj则标上1，否则为0 注意：什么叫可达？不是说一步走到是可达，而是存在通路即可，走多少步没关系，只要能走到就是可达！ D为强连通当且仅当P(D)为全1矩阵 第十五章 欧拉图与哈密顿图15.1 欧拉图欧拉通路通过图（无向图或有向图）中所有边一次且仅一次行遍所有顶点的通路称作欧拉通路。 欧拉回路通过图中所有边一次且仅一次行遍所有顶点的回路称作欧拉回路。 欧拉图具有欧拉回路的图称作欧拉图。 半欧拉图具有欧拉通路而无欧拉回路的图称作半欧拉图。 注意1 规定平凡图是欧拉图。(平凡图是只有一个孤立点组成的图) 欧拉通(回)路是简单通(回)路，但不一定是初级通(回)路。因为欧拉可以走环，而走了环就不满足所有点各异的条件，也就不是初级。 无向欧拉图的判别方法定理15.1 无向图G是欧拉图当且仅当G是连通图且没有奇度顶点。 ​ 即顶点的度数为偶数。理解：因为经过一个点需要走进来再走出去，而度数是由边提供的，故顶点度数为偶数。 定理 15.2 无向图G是半欧拉图当且仅当G是连通的且恰有两个奇度顶点。 有向欧拉图的判别方法定理 15.3 有向图D是欧拉图当且仅当D是强连通的且每个顶点的入度等于出度（度数为偶）。 ​ 一个图要是欧拉图它得首先是个强连通图。 定理 15.4 有向图D是半欧拉图当且仅当D是单向连通的且恰有两个奇度顶点，其中一个顶点的入读比出度大1，另一个顶点的出度比入度大1，而其余顶点的入度等于出度。 ​ 一个图是半欧拉图它得首先是个单向连通图 定理15.5G是非平凡的欧拉图当且仅当G是连通的且是若干个边不重的圈（无向）的并。 很好理解，如果是若干个边不重的圈的并，那么每个点度数都为偶 15.2 哈密顿图 经过图（有向图或无向图）中所有顶点一次且仅一次的初级通路称为哈密顿通路。 经过图中所有顶点一次且仅一次的初级回路称为哈密顿回路。 具有哈密顿回路的图称为哈密顿图。 具有哈密顿通路但不具有哈密顿回路的图称为半哈密顿图。 首先哈密顿通路一定是初级通路。但是对于哈密顿回路，如果加是初级回路的前提，那么哈密顿回路可以不是初级回路，例如v1ev2ev1，出现了重复的边，不是初级回路，但它确实是经过所有顶点一次且仅一次的回路。 哈密顿图的必要条件定理15.6 无向图G&lt;V,E&gt;是哈密顿图，则对于任意V1⊂V,且 V1≠∅，均有**p(G-V1)≤|V1|**。 ​ p是连通分支数，理解:分两种情况，一种v1,v2不相邻，去掉三个点，连通分支数为3；一种v1,v2相邻，与v3不相邻，去掉后两部分；当然如果都相邻去掉后为1，都满足p≤3 是半哈密顿图，则有p(G-V1)≤|V1|+1 作为必要条件，用来初步判断其不是哈密顿图/半哈密顿图 看看完全二部图什么时候是哈密顿图，用必要条件初步判别 哈密顿图的充分条件G为n阶无向简单图，若对于G中任意不相邻的顶点u,v,均有度数和d(u)+d(v)≥n-1，则G中存在哈密顿通路。 （存在哈密顿通路说明其可能是哈密顿图也可能是半哈密顿图 推论：设G为n(n≥3)阶无向简单图，若对于G中任意两个不相邻的顶点u*,v均有 d(u)+d(v)≥n*则 G 中存在哈密顿图 哈密顿图解决实际问题","link":"/2022/07/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"title":"微信小程序学习笔记","text":"Keys云数据库查询获取不到数据 云数据库get出来是空数组，一般是因为没有打开权限，修改为”所有用户可读即可”。 where条件查询要添加查询的索引，如果传入的是undefined会获取该数据集合的全部记录 调试！调试！调试！，如果获取到undefined注意多调试，可能是对象属性的问题，例如一般返回res，而res下还有一层data,因此获取想要的字段数据一般是res.data[0].[字段名] 异步同步问题特别是数据库的请求是异步的这个千万注意。 解决办法：网上大致用Promise 我也没有自己研究，我的解决办法是涉及到数据库的写成一个函数然后调用函数的时候设置2秒延时执行。 123setTimeout(()=&gt; //调用数据库 ,2000) 请求数据限制云数据库请求记录数据有20段的限制(偶然发现获取到的数据少了一些才查到这个规则)，建议把多的数据打包成数组放在一个字段里。 网上有分页方法还没学会，但是显然是提前打包好数据更为省事。 数组值传递的时候变字符串在查bug的时候发现数组totalIncomeKeep=[ , , ]在经过options传值后变成了totalIncomeKeep= , , ,，查了一下是字符串类型。刚开始尝试 JSON.parse()但是发现他是把将数组字符串转为数组对象。 ​ 应该使用totalIncomeKeep.split(&quot;,&quot;)，传过来的字符串就是按“，”分割的，这是直接用str.split(&quot;,&quot;)就成了！ 实用组件模板1.返回前页1234wx.navigateBack({ delta:4//delta值就是往前返回几页}) 2.输入框+滑动两种输入数值方式​ input和text同行,同时滑动块根据输入框动态改变，当输入值小于滑动范围时会提示过小(大)。 wxml12345678910&lt;view wx:if='{{!changeStatus}}' class=&quot;view-contain-ti&quot;&gt; &lt;!-- 设置面积 --&gt; &lt;!-- &lt;text class=&quot;text-ti&quot;&gt;设置民宿面积&lt;/text&gt; --&gt; &lt;view style=&quot;display:flex;align-items:center&quot;&gt; &lt;text&gt;设置民宿面积(平方米):&lt;/text&gt;&lt;input class=&quot;inputl&quot; bindinput=&quot;usernameInput&quot; placeholder=&quot;输入5-500的数字&quot; value=&quot;{{inputValue}}&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;intro&quot;&gt; &lt;slider bindchange=&quot;sliderchange&quot; min=&quot;{{minValue}}&quot; max=&quot;{{maxValue}}&quot; block-size=&quot;20&quot; value=&quot;{{areaValue}}&quot; show-value /&gt; &lt;/view&gt;&lt;/view&gt; js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//实时获取数据 usernameInput: function (e) { let value = this.validateNumber(e.detail.value); if(value&lt;=500&amp;&amp;value&gt;=5){ this.setData({ areaValue: value }) }else if(value&lt;5){ wx.showToast({ title: &quot;面积设置过小！&quot;, // 提示的内容 icon: &quot;none&quot;, // 图标，默认success image: &quot;&quot;, // 自定义图标的本地路径，image 的优先级高于 icon duration: 700, // 提示的延迟时间，默认1500 mask: false, // 是否显示透明蒙层，防止触摸穿透 }) this.setData({ areaValue: 5 }) }else if(value&gt;500){ wx.showToast({ title: &quot;面积设置过大！&quot;, // 提示的内容 icon: &quot;none&quot;, // 图标，默认success image: &quot;&quot;, // 自定义图标的本地路径，image 的优先级高于 icon duration: 700, // 提示的延迟时间，默认1500 mask: false, // 是否显示透明蒙层，防止触摸穿透 }) this.setData({ areaValue: 500 }) }else{ this.setData({ areaValue: 5, inputValue:'' }) } }, //数字限制 validateNumber(val) { return val.replace(/\\D/g, '') }, /** * slider滑动监听事件,滑动选择面积大小 */ sliderchange: function (e) { this.setData({ textValue: '设置民宿面积:' + e.detail.value + ' 平方米', areaValue: e.detail.value, inputValue:e.detail.value }) console.log(`当前值`, this.data.areaValue) }, 3.自定义弹窗​ 通过wx:if控制view的显隐实现弹窗效果，可以关注一下wxss的相关样式 wxml1234567891011121314&lt;view wx:if='{{showModal}}'&gt; &lt;view class='mask_layer' bindtap='modal_click_Hidden' /&gt; &lt;view class='modal_box'&gt; &lt;view class=&quot;title&quot;&gt;标题&lt;/view&gt; &lt;view class='content'&gt;&lt;!-- 弹窗内容--&gt; &lt;text class='modalMsg'&gt;&lt;/text&gt; &lt;/view&gt; &lt;view class='btn1'&gt; &lt;view bindtap='modal_click_Hidden' class='cancel'&gt;取消&lt;/view&gt; &lt;view bindtap='Sure' class='Sure'&gt;确定&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; wxss12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.mask_layer { width: 100%; height: 100%; position: fixed; z-index: 999; left:0;top:0; background: #000; opacity: 0.5; overflow: hidden;}.modal_box { width: 76%; overflow: hidden; position: fixed; top: 50%; left: 0; z-index: 1001; background: #fafafa; margin: -150px 12% 0 12%; border-radius: 3px;}.title { padding: 15px; text-align: center; background-color: gazure;}.content { overflow-y: scroll; /*超出父盒子高度可滚动*/}.input_show1{ margin: 0 auto; width: 80%; margin-left: 10%; font-size: 32rpx; text-align: center; }.btn1 { width: 100%; margin-top: 65rpx; display: flex; flex-direction: row; align-items: center; justify-content: space-between; box-sizing: border-box; background-color: white;}.cancel { width: 100%; padding: 10px; text-align: center; color: black;}.Sure { width: 100%; padding: 10px; color: #44b549; background-color: white; border-left: 1px solid #d0d0d0; text-align: center;}.modalMsg { text-align: center; margin-top: 45rpx; display: block;} js123456789101112131415showCancelOrder: function() { this.setData({ showModal:true }) }, //取消 modal_click_Hidden: function () { this.setData({ showModal: false, }) }, // 确定 Sure: function () { }, 4.数据可视化点击后显示坐标点的信息 ​ 下载echarts的微信小程序版本：echarts-for-weixin ，地址在：https://github.com/ecomfe/echarts-for-weixin，下载后解压，只需要其中的ec-canvas文件夹。 ​ 在需要引用echarts的页面json文件中，添加echarts引用（注意echarts的相对路径）： 123456{ &quot;usingComponents&quot;: { &quot;ec-canvas&quot;: &quot;../../ec-canvas/ec-canvas&quot; }, &quot;navigationBarTitleText&quot;: &quot;详情&quot;} ​ 在需要引用echarts的js文件中，引入echars.js： 1import * as echarts from '../../ec-canvas/echarts'; wxml12345&lt;!--wxml--&gt;&lt;view class=&quot;echart_panel&quot;&gt; &lt;ec-canvas id=&quot;mychart&quot; canvas-id=&quot;mychart-line&quot; ec=&quot;{{ ec }}&quot; &gt;&lt;/ec-canvas&gt;&lt;/view&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!--js--&gt;//在外部import * as echarts from '../../components/ec-canvas/echarts';const app = getApp();let chart;//在PageonLoad:function(){ this.initChart();}/**设置图表映射 */ initChart: function (xData, yData) { this.ecComponent = this.selectComponent('#mychart'); var that = this; var option = { grid: { containLabel: true }, tooltip: {//重写图表提示内容 show: true, trigger: 'axis', position: ['50%', '30%'], formatter: function (params) { return params[0].axisValue + ': ' + params[0].data + '元' } }, xAxis: { type: 'category', name:'时间', data: xData,//异步请求的数据 nameTextStyle: { fontSize: 10 }, splitLine: { show: true } }, yAxis: { type: 'value', title: '收益', name:'元', axisLabel: { formatter: function (p) {//重写y坐标数值单位 return p; } }, nameTextStyle: { fontSize: 15 } }, series: [{ name: '总收益', data: yData,//异步请求的数据 type: 'line', label: { show: true } }], dataPointShape: true, //是否在图标上显示数据点标志 }; //echarts会继承父元素的宽高,所以我们一定要设置echarts组件父元素的高度。 var myChart = that.ecComponent.init((canvas, width, height) =&gt; { const chart = echarts.init(canvas, null, { width: width, height: height, }); //此处为折线图的点击事件，点击展示折点信息 chart.on('click', function (handler, context) { var handlerValue = handler.name + ' : ' + handler.value+'元' wx.showToast({ title: handlerValue, icon: 'none', duration: 1200, mask: true }) }); //给echarts 设置数据及配置项（图表类型、数据量等） chart.setOption(option); return chart; }); }, wxss12345&lt;!-- wxss --&gt;.echart_panel { width: 100%; height: 700rpx; } 5.循环渲染多选框同时根据条件显示样式​ 设定的样式至少有五种，根据选项设定的权重来显示不同的样式（大于两种）。只在网上查到了运用三目运算符，没有多想，误以为只能设置两种。后来想到可以嵌套。！ wxml123456789101112&lt;view class=&quot;every_tab&quot;&gt; &lt;checkbox-group bindchange=&quot;checkboxChange3&quot; class=&quot;select&quot;&gt; &lt;!-- 循环时外层是items 内层的单个对象是item--&gt; &lt;label class=&quot;cell&quot; wx:for=&quot;{{items}}&quot; wx:if=&quot;{{index&gt;78}}&quot; wx:key=&quot;value&quot;&gt; &lt;!-- 三目运算符嵌套 根据items数组内对象的weight属性条件来显示样式--&gt; &lt;view class=&quot;{{item.weight==1?'weight1':(item.weight==2?'weight2':(item.weight==3?'weight3':(item.weight==4?'weight4':'weight5')))}}&quot;&gt; {{item.name}} &lt;checkbox value=&quot;{{item.value}}&quot; checked=&quot;{{item.checked}}&quot; /&gt; &lt;/view&gt; &lt;/label&gt; &lt;/checkbox-group&gt; &lt;/view&gt; wxss123456789101112131415161718.weigth1{ color: black;}.weight2{ color: green;}.weight3{ color: aqua;}.weight3{ color: blue;}.weight4{ color: blueviolet;}.weight5{ color: purple;} js12345678910111213141516171819202122232425262728data:{ items: [ { value: '1', weight: 1, name: '床品每客一换' }, { value: '2', weight: 1, name: '行李寄存' }, { value: '3', weight: 2, name: '自助入住' }, { value: '4', weight: 2, name: '保安' }, { value: '5', weight: 3, name: '管家式服务' }, { value: '6', weight: 4, name: '床品一天一换' },}, /*设施多选框 */ checkboxChange(e) { console.log('checkbox发生change事件，携带value值为：', e.detail.value) const items = this.data.items const values = e.detail.value for (let i = 0, lenI = 6; i &lt; lenI; ++i) { items[i].checked = false for (let j = 0, lenJ = values.length; j &lt; lenJ; ++j) {//遍历 if (items[i].value === values[j]) { items[i].checked = true; break; } } } this.setData({ items }) }, 6.进度条 属性 类型 默认值 必填 说明 percent number 否 百分比0~100 show-info boolean false 否 在进度条右侧显示百分比 wxml1234&lt;view class=&quot;progress-box&quot;&gt; &lt;text &gt;进度：&lt;/text&gt; &lt;progress percent=&quot;{{persent}}&quot; show-info stroke-width=&quot;3&quot; /&gt;&lt;/view&gt; wxss1234.progress-box{ width:85%; margin-left:70rpx;} 7.搜索框首页的搜索框，点击后进入搜索页面 Searchinput组件首先在components文件下准备一个Searchinput组件 Searchinput.wxml12345&lt;view class=&quot;search_input&quot;&gt; &lt;navigator url=&quot;/pages/search/index&quot; open-type=&quot;navigate&quot; class=&quot;Searchinput_navigator&quot;&gt; &lt;text &gt;搜索&lt;/text&gt; &lt;/navigator&gt;&lt;/view&gt; Searchinput.wxss123456789.search_input .Searchinput_navigator { height: 100%; display: flex; justify-content: center; align-items: center; background-color: white; border-radius: 50rpx; color: #666;} Searchinput.js不需要修改 然后再添加一个search界面 search界面search.wxml123456789101112131415161718192021222324252627&lt;view class=&quot;page&quot;&gt; &lt;view class=&quot;page__bd&quot;&gt; &lt;view class=&quot;weui-search-bar&quot;&gt; &lt;view class=&quot;weui-search-bar__form&quot;&gt; &lt;view class=&quot;weui-search-bar__box&quot;&gt; &lt;icon class=&quot;weui-icon-search_in-box&quot; type=&quot;search&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;input type=&quot;text&quot; class=&quot;weui-search-bar__input&quot; placeholder=&quot;搜索&quot; value=&quot;{{inputVal}}&quot; focus=&quot;{{inputShowed}}&quot; bindinput=&quot;inputTyping&quot; /&gt; &lt;view class=&quot;weui-icon-clear&quot; wx:if=&quot;{{inputVal.length &gt; 0}}&quot; bindtap=&quot;clearInput&quot;&gt; &lt;icon type=&quot;clear&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;/view&gt; &lt;/view&gt; &lt;label class=&quot;weui-search-bar__label&quot; hidden=&quot;{{inputShowed}}&quot; bindtap=&quot;showInput&quot;&gt; &lt;icon class=&quot;weui-icon-search&quot; type=&quot;search&quot; size=&quot;14&quot;&gt;&lt;/icon&gt; &lt;view class=&quot;weui-search-bar__text&quot;&gt;搜索&lt;/view&gt; &lt;/label&gt; &lt;/view&gt; &lt;view class=&quot;weui-search-bar__cancel-btn&quot; hidden=&quot;{{!inputShowed}}&quot; bindtap=&quot;hideInput&quot;&gt;取消&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;weui-cells searchbar-result&quot; wx:if=&quot;{{inputVal.length &gt; 0}}&quot; wx:for=&quot;{{search_list1}}&quot; wx:key=&quot;dessay_id&quot;&gt; &lt;navigator url=&quot;/pages/essays_detail/index?essay_id={{item.dessay_id}}&quot; class=&quot;weui-cell&quot; hover-class=&quot;weui-cell_active&quot;&gt; &lt;view class=&quot;weui-cell__bd&quot;&gt; &lt;view&gt;{{item.dessay_title}}&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; search.wxss​ 这里需要添加weui，可以上网上(或者到仓库里)找然后修改文件路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/*** Tencent is pleased to support the open source community by making* WeUI-WXSS available.* * Copyright (C) 2017 THL A29 Limited, a Tencent company.* All rights reserved.* * Licensed under the MIT License (the &quot;License&quot;); you may not use* this file except in compliance with the License. You may obtain a copy of* the License at* * http://opensource.org/licenses/MIT* * Unless required by applicable law or agreed to in writing, software* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.* See the License for the specific language governing permissions and* limitations under the License.*/@import &quot;base/reset.wxss&quot;;@import &quot;widget/weui-cell/weui-cell.wxss&quot;;@import &quot;./widget/weui-searchbar/weui-searchbar.wxss&quot;;page { background-color: white; padding: 20rpx;}.search_row { height: 60rpx; display: flex;}.search_row input { background-color: #dedede; flex: 1; height: 100%; padding-left: 30rpx;}.search_row button { background-color: white; width: 100rpx; height: 100%; font-size: 28rpx; padding: 0; margin: 0 10rpx; display: flex; justify-content: center; align-items: center;}.search_content { margin-top: 30rpx;}.search_content .search_item { background-color: white; font-size: 26rpx; padding: 15rpx 10rpx; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;} search.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Page({ /** * 页面的初始数据 */ data: { inputVal: '', inputShowed: false, search_list1: [], }, showInput: function () { this.setData({ inputShowed: true }); }, hideInput: function () { this.setData({ inputVal: &quot;&quot;, inputShowed: false }); }, clearInput: function () { this.setData({ inputVal: &quot;&quot; }); }, inputTyping: function (e) { this.setData({ inputVal: e.detail.value }); //连接数据库 const db = wx.cloud.database() var that = this db.collection('essays_detail').where({ //使用正则查询，实现对搜索的模糊查询 dessay_title: db.RegExp({ regexp: e.detail.value, //从搜索栏中获取的value作为规则进行匹配。 options: 'i', //大小写不区分 }), }).limit(10).get({ success: res =&gt; { that.setData({ search_list1: res.data }) } }) } }) 8.分类栏 在component文件夹下准备Cater组件： Cater.wxml1234567&lt;view&gt;&lt;scroll-view class=&quot;tab-list&quot; scroll-x scroll-with-animation&gt;&lt;view wx:for=&quot;{{tabs}}&quot; wx:key=&quot;id&quot; class=&quot;tab-item {{item.isActive ? 'active':''}}&quot; data-index=&quot;{{index}}&quot; bindtap=&quot;handleItemTap&quot;&gt;{{item.name}}&lt;/view&gt;&lt;/scroll-view&gt;&lt;slot&gt;&lt;/slot&gt; &lt;/view&gt; Cater.wxss12345678910111213141516171819202122.tab-list { width: 100%; height: 88rpx; border-bottom: 1rpx solid #e5e5e5; display: inline-block; white-space: nowrap; } .tab-item { width: 188rpx; height: 85rpx; display: inline-block; line-height: 85rpx; vertical-align: middle; text-align: center; } .active { color: red; border-bottom: 5rpx solid red; } Cater.js123456789101112131415161718192021222324252627282930313233343536Component({ properties:{ tabs:{ type:Array, value:[] } }, data: { }, //组件.js存放事件回到函数在methods中 methods:{ handleItemTap(e){ /* 1 1 绑定点击事件 2 获取被点击的索引 3 获取原数组 4 对数组循环 1 给每一个循环性 选中属性 改为 false 2 给 当前的索引的 项添加激活选中效果就可以了 */ // 2 获取索引 const {index}=e.currentTarget.dataset; // 传递事件给父组件 this.triggerEvent(&quot;itemChange&quot;,{index}); // 3 获取data中的数组 // 解构 对 复杂类型进行结构 复制了一份 变量引用而已 let {tabs}=this.data; // 4 循环数组 tabs.forEach((v,i) =&gt;i===index?v.isActive=true:v.isActive=false ) this.setData({ tabs }) }, } }) 然后在需要添加分类栏的界面： index.json先引入Cater组件 12345678910{ &quot;usingComponents&quot;: { &quot;Cater&quot;:&quot;../../components/Cater/Cater&quot; }, &quot;navigationBarTitleText&quot;: &quot;首页&quot;, &quot;enablePullDownRefresh&quot;:true, &quot;onReachBottomDistance&quot;:50, &quot;backgroundColor&quot;: &quot;#efefef&quot;, &quot;backgroundTextStyle&quot;: &quot;dark&quot;} index.wxml12345&lt;!-- 分类栏 --&gt; &lt;Cater tabs=&quot;{{tabs}}&quot; binditemChange=&quot;handleItemChange&quot;&gt;&lt;/Cater&gt; &lt;!-- 以下根据点击分类呈现相应的内容显示在block中--&gt; &lt;block wx:if=&quot;{{tabs[0].isActive}}&quot;&gt;&lt;/block&gt; &lt;block wx:if=&quot;{{tabs[1].isActive}}&quot;&gt;&lt;/block&gt; index.js1234567891011121314151617181920212223242526272829303132data: { tabs: [{ id: 1, name: &quot;推荐&quot;, isActive:true }, { id: 2, name: &quot;文创&quot;, isActive:false }, { id: 3, name: &quot;时装&quot;, isActive:false }, { id: 4, name: &quot;节目&quot;, isActive:false } ] },handleItemChange(e){ const {index}=e.detail; let {tabs}=this.data; // 4 循环数组 tabs.forEach((v,i) =&gt;i===index?v.isActive=true:v.isActive=false ) this.setData({ tabs }) }, 9.地图颜色块图例 wxml123456789101112131415161718&lt;!-- 图例 --&gt; &lt;view class=&quot;btm_tool&quot;&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label1&quot;&gt;111&lt;/view&gt;&lt;view &gt;1级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label2&quot;&gt;111&lt;/view&gt;&lt;view &gt;2级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label3&quot;&gt;111&lt;/view&gt;&lt;view &gt;3级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label4&quot;&gt;111&lt;/view&gt;&lt;view &gt;4级&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;label5&quot;&gt;111&lt;/view&gt;&lt;view &gt;5级&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; wxss1234567891011121314151617181920.btm_tool { border-top: 1rpx #ccc; position: fixed; left: 0; bottom: 20rpx; width: 100%; height: 100rpx; background-color: #fff; display: flex; z-index:200;}.btm_tool .tool_item { flex: 6; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative; font-size: 20px;} 10.收藏功能​ 在文章详情页点击“收藏”，就会在收藏夹”喜爱“界面出现文章的入口。 在需要添加收藏功能的页面： wxml12345&lt;view class=&quot;tool_item&quot;&gt; &lt;view class=&quot;iconfont {{isCollect?'icon-shoucang1':'icon-shoucang'}}&quot; bindtap=&quot;handleCollect&quot;&gt;&lt;/view&gt; &lt;view&gt;收藏&lt;/view&gt;&lt;/view&gt; wxss1234567891011.tool_item { flex: 2; display: flex; flex-direction: column; justify-content: center; align-items: center; position: relative;}.tool_item .icon-shoucang1 { color: orange;} js1234567891011121314151617181920212223242526272829303132333435363738394041 data: { // 是否被收藏 isCollect:false, },// 点击收藏图标 handleCollect(){ let isCollect=false; // 1 获取缓存中的收藏数组 let collect=wx.getStorageSync(&quot;collect&quot;)||[]; // 2 判断文章是否被收藏过 let index=collect.findIndex(v=&gt;v.dessay_id===this.EssaysInfo.dessay_id) // 3 当index!=-1 表示已经收藏过了 if(index!==-1){ // 已经收藏过了 在数组中删除 collect.splice(index,1); isCollect=false; // 弹窗提示 wx.showToast({ title: '取消成功', icon: 'success', mask: true }); }else{ // 没有收藏过 添加 collect.push(this.EssaysInfo); isCollect=true; // 弹窗提示 wx.showToast({ title: '收藏成功', icon: 'success', mask: true }); } // 4 把数组存入到缓存中 wx.setStorageSync(&quot;collect&quot;,collect); // 5 修改data中的属性 isCollect this.setData({ isCollect }) }, 然后在收藏夹界面： wxml12345678910111213141516&lt;view&gt; &lt;navigator class=&quot;essays_item&quot; wx:for=&quot;{{collect}}&quot; wx:key=&quot;essay_id&quot; url=&quot;/pages/essays_detail/index?essay_id={{item.dessay_id}}&quot;&gt; &lt;!-- 左侧图片 --&gt; &lt;view class=&quot;essays_img_wrap&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.dessay_img}}&quot;/&gt; &lt;/view&gt; &lt;!-- 右侧标题 --&gt; &lt;view class=&quot;essays_info_wrap&quot;&gt; &lt;view class=&quot;essays_title&quot;&gt;{{item.dessay_title}}&lt;/view&gt; &lt;view class=&quot;essays_src&quot;&gt;{{item.dessay_src}}&lt;/view&gt; &lt;/view&gt; &lt;/navigator&gt;&lt;/view&gt; wxss1234567891011121314151617181920212223242526272829303132333435/* pages/like/index.wxss */page { background-color: #f3f4f6;}.essays_item { display: flex; border-bottom: 1px solid #ccc;}.essays_item .essays_img_wrap { width: 70%; flex: 2; display: flex; justify-content: center; align-items: center; height: 300rpx;}.essays_item .essays_img_wrap image { width: 70%;}.essays_item .essays_info_wrap { flex: 3; display: flex; flex-direction: column; justify-content: space-around;}.essays_item .essays_info_wrap .essays_title { font-family: cursive; font-size: 45rpx; font-weight: bold; color: #000;}.essays_item .essays_info_wrap .essays_src { color: #dedede;} js1234567891011121314151617// pages/like/index.jsPage({ /** * 页面的初始数据 */ data: { collect:[] }, onShow(){ const collect= wx.getStorageSync(&quot;collect&quot;)||[]; this.setData({ collect }); } }) 图标还需要引入一下 app.wxss1@import &quot;./styles/iconfont.wxss&quot;; iconfont.wxss1234567891011121314151617181920212223@font-face { font-family: &quot;iconfont&quot;; /* Project id 3280754 */ src: url('//at.alicdn.com/t/font_3280754_152au8amv0n.woff2?t=1650717301641') format('woff2'), url('//at.alicdn.com/t/font_3280754_152au8amv0n.woff?t=1650717301641') format('woff'), url('//at.alicdn.com/t/font_3280754_152au8amv0n.ttf?t=1650717301641') format('truetype');}.iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}.icon-shoucang:before { content: &quot;\\e8b9&quot;;}.icon-shoucang1:before { content: &quot;\\e8c6&quot;;} 11.循环渲染板块 12345678910&lt;view class=&quot;box1&quot; wx:for=&quot;{{achievement}}&quot; wx:key=&quot;item&quot;&gt; &lt;view class=&quot;success_img_wrap&quot;&gt; &lt;image mode=&quot;widthFix&quot; src=&quot;{{item.img}}&quot;/&gt; &lt;/view&gt; &lt;view class=&quot;success_info_wrap&quot; &gt; &lt;view class=&quot;success_title&quot;&gt; {{item.title}} &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; 12345678910111213141516171819202122232425262728293031.box1 { display: flex; border-bottom: 1px solid #ccc;}.success_img_wrap { width: 60%; flex: 2; display: flex; justify-content: center; align-items: center; height: 250rpx;}.success_img_wrap image { width: 50%;}.success_info_wrap { flex: 3; display: flex; flex-direction: column; justify-content: space-around;}.success_title { font-family: cursive; font-size: 40rpx; font-weight: bold; color: #000;} 地图相关获取中心点坐标12345678910111213141516//监听拖动地图，拖动结束根据中心点更新页面 mapChange: function (e) { let self = this; if (e.type == 'end' &amp;&amp; (e.causedBy == 'scale' || e.causedBy == 'drag')){ self.mapCtx.getCenterLocation({ success: function (res) { self.setData({ nearList:[]， latitude: res.latitude, longitude: res.longitude, }) self.nearby_search(); } }) } 微信小程序——打开地图 选择位置 完整功能实现代码(定位，检索周边，可移动选点，可搜索，腾讯地图API)源码： CSDN: 微信小程序——打开地图选择位置信息完整功能实现代码(定位，可移动选点，可搜索，腾讯地图API)_微信小程序打开地图标点收藏-HTML5代码类资源-CSDN下载 github: https://github.com/mcky1928/map 效果： wxml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;!--pages/shopMap/shopMap.wxml--&gt;&lt;!--绑定点击事件--&gt;&lt;!--绑定输入事件--&gt;&lt;view wx:if=&quot;{{addListShow}}&quot;&gt;&lt;view class=&quot;top&quot;&gt; &lt;view class=&quot;back iconfont icon-fanhui&quot; bindtap=&quot;back1&quot;&gt;&lt;/view&gt; &lt;view class=&quot;search-box {{addListShow?'search-box1':''}}&quot;&gt; &lt;view class=&quot;region&quot; bindtap=&quot;chooseCity&quot;&gt;{{currentRegion.district}}&lt;/view&gt; &lt;view class=&quot;shu&quot;&gt;&lt;/view&gt; &lt;input bindinput=&quot;getsuggest&quot; placeholder=&quot;请输入您的店铺地址&quot;&gt;&lt;/input&gt; &lt;/view&gt;&lt;/view&gt;&lt;!--关键词输入提示列表渲染--&gt;&lt;view class=&quot;add-list-box&quot;&gt;&lt;scroll-view class=&quot;add-list&quot; scroll-y&gt; &lt;view class=&quot;add-item&quot; wx:for=&quot;{{suggestion}}&quot; wx:key=&quot;index&quot;&gt; &lt;!--绑定回填事件--&gt; &lt;view bindtap=&quot;backfill&quot; id=&quot;{{index}}&quot; data-name=&quot;{{item.title}}&quot;&gt; &lt;!--根据需求渲染相应数据--&gt; &lt;!--渲染地址title--&gt; &lt;view class=&quot;title&quot;&gt;{{item.title}}&lt;/view&gt; &lt;!--渲染详细地址--&gt; &lt;view class=&quot;add&quot;&gt;{{item.addr}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt;&lt;/view&gt;&lt;/view&gt; &lt;view wx:if=&quot;{{!addListShow &amp;&amp; !chooseCity}}&quot;&gt;&lt;!--地图容器--&gt;&lt;map id=&quot;myMap&quot; style=&quot;width:100%;height:300px;&quot; longitude=&quot;{{longitude}}&quot; latitude=&quot;{{latitude}}&quot; scale=&quot;17&quot; bindregionchange=&quot;mapChange&quot;&gt; &lt;cover-view class=&quot;top&quot;&gt; &lt;cover-view class=&quot;back&quot; bindtap=&quot;back1&quot;&gt; &lt;cover-image src=&quot;../../images/back.png&quot;&gt;&lt;/cover-image&gt; &lt;/cover-view&gt; &lt;cover-view class=&quot;search-box&quot;&gt; &lt;cover-view class=&quot;region&quot; bindtap=&quot;chooseCity&quot;&gt;{{currentRegion.district}}&lt;/cover-view&gt; &lt;cover-view class=&quot;shu&quot;&gt;&lt;/cover-view&gt; &lt;cover-view class=&quot;placeholder&quot; bindtap=&quot;showAddList&quot;&gt;请输入您的店铺地址&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt; &lt;cover-view class=&quot;map-prompt&quot;&gt;您可拖动地图, 标记店铺准确位置&lt;/cover-view&gt; &lt;cover-image class=&quot;current-site-icon&quot; src=&quot;../../images/my_marker.png&quot;&gt;&lt;/cover-image&gt; &lt;cover-view class=&quot;reload&quot; bindtap=&quot;reload&quot;&gt; &lt;cover-view class=&quot;center1&quot;&gt; &lt;cover-view class=&quot;center2&quot;&gt;&lt;/cover-view&gt; &lt;/cover-view&gt; &lt;/cover-view&gt;&lt;/map&gt; &lt;scroll-view class=&quot;near-list&quot; scroll-y&gt; &lt;!--绑定回填事件--&gt; &lt;view class=&quot;near-item&quot; wx:for=&quot;{{nearList}}&quot; wx:key=&quot;index&quot;&gt; &lt;view class=&quot;current-site iconfont icon-location&quot; wx:if=&quot;{{index == selectedId }}&quot;&gt;&lt;/view&gt; &lt;!--根据需求渲染相应数据--&gt; &lt;view bindtap=&quot;chooseCenter&quot; id=&quot;{{index}}&quot; data-name=&quot;{{item.title}}&quot;&gt; &lt;!--渲染地址title--&gt; &lt;view class=&quot;title {{ index == selectedId?'title1':'' }}&quot;&gt;{{item.title}}&lt;/view&gt; &lt;!--渲染详细地址--&gt; &lt;view class=&quot;add {{ index == selectedId?'add1':'' }}&quot;&gt;{{item.addr}}&lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/scroll-view&gt;&lt;view class=&quot;bottom-box&quot;&gt; &lt;button bindtap=&quot;selectedOk&quot;&gt;确认地址&lt;/button&gt;&lt;/view&gt;&lt;/view&gt; &lt;view class=&quot;region-box&quot; wx:if=&quot;{{chooseCity}}&quot;&gt; &lt;view class=&quot;region-top&quot;&gt; &lt;view class=&quot;region-back iconfont icon-fanhui&quot; bindtap=&quot;back2&quot;&gt;&lt;/view&gt; &lt;view class=&quot;title&quot;&gt;选择城市&lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-tabs&quot;&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showProvince&quot;&gt;{{currentProvince}}&lt;/text&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showCity&quot; wx:if=&quot;{{!regionShow.province}}&quot; bindtap=&quot;showCity&quot;&gt;{{currentCity}}&lt;/text&gt; &lt;text class=&quot;tab&quot; bindtap=&quot;showDistrict&quot; wx:if=&quot;{{regionShow.district}}&quot; bindtap=&quot;showDistrict&quot;&gt;{{currentDistrict}}&lt;/text&gt; &lt;/view&gt; &lt;scroll-view scroll-y style=&quot;height:1050rpx;&quot;&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;{{regionShow.province}}&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;{{regionData.province}}&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;{{item.id}}&quot; data-name=&quot;{{item.fullname}}&quot; bindtap=&quot;selectProvince&quot;&gt; &lt;text&gt;{{item.fullname}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;{{regionShow.city}}&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;{{regionData.city}}&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;{{item.id}}&quot; data-name=&quot;{{item.fullname}}&quot; bindtap=&quot;selectCity&quot;&gt; &lt;text&gt;{{item.fullname}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;region-list&quot; wx:if=&quot;{{regionShow.district}}&quot;&gt; &lt;view class=&quot;region-item&quot; wx:for=&quot;{{regionData.district}}&quot; wx:key=&quot;index&quot;&gt; &lt;view data-id=&quot;{{item.id}}&quot; data-name=&quot;{{item.fullname}}&quot; data-latitude=&quot;{{item.location.lat}}&quot; data-longitude=&quot;{{item.location.lng}}&quot; bindtap=&quot;selectDistrict&quot;&gt; &lt;text&gt;{{item.fullname}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279/* pages/shopMap/shopMap.wxss */@import &quot;../../lib/css/iconfont.wxss&quot;; .top { width: 100%; height: 80rpx; line-height: 80rpx; position: fixed; top: 0; left: 0; padding: 30rpx 20rpx; z-index: 999; overflow: hidden;}.back { width: 80rpx; height: 80rpx; line-height: 80rpx; color: #666; text-align: center; background: rgb(255,255,255); font-size: 50rpx; border-radius: 50%; float: left;}.back cover-image{ width: 50rpx; height: 50rpx; display: inline-block; margin-top: 15rpx;}.search-box { width: 610rpx; height: 80rpx; line-height: 80rpx; border-radius: 40rpx; background: rgb(255,255,255); margin-left: 20rpx; float: left; overflow: hidden;}.search-box1 { border: 1px solid #ccc; border-radius: 10rpx; background: #eee;}.search-box .region { width: 199rpx; line-height: 80rpx; font-size: 30rpx; color: #282828; text-align: center; float: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.search-box .shu { width: 1rpx; height: 80rpx; background:#ccc; float: left;}.search-box input { width: 380rpx; height: 80rpx; line-height: 80rpx; font-size: 30rpx; color: #282828; padding: 10rpx 20rpx; box-sizing: border-box; float: left;}.search-box .placeholder{ width: 380rpx; height: 80rpx; line-height: 80rpx; font-size: 30rpx; color: #ccc; padding: 0 20rpx; box-sizing: border-box; float: left;}.add-list-box { position: absolute; width: 100%; height: 100%; top: 0; z-index: 998; padding-top: 150rpx; background: #fff; box-sizing: border-box; overflow: hidden;}.add-list { width: 100%; height: 1000rpx;}.add-item { line-height: 40rpx; padding: 30rpx 50rpx; text-align: left; border-top: 1px solid #eee;}.add-item .title { color: #282828; font-size: 32rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.add-item .add { color: #707070; font-size: 24rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.current-site-icon { width: 50rpx; height: 50rpx; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);}.near-list { height: 650rpx; padding-bottom: 100rpx; box-sizing: border-box;}.near-item { line-height: 40rpx; padding: 30rpx 50rpx 30rpx 90rpx; text-align: left; border-bottom: 1px solid #eee; position: relative;}.current-site { font-size: 40rpx; color: #3095F9; position: absolute; top: 40rpx; left: 30rpx;}.near-item .title { color: #282828; font-size: 32rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.near-item .add { color: #707070; font-size: 24rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.near-item .title1 { color: #3095F9;}.near-item .add1 { color: #3095F9;}.bottom-box { width: 100%; padding: 20rpx; background: #fff; box-sizing: border-box; position: fixed; left: 0; bottom: 0; z-index: 88; overflow: hidden;}.bottom-box button{ width: 100%; height: 80rpx; line-height: 80rpx; border: none; background: #3095F9; color: #fff; font-size: 36rpx;} .region-box { width: 100%; height: 100%; background: #FFF; position: fixed; top: 0; left: 0; z-index: 1001;}.region-box .region-top { position: relative; font-size: 40rpx; color: #282828; font-weight: bold; line-height: 100rpx; text-align: center;}.region-box .region-back { width: 80rpx; height: 80rpx; font-size: 50rpx; text-align: center; position: absolute; top: 0; left: 0;}.region-box .region-tabs{ line-height: 60rpx; font-size: 20rpx;}.region-tabs .tab { min-width: 100rpx; max-width: 200rpx; line-height: 40rpx; font-size: 20rpx; color: #3095F9; text-align: center; border: 1rpx solid #3095F9; border-radius: 20rpx; display: inline-block; margin: 20rpx 0 20rpx 20rpx; padding: 3rpx 20rpx; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}.region-list .region-item{ font-size: 30rpx; color: #282828; line-height: 80rpx; padding: 10rpx 30rpx; border-top: 1rpx solid #eee;} .map-prompt { width: 420rpx; height: 60rpx; line-height: 60rpx; font-size: 24rpx; color: #707070; text-align: center; background: #fff; border-radius: 10rpx; box-shadow: 0 0 10rpx rgba(0,0,0,0.1); position: absolute; bottom: 40rpx; left: 50%; transform: translate(-50%,0);}.reload { width: 80rpx; height: 80rpx; background: #fff; border-radius: 50%; box-shadow: 0 0 10rpx rgba(0,0,0,0.1); position: absolute; bottom: 30rpx; right: 30rpx;}.reload .center1 { width: 30rpx; height: 30rpx; border: 1rpx solid #3095F9; border-radius: 50%; margin: 24rpx auto;}.reload .center2 { width: 25rpx; height: 25rpx; background: #3095F9; border-radius: 50%; margin: 3rpx auto;} js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528var QQMapWX = require('../../utils/qqmap-wx-jssdk1.2/qqmap-wx-jssdk.min.js');var qqmapsdk;Page({ data: { addListShow: false, chooseCity: false, regionShow: { province: false, city: false, district: true }, regionData: {}, currentRegion: { province: '选择城市', city: '选择城市', district: '选择城市', }, currentProvince: '选择城市', currentCity: '选择城市', currentDistrict: '选择城市', latitude: '', longitude: '', centerData: {}, nearList: [], suggestion: [], selectedId: 0, defaultKeyword: '房产小区', keyword: '' }, onLoad: function () { let self =this; self.mapCtx = wx.createMapContext('myMap') // 实例化API核心类 qqmapsdk = new QQMapWX({ key: 'W57BZ-JDB6X-XPA4H-Z76MI-73FF2-24BT4' }); wx.showLoading({ title: '加载中' }); //定位 wx.getLocation({ type: 'wgs84', success(res) { //console.log(res) const latitude = res.latitude const longitude = res.longitude const speed = res.speed const accuracy = res.accuracy //你地址解析 qqmapsdk.reverseGeocoder({ location: { latitude: latitude, longitude: longitude }, success: function (res) { //console.log(res) self.setData({ latitude: latitude, longitude: longitude, currentRegion: res.result.address_component, keyword: self.data.defaultKeyword }) // 调用接口 self.nearby_search(); }, }); }, fail(err) { //console.log(err) wx.hideLoading({}); wx.showToast({ title: '定位失败', icon: 'none', duration: 1500 }) setTimeout(function () { wx.navigateBack({ delta: 1 }) }, 1500) } }) }, onReady: function () { }, //监听拖动地图，拖动结束根据中心点更新页面 mapChange: function (e) { let self = this; if (e.type == 'end' &amp;&amp; (e.causedBy == 'scale' || e.causedBy == 'drag')){ self.mapCtx.getCenterLocation({ success: function (res) { //console.log(res) self.setData({ nearList:[], latitude: res.latitude, longitude: res.longitude, }) self.nearby_search(); } }) } }, //重新定位 reload: function () { this.onLoad(); }, //整理目前选择省市区的省市区列表 getRegionData: function () { let self = this; //调用获取城市列表接口 qqmapsdk.getCityList({ success: function (res) {//成功后的回调 //console.log(res) let provinceArr = res.result[0]; let cityArr = []; let districtArr = []; for (var i = 0; i &lt; provinceArr.length; i++) { var name = provinceArr[i].fullname; if (self.data.currentRegion.province == name) { if (name == '北京市' || name == '天津市' || name == '上海市' || name == '重庆市') { cityArr.push(provinceArr[i]) } else { qqmapsdk.getDistrictByCityId({ // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: provinceArr[i].id, success: function (res) {//成功后的回调 //console.log(res); cityArr = res.result[0]; self.setData({ regionData: { province: provinceArr, city: cityArr, district: districtArr } }) }, fail: function (error) { //console.error(error); }, complete: function (res) { //console.log(res); } }); } } } for (var i = 0; i &lt; res.result[1].length; i++) { var name = res.result[1][i].fullname; if (self.data.currentRegion.city == name) { qqmapsdk.getDistrictByCityId({ // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: res.result[1][i].id, success: function (res) {//成功后的回调 //console.log(res); districtArr = res.result[0]; self.setData({ regionData: { province: provinceArr, city: cityArr, district: districtArr } }) }, fail: function (error) { //console.error(error); }, complete: function (res) { //console.log(res); } }); } } }, fail: function (error) { //console.error(error); }, complete: function (res) { //console.log(res); } }); }, onShow: function () { let self = this; }, //地图标记点 addMarker: function (data) { //console.log(data) //console.log(data.title) var mks = []; mks.push({ // 获取返回结果，放到mks数组中 title: data.title, id: data.id, addr: data.addr, province: data.province, city: data.city, district: data.district, latitude: data.latitude, longitude: data.longitude, iconPath: &quot;/images/my_marker.png&quot;, //图标路径 width: 25, height: 25 }) this.setData({ //设置markers属性，将搜索结果显示在地图中 markers: mks, currentRegion: { province: data.province, city: data.city, district: data.district, } }) wx.hideLoading({}); }, //点击选择搜索结果 backfill: function (e) { var id = e.currentTarget.id; let name = e.currentTarget.dataset.name; for (var i = 0; i &lt; this.data.suggestion.length; i++) { if (i == id) { //console.log(this.data.suggestion[i]) this.setData({ centerData: this.data.suggestion[i], addListShow: false, latitude: this.data.suggestion[i].latitude, longitude: this.data.suggestion[i].longitude }); this.nearby_search(); return; //console.log(this.data.centerData) } } }, //点击选择地图下方列表某项 chooseCenter: function (e) { var id = e.currentTarget.id; let name = e.currentTarget.dataset.name; for (var i = 0; i &lt; this.data.nearList.length; i++) { if (i == id) { this.setData({ selectedId: id, centerData: this.data.nearList[i], latitude: this.data.nearList[i].latitude, longitude: this.data.nearList[i].longitude, }); this.addMarker(this.data.nearList[id]); return; //console.log(this.data.centerData) } } }, //显示搜索列表 showAddList: function () { this.setData({ addListShow: true }) }, // 根据关键词搜索附近位置 nearby_search: function () { var self = this; wx.hideLoading(); wx.showLoading({ title: '加载中' }); // 调用接口 qqmapsdk.search({ keyword: self.data.keyword, //搜索关键词 //boundary: 'nearby(' + self.data.latitude + ', ' + self.data.longitude + ', 1000, 16)', location: self.data.latitude + ',' + self.data.longitude, page_size: 20, page_index: 1, success: function (res) { //搜索成功后的回调 //console.log(res.data) var sug = []; for (var i = 0; i &lt; res.data.length; i++) { sug.push({ // 获取返回结果，放到sug数组中 title: res.data[i].title, id: res.data[i].id, addr: res.data[i].address, province: res.data[i].ad_info.province, city: res.data[i].ad_info.city, district: res.data[i].ad_info.district, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng }); } self.setData({ selectedId: 0, centerData: sug[0], nearList: sug, suggestion: sug }) self.addMarker(sug[0]); }, fail: function (res) { //console.log(res); }, complete: function (res) { //console.log(res); } }); }, //根据关键词搜索匹配位置 getsuggest: function (e) { var _this = this; var keyword = e.detail.value; _this.setData({ addListShow: true }) //调用关键词提示接口 qqmapsdk.getSuggestion({ //获取输入框值并设置keyword参数 keyword: keyword, //用户输入的关键词，可设置固定值,如keyword:'KFC' location: _this.data.latitude + ',' + _this.data.longitude, page_size: 20, page_index: 1, //region:'北京', //设置城市名，限制关键词所示的地域范围，非必填参数 success: function (res) {//搜索成功后的回调 //console.log(res); var sug = []; for (var i = 0; i &lt; res.data.length; i++) { sug.push({ // 获取返回结果，放到sug数组中 title: res.data[i].title, id: res.data[i].id, addr: res.data[i].address, province: res.data[i].province, city: res.data[i].city, district: res.data[i].district, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng }); } _this.setData({ //设置suggestion属性，将关键词搜索结果以列表形式展示 suggestion: sug, nearList: sug, keyword: keyword }); }, fail: function (error) { //console.error(error); }, complete: function (res) { //console.log(res); } }); }, //打开选择省市区页面 chooseCity: function () { let self = this; self.getRegionData(); self.setData({ chooseCity: true, regionShow: { province: false, city: false, district: true }, currentProvince: self.data.currentRegion.province, currentCity: self.data.currentRegion.city, currentDistrict: self.data.currentRegion.district, }) }, //选择省 showProvince: function () { this.setData({ regionShow: { province: true, city: false, district: false } }) }, //选择城市 showCity: function () { this.setData({ regionShow: { province: false, city: true, district: false } }) }, //选择地区 showDistrict: function () { this.setData({ regionShow: { province: false, city: false, district: true } }) }, //选择省之后操作 selectProvince: function (e) { //console.log(e) let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; self.setData({ currentProvince: name, currentCity: '请选择城市', }) if (name == '北京市' || name == '天津市' || name == '上海市' || name == '重庆市'){ var provinceArr = self.data.regionData.province; var cityArr = []; for (var i = 0; i &lt; provinceArr.length;i++){ if(provinceArr[i].fullname == name){ cityArr.push(provinceArr[i]) self.setData({ regionData: { province: self.data.regionData.province, city: cityArr, district: self.data.regionData.district } }) self.showCity(); return; } } }else{ let bj = self.data.regionShow; self.getById(id, name, bj) } }, //选择城市之后操作 selectCity: function (e) { let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; self.setData({ currentCity: name, currentDistrict: '请选择城市', }) let bj = self.data.regionShow; self.getById(id, name, bj) }, //选择区县之后操作 selectDistrict: function (e) { let self = this; let id = e.currentTarget.dataset.id; let name = e.currentTarget.dataset.name; let latitude = e.currentTarget.dataset.latitude; let longitude = e.currentTarget.dataset.longitude; self.setData({ currentDistrict: name, latitude: latitude, longitude: longitude, currentRegion: { province: self.data.currentProvince, city: self.data.currentCity, district: name }, chooseCity: false, keyword: self.data.defaultKeyword }) self.nearby_search(); }, //根据选择省市加载市区列表 getById: function (id,name,bj) { let self = this; qqmapsdk.getDistrictByCityId({ // 传入对应省份ID获得城市数据，传入城市ID获得区县数据,依次类推 id: id, //对应接口getCityList返回数据的Id，如：北京是'110000' success: function (res) {//成功后的回调 //console.log(res); if(bj.province){ self.setData({ regionData: { province: self.data.regionData.province, city: res.result[0], district: self.data.regionData.district } }) self.showCity(); } else if (bj.city) { self.setData({ regionData: { province: self.data.regionData.province, city: self.data.regionData.city, district: res.result[0] } }) self.showDistrict(); } else { self.setData({ chooseCity: false, }) } }, fail: function (error) { //console.error(error); }, complete: function (res) { //console.log(res); } }); }, //返回上一页或关闭搜索页面 back1: function () { if (this.data.addListShow) { this.setData({ addListShow: false }) }else { wx.navigateBack({ delta: 1 }) } }, //关闭选择省市区页面 back2: function () { this.setData({ chooseCity: false }) }, //确认选择地址 selectedOk: function () { let pages = getCurrentPages(); //获取当前页面js里面的pages里的所有信息。 let prevPage = pages[pages.length - 2]; //console.log(this.data.centerData) prevPage.setData({ storeAddress: this.data.centerData.title }) wx.navigateBack({ delta: 1 }) }}) 引用的阿里图标 iconfont.wxss 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@font-face {font-family: &quot;iconfont&quot;; src: url('//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999'); /* IE9 */ src: url('//at.alicdn.com/t/font_1120834_hvoztl864h6.eot?t=1554258412999#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAgQAAsAAAAADnAAAAfAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCEIAqOMIwEATYCJAMoCxYABCAFhG0HgRsbZQxRlG9SkOzjMG74SoiyxOJKUQ6m+GaJv3j4fr//rb3Puf7FEE2iUTWqZhKe6QwJGo1EowRIJKYTkmfym3/ctJ8wScURvVFxQm2q0AnUsDdqSBIoEnSiYcrKRJQyE0dmdpyI9Ofv92oXzfKu7buc91//yqZV86fheECRDT6QAB0gzH3LdJLMDLxi+q3XExhtJwJdlIxTAERFeQEpT8yEDiA+uZrSGnpRG3NsFe9Bo8+38D0AvDM/H/9AZSCkpqAHXXs8ygiG/hRvpFGdFFUCiPq0uG5EwQFAvQo/xUo+AuDHu51mzK5eAdakI1vxN0iJp8Wz4py4MD4mfjf+qLOTmNFp8bDG9EAZ67+8Kg06rYZoIX8OKl8HBn4CMULhZ8oIPT/TRgh+Zo1Q+ckZIfkpxOsQjAGpDgRqkGpB0Aj4vtAzqmPWAPuBPAqUbajwksmvUtgK2i/nCnlmmenJyRnJKXwkgcNBUhGELiVJqQ6cXSlIMsI/LqELKyMlRRfk4geiUCymjkSUVFhkXItj0KoAi4hB0agqHFZQOkMkHRQOj78WFm6LjLoZy90etVyxCO+qXYEO1u/e0ajmRjRnR0x6PZK9NWwg8PUXe2GrKLrxxIGp26OVXCJVJeb2ssOUklNECiXdrbyjMdxlFfGMRub71Mq1FEcL5dES+gZsFa9sDYs1gDVWSaUKrOWxKG4rBHR6lgcnrT9TAF2PoAqIy1ULOAI2n61i8ZT7wiOhjrM8pbLFKOhmbATEo1gydithAOr5Cn7DBxyISlQgb2ReNX0cXUQfptfoi5Upu4jFslivLqRmoMWy/PzRjFEQYEpWM5ljBjOVTqxm0LJ8a2l7YkGQ5tzq1y1m5DMYvPYzR3ZcvGnH7NpP7TulmWKsKwepVbweuT24OWKuOkLZVc141Ud8CubgC1hK+j4KZYwPRlXp9oUTQf7o1kQoKRArS9GFw6pAlmpfuBkEIuiM+5TMA9HENH9EydBfD35B5a7HazFjHUEs25M69vr2tIeo3cqkLokTV7fTjarVQTp95VqGchVjtbVrfMRiRYXamfhqn29AYDdFN6wsUUn3BjI0UCPZPcXOsZLqHOz4CJnnczRi2qKr51fQGCiw7yFmq+fDbR+FyyETyEVyIXOppB6efqBjFoyAgBn1PZ0yiCAg2SojcAZC3M0gZJLHtXV8gRjw6FJdnYCfATo7rblkCXxaRzvxW8X6aYs/WzxNg2OBtbA1KtI6rba6umtXIaw17wEGjyrvLx21fWyR3UIwCLNlayoYCFHdudbDSwfqr5BuGp2DBseytA/2Ablhl8MNg8v5DnOtxz7YaKfb+jfJRah0SYMSfnzS1uRJNp7+zAPGYGWwKR1UVOb7pyV++93DQzJ061b//AkP69eu2LZMte0enJH38yulMbh6Zf3OHUdc1CztT78iX+1pP/cptEybqSjf3dcC99HL0MdkRtmylTJRc0W/lt2K8kztstCnlt4ytHj4fHkNrNU395oJddSPKOaVVOlDclHf4E0zPydz1PvkRzXwfHnxcBn6prmXPuu2tvzlhHOV0zqjveWi/k2n2yqDvTn45o+maGwQQIc2c/CtnoF8yrwv/QzEsqP8D1JLEdtWzFp/acT8BW98cnTKxTf/rhnZrNVVw2i0HMesIzt21q9cHTQqR/z0USZSga+6/3J5heAH5ck1k/e6GwOVgVDaOK0SXtKASls89/8v5KIfvp3TPXFXj+VytEoXNUZbe5eM23eCU8YVl+SralR+BLaodg7THLQe1LTRJvKBctEy6zLf04u6/gPJ8WCFunQ0d1/i7MQ+Tb0fSh1Ds69ep6m1a4d6oaG55EBd/4utvUtHr1Br49KHTb37vLXadZp6pYJh8yV6M3kbgWvT1qVnrsvIzMgwmeD3kulwqAOewbSh0HQNZ9yN63gaTJ+Yd3r/gXuUe5Xgj/K1XCX4abQb7VPmBdODJguxPzMHrOOuy85ewAGLZ6amfc9Zm3MXRc/lnJPsXdznHri6wc/yv3s3kQ1Yb/SWk1jIJLZ/82Y/K4NFLgBmfgWYXS5NtCEA5ZTFrDNf0boZyaUCeFxHfoPvbk2V3EIBlMwTRP8Zfu43PoFtx5HtfNhPZbSkDfzfJ/23rPhxp/+3xj6jKiiv72WSIThqEDmn1Q9F2fG7YAIv1TPGS8CXphvGlnGsMK94U7dwXW7i8CRc56LU2YaK3o7SWnkANSYHUat3Bo32k548WeVCE3XAPnMJCksOorTgCyqW3AcAqHyNGut9h1pLQUOjO5F1zsmuMCeOcGE6D2YU6icLzQbSjnOVJ9FKrccIr1Xn8lKmU4W53GaXsEJcHgxJMTvmquMA9wSi0uPBhbiLtAkl5GaY1UoKHS6yDTN4xCaPx9G/rAyPO1BsIG0g0QUuGB2PGmwkpDeZ08yAZIcX90gMfX89DMHLSseVMuqbUwXj4mZeu1AFsfIcpVK+Pdeofcl2m4BQyYNanFB4XUg2Wyg5aTFW5icJOeK3aoMx8BAzlfA69FeGs+F5+eL2hbatTf0TjUFvO0ZGiRpNtNFFH0OMMdm4ButMMZmneEm9WUfat/XaK3ojVtKg85hJe3ejbrLXpCOT2hKNHi8SVlZ0Px+LTDFhdsLpxbrhOrvJa94ErOuiQwEAAAAA') format('woff2'), url('//at.alicdn.com/t/font_1120834_hvoztl864h6.woff?t=1554258412999') format('woff'), url('//at.alicdn.com/t/font_1120834_hvoztl864h6.ttf?t=1554258412999') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('//at.alicdn.com/t/font_1120834_hvoztl864h6.svg?t=1554258412999#iconfont') format('svg'); /* iOS 4.1- */} .iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;} .icon-iconfontzhizuobiaozhun16:before { content: &quot;\\e60f&quot;;} .icon-location:before { content: &quot;\\e619&quot;;} .icon-dayuhao:before { content: &quot;\\e600&quot;;} .icon-jizuobiaotu:before { content: &quot;\\e613&quot;;} .icon-dayuhao1:before { content: &quot;\\e65c&quot;;} .icon-zuobiao:before { content: &quot;\\e657&quot;;} .icon-zhengque:before { content: &quot;\\e64a&quot;;} .icon-fanhui:before { content: &quot;\\e60d&quot;;} .icon-iconfront-:before { content: &quot;\\e620&quot;;} 用到的图片 back.png(wxml39行)和my_marker.png(wxml48行) 可参考 WebService API | 腾讯位置服务","link":"/2022/08/24/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"线性代数","text":"","link":"/2022/07/01/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"title":"解决rehl8 Unable to read consumer identity的问题","text":"看看现在的时间吧01:00……本来想着今天能早点睡了，结果被这个问题折磨了一个多小时(尝试百度，然后CSDN上各种牛鬼蛇神的答案折磨) 感谢susu老师的录屏，经过几步简单的操作让我今晚能安心入眠。 起因在进行源码编译安装的开头 1234[root@localhost ~]# yum -y install gcc makeUnable to read consumer identityThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.Error: There are no enabled repos. 哈哈出现了这个问题”This system is not registered to Red Hat” 其实就是需要换一下国内源，而用CentOS应该是没有问题的，这里就介绍以下rehl8的解决办法。 解决办法先挂好光驱临时挂载 12[root@localhost ~]# mkdir /dvd/[root@localhost ~]# mount /dev/cdrom /dvd/ #把光驱挂到/dvd下 至关重要的一步！！修改配置文件，这里进行换源 1[root@localhost ~]# vim /etc/yum.repos.d/dvd.repo 直接复制粘贴以下内容，但是注意如果你的不是挂载/dvd/下的，在注释的地方要作相应变动。 123456789101112131415161718[BaseOS]name=BaseOSbaseurl=file:///dvd/BaseOS #具体路径修改gpgcheck=1gpgkey=/etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial[AppStream]name=AppStreambaseurl=file:///dvd/AppStream #具体路径修改gpgcheck=0[epel]name=EPELbaseurl=http://mirrors.aliyun.com/epel/$releasever/Everything/$basearchgpgcheck=0enabled=1[httpAppstream]name=aliyun Appstreambaseurl=https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/osgpgcheck=0 记得ESC+:wq保存~ 这一步设置之后就可以解决问题了！ 重启之后都要重新mount，不太方便，接着进行： 永久挂载 1234[root@localhost ~]# vim /etc/fstab#在末尾添加 空格分隔即可/dev/cdrom /dvd/ iso9660 defaults 0 0[root@localhost ~]# reboot #重启一下 检查挂好没 1[root@localhost ~]# mount #看最后是否有 /dev/sr0 on /dvd.... 开始装编译器123456789101112131415[root@localhost ~]# yum clean /all #清一下缓存[root@localhost ~]# yum repolist -v #重新加载一下[root@localhost ~]# yum -y install gcc gcc-c++ makeUpdating Subscription Management repositories.Unable to read consumer identityThis system is not registered to Red Hat Subscription Management. You can use subscription-manager to register.上次元数据过期检查：0:00:37 前，执行于 2022年11月02日 星期三 00时55分25秒。错误： 问题 1: cannot install the best candidate for the job - nothing provides libgcc &gt;= 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64 - nothing provides libgomp = 8.5.0-4.el8_5 needed by gcc-8.5.0-4.el8_5.x86_64 问题 2: cannot install the best candidate for the job - nothing provides libstdc++ = 8.5.0-4.el8_5 needed by gcc-c++-8.5.0-4.el8_5.x86_64(尝试添加 '--skip-broken' 来跳过无法安装的软件包 或 '--nobest' 来不只使用最佳选择的软件包) 这时候报错了。 确实，又报错了哈哈，应该是版本问题，还好susu也有讲，按照提示加上’–nobest’即可。 1[root@localhost ~]# yum -y install --nobest gcc gcc-c++ make 搞掂！舒服了~ Zzz 对了，这时候别忘了拍张快照，一劳永逸：）","link":"/2022/11/02/%E8%A7%A3%E5%86%B3rehl8-Unable-to-read-consumer-identity%E7%9A%84%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"深度学习","slug":"深度学习","link":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"云服务器","slug":"云服务器","link":"/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"minecraft","slug":"minecraft","link":"/tags/minecraft/"},{"name":"经验分享","slug":"经验分享","link":"/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"编程","slug":"编程","link":"/categories/%E7%BC%96%E7%A8%8B/"},{"name":"本科课程","slug":"编程/本科课程","link":"/categories/%E7%BC%96%E7%A8%8B/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"深度学习","slug":"深度学习","link":"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"项目","slug":"编程/项目","link":"/categories/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"小程序","slug":"编程/项目/小程序","link":"/categories/%E7%BC%96%E7%A8%8B/%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"编程","slug":"教程/编程","link":"/categories/%E6%95%99%E7%A8%8B/%E7%BC%96%E7%A8%8B/"},{"name":"本科课程","slug":"本科课程","link":"/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"}],"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"友情连接","text":"","link":"/link/index.html"}]}